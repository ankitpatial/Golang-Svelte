package server

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.32

import (
	"context"
	"errors"
	"fmt"
	"path/filepath"
	"roofix/config"
	"roofix/ent"
	entJob "roofix/ent/job"
	"roofix/pkg/account"
	"roofix/pkg/document"
	"roofix/pkg/enum"
	"roofix/pkg/job"
	"roofix/pkg/msg"
	"roofix/pkg/survey"
	"roofix/pkg/util/crypt"
	"roofix/pkg/util/storage"
	"roofix/pkg/util/uid"
	"roofix/server/generated"
	"roofix/server/model"
	"time"
)

// Section is the resolver for the section field.
func (r *documentResolver) Section(ctx context.Context, obj *document.Info) (string, error) {
	if obj == nil {
		return "", nil
	}

	return obj.Section.String(), nil
}

// PublicURL is the resolver for the publicUrl field.
func (r *documentResolver) PublicURL(ctx context.Context, obj *document.Info) (*string, error) {
	if obj == nil || obj.Folder != enum.FolderPublicData || obj.Key == "" {
		return nil, nil
	}

	publicUrl := fmt.Sprintf("%s/%s", config.Read().Website.AssetUrl, obj.Key)
	return &publicUrl, nil
}

// Meta is the resolver for the meta field.
func (r *documentResolver) Meta(ctx context.Context, obj *document.Info) (interface{}, error) {
	if obj == nil {
		return nil, nil
	}

	return obj.Meta, nil
}

// URL is the resolver for the url field.
func (r *documentInfoResolver) URL(ctx context.Context, obj *document.InfoShort) (string, error) {
	if obj == nil || obj.Key == "" {
		return "", nil
	}

	// public URL
	if obj.Folder == enum.FolderPublicData {
		return fmt.Sprintf("%s/%s", config.Read().Website.AssetUrl, obj.Key), nil
	}

	// signed URL
	return storage.GetSignedUrl(ctx, config.DataBucket(), obj.Key, time.Hour*24)
}

// DocumentUploadURL is the resolver for the documentUploadUrl field.
func (r *mutationResolver) DocumentUploadURL(ctx context.Context, doc document.Input) (*document.Info, error) {
	if !doc.Overwrite {
		if exists, err := document.Exists(ctx, doc.Folder, &doc.Dir, &doc.Section, &doc.Name); err != nil {
			return nil, err
		} else if exists {
			return nil, errors.New(fmt.Sprintf("file with same name '%s' already exists", doc.Name))
		}
	}

	key := fmt.Sprintf("%s/%s/%s", doc.Folder, doc.Dir, doc.Name)
	meta := map[string]string{
		"filename": doc.FileName,
		"section":  doc.Section.String(),
	}

	return document.UploadRequest(ctx, key, &doc, meta)
}

// PublicDataUploadURL is the resolver for the publicDataUploadUrl field.
func (r *mutationResolver) PublicDataUploadURL(ctx context.Context, entityID string, section enum.DocSection, doc model.InputFile) (*document.Info, error) {
	inp := document.Input{
		Folder:      enum.FolderPublicData,
		Dir:         entityID,
		Section:     section,
		Name:        doc.Name,
		FileName:    doc.FileName,
		ContentType: doc.ContentType,
		ContentSize: doc.ContentSize,
	}

	// check and remove if already exists
	if d, _ := document.Get(ctx, inp.Folder, &inp.Dir, &inp.Section, &inp.Name); d != nil {
		if err := storage.DeleteObject(ctx, d.Bucket, d.Key); err != nil {
			return nil, err
		}
	}

	dirHash := crypt.MD5Hash(inp.Dir)
	key := fmt.Sprintf("%s/%s/%s%s", inp.Folder, dirHash, uid.ULID(), filepath.Ext(inp.FileName))
	meta := map[string]string{
		"filename": inp.FileName,
		"section":  inp.Section.String(),
	}

	res, err := document.UploadRequest(ctx, key, &inp, meta)
	if err != nil {
		return nil, err
	}

	return res, err
}

// PartnerDocUploadURL is the resolver for the partnerDocUploadUrl field.
func (r *mutationResolver) PartnerDocUploadURL(ctx context.Context, partnerID string, section enum.DocSection, doc model.InputFile) (*document.Info, error) {
	if !isAdminOrCompanyAdmin(ctx, partnerID) {
		return nil, msg.AsError(msg.NotAuthorized)
	}

	inp := document.Input{
		Folder:      enum.FolderPartnerDocs,
		Dir:         partnerID,
		Section:     section,
		Name:        doc.Name,
		FileName:    doc.FileName,
		ContentType: doc.ContentType,
		ContentSize: doc.ContentSize,
	}
	key := fmt.Sprintf("%s/%s/%s", inp.Folder, inp.Dir, inp.Name)
	meta := map[string]string{
		"partner_id": partnerID,
		"filename":   inp.FileName,
		"section":    inp.Section.String(),
	}
	return document.UploadRequest(ctx, key, &inp, meta)
}

// JobDocUploadURL is the resolver for the jobDocUploadUrl field.
func (r *mutationResolver) JobDocUploadURL(ctx context.Context, jobID string, section enum.DocSection, doc model.InputFile) (*document.Info, error) {
	if err := job.AssertAccess(ctx, jobID); err != nil {
		return nil, err
	}

	inp := document.Input{
		Folder:      enum.FolderJobDocs,
		Dir:         jobID,
		Section:     section,
		Name:        doc.Name,
		FileName:    doc.FileName,
		ContentType: doc.ContentType,
		ContentSize: doc.ContentSize,
	}
	if inp.Name == "" {
		ext := filepath.Ext(inp.FileName)
		inp.Name = fmt.Sprintf("%s%s", uid.ULID(), ext)
	}

	key := fmt.Sprintf("%s/%s/%s", inp.Folder, inp.Dir, inp.Name)
	meta := map[string]string{
		"job_id":   jobID,
		"filename": inp.Name,
		"section":  inp.Section.String(),
	}

	return document.UploadRequest(ctx, key, &inp, meta)
}

// SurveyDocUploadURL is the resolver for the surveyDocUploadUrl field.
func (r *mutationResolver) SurveyDocUploadURL(ctx context.Context, surveyID string, section enum.DocSection, doc model.InputFile) (*document.Info, error) {
	u := account.CtxUser(ctx)
	db := ent.GetClient()
	defer db.CloseClient()

	if u.Role != enum.RoleAdmin {
		// check access
		if _, err := survey.ByIdAndCreatorID(ctx, db, surveyID, u.ID); err != nil {
			return nil, err
		}
	}

	inp := document.Input{
		Folder:      enum.FolderSurvey,
		Dir:         surveyID,
		Section:     section,
		Name:        doc.Name,
		FileName:    doc.FileName,
		ContentType: doc.ContentType,
		ContentSize: doc.ContentSize,
	}
	ext := filepath.Ext(inp.Name)
	key := fmt.Sprintf("%s/%s/%s%s", inp.Folder, inp.Dir, uid.ULID(), ext)
	meta := map[string]string{
		"survey_id": surveyID,
		"filename":  inp.Name,
	}
	return document.UploadRequest(ctx, key, &inp, meta)
}

// DeleteDoc is the resolver for the deleteDoc field.
func (r *mutationResolver) DeleteDoc(ctx context.Context, id string) (bool, error) {
	return document.Delete(ctx, id)
}

// ViewDocURL is the resolver for the viewDocURL field.
func (r *queryResolver) ViewDocURL(ctx context.Context, docID string) (string, error) {
	db := ent.GetClient()
	defer db.CloseClient()

	d, err := db.Document.Get(ctx, docID)
	if err != nil {
		return "", err
	}

	bucket := config.DataBucket()
	return storage.GetSignedUrl(ctx, bucket, d.Key, time.Minute*5)
}

// JobDocs is the resolver for the jobDocs field.
func (r *queryResolver) JobDocs(ctx context.Context, jobID string) ([]*document.Info, error) {
	if err := job.AssertAccess(ctx, jobID); err != nil {
		return nil, err
	}

	docs, err := document.ByFolderDirSection(ctx, enum.FolderJobDocs, &jobID, nil)
	if err != nil {
		return nil, err
	}

	// pull estimate pdf also.
	j, _ := ent.GetClient().Job.Query().
		WithEstimatePdf().
		Where(entJob.ID(jobID)).
		Select(entJob.FieldID, entJob.EstimatePdfColumn).
		First(ctx)
	if j != nil && j.Edges.EstimatePdf != nil {
		res := []*document.Info{
			document.AsDocInfo(j.Edges.EstimatePdf),
		}
		return append(res, docs...), nil
	}

	return docs, nil
}

// JobDocsBySection is the resolver for the jobDocsBySection field.
func (r *queryResolver) JobDocsBySection(ctx context.Context, jobID string) ([]*model.SectionDocs, error) {
	if err := job.AssertAccess(ctx, jobID); err != nil {
		return nil, err
	}

	docs := &model.SectionDocs{Section: enum.SectionDocs}
	prodPics := &model.SectionDocs{Section: enum.SectionProductionPics}
	inspectionDocs := &model.SectionDocs{Section: enum.SectionInspectionDocs}
	pricing := &model.SectionDocs{Section: enum.SectionPricingPDF}
	// pull se
	jDocs, err := document.ByFolderDirSection(ctx, enum.FolderJobDocs, &jobID, nil)
	if err != nil {
		return nil, err
	}

	for _, i := range jDocs {
		d := document.AsShortInfo(i)
		switch i.Section {
		case enum.SectionDocs:
			docs.Docs = append(docs.Docs, d)
		case enum.SectionProductionPics:
			prodPics.Docs = append(prodPics.Docs, d)
		case enum.SectionInspectionDocs:
			inspectionDocs.Docs = append(inspectionDocs.Docs, d)
		case enum.SectionPricingPDF:

			pricing.Docs = append(pricing.Docs, d)
		}
	}

	return []*model.SectionDocs{
		docs,
		prodPics,
		inspectionDocs,
		pricing,
	}, nil
}

// SurveyDocs is the resolver for the surveyDocs field.
func (r *queryResolver) SurveyDocs(ctx context.Context, surveyID string) ([]*document.Info, error) {
	db := ent.GetClient()
	defer db.CloseClient()

	u := account.CtxUser(ctx)
	if u.Role != enum.RoleAdmin {
		// check access
		if _, err := survey.ByIdAndCreatorID(ctx, db, surveyID, u.ID); err != nil {
			return nil, err
		}
	}

	return document.ByFolderDirSection(ctx, enum.FolderJobDocs, &surveyID, nil)
}

// Document returns generated.DocumentResolver implementation.
func (r *Resolver) Document() generated.DocumentResolver { return &documentResolver{r} }

// DocumentInfo returns generated.DocumentInfoResolver implementation.
func (r *Resolver) DocumentInfo() generated.DocumentInfoResolver { return &documentInfoResolver{r} }

type documentResolver struct{ *Resolver }
type documentInfoResolver struct{ *Resolver }
