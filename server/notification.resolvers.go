package server

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.32

import (
	"context"
	"fmt"
	"roofix/ent"
	"roofix/ent/notifysetting"
	"roofix/ent/user"
	"roofix/pkg/account"
	"roofix/pkg/enum"
	"roofix/pkg/model"
	"roofix/pkg/notification"
	"roofix/pkg/util/crypt"
	gqlModel "roofix/server/model"
)

// SaveNotifySettings is the resolver for the saveNotifySettings field.
func (r *mutationResolver) SaveNotifySettings(ctx context.Context, userID string, topicID string, email bool) (bool, error) {
	db := ent.GetClient()
	defer db.CloseClient()

	ns, err := db.NotifySetting.Query().
		Where(notifysetting.HasUserWith(user.ID(userID)), notifysetting.TopicID(topicID)).
		Only(ctx)
	if err != nil && !ent.IsNotFound(err) {
		return false, err
	}

	if ns != nil { // update
		err = db.NotifySetting.UpdateOneID(ns.ID).
			SetReceiveEmail(email).
			Exec(ctx)

		// return
		return err != nil, err
	}

	// create
	err = db.NotifySetting.Create().
		SetUserID(userID).
		SetTopicID(topicID).
		SetReceiveEmail(email).
		Exec(ctx)

	return err != nil, err
}

// NotificationRead is the resolver for the notificationRead field.
func (r *mutationResolver) NotificationRead(ctx context.Context, messageID string) (bool, error) {
	uID := account.CtxUserID(ctx)
	db := ent.GetClient()
	defer db.CloseClient()

	id := crypt.MD5Hash(fmt.Sprintf("%s%s", uID, messageID))
	err := db.ChannelMessageRead.Create().
		SetID(id).
		SetChannelMessageID(messageID).
		SetUserID(uID).
		SetRead(true).
		OnConflict().
		Ignore().
		Exec(ctx)

	return err == nil, err
}

// UserNotifySettings is the resolver for the userNotifyEmailSettings field.
func (r *queryResolver) UserNotifySettings(ctx context.Context, id string) ([]*model.Notify, error) {
	db := ent.GetClient()
	defer db.CloseClient()

	u, err := db.User.
		Query().
		Where(user.ID(id)).
		WithNotify().
		Select(user.FieldID, user.FieldRole).
		Only(ctx)

	if err != nil {
		return nil, err
	}

	d := u.Edges.Notify

	if err != nil {
		return nil, err
	}

	var res []*model.Notify
	addToRes := func(topic string) {
		topicID := crypt.MD5Hash(topic)
		r := &model.Notify{
			ID:    topicID,
			Topic: topic,
		}

		if len(d) > 0 {
			for _, s := range d {
				if s.TopicID == topicID {
					r.ReceiveEmail = s.ReceiveEmail
					r.ReceiveSms = s.ReceiveSms
				}
			}
		}

		res = append(res, r)
	}

	if u.Role == enum.RoleAdmin {
		for _, n := range gqlModel.AllAdminNotifyTopic {
			addToRes(n.String())
		}
	} else {
		for _, n := range gqlModel.AllUserNotifyTopic {
			addToRes(n.String())
		}
	}

	return res, err
}

// MyUnreadNotificationsCount is the resolver for the myUnreadNotifications field.
func (r *queryResolver) MyUnreadNotificationsCount(ctx context.Context) (int, error) {
	var uID string
	var partnerID *string
	u := account.CtxUser(ctx)
	uID = u.ID
	if u.IsCompanyAdmin {
		partnerID = &u.Partner.ID
	}

	return notification.UnreadCount(ctx, uID, partnerID, u.IsAdmin)
}

// MyNotifications is the resolver for the myNotifications field.
func (r *queryResolver) MyNotifications(ctx context.Context, page gqlModel.PageInput) (*model.NotifyMessageConnection, error) {
	var uID string
	var partnerID *string
	u := account.CtxUser(ctx)
	uID = u.ID
	if u.IsCompanyAdmin {
		partnerID = &u.Partner.ID
	}

	return notification.Messages(uID, partnerID, u.IsAdmin, page.After, page.First)
}
