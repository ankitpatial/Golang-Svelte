package server

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.32

import (
	"context"
	"fmt"
	"roofix/ent"
	"roofix/ent/partnercontact"
	"roofix/ent/user"
	"roofix/pkg/account"
	"roofix/pkg/enum"
	"roofix/pkg/msg"
	"roofix/pkg/partner"
	"roofix/pkg/util/str"
	"roofix/server/generated"
	"roofix/server/model"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
)

// SavePartnerContacts is the resolver for the savePartnerContact field.
func (r *mutationResolver) SavePartnerContacts(ctx context.Context, partnerID string, contacts []*partner.ContactUserInput) ([]*ent.PartnerContact, error) {
	if !isAdminOrCompanyAdmin(ctx, partnerID) {
		return nil, msg.AsError(msg.NotAuthorized)
	}

	return partner.SaveContacts(ctx, partnerID, contacts)
}

// SavePartnerContact is the resolver for the savePartnerContact field.
func (r *mutationResolver) SavePartnerContact(ctx context.Context, partnerID string, contact partner.ContactUserInput) (bool, error) {
	u := account.CtxUser(ctx)
	if (!u.IsAdmin && !u.IsCompanyAdmin) || (u.IsCompanyAdmin && u.Partner.ID != partnerID) {
		return false, msg.AsError(msg.NotAuthorized)
	}

	err := partner.SaveContact(ctx, partnerID, &contact)
	return err == nil, err
}

// PartnerContactSendPwdResetEmail is the resolver for the partnerContactSendPwdResetEmail field.
func (r *mutationResolver) PartnerContactSendPwdResetEmail(ctx context.Context, partnerID string, userID string) (bool, error) {
	u := account.CtxUser(ctx)
	if (!u.IsAdmin && !u.IsCompanyAdmin) || (u.IsCompanyAdmin && u.Partner.ID != partnerID) {
		return false, msg.AsError(msg.NotAuthorized)
	}

	err := partner.ContactResetPasswordEmail(ctx, userID)
	return err == nil, err
}

// AccountStatus is the resolver for the accountStatus field.
func (r *partnerContactResolver) AccountStatus(ctx context.Context, obj *ent.PartnerContact) (*enum.AccountStatus, error) {
	return &obj.Edges.User.Status, nil
}

// FirstName is the resolver for the firstName field.
func (r *partnerContactResolver) FirstName(ctx context.Context, obj *ent.PartnerContact) (string, error) {
	return obj.Edges.User.FirstName, nil
}

// LastName is the resolver for the lastName field.
func (r *partnerContactResolver) LastName(ctx context.Context, obj *ent.PartnerContact) (string, error) {
	return obj.Edges.User.LastName, nil
}

// Email is the resolver for the email field.
func (r *partnerContactResolver) Email(ctx context.Context, obj *ent.PartnerContact) (string, error) {
	return obj.Edges.User.Email, nil
}

// Phone is the resolver for the phone field.
func (r *partnerContactResolver) Phone(ctx context.Context, obj *ent.PartnerContact) (*string, error) {
	return &obj.Edges.User.Phone, nil
}

// OtherEmail is the resolver for the otherEmail field.
func (r *partnerContactResolver) OtherEmail(ctx context.Context, obj *ent.PartnerContact) (*string, error) {
	if obj == nil || obj.Type != enum.PartnerContactAccounting {
		return nil, nil
	}

	return obj.InvoicingEmail, nil
}

// Picture is the resolver for the picture field.
func (r *partnerContactResolver) Picture(ctx context.Context, obj *ent.PartnerContact) (*string, error) {
	return obj.Edges.User.Picture, nil
}

// PartnerContacts is the resolver for the partnerContacts field.
func (r *queryResolver) PartnerContacts(ctx context.Context, partnerID string, search *string, page model.PageInput) (*model.ContactConnection, error) {
	u := account.CtxUser(ctx)
	if (!u.IsAdmin && !u.IsCompanyAdmin) || (u.IsCompanyAdmin && u.Partner.ID != partnerID) {
		return nil, msg.AsError(msg.NotAuthorized)
	}

	db := ent.GetClient()
	defer db.CloseClient()

	order := &ent.UserOrder{
		Direction: entgql.OrderDirectionAsc,
		Field:     ent.UserOrderFieldFirstName,
	}

	c, err := db.Debug().User.Query().
		WithPartnerContacts(func(pc *ent.PartnerContactQuery) {
			pc.Select(
				partnercontact.FieldType,
				partnercontact.FieldRole,
				partnercontact.FieldTitle,
				partnercontact.FieldDescription,
			)
		}).
		Where(func(u *sql.Selector) {
			pc := sql.Table(partnercontact.Table)
			u.Join(pc).On(u.C(user.FieldID), pc.C(partnercontact.UserColumn))
			u.Where(sql.EQ(pc.C(partnercontact.PartnerColumn), partnerID))
			q := str.Val(search)
			if q != "" {
				u.Where(sql.Or(
					sql.ContainsFold(u.C(user.FieldFirstName), q),
					sql.ContainsFold(u.C(user.FieldLastName), q),
					sql.ContainsFold(u.C(user.FieldEmail), q),
					sql.ContainsFold(u.C(user.FieldPhone), q),
				))
			}

			u.Select(
				fmt.Sprintf("%s as id", u.C(user.FieldID)),
				user.FieldFirstName,
				user.FieldLastName,
				user.FieldEmail,
				user.FieldPhone,
				user.FieldPicture,
				user.FieldStatus,
			)
		}).
		Paginate(context.Background(), page.After, page.First, page.Before, page.Last, ent.WithUserOrder(order))
	if err != nil {
		return nil, err
	}

	res := &model.ContactConnection{
		TotalCount: c.TotalCount,
		PageInfo:   &c.PageInfo,
	}
	for _, e := range c.Edges {
		usr := e.Node
		pc := &ent.PartnerContact{
			UserID: usr.ID,
			Edges: ent.PartnerContactEdges{
				User: usr,
			},
		}

		if len(usr.Edges.Partner) > 0 {
			par := usr.Edges.Partner[0]
			pc.PartnerID = par.ID
			pc.Edges.Partner = par
		}

		if len(usr.Edges.PartnerContacts) > 0 {
			con := usr.Edges.PartnerContacts[0]
			pc.ID = con.ID
			pc.Role = con.Role
			pc.Type = con.Type
			pc.Title = con.Title
			pc.Description = con.Description
			pc.InvoicingEmail = con.InvoicingEmail
		}

		res.Edges = append(res.Edges, &ent.PartnerContactEdge{
			Cursor: e.Cursor,
			Node:   pc,
		})
	}

	return res, nil
}

// PartnerContact returns generated.PartnerContactResolver implementation.
func (r *Resolver) PartnerContact() generated.PartnerContactResolver {
	return &partnerContactResolver{r}
}

type partnerContactResolver struct{ *Resolver }
