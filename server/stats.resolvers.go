package server

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.32

import (
	"context"
	"fmt"
	"roofix/ent"
	"roofix/pkg/account"
	"roofix/pkg/util/log"
	"roofix/server/model"
	"strings"
)

// Counts is the resolver for the countByCategory field.
func (r *queryResolver) Counts(ctx context.Context) (*model.Counts, error) {
	var (
		qry string
		u   = account.CtxUser(ctx)
	)

	if u.IsAdmin {
		qry = `select 
       (select count(id) from estimates) 'c1',
       (select count(id) from jobs where roofing_partner_id is null ) 'c2',
       (select count(id) from jobs where roofing_partner_id is not null) 'c3',
       (select count(id) from jobs where progress = 'Invoiced') 'c4',
       (select count(id) from jobs where progress = 'InvoiceApproved') 'c5',
       (select count(id) from jobs where progress = 'InvoicePaid') 'c6'`
	} else {
		var qb strings.Builder
		qb.WriteString("select")

		// estimate creator, sales rep, or company admin filter
		cond := fmt.Sprintf("creator_id = '%s' OR sales_rep_id = '%s'", u.ID, u.ID)
		if u.IsCompanyAdmin {
			cond += fmt.Sprintf(" OR partner_id = '%s'", u.Partner.ID)
			qb.WriteString(fmt.Sprintf("(select count(id) from estimates where %s) 'c1',", cond))
		} else {
			qb.WriteString(fmt.Sprintf("(select count(id) from estimates where %s) 'c1',", cond))
		}

		// job creator, sales rep, or company admin filter
		cond = fmt.Sprintf("creator_id = '%s' OR sales_rep_id = '%s'", u.ID, u.ID)
		if u.IsCompanyAdmin {
			cond += fmt.Sprintf(" OR partner_id = '%s'", u.Partner.ID)
			qb.WriteString(fmt.Sprintf("(select count(id) from estimates where status = 'Approved' and %s) 'c3',", cond))
		} else {
			qb.WriteString(fmt.Sprintf("(select count(id) from estimates where status = 'Approved' and %s) 'c3',", cond))
		}

		qb.WriteString("0 'c2', 0 'c4', 0 'c5', 0 'c6'")
		qry = qb.String()
	}

	res, err := ent.SqlDB().Query(qry)

	if err != nil {
		return nil, err
	}

	var estCount, unCount, asCount, invoiced, approved, paid int
	if res.Next() {
		if err := res.Scan(&estCount, &unCount, &asCount, &invoiced, &approved, &paid); err != nil {
			log.Error(err)
		}
	}

	return &model.Counts{
		EstimateCount:      estCount,
		UnassignedJobCount: unCount,
		AssignedJobCount:   asCount,
		PaymentsPending:    invoiced,
		PaymentsApproved:   approved,
		PaymentsCompleted:  paid,
	}, err
}
