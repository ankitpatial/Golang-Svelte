package server

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.32

import (
	"context"
	"errors"
	"fmt"
	"roofix/config"
	"roofix/ent"
	"roofix/ent/partner"
	"roofix/ent/partnercontact"
	"roofix/ent/user"
	"roofix/pkg/account"
	"roofix/pkg/audit"
	pkgModel "roofix/pkg/model"
	pkgPartner "roofix/pkg/partner"
	"roofix/pkg/util/log"
	"roofix/pkg/util/str"
	"roofix/pkg/util/validate"
	"roofix/server/generated"
	"roofix/server/model"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
)

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input *account.LoginInput) (*model.LoginResult, error) {
	u, err := account.Authenticate(ctx, input)
	if err != nil {
		audit.OpFailed(ctx, audit.AccLogin, err)
		return nil, err
	}

	d := time.Hour * 24 * 7
	sid, err := account.NewSession(ctx, u.ID, u.Role, time.Now().Add(d), account.CtxIP(ctx))
	if err != nil {
		audit.OpFailed(ctx, audit.AccLogin, err)
		return nil, err
	}

	t, err := account.AuthToken(sid, d)
	if err != nil {
		audit.OpFailed(ctx, audit.AccLogin, err)
		return nil, err
	}

	return &model.LoginResult{
		Token: t,
		User:  account.SessionUser(ctx, sid),
	}, nil
}

// Logout is the resolver for the logout field.
func (r *mutationResolver) Logout(ctx context.Context) (bool, error) {
	u := account.CtxUser(ctx)
	if u == nil || u.SessionID == "" {
		return false, errors.New("failed to get user session info")
	}

	if err := ent.GetClient().UserSession.DeleteOneID(u.SessionID).Exec(ctx); err != nil {
		log.Error(err)
	}

	return true, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input *account.CreateUserInput) (string, error) {
	id, err := account.Create(ctx, input)
	audit.Operation(ctx, audit.AccCreate, fmt.Sprintf("new userID: %s", id), err)
	return id, err
}

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input *account.UpdateUserInput) (bool, error) {
	me := account.CtxUser(ctx)
	err := account.UpdateUser(ctx, input, me.Role)
	audit.Operation(ctx, audit.AccUpdate, fmt.Sprintf("updated userID: %s", input.ID), err)
	return err == nil, err
}

// AccForgotPwd is the resolver for the accForgotPwd field.
func (r *mutationResolver) AccForgotPwd(ctx context.Context, email string) (bool, error) {
	err := account.ChangePasswordRequest(ctx, email)
	audit.Operation(ctx, audit.AccForgotPassword, "received forgot password request", err)
	return err == nil, err
}

// SetUserPwd is the resolver for the setUserPwd field.
func (r *mutationResolver) SetUserPwd(ctx context.Context, userID string, pwd string, confirmPwd string) (bool, error) {
	ctxUserID := account.CtxUserID(ctx)
	err := account.SetUserPassword(ctx, ctxUserID, userID, pwd, confirmPwd)
	return err == nil, err
}

// SetMyPwd is the resolver for the setMyPwd field.
func (r *mutationResolver) SetMyPwd(ctx context.Context, oldPwd string, pwd string, confirmPwd string) (bool, error) {
	ctxUserID := account.CtxUserID(ctx)
	err := account.SetMyPassword(ctx, ctxUserID, oldPwd, pwd, confirmPwd)
	return err == nil, err
}

// UpdateProfile is the resolver for the updateProfile field.
func (r *mutationResolver) UpdateProfile(ctx context.Context, input *pkgModel.InputUserProfile) (bool, error) {
	err := account.UpdateProfile(ctx, account.CtxUser(ctx), input)
	return err == nil, err
}

// SessionAlive is the resolver for the sessionAlive field.
func (r *queryResolver) SessionAlive(ctx context.Context) (bool, error) {
	return account.CtxUserID(ctx) != "", nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*account.User, error) {
	u := account.CtxUser(ctx)
	return u, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*ent.User, error) {
	db := ent.GetClient()
	defer db.CloseClient()
	return db.User.Get(ctx, id)
}

// Users is the resolver for the users field.
func (r *queryResolver) Users(ctx context.Context, page model.PageInput, where *ent.UserWhereInput) (*ent.UserConnection, error) {
	db := ent.GetClient()
	defer db.CloseClient()

	qry := db.User.Query().Where(user.DeletedAtIsNil())
	return qry.Paginate(ctx, page.After, page.First, page.Before, page.Last, ent.WithUserFilter(where.Filter))
}

// UsersSearch is the resolver for the usersSearch field.
func (r *queryResolver) UsersSearch(ctx context.Context, search *string) ([]*model.UserSearchResult, error) {
	db := ent.GetClient()
	defer db.CloseClient()

	qry := db.Debug().User.Query().
		Where(user.DeletedAtIsNil()).
		Where(func(u *sql.Selector) {
			pc := sql.Table(partnercontact.Table)
			p := sql.Table(partner.Table)
			u.
				LeftJoin(pc).On(u.C(user.FieldID), pc.C(partnercontact.FieldUserID)).
				LeftJoin(p).On(pc.C(partnercontact.FieldPartnerID), p.C(partner.FieldID))

			u.Select(
				fmt.Sprintf("%s as id", u.C(user.FieldID)),
				fmt.Sprintf("%s as firstName", u.C(user.FieldFirstName)),
				fmt.Sprintf("%s as lastName", u.C(user.FieldLastName)),
				fmt.Sprintf("%s as email", u.C(user.FieldEmail)),
				fmt.Sprintf("%s as phone", u.C(user.FieldPhone)),
				fmt.Sprintf("%s as partnerID", p.C(partner.FieldID)),
				fmt.Sprintf("%s as partnerName", p.C(partner.FieldName)),
				fmt.Sprintf("%s as partnerContactType", pc.C(partnercontact.FieldType)),
				fmt.Sprintf("%s as partnerContactTitle", pc.C(partnercontact.FieldTitle)),
			)
		})

	q := str.Val(search)
	if q != "" {
		qry.Where(
			user.Or(
				user.EmailContainsFold(q),
				user.FirstNameContainsFold(q),
				user.LastNameContainsFold(q),
			),
		)
	}

	var list []*model.UserSearchResult
	if err := qry.Select().Scan(ctx, &list); err != nil {
		return nil, err
	}

	return list, nil
}

// UserEmailAvailable is the resolver for the userEmailAvailable field.
func (r *queryResolver) UserEmailAvailable(ctx context.Context, id string, email string) (bool, error) {
	if !validate.Email(email) { // empty will send back true
		return false, errors.New("invalid email address")
	}

	db := ent.GetClient()
	defer db.CloseClient()

	e := strings.TrimSpace(email)
	qry := db.User.Query().Where(user.EmailEqualFold(e))
	if id != "" {
		qry.Where(user.IDNEQ(id))
	}
	exists, err := qry.Exist(ctx)

	return !exists, err
}

// MyCompanyUsers is the resolver for the myCompanyUsers field.
func (r *queryResolver) MyCompanyUsers(ctx context.Context, search *string, page model.PageInput) (*ent.UserConnection, error) {
	u := account.CtxUser(ctx)
	if u.Partner == nil {
		return nil, errors.New("unable to find linked partner account info")
	}

	return pkgPartner.SearchUsers(ctx, u.ID, u.Partner.ID, str.Val(search), &page)
}

// IosAppVersion is the resolver for the iosAppVersion field.
func (r *queryResolver) IosAppVersion(ctx context.Context) (string, error) {
	switch config.AppEnv {
	case config.AppEnvProd:
		return "1.1.0", nil
	default:
		return "1.3.0", nil
	}
}

// Partner is the resolver for the partner field.
func (r *userResolver) Partner(ctx context.Context, obj *ent.User) (*model.Entity, error) {
	if obj == nil || obj.Edges.Partner == nil || len(obj.Edges.Partner) == 0 {
		return nil, nil
	}

	p := obj.Edges.Partner[0]
	return &model.Entity{
		ID:   p.ID,
		Name: p.Name,
	}, nil
}

// User returns generated.UserResolver implementation.
func (r *Resolver) User() generated.UserResolver { return &userResolver{r} }

type userResolver struct{ *Resolver }
