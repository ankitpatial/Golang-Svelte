package server

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.32

import (
	"context"
	"roofix/ent"
	entJob "roofix/ent/job"
	"roofix/ent/jobprogresshistory"
	"roofix/pkg/enum"
	"roofix/pkg/job"
	"roofix/server/generated"
	"roofix/server/model"
	"time"
)

// StatusAt is the resolver for the statusAt field.
func (r *jobProgressHistoryResolver) StatusAt(ctx context.Context, obj *ent.JobProgressHistory) (*time.Time, error) {
	if obj == nil {
		return nil, nil
	}

	return &obj.CreatedAt, nil
}

// JobProgressUpdate is the resolver for the jobProgressUpdate field.
func (r *mutationResolver) JobProgressUpdate(ctx context.Context, id string, step enum.JobProgress, stepComplete bool, note string, data *model.ProgressInput) (bool, error) {
	if err := job.AssertAdminOrAssigned(ctx, id); err != nil {
		return false, err
	}

	err := job.ProgressUpdate(ctx, id, step, stepComplete, note, data)
	return err == nil, err
}

// JobDelay is the resolver for the jobDelay field.
func (r *mutationResolver) JobDelay(ctx context.Context, id string, flag bool, reason string) (bool, error) {
	if err := job.AssertAdminOrAssigned(ctx, id); err != nil {
		return false, err
	}

	err := job.ProgressDelay(ctx, id, flag, reason)
	return err == nil, err
}

// JobCompletedProgress history
func (r *queryResolver) JobCompletedProgress(ctx context.Context, id string) ([]*ent.JobProgressHistory, error) {
	if err := job.AssertAccess(ctx, id); err != nil {
		return nil, err
	}

	db := ent.GetClient()
	defer db.CloseClient()

	return db.JobProgressHistory.Query().
		Where(
			jobprogresshistory.HasJobWith(entJob.ID(id)),
			jobprogresshistory.Complete(true),
		).
		Order(ent.Asc(jobprogresshistory.FieldCreatedAt)).
		All(ctx)
}

// JobProgress is the resolver for the jobProgress field.
func (r *queryResolver) JobProgress(ctx context.Context, id string, search *string, page model.PageInput) (*ent.JobProgressHistoryConnection, error) {
	if err := job.AssertAccess(ctx, id); err != nil {
		return nil, err
	}

	db := ent.GetClient()
	defer db.CloseClient()

	qry := db.JobProgressHistory.
		Query().
		Where(jobprogresshistory.HasJobWith(entJob.ID(id))).
		Order(ent.Desc(jobprogresshistory.FieldCreatedAt))

	res, err := qry.Paginate(ctx, page.After, page.First, page.Before, page.Last)

	return res, err
}

// JobProgressHistory returns generated.JobProgressHistoryResolver implementation.
func (r *Resolver) JobProgressHistory() generated.JobProgressHistoryResolver {
	return &jobProgressHistoryResolver{r}
}

type jobProgressHistoryResolver struct{ *Resolver }
