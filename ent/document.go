// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"roofix/ent/document"
	"roofix/ent/estimate"
	"roofix/ent/installationjobitem"
	"roofix/ent/job"
	"roofix/ent/product"
	"roofix/ent/trainingvideo"
	"roofix/pkg/enum"
	"strings"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Document is the model entity for the Document schema.
type Document struct {
	config `json:"-"`
	// ID of the ent.
	ID string `json:"id,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"createdAt"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updatedAt"`
	// Bucket holds the value of the "bucket" field.
	Bucket string `json:"bucket,omitempty"`
	// Key holds the value of the "key" field.
	Key string `json:"key,omitempty"`
	// Folder holds the value of the "folder" field.
	Folder enum.DocFolder `json:"folder,omitempty"`
	// Dir holds the value of the "dir" field.
	Dir *string `json:"dir,omitempty"`
	// Section holds the value of the "section" field.
	Section enum.DocSection `json:"section,omitempty"`
	// name on storage
	Name string `json:"name,omitempty"`
	// actual filename
	Filename string `json:"filename,omitempty"`
	// ContentType holds the value of the "content_type" field.
	ContentType *string `json:"content_type,omitempty"`
	// ContentSize holds the value of the "content_size" field.
	ContentSize int64 `json:"content_size,omitempty"`
	// ready to access. True means uploaded and saved ok to storage
	Ready bool `json:"ready,omitempty"`
	// CreatorID holds the value of the "creator_id" field.
	CreatorID string `json:"creator_id,omitempty"`
	// UpdaterID holds the value of the "updater_id" field.
	UpdaterID *string `json:"updater_id,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the DocumentQuery when eager-loading is set.
	Edges        DocumentEdges `json:"edges"`
	image_id     *string
	selectValues sql.SelectValues
}

// DocumentEdges holds the relations/edges for other nodes in the graph.
type DocumentEdges struct {
	// TrainingVideo holds the value of the training_video edge.
	TrainingVideo *TrainingVideo `json:"training_video,omitempty"`
	// TrainingVideoPoster holds the value of the training_video_poster edge.
	TrainingVideoPoster *TrainingVideo `json:"training_video_poster,omitempty"`
	// ProductsImage holds the value of the products_image edge.
	ProductsImage *Product `json:"products_image,omitempty"`
	// InstallationJobItemImage holds the value of the installation_job_item_image edge.
	InstallationJobItemImage *InstallationJobItem `json:"installation_job_item_image,omitempty"`
	// EstimatePdf holds the value of the estimate_pdf edge.
	EstimatePdf *Estimate `json:"estimate_pdf,omitempty"`
	// JobEstimatePdf holds the value of the job_estimate_pdf edge.
	JobEstimatePdf *Job `json:"job_estimate_pdf,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [6]bool
	// totalCount holds the count of the edges above.
	totalCount [6]map[string]int
}

// TrainingVideoOrErr returns the TrainingVideo value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e DocumentEdges) TrainingVideoOrErr() (*TrainingVideo, error) {
	if e.loadedTypes[0] {
		if e.TrainingVideo == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: trainingvideo.Label}
		}
		return e.TrainingVideo, nil
	}
	return nil, &NotLoadedError{edge: "training_video"}
}

// TrainingVideoPosterOrErr returns the TrainingVideoPoster value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e DocumentEdges) TrainingVideoPosterOrErr() (*TrainingVideo, error) {
	if e.loadedTypes[1] {
		if e.TrainingVideoPoster == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: trainingvideo.Label}
		}
		return e.TrainingVideoPoster, nil
	}
	return nil, &NotLoadedError{edge: "training_video_poster"}
}

// ProductsImageOrErr returns the ProductsImage value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e DocumentEdges) ProductsImageOrErr() (*Product, error) {
	if e.loadedTypes[2] {
		if e.ProductsImage == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: product.Label}
		}
		return e.ProductsImage, nil
	}
	return nil, &NotLoadedError{edge: "products_image"}
}

// InstallationJobItemImageOrErr returns the InstallationJobItemImage value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e DocumentEdges) InstallationJobItemImageOrErr() (*InstallationJobItem, error) {
	if e.loadedTypes[3] {
		if e.InstallationJobItemImage == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: installationjobitem.Label}
		}
		return e.InstallationJobItemImage, nil
	}
	return nil, &NotLoadedError{edge: "installation_job_item_image"}
}

// EstimatePdfOrErr returns the EstimatePdf value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e DocumentEdges) EstimatePdfOrErr() (*Estimate, error) {
	if e.loadedTypes[4] {
		if e.EstimatePdf == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: estimate.Label}
		}
		return e.EstimatePdf, nil
	}
	return nil, &NotLoadedError{edge: "estimate_pdf"}
}

// JobEstimatePdfOrErr returns the JobEstimatePdf value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e DocumentEdges) JobEstimatePdfOrErr() (*Job, error) {
	if e.loadedTypes[5] {
		if e.JobEstimatePdf == nil {
			// Edge was loaded but was not found.
			return nil, &NotFoundError{label: job.Label}
		}
		return e.JobEstimatePdf, nil
	}
	return nil, &NotLoadedError{edge: "job_estimate_pdf"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Document) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case document.FieldReady:
			values[i] = new(sql.NullBool)
		case document.FieldContentSize:
			values[i] = new(sql.NullInt64)
		case document.FieldID, document.FieldBucket, document.FieldKey, document.FieldFolder, document.FieldDir, document.FieldSection, document.FieldName, document.FieldFilename, document.FieldContentType, document.FieldCreatorID, document.FieldUpdaterID:
			values[i] = new(sql.NullString)
		case document.FieldCreatedAt, document.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		case document.ForeignKeys[0]: // image_id
			values[i] = new(sql.NullString)
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Document fields.
func (d *Document) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case document.FieldID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value.Valid {
				d.ID = value.String
			}
		case document.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				d.CreatedAt = value.Time
			}
		case document.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				d.UpdatedAt = value.Time
			}
		case document.FieldBucket:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field bucket", values[i])
			} else if value.Valid {
				d.Bucket = value.String
			}
		case document.FieldKey:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field key", values[i])
			} else if value.Valid {
				d.Key = value.String
			}
		case document.FieldFolder:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field folder", values[i])
			} else if value.Valid {
				d.Folder = enum.DocFolder(value.String)
			}
		case document.FieldDir:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field dir", values[i])
			} else if value.Valid {
				d.Dir = new(string)
				*d.Dir = value.String
			}
		case document.FieldSection:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field section", values[i])
			} else if value.Valid {
				d.Section = enum.DocSection(value.String)
			}
		case document.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				d.Name = value.String
			}
		case document.FieldFilename:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field filename", values[i])
			} else if value.Valid {
				d.Filename = value.String
			}
		case document.FieldContentType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field content_type", values[i])
			} else if value.Valid {
				d.ContentType = new(string)
				*d.ContentType = value.String
			}
		case document.FieldContentSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field content_size", values[i])
			} else if value.Valid {
				d.ContentSize = value.Int64
			}
		case document.FieldReady:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field ready", values[i])
			} else if value.Valid {
				d.Ready = value.Bool
			}
		case document.FieldCreatorID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field creator_id", values[i])
			} else if value.Valid {
				d.CreatorID = value.String
			}
		case document.FieldUpdaterID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field updater_id", values[i])
			} else if value.Valid {
				d.UpdaterID = new(string)
				*d.UpdaterID = value.String
			}
		case document.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field image_id", values[i])
			} else if value.Valid {
				d.image_id = new(string)
				*d.image_id = value.String
			}
		default:
			d.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Document.
// This includes values selected through modifiers, order, etc.
func (d *Document) Value(name string) (ent.Value, error) {
	return d.selectValues.Get(name)
}

// QueryTrainingVideo queries the "training_video" edge of the Document entity.
func (d *Document) QueryTrainingVideo() *TrainingVideoQuery {
	return NewDocumentClient(d.config).QueryTrainingVideo(d)
}

// QueryTrainingVideoPoster queries the "training_video_poster" edge of the Document entity.
func (d *Document) QueryTrainingVideoPoster() *TrainingVideoQuery {
	return NewDocumentClient(d.config).QueryTrainingVideoPoster(d)
}

// QueryProductsImage queries the "products_image" edge of the Document entity.
func (d *Document) QueryProductsImage() *ProductQuery {
	return NewDocumentClient(d.config).QueryProductsImage(d)
}

// QueryInstallationJobItemImage queries the "installation_job_item_image" edge of the Document entity.
func (d *Document) QueryInstallationJobItemImage() *InstallationJobItemQuery {
	return NewDocumentClient(d.config).QueryInstallationJobItemImage(d)
}

// QueryEstimatePdf queries the "estimate_pdf" edge of the Document entity.
func (d *Document) QueryEstimatePdf() *EstimateQuery {
	return NewDocumentClient(d.config).QueryEstimatePdf(d)
}

// QueryJobEstimatePdf queries the "job_estimate_pdf" edge of the Document entity.
func (d *Document) QueryJobEstimatePdf() *JobQuery {
	return NewDocumentClient(d.config).QueryJobEstimatePdf(d)
}

// Update returns a builder for updating this Document.
// Note that you need to call Document.Unwrap() before calling this method if this Document
// was returned from a transaction, and the transaction was committed or rolled back.
func (d *Document) Update() *DocumentUpdateOne {
	return NewDocumentClient(d.config).UpdateOne(d)
}

// Unwrap unwraps the Document entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (d *Document) Unwrap() *Document {
	_tx, ok := d.config.driver.(*txDriver)
	if !ok {
		panic("ent: Document is not a transactional entity")
	}
	d.config.driver = _tx.drv
	return d
}

// String implements the fmt.Stringer.
func (d *Document) String() string {
	var builder strings.Builder
	builder.WriteString("Document(")
	builder.WriteString(fmt.Sprintf("id=%v, ", d.ID))
	builder.WriteString("created_at=")
	builder.WriteString(d.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(d.UpdatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("bucket=")
	builder.WriteString(d.Bucket)
	builder.WriteString(", ")
	builder.WriteString("key=")
	builder.WriteString(d.Key)
	builder.WriteString(", ")
	builder.WriteString("folder=")
	builder.WriteString(fmt.Sprintf("%v", d.Folder))
	builder.WriteString(", ")
	if v := d.Dir; v != nil {
		builder.WriteString("dir=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("section=")
	builder.WriteString(fmt.Sprintf("%v", d.Section))
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(d.Name)
	builder.WriteString(", ")
	builder.WriteString("filename=")
	builder.WriteString(d.Filename)
	builder.WriteString(", ")
	if v := d.ContentType; v != nil {
		builder.WriteString("content_type=")
		builder.WriteString(*v)
	}
	builder.WriteString(", ")
	builder.WriteString("content_size=")
	builder.WriteString(fmt.Sprintf("%v", d.ContentSize))
	builder.WriteString(", ")
	builder.WriteString("ready=")
	builder.WriteString(fmt.Sprintf("%v", d.Ready))
	builder.WriteString(", ")
	builder.WriteString("creator_id=")
	builder.WriteString(d.CreatorID)
	builder.WriteString(", ")
	if v := d.UpdaterID; v != nil {
		builder.WriteString("updater_id=")
		builder.WriteString(*v)
	}
	builder.WriteByte(')')
	return builder.String()
}

// Documents is a parsable slice of Document.
type Documents []*Document
