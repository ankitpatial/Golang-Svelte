// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"roofix/ent/apiaccess"
	"roofix/ent/apiuser"
	"roofix/ent/apiusertoken"
	"roofix/ent/auditlog"
	"roofix/ent/channel"
	"roofix/ent/channelmessage"
	"roofix/ent/channelmessageread"
	"roofix/ent/channelsub"
	"roofix/ent/contactus"
	"roofix/ent/document"
	"roofix/ent/estimate"
	"roofix/ent/estimateactivity"
	"roofix/ent/homeowner"
	"roofix/ent/installationjob"
	"roofix/ent/installationjobitem"
	"roofix/ent/installationjobprogress"
	"roofix/ent/job"
	"roofix/ent/jobactivity"
	"roofix/ent/jobassignmenthistory"
	"roofix/ent/jobdocurl"
	"roofix/ent/jobnote"
	"roofix/ent/jobprogresshistory"
	"roofix/ent/notifysetting"
	"roofix/ent/optionlist"
	"roofix/ent/partner"
	"roofix/ent/partneractivity"
	"roofix/ent/partnercontact"
	"roofix/ent/partnerservice"
	"roofix/ent/partnerservicecity"
	"roofix/ent/partnerservicestate"
	"roofix/ent/partnertrainingvideo"
	"roofix/ent/payment"
	"roofix/ent/postalcode"
	"roofix/ent/pricing"
	"roofix/ent/product"
	"roofix/ent/productpackage"
	"roofix/ent/survey"
	"roofix/ent/surveyprogress"
	"roofix/ent/token"
	"roofix/ent/trainingcourse"
	"roofix/ent/trainingvideo"
	"roofix/ent/user"
	"roofix/ent/useractivity"
	"roofix/ent/userauth"
	"roofix/ent/usersession"
	"roofix/ent/usersessionsocket"

	"entgo.io/contrib/entgql"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (aa *ApiAccessQuery) CollectFields(ctx context.Context, satisfies ...string) (*ApiAccessQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return aa, nil
	}
	if err := aa.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return aa, nil
}

func (aa *ApiAccessQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(apiaccess.Columns))
		selectedFields = []string{apiaccess.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createdAt":
			if _, ok := fieldSeen[apiaccess.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, apiaccess.FieldCreatedAt)
				fieldSeen[apiaccess.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[apiaccess.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, apiaccess.FieldUpdatedAt)
				fieldSeen[apiaccess.FieldUpdatedAt] = struct{}{}
			}
		case "url":
			if _, ok := fieldSeen[apiaccess.FieldURL]; !ok {
				selectedFields = append(selectedFields, apiaccess.FieldURL)
				fieldSeen[apiaccess.FieldURL] = struct{}{}
			}
		case "username":
			if _, ok := fieldSeen[apiaccess.FieldUsername]; !ok {
				selectedFields = append(selectedFields, apiaccess.FieldUsername)
				fieldSeen[apiaccess.FieldUsername] = struct{}{}
			}
		case "password":
			if _, ok := fieldSeen[apiaccess.FieldPassword]; !ok {
				selectedFields = append(selectedFields, apiaccess.FieldPassword)
				fieldSeen[apiaccess.FieldPassword] = struct{}{}
			}
		case "key":
			if _, ok := fieldSeen[apiaccess.FieldKey]; !ok {
				selectedFields = append(selectedFields, apiaccess.FieldKey)
				fieldSeen[apiaccess.FieldKey] = struct{}{}
			}
		case "secret":
			if _, ok := fieldSeen[apiaccess.FieldSecret]; !ok {
				selectedFields = append(selectedFields, apiaccess.FieldSecret)
				fieldSeen[apiaccess.FieldSecret] = struct{}{}
			}
		case "accessToken":
			if _, ok := fieldSeen[apiaccess.FieldAccessToken]; !ok {
				selectedFields = append(selectedFields, apiaccess.FieldAccessToken)
				fieldSeen[apiaccess.FieldAccessToken] = struct{}{}
			}
		case "refreshToken":
			if _, ok := fieldSeen[apiaccess.FieldRefreshToken]; !ok {
				selectedFields = append(selectedFields, apiaccess.FieldRefreshToken)
				fieldSeen[apiaccess.FieldRefreshToken] = struct{}{}
			}
		case "expiresAt":
			if _, ok := fieldSeen[apiaccess.FieldExpiresAt]; !ok {
				selectedFields = append(selectedFields, apiaccess.FieldExpiresAt)
				fieldSeen[apiaccess.FieldExpiresAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		aa.Select(selectedFields...)
	}
	return nil
}

type apiaccessPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ApiAccessPaginateOption
}

func newApiAccessPaginateArgs(rv map[string]any) *apiaccessPaginateArgs {
	args := &apiaccessPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ApiAccessOrder{Field: &ApiAccessOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithApiAccessOrder(order))
			}
		case *ApiAccessOrder:
			if v != nil {
				args.opts = append(args.opts, WithApiAccessOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ApiAccessWhereInput); ok {
		args.opts = append(args.opts, WithApiAccessFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (au *ApiUserQuery) CollectFields(ctx context.Context, satisfies ...string) (*ApiUserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return au, nil
	}
	if err := au.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return au, nil
}

func (au *ApiUserQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(apiuser.Columns))
		selectedFields = []string{apiuser.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "tokens":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserTokenClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedTokens(alias, func(wq *ApiUserTokenQuery) {
				*wq = *query
			})
		case "auditLogs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AuditLogClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedAuditLogs(alias, func(wq *AuditLogQuery) {
				*wq = *query
			})
		case "createdEstimates":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedCreatedEstimates(alias, func(wq *EstimateQuery) {
				*wq = *query
			})
		case "createdJobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedCreatedJobs(alias, func(wq *JobQuery) {
				*wq = *query
			})
		case "createdPartners":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedCreatedPartners(alias, func(wq *PartnerQuery) {
				*wq = *query
			})
		case "surveyProgress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SurveyProgressClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedSurveyProgress(alias, func(wq *SurveyProgressQuery) {
				*wq = *query
			})
		case "estimateActivities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateActivityClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedEstimateActivities(alias, func(wq *EstimateActivityQuery) {
				*wq = *query
			})
		case "userActivities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserActivityClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedUserActivities(alias, func(wq *UserActivityQuery) {
				*wq = *query
			})
		case "partnerActivities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerActivityClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedPartnerActivities(alias, func(wq *PartnerActivityQuery) {
				*wq = *query
			})
		case "jobActivities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobActivityClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedJobActivities(alias, func(wq *JobActivityQuery) {
				*wq = *query
			})
		case "notifications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelMessageClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedNotifications(alias, func(wq *ChannelMessageQuery) {
				*wq = *query
			})
		case "jobProgressHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobProgressHistoryClient{config: au.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			au.WithNamedJobProgressHistory(alias, func(wq *JobProgressHistoryQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[apiuser.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, apiuser.FieldCreatedAt)
				fieldSeen[apiuser.FieldCreatedAt] = struct{}{}
			}
		case "username":
			if _, ok := fieldSeen[apiuser.FieldUsername]; !ok {
				selectedFields = append(selectedFields, apiuser.FieldUsername)
				fieldSeen[apiuser.FieldUsername] = struct{}{}
			}
		case "pwdHash":
			if _, ok := fieldSeen[apiuser.FieldPwdHash]; !ok {
				selectedFields = append(selectedFields, apiuser.FieldPwdHash)
				fieldSeen[apiuser.FieldPwdHash] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[apiuser.FieldActive]; !ok {
				selectedFields = append(selectedFields, apiuser.FieldActive)
				fieldSeen[apiuser.FieldActive] = struct{}{}
			}
		case "cbAPIURL":
			if _, ok := fieldSeen[apiuser.FieldCbAPIURL]; !ok {
				selectedFields = append(selectedFields, apiuser.FieldCbAPIURL)
				fieldSeen[apiuser.FieldCbAPIURL] = struct{}{}
			}
		case "cbAPIAuth":
			if _, ok := fieldSeen[apiuser.FieldCbAPIAuth]; !ok {
				selectedFields = append(selectedFields, apiuser.FieldCbAPIAuth)
				fieldSeen[apiuser.FieldCbAPIAuth] = struct{}{}
			}
		case "cbAPIUser":
			if _, ok := fieldSeen[apiuser.FieldCbAPIUser]; !ok {
				selectedFields = append(selectedFields, apiuser.FieldCbAPIUser)
				fieldSeen[apiuser.FieldCbAPIUser] = struct{}{}
			}
		case "cbAPIPwd":
			if _, ok := fieldSeen[apiuser.FieldCbAPIPwd]; !ok {
				selectedFields = append(selectedFields, apiuser.FieldCbAPIPwd)
				fieldSeen[apiuser.FieldCbAPIPwd] = struct{}{}
			}
		case "cbAPIToken":
			if _, ok := fieldSeen[apiuser.FieldCbAPIToken]; !ok {
				selectedFields = append(selectedFields, apiuser.FieldCbAPIToken)
				fieldSeen[apiuser.FieldCbAPIToken] = struct{}{}
			}
		case "cbAPIEndpoints":
			if _, ok := fieldSeen[apiuser.FieldCbAPIEndpoints]; !ok {
				selectedFields = append(selectedFields, apiuser.FieldCbAPIEndpoints)
				fieldSeen[apiuser.FieldCbAPIEndpoints] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		au.Select(selectedFields...)
	}
	return nil
}

type apiuserPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ApiUserPaginateOption
}

func newApiUserPaginateArgs(rv map[string]any) *apiuserPaginateArgs {
	args := &apiuserPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ApiUserOrder{Field: &ApiUserOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithApiUserOrder(order))
			}
		case *ApiUserOrder:
			if v != nil {
				args.opts = append(args.opts, WithApiUserOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ApiUserWhereInput); ok {
		args.opts = append(args.opts, WithApiUserFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (aut *ApiUserTokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*ApiUserTokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return aut, nil
	}
	if err := aut.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return aut, nil
}

func (aut *ApiUserTokenQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(apiusertoken.Columns))
		selectedFields = []string{apiusertoken.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "apiUser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: aut.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			aut.withAPIUser = query
		case "createdAt":
			if _, ok := fieldSeen[apiusertoken.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, apiusertoken.FieldCreatedAt)
				fieldSeen[apiusertoken.FieldCreatedAt] = struct{}{}
			}
		case "tokenType":
			if _, ok := fieldSeen[apiusertoken.FieldTokenType]; !ok {
				selectedFields = append(selectedFields, apiusertoken.FieldTokenType)
				fieldSeen[apiusertoken.FieldTokenType] = struct{}{}
			}
		case "tokenID":
			if _, ok := fieldSeen[apiusertoken.FieldTokenID]; !ok {
				selectedFields = append(selectedFields, apiusertoken.FieldTokenID)
				fieldSeen[apiusertoken.FieldTokenID] = struct{}{}
			}
		case "refreshTokenID":
			if _, ok := fieldSeen[apiusertoken.FieldRefreshTokenID]; !ok {
				selectedFields = append(selectedFields, apiusertoken.FieldRefreshTokenID)
				fieldSeen[apiusertoken.FieldRefreshTokenID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		aut.Select(selectedFields...)
	}
	return nil
}

type apiusertokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ApiUserTokenPaginateOption
}

func newApiUserTokenPaginateArgs(rv map[string]any) *apiusertokenPaginateArgs {
	args := &apiusertokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ApiUserTokenOrder{Field: &ApiUserTokenOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithApiUserTokenOrder(order))
			}
		case *ApiUserTokenOrder:
			if v != nil {
				args.opts = append(args.opts, WithApiUserTokenOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ApiUserTokenWhereInput); ok {
		args.opts = append(args.opts, WithApiUserTokenFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (al *AuditLogQuery) CollectFields(ctx context.Context, satisfies ...string) (*AuditLogQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return al, nil
	}
	if err := al.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return al, nil
}

func (al *AuditLogQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(auditlog.Columns))
		selectedFields = []string{auditlog.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: al.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			al.withUser = query
		case "apiUser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: al.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			al.withAPIUser = query
		case "createdAt":
			if _, ok := fieldSeen[auditlog.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldCreatedAt)
				fieldSeen[auditlog.FieldCreatedAt] = struct{}{}
			}
		case "action":
			if _, ok := fieldSeen[auditlog.FieldAction]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldAction)
				fieldSeen[auditlog.FieldAction] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[auditlog.FieldDescription]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldDescription)
				fieldSeen[auditlog.FieldDescription] = struct{}{}
			}
		case "ip":
			if _, ok := fieldSeen[auditlog.FieldIP]; !ok {
				selectedFields = append(selectedFields, auditlog.FieldIP)
				fieldSeen[auditlog.FieldIP] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		al.Select(selectedFields...)
	}
	return nil
}

type auditlogPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AuditLogPaginateOption
}

func newAuditLogPaginateArgs(rv map[string]any) *auditlogPaginateArgs {
	args := &auditlogPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &AuditLogOrder{Field: &AuditLogOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithAuditLogOrder(order))
			}
		case *AuditLogOrder:
			if v != nil {
				args.opts = append(args.opts, WithAuditLogOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*AuditLogWhereInput); ok {
		args.opts = append(args.opts, WithAuditLogFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ChannelQuery) CollectFields(ctx context.Context, satisfies ...string) (*ChannelQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *ChannelQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(channel.Columns))
		selectedFields = []string{channel.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "subscriptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelSubClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedSubscriptions(alias, func(wq *ChannelSubQuery) {
				*wq = *query
			})
		case "messages":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelMessageClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			c.WithNamedMessages(alias, func(wq *ChannelMessageQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[channel.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, channel.FieldCreatedAt)
				fieldSeen[channel.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[channel.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, channel.FieldUpdatedAt)
				fieldSeen[channel.FieldUpdatedAt] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[channel.FieldName]; !ok {
				selectedFields = append(selectedFields, channel.FieldName)
				fieldSeen[channel.FieldName] = struct{}{}
			}
		case "topic":
			if _, ok := fieldSeen[channel.FieldTopic]; !ok {
				selectedFields = append(selectedFields, channel.FieldTopic)
				fieldSeen[channel.FieldTopic] = struct{}{}
			}
		case "refID":
			if _, ok := fieldSeen[channel.FieldRefID]; !ok {
				selectedFields = append(selectedFields, channel.FieldRefID)
				fieldSeen[channel.FieldRefID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type channelPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ChannelPaginateOption
}

func newChannelPaginateArgs(rv map[string]any) *channelPaginateArgs {
	args := &channelPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ChannelOrder{Field: &ChannelOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithChannelOrder(order))
			}
		case *ChannelOrder:
			if v != nil {
				args.opts = append(args.opts, WithChannelOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ChannelWhereInput); ok {
		args.opts = append(args.opts, WithChannelFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cm *ChannelMessageQuery) CollectFields(ctx context.Context, satisfies ...string) (*ChannelMessageQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cm, nil
	}
	if err := cm.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cm, nil
}

func (cm *ChannelMessageQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(channelmessage.Columns))
		selectedFields = []string{channelmessage.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "reads":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelMessageReadClient{config: cm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cm.WithNamedReads(alias, func(wq *ChannelMessageReadQuery) {
				*wq = *query
			})
		case "channel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelClient{config: cm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cm.withChannel = query
		case "from":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: cm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cm.withFrom = query
		case "fromAPIUser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: cm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cm.withFromAPIUser = query
		case "to":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: cm.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cm.withTo = query
		case "createdAt":
			if _, ok := fieldSeen[channelmessage.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, channelmessage.FieldCreatedAt)
				fieldSeen[channelmessage.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[channelmessage.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, channelmessage.FieldUpdatedAt)
				fieldSeen[channelmessage.FieldUpdatedAt] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[channelmessage.FieldTitle]; !ok {
				selectedFields = append(selectedFields, channelmessage.FieldTitle)
				fieldSeen[channelmessage.FieldTitle] = struct{}{}
			}
		case "message":
			if _, ok := fieldSeen[channelmessage.FieldMessage]; !ok {
				selectedFields = append(selectedFields, channelmessage.FieldMessage)
				fieldSeen[channelmessage.FieldMessage] = struct{}{}
			}
		case "fromName":
			if _, ok := fieldSeen[channelmessage.FieldFromName]; !ok {
				selectedFields = append(selectedFields, channelmessage.FieldFromName)
				fieldSeen[channelmessage.FieldFromName] = struct{}{}
			}
		case "toName":
			if _, ok := fieldSeen[channelmessage.FieldToName]; !ok {
				selectedFields = append(selectedFields, channelmessage.FieldToName)
				fieldSeen[channelmessage.FieldToName] = struct{}{}
			}
		case "private":
			if _, ok := fieldSeen[channelmessage.FieldPrivate]; !ok {
				selectedFields = append(selectedFields, channelmessage.FieldPrivate)
				fieldSeen[channelmessage.FieldPrivate] = struct{}{}
			}
		case "unread":
			if _, ok := fieldSeen[channelmessage.FieldUnread]; !ok {
				selectedFields = append(selectedFields, channelmessage.FieldUnread)
				fieldSeen[channelmessage.FieldUnread] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cm.Select(selectedFields...)
	}
	return nil
}

type channelmessagePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ChannelMessagePaginateOption
}

func newChannelMessagePaginateArgs(rv map[string]any) *channelmessagePaginateArgs {
	args := &channelmessagePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ChannelMessageOrder{Field: &ChannelMessageOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithChannelMessageOrder(order))
			}
		case *ChannelMessageOrder:
			if v != nil {
				args.opts = append(args.opts, WithChannelMessageOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ChannelMessageWhereInput); ok {
		args.opts = append(args.opts, WithChannelMessageFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cmr *ChannelMessageReadQuery) CollectFields(ctx context.Context, satisfies ...string) (*ChannelMessageReadQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cmr, nil
	}
	if err := cmr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cmr, nil
}

func (cmr *ChannelMessageReadQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(channelmessageread.Columns))
		selectedFields = []string{channelmessageread.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "channelMessage":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelMessageClient{config: cmr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cmr.withChannelMessage = query
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: cmr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cmr.withUser = query
		case "createdAt":
			if _, ok := fieldSeen[channelmessageread.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, channelmessageread.FieldCreatedAt)
				fieldSeen[channelmessageread.FieldCreatedAt] = struct{}{}
			}
		case "read":
			if _, ok := fieldSeen[channelmessageread.FieldRead]; !ok {
				selectedFields = append(selectedFields, channelmessageread.FieldRead)
				fieldSeen[channelmessageread.FieldRead] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cmr.Select(selectedFields...)
	}
	return nil
}

type channelmessagereadPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ChannelMessageReadPaginateOption
}

func newChannelMessageReadPaginateArgs(rv map[string]any) *channelmessagereadPaginateArgs {
	args := &channelmessagereadPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ChannelMessageReadOrder{Field: &ChannelMessageReadOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithChannelMessageReadOrder(order))
			}
		case *ChannelMessageReadOrder:
			if v != nil {
				args.opts = append(args.opts, WithChannelMessageReadOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ChannelMessageReadWhereInput); ok {
		args.opts = append(args.opts, WithChannelMessageReadFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cs *ChannelSubQuery) CollectFields(ctx context.Context, satisfies ...string) (*ChannelSubQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cs, nil
	}
	if err := cs.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cs, nil
}

func (cs *ChannelSubQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(channelsub.Columns))
		selectedFields = []string{channelsub.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "channel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cs.withChannel = query
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cs.withUser = query
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cs.withPartner = query
		case "createdAt":
			if _, ok := fieldSeen[channelsub.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, channelsub.FieldCreatedAt)
				fieldSeen[channelsub.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[channelsub.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, channelsub.FieldUpdatedAt)
				fieldSeen[channelsub.FieldUpdatedAt] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[channelsub.FieldRole]; !ok {
				selectedFields = append(selectedFields, channelsub.FieldRole)
				fieldSeen[channelsub.FieldRole] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cs.Select(selectedFields...)
	}
	return nil
}

type channelsubPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ChannelSubPaginateOption
}

func newChannelSubPaginateArgs(rv map[string]any) *channelsubPaginateArgs {
	args := &channelsubPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ChannelSubOrder{Field: &ChannelSubOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithChannelSubOrder(order))
			}
		case *ChannelSubOrder:
			if v != nil {
				args.opts = append(args.opts, WithChannelSubOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ChannelSubWhereInput); ok {
		args.opts = append(args.opts, WithChannelSubFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cu *ContactUsQuery) CollectFields(ctx context.Context, satisfies ...string) (*ContactUsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cu, nil
	}
	if err := cu.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cu, nil
}

func (cu *ContactUsQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(contactus.Columns))
		selectedFields = []string{contactus.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: cu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cu.withPartner = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: cu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			cu.withCreator = query
		case "createdAt":
			if _, ok := fieldSeen[contactus.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, contactus.FieldCreatedAt)
				fieldSeen[contactus.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[contactus.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, contactus.FieldUpdatedAt)
				fieldSeen[contactus.FieldUpdatedAt] = struct{}{}
			}
		case "reason":
			if _, ok := fieldSeen[contactus.FieldReason]; !ok {
				selectedFields = append(selectedFields, contactus.FieldReason)
				fieldSeen[contactus.FieldReason] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cu.Select(selectedFields...)
	}
	return nil
}

type contactusPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ContactUsPaginateOption
}

func newContactUsPaginateArgs(rv map[string]any) *contactusPaginateArgs {
	args := &contactusPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ContactUsOrder{Field: &ContactUsOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithContactUsOrder(order))
			}
		case *ContactUsOrder:
			if v != nil {
				args.opts = append(args.opts, WithContactUsOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ContactUsWhereInput); ok {
		args.opts = append(args.opts, WithContactUsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (d *DocumentQuery) CollectFields(ctx context.Context, satisfies ...string) (*DocumentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return d, nil
	}
	if err := d.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *DocumentQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(document.Columns))
		selectedFields = []string{document.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "trainingVideo":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TrainingVideoClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withTrainingVideo = query
		case "trainingVideoPoster":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TrainingVideoClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withTrainingVideoPoster = query
		case "productsImage":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withProductsImage = query
		case "installationJobItemImage":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InstallationJobItemClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withInstallationJobItemImage = query
		case "estimatePdf":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withEstimatePdf = query
		case "jobEstimatePdf":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			d.withJobEstimatePdf = query
		case "createdAt":
			if _, ok := fieldSeen[document.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, document.FieldCreatedAt)
				fieldSeen[document.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[document.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, document.FieldUpdatedAt)
				fieldSeen[document.FieldUpdatedAt] = struct{}{}
			}
		case "bucket":
			if _, ok := fieldSeen[document.FieldBucket]; !ok {
				selectedFields = append(selectedFields, document.FieldBucket)
				fieldSeen[document.FieldBucket] = struct{}{}
			}
		case "key":
			if _, ok := fieldSeen[document.FieldKey]; !ok {
				selectedFields = append(selectedFields, document.FieldKey)
				fieldSeen[document.FieldKey] = struct{}{}
			}
		case "folder":
			if _, ok := fieldSeen[document.FieldFolder]; !ok {
				selectedFields = append(selectedFields, document.FieldFolder)
				fieldSeen[document.FieldFolder] = struct{}{}
			}
		case "dir":
			if _, ok := fieldSeen[document.FieldDir]; !ok {
				selectedFields = append(selectedFields, document.FieldDir)
				fieldSeen[document.FieldDir] = struct{}{}
			}
		case "section":
			if _, ok := fieldSeen[document.FieldSection]; !ok {
				selectedFields = append(selectedFields, document.FieldSection)
				fieldSeen[document.FieldSection] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[document.FieldName]; !ok {
				selectedFields = append(selectedFields, document.FieldName)
				fieldSeen[document.FieldName] = struct{}{}
			}
		case "filename":
			if _, ok := fieldSeen[document.FieldFilename]; !ok {
				selectedFields = append(selectedFields, document.FieldFilename)
				fieldSeen[document.FieldFilename] = struct{}{}
			}
		case "contentType":
			if _, ok := fieldSeen[document.FieldContentType]; !ok {
				selectedFields = append(selectedFields, document.FieldContentType)
				fieldSeen[document.FieldContentType] = struct{}{}
			}
		case "contentSize":
			if _, ok := fieldSeen[document.FieldContentSize]; !ok {
				selectedFields = append(selectedFields, document.FieldContentSize)
				fieldSeen[document.FieldContentSize] = struct{}{}
			}
		case "ready":
			if _, ok := fieldSeen[document.FieldReady]; !ok {
				selectedFields = append(selectedFields, document.FieldReady)
				fieldSeen[document.FieldReady] = struct{}{}
			}
		case "creatorID":
			if _, ok := fieldSeen[document.FieldCreatorID]; !ok {
				selectedFields = append(selectedFields, document.FieldCreatorID)
				fieldSeen[document.FieldCreatorID] = struct{}{}
			}
		case "updaterID":
			if _, ok := fieldSeen[document.FieldUpdaterID]; !ok {
				selectedFields = append(selectedFields, document.FieldUpdaterID)
				fieldSeen[document.FieldUpdaterID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		d.Select(selectedFields...)
	}
	return nil
}

type documentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DocumentPaginateOption
}

func newDocumentPaginateArgs(rv map[string]any) *documentPaginateArgs {
	args := &documentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &DocumentOrder{Field: &DocumentOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithDocumentOrder(order))
			}
		case *DocumentOrder:
			if v != nil {
				args.opts = append(args.opts, WithDocumentOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*DocumentWhereInput); ok {
		args.opts = append(args.opts, WithDocumentFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (e *EstimateQuery) CollectFields(ctx context.Context, satisfies ...string) (*EstimateQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return e, nil
	}
	if err := e.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return e, nil
}

func (e *EstimateQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(estimate.Columns))
		selectedFields = []string{estimate.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "activities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateActivityClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.WithNamedActivities(alias, func(wq *EstimateActivityQuery) {
				*wq = *query
			})
		case "jobInfo":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.withJobInfo = query
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.withPartner = query
		case "homeOwner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HomeOwnerClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.withHomeOwner = query
		case "salesRep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.withSalesRep = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.withCreator = query
		case "creatorAPI":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.withCreatorAPI = query
		case "pdf":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: e.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			e.withPdf = query
		case "createdAt":
			if _, ok := fieldSeen[estimate.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, estimate.FieldCreatedAt)
				fieldSeen[estimate.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[estimate.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, estimate.FieldUpdatedAt)
				fieldSeen[estimate.FieldUpdatedAt] = struct{}{}
			}
		case "regionID":
			if _, ok := fieldSeen[estimate.FieldRegionID]; !ok {
				selectedFields = append(selectedFields, estimate.FieldRegionID)
				fieldSeen[estimate.FieldRegionID] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[estimate.FieldStatus]; !ok {
				selectedFields = append(selectedFields, estimate.FieldStatus)
				fieldSeen[estimate.FieldStatus] = struct{}{}
			}
		case "currentMaterial":
			if _, ok := fieldSeen[estimate.FieldCurrentMaterial]; !ok {
				selectedFields = append(selectedFields, estimate.FieldCurrentMaterial)
				fieldSeen[estimate.FieldCurrentMaterial] = struct{}{}
			}
		case "newRoofingMaterial":
			if _, ok := fieldSeen[estimate.FieldNewRoofingMaterial]; !ok {
				selectedFields = append(selectedFields, estimate.FieldNewRoofingMaterial)
				fieldSeen[estimate.FieldNewRoofingMaterial] = struct{}{}
			}
		case "lowslope":
			if _, ok := fieldSeen[estimate.FieldLowSlope]; !ok {
				selectedFields = append(selectedFields, estimate.FieldLowSlope)
				fieldSeen[estimate.FieldLowSlope] = struct{}{}
			}
		case "currentMaterialLowSlope":
			if _, ok := fieldSeen[estimate.FieldCurrentMaterialLowSlope]; !ok {
				selectedFields = append(selectedFields, estimate.FieldCurrentMaterialLowSlope)
				fieldSeen[estimate.FieldCurrentMaterialLowSlope] = struct{}{}
			}
		case "newRoofingMaterialLowSlope":
			if _, ok := fieldSeen[estimate.FieldNewRoofingMaterialLowSlope]; !ok {
				selectedFields = append(selectedFields, estimate.FieldNewRoofingMaterialLowSlope)
				fieldSeen[estimate.FieldNewRoofingMaterialLowSlope] = struct{}{}
			}
		case "redeck":
			if _, ok := fieldSeen[estimate.FieldRedeck]; !ok {
				selectedFields = append(selectedFields, estimate.FieldRedeck)
				fieldSeen[estimate.FieldRedeck] = struct{}{}
			}
		case "layers":
			if _, ok := fieldSeen[estimate.FieldLayers]; !ok {
				selectedFields = append(selectedFields, estimate.FieldLayers)
				fieldSeen[estimate.FieldLayers] = struct{}{}
			}
		case "layer2Material":
			if _, ok := fieldSeen[estimate.FieldLayer2Material]; !ok {
				selectedFields = append(selectedFields, estimate.FieldLayer2Material)
				fieldSeen[estimate.FieldLayer2Material] = struct{}{}
			}
		case "layer3Material":
			if _, ok := fieldSeen[estimate.FieldLayer3Material]; !ok {
				selectedFields = append(selectedFields, estimate.FieldLayer3Material)
				fieldSeen[estimate.FieldLayer3Material] = struct{}{}
			}
		case "partialPercentage":
			if _, ok := fieldSeen[estimate.FieldPartialPercentage]; !ok {
				selectedFields = append(selectedFields, estimate.FieldPartialPercentage)
				fieldSeen[estimate.FieldPartialPercentage] = struct{}{}
			}
		case "materialMappingNote":
			if _, ok := fieldSeen[estimate.FieldMaterialMappingNote]; !ok {
				selectedFields = append(selectedFields, estimate.FieldMaterialMappingNote)
				fieldSeen[estimate.FieldMaterialMappingNote] = struct{}{}
			}
		case "measureType":
			if _, ok := fieldSeen[estimate.FieldMeasureType]; !ok {
				selectedFields = append(selectedFields, estimate.FieldMeasureType)
				fieldSeen[estimate.FieldMeasureType] = struct{}{}
			}
		case "extraChargeType":
			if _, ok := fieldSeen[estimate.FieldExtraChargeType]; !ok {
				selectedFields = append(selectedFields, estimate.FieldExtraChargeType)
				fieldSeen[estimate.FieldExtraChargeType] = struct{}{}
			}
		case "extraCharges":
			if _, ok := fieldSeen[estimate.FieldExtraCharges]; !ok {
				selectedFields = append(selectedFields, estimate.FieldExtraCharges)
				fieldSeen[estimate.FieldExtraCharges] = struct{}{}
			}
		case "extraChargeCond":
			if _, ok := fieldSeen[estimate.FieldExtraChargeCond]; !ok {
				selectedFields = append(selectedFields, estimate.FieldExtraChargeCond)
				fieldSeen[estimate.FieldExtraChargeCond] = struct{}{}
			}
		case "extraChargeNote":
			if _, ok := fieldSeen[estimate.FieldExtraChargeNote]; !ok {
				selectedFields = append(selectedFields, estimate.FieldExtraChargeNote)
				fieldSeen[estimate.FieldExtraChargeNote] = struct{}{}
			}
		case "estimator":
			if _, ok := fieldSeen[estimate.FieldEstimator]; !ok {
				selectedFields = append(selectedFields, estimate.FieldEstimator)
				fieldSeen[estimate.FieldEstimator] = struct{}{}
			}
		case "estimatorOrderID":
			if _, ok := fieldSeen[estimate.FieldEstimatorOrderID]; !ok {
				selectedFields = append(selectedFields, estimate.FieldEstimatorOrderID)
				fieldSeen[estimate.FieldEstimatorOrderID] = struct{}{}
			}
		case "estimatorReportID":
			if _, ok := fieldSeen[estimate.FieldEstimatorReportID]; !ok {
				selectedFields = append(selectedFields, estimate.FieldEstimatorReportID)
				fieldSeen[estimate.FieldEstimatorReportID] = struct{}{}
			}
		case "totalSquares":
			if _, ok := fieldSeen[estimate.FieldTotalSquares]; !ok {
				selectedFields = append(selectedFields, estimate.FieldTotalSquares)
				fieldSeen[estimate.FieldTotalSquares] = struct{}{}
			}
		case "primaryPitch":
			if _, ok := fieldSeen[estimate.FieldPrimaryPitch]; !ok {
				selectedFields = append(selectedFields, estimate.FieldPrimaryPitch)
				fieldSeen[estimate.FieldPrimaryPitch] = struct{}{}
			}
		case "price":
			if _, ok := fieldSeen[estimate.FieldPrice]; !ok {
				selectedFields = append(selectedFields, estimate.FieldPrice)
				fieldSeen[estimate.FieldPrice] = struct{}{}
			}
		case "priceSummary":
			if _, ok := fieldSeen[estimate.FieldPriceSummary]; !ok {
				selectedFields = append(selectedFields, estimate.FieldPriceSummary)
				fieldSeen[estimate.FieldPriceSummary] = struct{}{}
			}
		case "bounds":
			if _, ok := fieldSeen[estimate.FieldBounds]; !ok {
				selectedFields = append(selectedFields, estimate.FieldBounds)
				fieldSeen[estimate.FieldBounds] = struct{}{}
			}
		case "estimatorRawResponse":
			if _, ok := fieldSeen[estimate.FieldEstimatorRawResponse]; !ok {
				selectedFields = append(selectedFields, estimate.FieldEstimatorRawResponse)
				fieldSeen[estimate.FieldEstimatorRawResponse] = struct{}{}
			}
		case "override":
			if _, ok := fieldSeen[estimate.FieldOverride]; !ok {
				selectedFields = append(selectedFields, estimate.FieldOverride)
				fieldSeen[estimate.FieldOverride] = struct{}{}
			}
		case "overrideTotalSquares":
			if _, ok := fieldSeen[estimate.FieldOverrideTotalSquares]; !ok {
				selectedFields = append(selectedFields, estimate.FieldOverrideTotalSquares)
				fieldSeen[estimate.FieldOverrideTotalSquares] = struct{}{}
			}
		case "overridePrimaryPitch":
			if _, ok := fieldSeen[estimate.FieldOverridePrimaryPitch]; !ok {
				selectedFields = append(selectedFields, estimate.FieldOverridePrimaryPitch)
				fieldSeen[estimate.FieldOverridePrimaryPitch] = struct{}{}
			}
		case "overridePrice":
			if _, ok := fieldSeen[estimate.FieldOverridePrice]; !ok {
				selectedFields = append(selectedFields, estimate.FieldOverridePrice)
				fieldSeen[estimate.FieldOverridePrice] = struct{}{}
			}
		case "overridePriceSummary":
			if _, ok := fieldSeen[estimate.FieldOverridePriceSummary]; !ok {
				selectedFields = append(selectedFields, estimate.FieldOverridePriceSummary)
				fieldSeen[estimate.FieldOverridePriceSummary] = struct{}{}
			}
		case "companyRefID":
			if _, ok := fieldSeen[estimate.FieldCompanyRefID]; !ok {
				selectedFields = append(selectedFields, estimate.FieldCompanyRefID)
				fieldSeen[estimate.FieldCompanyRefID] = struct{}{}
			}
		case "companyRefName":
			if _, ok := fieldSeen[estimate.FieldCompanyRefName]; !ok {
				selectedFields = append(selectedFields, estimate.FieldCompanyRefName)
				fieldSeen[estimate.FieldCompanyRefName] = struct{}{}
			}
		case "failureReason":
			if _, ok := fieldSeen[estimate.FieldFailureReason]; !ok {
				selectedFields = append(selectedFields, estimate.FieldFailureReason)
				fieldSeen[estimate.FieldFailureReason] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		e.Select(selectedFields...)
	}
	return nil
}

type estimatePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EstimatePaginateOption
}

func newEstimatePaginateArgs(rv map[string]any) *estimatePaginateArgs {
	args := &estimatePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &EstimateOrder{Field: &EstimateOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEstimateOrder(order))
			}
		case *EstimateOrder:
			if v != nil {
				args.opts = append(args.opts, WithEstimateOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*EstimateWhereInput); ok {
		args.opts = append(args.opts, WithEstimateFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ea *EstimateActivityQuery) CollectFields(ctx context.Context, satisfies ...string) (*EstimateActivityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ea, nil
	}
	if err := ea.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ea, nil
}

func (ea *EstimateActivityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(estimateactivity.Columns))
		selectedFields = []string{estimateactivity.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "estimate":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateClient{config: ea.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ea.withEstimate = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ea.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ea.withCreator = query
		case "creatorAPI":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: ea.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ea.withCreatorAPI = query
		case "createdAt":
			if _, ok := fieldSeen[estimateactivity.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, estimateactivity.FieldCreatedAt)
				fieldSeen[estimateactivity.FieldCreatedAt] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[estimateactivity.FieldDescription]; !ok {
				selectedFields = append(selectedFields, estimateactivity.FieldDescription)
				fieldSeen[estimateactivity.FieldDescription] = struct{}{}
			}
		case "raw":
			if _, ok := fieldSeen[estimateactivity.FieldRaw]; !ok {
				selectedFields = append(selectedFields, estimateactivity.FieldRaw)
				fieldSeen[estimateactivity.FieldRaw] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ea.Select(selectedFields...)
	}
	return nil
}

type estimateactivityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EstimateActivityPaginateOption
}

func newEstimateActivityPaginateArgs(rv map[string]any) *estimateactivityPaginateArgs {
	args := &estimateactivityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &EstimateActivityOrder{Field: &EstimateActivityOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithEstimateActivityOrder(order))
			}
		case *EstimateActivityOrder:
			if v != nil {
				args.opts = append(args.opts, WithEstimateActivityOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*EstimateActivityWhereInput); ok {
		args.opts = append(args.opts, WithEstimateActivityFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ho *HomeOwnerQuery) CollectFields(ctx context.Context, satisfies ...string) (*HomeOwnerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ho, nil
	}
	if err := ho.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ho, nil
}

func (ho *HomeOwnerQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(homeowner.Columns))
		selectedFields = []string{homeowner.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "estimates":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateClient{config: ho.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ho.WithNamedEstimates(alias, func(wq *EstimateQuery) {
				*wq = *query
			})
		case "jobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: ho.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ho.WithNamedJobs(alias, func(wq *JobQuery) {
				*wq = *query
			})
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: ho.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ho.withPartner = query
		case "createdAt":
			if _, ok := fieldSeen[homeowner.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldCreatedAt)
				fieldSeen[homeowner.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[homeowner.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldUpdatedAt)
				fieldSeen[homeowner.FieldUpdatedAt] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[homeowner.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldFirstName)
				fieldSeen[homeowner.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[homeowner.FieldLastName]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldLastName)
				fieldSeen[homeowner.FieldLastName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[homeowner.FieldEmail]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldEmail)
				fieldSeen[homeowner.FieldEmail] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[homeowner.FieldPhone]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldPhone)
				fieldSeen[homeowner.FieldPhone] = struct{}{}
			}
		case "streetNumber":
			if _, ok := fieldSeen[homeowner.FieldStreetNumber]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldStreetNumber)
				fieldSeen[homeowner.FieldStreetNumber] = struct{}{}
			}
		case "streetName":
			if _, ok := fieldSeen[homeowner.FieldStreetName]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldStreetName)
				fieldSeen[homeowner.FieldStreetName] = struct{}{}
			}
		case "city":
			if _, ok := fieldSeen[homeowner.FieldCity]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldCity)
				fieldSeen[homeowner.FieldCity] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[homeowner.FieldState]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldState)
				fieldSeen[homeowner.FieldState] = struct{}{}
			}
		case "stateAbbr":
			if _, ok := fieldSeen[homeowner.FieldStateAbbr]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldStateAbbr)
				fieldSeen[homeowner.FieldStateAbbr] = struct{}{}
			}
		case "zip":
			if _, ok := fieldSeen[homeowner.FieldZip]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldZip)
				fieldSeen[homeowner.FieldZip] = struct{}{}
			}
		case "formattedAddress":
			if _, ok := fieldSeen[homeowner.FieldFormattedAddress]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldFormattedAddress)
				fieldSeen[homeowner.FieldFormattedAddress] = struct{}{}
			}
		case "latitude":
			if _, ok := fieldSeen[homeowner.FieldLatitude]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldLatitude)
				fieldSeen[homeowner.FieldLatitude] = struct{}{}
			}
		case "longitude":
			if _, ok := fieldSeen[homeowner.FieldLongitude]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldLongitude)
				fieldSeen[homeowner.FieldLongitude] = struct{}{}
			}
		case "hash":
			if _, ok := fieldSeen[homeowner.FieldHash]; !ok {
				selectedFields = append(selectedFields, homeowner.FieldHash)
				fieldSeen[homeowner.FieldHash] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ho.Select(selectedFields...)
	}
	return nil
}

type homeownerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HomeOwnerPaginateOption
}

func newHomeOwnerPaginateArgs(rv map[string]any) *homeownerPaginateArgs {
	args := &homeownerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &HomeOwnerOrder{Field: &HomeOwnerOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithHomeOwnerOrder(order))
			}
		case *HomeOwnerOrder:
			if v != nil {
				args.opts = append(args.opts, WithHomeOwnerOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*HomeOwnerWhereInput); ok {
		args.opts = append(args.opts, WithHomeOwnerFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ij *InstallationJobQuery) CollectFields(ctx context.Context, satisfies ...string) (*InstallationJobQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ij, nil
	}
	if err := ij.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ij, nil
}

func (ij *InstallationJobQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(installationjob.Columns))
		selectedFields = []string{installationjob.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "items":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InstallationJobItemClient{config: ij.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ij.WithNamedItems(alias, func(wq *InstallationJobItemQuery) {
				*wq = *query
			})
		case "progressHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InstallationJobProgressClient{config: ij.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ij.WithNamedProgressHistory(alias, func(wq *InstallationJobProgressQuery) {
				*wq = *query
			})
		case "requestingPartner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: ij.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ij.withRequestingPartner = query
		case "assignedPartner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: ij.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ij.withAssignedPartner = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ij.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ij.withCreator = query
		case "salesRep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ij.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ij.withSalesRep = query
		case "createdAt":
			if _, ok := fieldSeen[installationjob.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldCreatedAt)
				fieldSeen[installationjob.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[installationjob.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldUpdatedAt)
				fieldSeen[installationjob.FieldUpdatedAt] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[installationjob.FieldType]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldType)
				fieldSeen[installationjob.FieldType] = struct{}{}
			}
		case "ownerName":
			if _, ok := fieldSeen[installationjob.FieldOwnerName]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldOwnerName)
				fieldSeen[installationjob.FieldOwnerName] = struct{}{}
			}
		case "ownerPhone":
			if _, ok := fieldSeen[installationjob.FieldOwnerPhone]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldOwnerPhone)
				fieldSeen[installationjob.FieldOwnerPhone] = struct{}{}
			}
		case "ownerEmail":
			if _, ok := fieldSeen[installationjob.FieldOwnerEmail]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldOwnerEmail)
				fieldSeen[installationjob.FieldOwnerEmail] = struct{}{}
			}
		case "ownerAddress":
			if _, ok := fieldSeen[installationjob.FieldOwnerAddress]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldOwnerAddress)
				fieldSeen[installationjob.FieldOwnerAddress] = struct{}{}
			}
		case "ownerAddressLat":
			if _, ok := fieldSeen[installationjob.FieldOwnerAddressLat]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldOwnerAddressLat)
				fieldSeen[installationjob.FieldOwnerAddressLat] = struct{}{}
			}
		case "ownerAddressLng":
			if _, ok := fieldSeen[installationjob.FieldOwnerAddressLng]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldOwnerAddressLng)
				fieldSeen[installationjob.FieldOwnerAddressLng] = struct{}{}
			}
		case "specialNote":
			if _, ok := fieldSeen[installationjob.FieldSpecialNote]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldSpecialNote)
				fieldSeen[installationjob.FieldSpecialNote] = struct{}{}
			}
		case "pkg":
			if _, ok := fieldSeen[installationjob.FieldPkg]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldPkg)
				fieldSeen[installationjob.FieldPkg] = struct{}{}
			}
		case "pkgDescription":
			if _, ok := fieldSeen[installationjob.FieldPkgDescription]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldPkgDescription)
				fieldSeen[installationjob.FieldPkgDescription] = struct{}{}
			}
		case "pkgFeatures":
			if _, ok := fieldSeen[installationjob.FieldPkgFeatures]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldPkgFeatures)
				fieldSeen[installationjob.FieldPkgFeatures] = struct{}{}
			}
		case "price":
			if _, ok := fieldSeen[installationjob.FieldPrice]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldPrice)
				fieldSeen[installationjob.FieldPrice] = struct{}{}
			}
		case "approval":
			if _, ok := fieldSeen[installationjob.FieldApproval]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldApproval)
				fieldSeen[installationjob.FieldApproval] = struct{}{}
			}
		case "approvalAt":
			if _, ok := fieldSeen[installationjob.FieldApprovalAt]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldApprovalAt)
				fieldSeen[installationjob.FieldApprovalAt] = struct{}{}
			}
		case "denyReason":
			if _, ok := fieldSeen[installationjob.FieldDenyReason]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldDenyReason)
				fieldSeen[installationjob.FieldDenyReason] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[installationjob.FieldStatus]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldStatus)
				fieldSeen[installationjob.FieldStatus] = struct{}{}
			}
		case "statusAt":
			if _, ok := fieldSeen[installationjob.FieldStatusAt]; !ok {
				selectedFields = append(selectedFields, installationjob.FieldStatusAt)
				fieldSeen[installationjob.FieldStatusAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ij.Select(selectedFields...)
	}
	return nil
}

type installationjobPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InstallationJobPaginateOption
}

func newInstallationJobPaginateArgs(rv map[string]any) *installationjobPaginateArgs {
	args := &installationjobPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &InstallationJobOrder{Field: &InstallationJobOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithInstallationJobOrder(order))
			}
		case *InstallationJobOrder:
			if v != nil {
				args.opts = append(args.opts, WithInstallationJobOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*InstallationJobWhereInput); ok {
		args.opts = append(args.opts, WithInstallationJobFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (iji *InstallationJobItemQuery) CollectFields(ctx context.Context, satisfies ...string) (*InstallationJobItemQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return iji, nil
	}
	if err := iji.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return iji, nil
}

func (iji *InstallationJobItemQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(installationjobitem.Columns))
		selectedFields = []string{installationjobitem.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "job":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InstallationJobClient{config: iji.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			iji.withJob = query
		case "name":
			if _, ok := fieldSeen[installationjobitem.FieldName]; !ok {
				selectedFields = append(selectedFields, installationjobitem.FieldName)
				fieldSeen[installationjobitem.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[installationjobitem.FieldDescription]; !ok {
				selectedFields = append(selectedFields, installationjobitem.FieldDescription)
				fieldSeen[installationjobitem.FieldDescription] = struct{}{}
			}
		case "features":
			if _, ok := fieldSeen[installationjobitem.FieldFeatures]; !ok {
				selectedFields = append(selectedFields, installationjobitem.FieldFeatures)
				fieldSeen[installationjobitem.FieldFeatures] = struct{}{}
			}
		case "price":
			if _, ok := fieldSeen[installationjobitem.FieldPrice]; !ok {
				selectedFields = append(selectedFields, installationjobitem.FieldPrice)
				fieldSeen[installationjobitem.FieldPrice] = struct{}{}
			}
		case "imgKey":
			if _, ok := fieldSeen[installationjobitem.FieldImgKey]; !ok {
				selectedFields = append(selectedFields, installationjobitem.FieldImgKey)
				fieldSeen[installationjobitem.FieldImgKey] = struct{}{}
			}
		case "specialNote":
			if _, ok := fieldSeen[installationjobitem.FieldSpecialNote]; !ok {
				selectedFields = append(selectedFields, installationjobitem.FieldSpecialNote)
				fieldSeen[installationjobitem.FieldSpecialNote] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		iji.Select(selectedFields...)
	}
	return nil
}

type installationjobitemPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InstallationJobItemPaginateOption
}

func newInstallationJobItemPaginateArgs(rv map[string]any) *installationjobitemPaginateArgs {
	args := &installationjobitemPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*InstallationJobItemWhereInput); ok {
		args.opts = append(args.opts, WithInstallationJobItemFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ijp *InstallationJobProgressQuery) CollectFields(ctx context.Context, satisfies ...string) (*InstallationJobProgressQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ijp, nil
	}
	if err := ijp.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ijp, nil
}

func (ijp *InstallationJobProgressQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(installationjobprogress.Columns))
		selectedFields = []string{installationjobprogress.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "job":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InstallationJobClient{config: ijp.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ijp.withJob = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ijp.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ijp.withCreator = query
		case "createdAt":
			if _, ok := fieldSeen[installationjobprogress.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, installationjobprogress.FieldCreatedAt)
				fieldSeen[installationjobprogress.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[installationjobprogress.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, installationjobprogress.FieldUpdatedAt)
				fieldSeen[installationjobprogress.FieldUpdatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[installationjobprogress.FieldStatus]; !ok {
				selectedFields = append(selectedFields, installationjobprogress.FieldStatus)
				fieldSeen[installationjobprogress.FieldStatus] = struct{}{}
			}
		case "complete":
			if _, ok := fieldSeen[installationjobprogress.FieldComplete]; !ok {
				selectedFields = append(selectedFields, installationjobprogress.FieldComplete)
				fieldSeen[installationjobprogress.FieldComplete] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[installationjobprogress.FieldNote]; !ok {
				selectedFields = append(selectedFields, installationjobprogress.FieldNote)
				fieldSeen[installationjobprogress.FieldNote] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ijp.Select(selectedFields...)
	}
	return nil
}

type installationjobprogressPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InstallationJobProgressPaginateOption
}

func newInstallationJobProgressPaginateArgs(rv map[string]any) *installationjobprogressPaginateArgs {
	args := &installationjobprogressPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &InstallationJobProgressOrder{Field: &InstallationJobProgressOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithInstallationJobProgressOrder(order))
			}
		case *InstallationJobProgressOrder:
			if v != nil {
				args.opts = append(args.opts, WithInstallationJobProgressOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*InstallationJobProgressWhereInput); ok {
		args.opts = append(args.opts, WithInstallationJobProgressFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (j *JobQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return j, nil
	}
	if err := j.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return j, nil
}

func (j *JobQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(job.Columns))
		selectedFields = []string{job.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "payments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PaymentClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.WithNamedPayments(alias, func(wq *PaymentQuery) {
				*wq = *query
			})
		case "activities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobActivityClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.WithNamedActivities(alias, func(wq *JobActivityQuery) {
				*wq = *query
			})
		case "assignmentHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobAssignmentHistoryClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.WithNamedAssignmentHistory(alias, func(wq *JobAssignmentHistoryQuery) {
				*wq = *query
			})
		case "progressHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobProgressHistoryClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.WithNamedProgressHistory(alias, func(wq *JobProgressHistoryQuery) {
				*wq = *query
			})
		case "notes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobNoteClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.WithNamedNotes(alias, func(wq *JobNoteQuery) {
				*wq = *query
			})
		case "docUrls":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDocURLClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.WithNamedDocUrls(alias, func(wq *JobDocURLQuery) {
				*wq = *query
			})
		case "estimate":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withEstimate = query
		case "creatorAPI":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withCreatorAPI = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withCreator = query
		case "homeOwner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HomeOwnerClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withHomeOwner = query
		case "salesRep":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withSalesRep = query
		case "requester":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withRequester = query
		case "roofingPartner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withRoofingPartner = query
		case "integrationPartner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withIntegrationPartner = query
		case "epcPartner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withEpcPartner = query
		case "epc":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OptionListClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withEpc = query
		case "estimatePdf":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: j.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			j.withEstimatePdf = query
		case "createdAt":
			if _, ok := fieldSeen[job.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, job.FieldCreatedAt)
				fieldSeen[job.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[job.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, job.FieldUpdatedAt)
				fieldSeen[job.FieldUpdatedAt] = struct{}{}
			}
		case "progress":
			if _, ok := fieldSeen[job.FieldProgress]; !ok {
				selectedFields = append(selectedFields, job.FieldProgress)
				fieldSeen[job.FieldProgress] = struct{}{}
			}
		case "progressAt":
			if _, ok := fieldSeen[job.FieldProgressAt]; !ok {
				selectedFields = append(selectedFields, job.FieldProgressAt)
				fieldSeen[job.FieldProgressAt] = struct{}{}
			}
		case "progressFlagAt":
			if _, ok := fieldSeen[job.FieldProgressFlagAt]; !ok {
				selectedFields = append(selectedFields, job.FieldProgressFlagAt)
				fieldSeen[job.FieldProgressFlagAt] = struct{}{}
			}
		case "regionID":
			if _, ok := fieldSeen[job.FieldRegionID]; !ok {
				selectedFields = append(selectedFields, job.FieldRegionID)
				fieldSeen[job.FieldRegionID] = struct{}{}
			}
		case "companyRefID":
			if _, ok := fieldSeen[job.FieldCompanyRefID]; !ok {
				selectedFields = append(selectedFields, job.FieldCompanyRefID)
				fieldSeen[job.FieldCompanyRefID] = struct{}{}
			}
		case "companyName":
			if _, ok := fieldSeen[job.FieldCompanyName]; !ok {
				selectedFields = append(selectedFields, job.FieldCompanyName)
				fieldSeen[job.FieldCompanyName] = struct{}{}
			}
		case "price":
			if _, ok := fieldSeen[job.FieldPrice]; !ok {
				selectedFields = append(selectedFields, job.FieldPrice)
				fieldSeen[job.FieldPrice] = struct{}{}
			}
		case "workOrderPrice":
			if _, ok := fieldSeen[job.FieldWorkOrderPrice]; !ok {
				selectedFields = append(selectedFields, job.FieldWorkOrderPrice)
				fieldSeen[job.FieldWorkOrderPrice] = struct{}{}
			}
		case "contractPrice":
			if _, ok := fieldSeen[job.FieldContractPrice]; !ok {
				selectedFields = append(selectedFields, job.FieldContractPrice)
				fieldSeen[job.FieldContractPrice] = struct{}{}
			}
		case "changeOrderPrice":
			if _, ok := fieldSeen[job.FieldChangeOrderPrice]; !ok {
				selectedFields = append(selectedFields, job.FieldChangeOrderPrice)
				fieldSeen[job.FieldChangeOrderPrice] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[job.FieldNote]; !ok {
				selectedFields = append(selectedFields, job.FieldNote)
				fieldSeen[job.FieldNote] = struct{}{}
			}
		case "shingleColor":
			if _, ok := fieldSeen[job.FieldShingleColor]; !ok {
				selectedFields = append(selectedFields, job.FieldShingleColor)
				fieldSeen[job.FieldShingleColor] = struct{}{}
			}
		case "permitRequired":
			if _, ok := fieldSeen[job.FieldPermitRequired]; !ok {
				selectedFields = append(selectedFields, job.FieldPermitRequired)
				fieldSeen[job.FieldPermitRequired] = struct{}{}
			}
		case "inspectionRequired":
			if _, ok := fieldSeen[job.FieldInspectionRequired]; !ok {
				selectedFields = append(selectedFields, job.FieldInspectionRequired)
				fieldSeen[job.FieldInspectionRequired] = struct{}{}
			}
		case "inspectionDate":
			if _, ok := fieldSeen[job.FieldInspectionDate]; !ok {
				selectedFields = append(selectedFields, job.FieldInspectionDate)
				fieldSeen[job.FieldInspectionDate] = struct{}{}
			}
		case "progressInspectionDate":
			if _, ok := fieldSeen[job.FieldProgressInspectionDate]; !ok {
				selectedFields = append(selectedFields, job.FieldProgressInspectionDate)
				fieldSeen[job.FieldProgressInspectionDate] = struct{}{}
			}
		case "installDate":
			if _, ok := fieldSeen[job.FieldInstallDate]; !ok {
				selectedFields = append(selectedFields, job.FieldInstallDate)
				fieldSeen[job.FieldInstallDate] = struct{}{}
			}
		case "completionDate":
			if _, ok := fieldSeen[job.FieldCompletionDate]; !ok {
				selectedFields = append(selectedFields, job.FieldCompletionDate)
				fieldSeen[job.FieldCompletionDate] = struct{}{}
			}
		case "materialDeliveryDate":
			if _, ok := fieldSeen[job.FieldMaterialDeliveryDate]; !ok {
				selectedFields = append(selectedFields, job.FieldMaterialDeliveryDate)
				fieldSeen[job.FieldMaterialDeliveryDate] = struct{}{}
			}
		case "agree":
			if _, ok := fieldSeen[job.FieldAgree]; !ok {
				selectedFields = append(selectedFields, job.FieldAgree)
				fieldSeen[job.FieldAgree] = struct{}{}
			}
		case "agreeAt":
			if _, ok := fieldSeen[job.FieldAgreeAt]; !ok {
				selectedFields = append(selectedFields, job.FieldAgreeAt)
				fieldSeen[job.FieldAgreeAt] = struct{}{}
			}
		case "poNumber":
			if _, ok := fieldSeen[job.FieldPoNumber]; !ok {
				selectedFields = append(selectedFields, job.FieldPoNumber)
				fieldSeen[job.FieldPoNumber] = struct{}{}
			}
		case "roofingPartnerAssignedAt":
			if _, ok := fieldSeen[job.FieldRoofingPartnerAssignedAt]; !ok {
				selectedFields = append(selectedFields, job.FieldRoofingPartnerAssignedAt)
				fieldSeen[job.FieldRoofingPartnerAssignedAt] = struct{}{}
			}
		case "roofingPartnerFlagAt":
			if _, ok := fieldSeen[job.FieldRoofingPartnerFlagAt]; !ok {
				selectedFields = append(selectedFields, job.FieldRoofingPartnerFlagAt)
				fieldSeen[job.FieldRoofingPartnerFlagAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		j.Select(selectedFields...)
	}
	return nil
}

type jobPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobPaginateOption
}

func newJobPaginateArgs(rv map[string]any) *jobPaginateArgs {
	args := &jobPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &JobOrder{Field: &JobOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithJobOrder(order))
			}
		case *JobOrder:
			if v != nil {
				args.opts = append(args.opts, WithJobOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*JobWhereInput); ok {
		args.opts = append(args.opts, WithJobFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ja *JobActivityQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobActivityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ja, nil
	}
	if err := ja.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ja, nil
}

func (ja *JobActivityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobactivity.Columns))
		selectedFields = []string{jobactivity.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "job":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: ja.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ja.withJob = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ja.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ja.withCreator = query
		case "creatorAPI":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: ja.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ja.withCreatorAPI = query
		case "createdAt":
			if _, ok := fieldSeen[jobactivity.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobactivity.FieldCreatedAt)
				fieldSeen[jobactivity.FieldCreatedAt] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[jobactivity.FieldDescription]; !ok {
				selectedFields = append(selectedFields, jobactivity.FieldDescription)
				fieldSeen[jobactivity.FieldDescription] = struct{}{}
			}
		case "raw":
			if _, ok := fieldSeen[jobactivity.FieldRaw]; !ok {
				selectedFields = append(selectedFields, jobactivity.FieldRaw)
				fieldSeen[jobactivity.FieldRaw] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ja.Select(selectedFields...)
	}
	return nil
}

type jobactivityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobActivityPaginateOption
}

func newJobActivityPaginateArgs(rv map[string]any) *jobactivityPaginateArgs {
	args := &jobactivityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &JobActivityOrder{Field: &JobActivityOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithJobActivityOrder(order))
			}
		case *JobActivityOrder:
			if v != nil {
				args.opts = append(args.opts, WithJobActivityOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*JobActivityWhereInput); ok {
		args.opts = append(args.opts, WithJobActivityFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jah *JobAssignmentHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobAssignmentHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jah, nil
	}
	if err := jah.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jah, nil
}

func (jah *JobAssignmentHistoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobassignmenthistory.Columns))
		selectedFields = []string{jobassignmenthistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "job":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: jah.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			jah.withJob = query
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: jah.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			jah.withPartner = query
		case "createdAt":
			if _, ok := fieldSeen[jobassignmenthistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobassignmenthistory.FieldCreatedAt)
				fieldSeen[jobassignmenthistory.FieldCreatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[jobassignmenthistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, jobassignmenthistory.FieldStatus)
				fieldSeen[jobassignmenthistory.FieldStatus] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobassignmenthistory.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobassignmenthistory.FieldNote)
				fieldSeen[jobassignmenthistory.FieldNote] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jah.Select(selectedFields...)
	}
	return nil
}

type jobassignmenthistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobAssignmentHistoryPaginateOption
}

func newJobAssignmentHistoryPaginateArgs(rv map[string]any) *jobassignmenthistoryPaginateArgs {
	args := &jobassignmenthistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &JobAssignmentHistoryOrder{Field: &JobAssignmentHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithJobAssignmentHistoryOrder(order))
			}
		case *JobAssignmentHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithJobAssignmentHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*JobAssignmentHistoryWhereInput); ok {
		args.opts = append(args.opts, WithJobAssignmentHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jdu *JobDocURLQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobDocURLQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jdu, nil
	}
	if err := jdu.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jdu, nil
}

func (jdu *JobDocURLQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobdocurl.Columns))
		selectedFields = []string{jobdocurl.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "job":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: jdu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			jdu.withJob = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: jdu.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			jdu.withCreator = query
		case "createdAt":
			if _, ok := fieldSeen[jobdocurl.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobdocurl.FieldCreatedAt)
				fieldSeen[jobdocurl.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[jobdocurl.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobdocurl.FieldUpdatedAt)
				fieldSeen[jobdocurl.FieldUpdatedAt] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[jobdocurl.FieldType]; !ok {
				selectedFields = append(selectedFields, jobdocurl.FieldType)
				fieldSeen[jobdocurl.FieldType] = struct{}{}
			}
		case "url":
			if _, ok := fieldSeen[jobdocurl.FieldURL]; !ok {
				selectedFields = append(selectedFields, jobdocurl.FieldURL)
				fieldSeen[jobdocurl.FieldURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jdu.Select(selectedFields...)
	}
	return nil
}

type jobdocurlPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobDocURLPaginateOption
}

func newJobDocURLPaginateArgs(rv map[string]any) *jobdocurlPaginateArgs {
	args := &jobdocurlPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &JobDocURLOrder{Field: &JobDocURLOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithJobDocURLOrder(order))
			}
		case *JobDocURLOrder:
			if v != nil {
				args.opts = append(args.opts, WithJobDocURLOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*JobDocURLWhereInput); ok {
		args.opts = append(args.opts, WithJobDocURLFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jn *JobNoteQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobNoteQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jn, nil
	}
	if err := jn.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jn, nil
}

func (jn *JobNoteQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobnote.Columns))
		selectedFields = []string{jobnote.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "job":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: jn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			jn.withJob = query
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: jn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			jn.withUser = query
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: jn.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			jn.withPartner = query
		case "createdAt":
			if _, ok := fieldSeen[jobnote.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobnote.FieldCreatedAt)
				fieldSeen[jobnote.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[jobnote.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, jobnote.FieldUpdatedAt)
				fieldSeen[jobnote.FieldUpdatedAt] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobnote.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobnote.FieldNote)
				fieldSeen[jobnote.FieldNote] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jn.Select(selectedFields...)
	}
	return nil
}

type jobnotePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobNotePaginateOption
}

func newJobNotePaginateArgs(rv map[string]any) *jobnotePaginateArgs {
	args := &jobnotePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &JobNoteOrder{Field: &JobNoteOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithJobNoteOrder(order))
			}
		case *JobNoteOrder:
			if v != nil {
				args.opts = append(args.opts, WithJobNoteOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*JobNoteWhereInput); ok {
		args.opts = append(args.opts, WithJobNoteFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (jph *JobProgressHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*JobProgressHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return jph, nil
	}
	if err := jph.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return jph, nil
}

func (jph *JobProgressHistoryQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(jobprogresshistory.Columns))
		selectedFields = []string{jobprogresshistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "job":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: jph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			jph.withJob = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: jph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			jph.withCreator = query
		case "creatorAPIUser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: jph.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			jph.withCreatorAPIUser = query
		case "createdAt":
			if _, ok := fieldSeen[jobprogresshistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, jobprogresshistory.FieldCreatedAt)
				fieldSeen[jobprogresshistory.FieldCreatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[jobprogresshistory.FieldStatus]; !ok {
				selectedFields = append(selectedFields, jobprogresshistory.FieldStatus)
				fieldSeen[jobprogresshistory.FieldStatus] = struct{}{}
			}
		case "complete":
			if _, ok := fieldSeen[jobprogresshistory.FieldComplete]; !ok {
				selectedFields = append(selectedFields, jobprogresshistory.FieldComplete)
				fieldSeen[jobprogresshistory.FieldComplete] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[jobprogresshistory.FieldNote]; !ok {
				selectedFields = append(selectedFields, jobprogresshistory.FieldNote)
				fieldSeen[jobprogresshistory.FieldNote] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		jph.Select(selectedFields...)
	}
	return nil
}

type jobprogresshistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []JobProgressHistoryPaginateOption
}

func newJobProgressHistoryPaginateArgs(rv map[string]any) *jobprogresshistoryPaginateArgs {
	args := &jobprogresshistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &JobProgressHistoryOrder{Field: &JobProgressHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithJobProgressHistoryOrder(order))
			}
		case *JobProgressHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithJobProgressHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*JobProgressHistoryWhereInput); ok {
		args.opts = append(args.opts, WithJobProgressHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ns *NotifySettingQuery) CollectFields(ctx context.Context, satisfies ...string) (*NotifySettingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ns, nil
	}
	if err := ns.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ns, nil
}

func (ns *NotifySettingQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(notifysetting.Columns))
		selectedFields = []string{notifysetting.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ns.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ns.withUser = query
		case "createdAt":
			if _, ok := fieldSeen[notifysetting.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, notifysetting.FieldCreatedAt)
				fieldSeen[notifysetting.FieldCreatedAt] = struct{}{}
			}
		case "topicID":
			if _, ok := fieldSeen[notifysetting.FieldTopicID]; !ok {
				selectedFields = append(selectedFields, notifysetting.FieldTopicID)
				fieldSeen[notifysetting.FieldTopicID] = struct{}{}
			}
		case "receiveEmail":
			if _, ok := fieldSeen[notifysetting.FieldReceiveEmail]; !ok {
				selectedFields = append(selectedFields, notifysetting.FieldReceiveEmail)
				fieldSeen[notifysetting.FieldReceiveEmail] = struct{}{}
			}
		case "receiveSms":
			if _, ok := fieldSeen[notifysetting.FieldReceiveSms]; !ok {
				selectedFields = append(selectedFields, notifysetting.FieldReceiveSms)
				fieldSeen[notifysetting.FieldReceiveSms] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ns.Select(selectedFields...)
	}
	return nil
}

type notifysettingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NotifySettingPaginateOption
}

func newNotifySettingPaginateArgs(rv map[string]any) *notifysettingPaginateArgs {
	args := &notifysettingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &NotifySettingOrder{Field: &NotifySettingOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithNotifySettingOrder(order))
			}
		case *NotifySettingOrder:
			if v != nil {
				args.opts = append(args.opts, WithNotifySettingOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*NotifySettingWhereInput); ok {
		args.opts = append(args.opts, WithNotifySettingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ol *OptionListQuery) CollectFields(ctx context.Context, satisfies ...string) (*OptionListQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ol, nil
	}
	if err := ol.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ol, nil
}

func (ol *OptionListQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(optionlist.Columns))
		selectedFields = []string{optionlist.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "financeOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: ol.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ol.WithNamedFinanceOptions(alias, func(wq *PartnerQuery) {
				*wq = *query
			})
		case "epcOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: ol.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ol.WithNamedEpcOptions(alias, func(wq *PartnerQuery) {
				*wq = *query
			})
		case "epc":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: ol.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ol.WithNamedEpc(alias, func(wq *JobQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[optionlist.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, optionlist.FieldCreatedAt)
				fieldSeen[optionlist.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[optionlist.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, optionlist.FieldUpdatedAt)
				fieldSeen[optionlist.FieldUpdatedAt] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[optionlist.FieldType]; !ok {
				selectedFields = append(selectedFields, optionlist.FieldType)
				fieldSeen[optionlist.FieldType] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[optionlist.FieldName]; !ok {
				selectedFields = append(selectedFields, optionlist.FieldName)
				fieldSeen[optionlist.FieldName] = struct{}{}
			}
		case "displayName":
			if _, ok := fieldSeen[optionlist.FieldDisplayName]; !ok {
				selectedFields = append(selectedFields, optionlist.FieldDisplayName)
				fieldSeen[optionlist.FieldDisplayName] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[optionlist.FieldActive]; !ok {
				selectedFields = append(selectedFields, optionlist.FieldActive)
				fieldSeen[optionlist.FieldActive] = struct{}{}
			}
		case "order":
			if _, ok := fieldSeen[optionlist.FieldOrder]; !ok {
				selectedFields = append(selectedFields, optionlist.FieldOrder)
				fieldSeen[optionlist.FieldOrder] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ol.Select(selectedFields...)
	}
	return nil
}

type optionlistPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OptionListPaginateOption
}

func newOptionListPaginateArgs(rv map[string]any) *optionlistPaginateArgs {
	args := &optionlistPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &OptionListOrder{Field: &OptionListOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOptionListOrder(order))
			}
		case *OptionListOrder:
			if v != nil {
				args.opts = append(args.opts, WithOptionListOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*OptionListWhereInput); ok {
		args.opts = append(args.opts, WithOptionListFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pa *PartnerQuery) CollectFields(ctx context.Context, satisfies ...string) (*PartnerQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pa, nil
	}
	if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pa, nil
}

func (pa *PartnerQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(partner.Columns))
		selectedFields = []string{partner.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "requestedEstimates":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedRequestedEstimates(alias, func(wq *EstimateQuery) {
				*wq = *query
			})
		case "estimateHomeOwners":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HomeOwnerClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedEstimateHomeOwners(alias, func(wq *HomeOwnerQuery) {
				*wq = *query
			})
		case "roofingJobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedRoofingJobs(alias, func(wq *JobQuery) {
				*wq = *query
			})
		case "integrationJobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedIntegrationJobs(alias, func(wq *JobQuery) {
				*wq = *query
			})
		case "epcJobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedEpcJobs(alias, func(wq *JobQuery) {
				*wq = *query
			})
		case "jobRequests":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedJobRequests(alias, func(wq *JobQuery) {
				*wq = *query
			})
		case "activities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerActivityClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedActivities(alias, func(wq *PartnerActivityQuery) {
				*wq = *query
			})
		case "jobAssignmentHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobAssignmentHistoryClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedJobAssignmentHistory(alias, func(wq *JobAssignmentHistoryQuery) {
				*wq = *query
			})
		case "requestedInstallationJobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InstallationJobClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedRequestedInstallationJobs(alias, func(wq *InstallationJobQuery) {
				*wq = *query
			})
		case "assignedInstallationJobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InstallationJobClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedAssignedInstallationJobs(alias, func(wq *InstallationJobQuery) {
				*wq = *query
			})
		case "contacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedContacts(alias, func(wq *UserQuery) {
				*wq = *query
			})
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.withCreator = query
			if _, ok := fieldSeen[partner.FieldCreatorID]; !ok {
				selectedFields = append(selectedFields, partner.FieldCreatorID)
				fieldSeen[partner.FieldCreatorID] = struct{}{}
			}
		case "creatorAPI":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.withCreatorAPI = query
		case "services":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerServiceClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedServices(alias, func(wq *PartnerServiceQuery) {
				*wq = *query
			})
		case "serviceStates":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerServiceStateClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedServiceStates(alias, func(wq *PartnerServiceStateQuery) {
				*wq = *query
			})
		case "serviceCities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerServiceCityClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedServiceCities(alias, func(wq *PartnerServiceCityQuery) {
				*wq = *query
			})
		case "trainingVideos":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerTrainingVideoClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedTrainingVideos(alias, func(wq *PartnerTrainingVideoQuery) {
				*wq = *query
			})
		case "contactUsRequests":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContactUsClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedContactUsRequests(alias, func(wq *ContactUsQuery) {
				*wq = *query
			})
		case "surveys":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SurveyClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedSurveys(alias, func(wq *SurveyQuery) {
				*wq = *query
			})
		case "sessions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserSessionClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedSessions(alias, func(wq *UserSessionQuery) {
				*wq = *query
			})
		case "jobNotes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobNoteClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedJobNotes(alias, func(wq *JobNoteQuery) {
				*wq = *query
			})
		case "channels":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelSubClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedChannels(alias, func(wq *ChannelSubQuery) {
				*wq = *query
			})
		case "financeOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OptionListClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedFinanceOptions(alias, func(wq *OptionListQuery) {
				*wq = *query
			})
		case "epcOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OptionListClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedEpcOptions(alias, func(wq *OptionListQuery) {
				*wq = *query
			})
		case "partnerContacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerContactClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.WithNamedPartnerContacts(alias, func(wq *PartnerContactQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[partner.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, partner.FieldCreatedAt)
				fieldSeen[partner.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[partner.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, partner.FieldUpdatedAt)
				fieldSeen[partner.FieldUpdatedAt] = struct{}{}
			}
		case "externalID":
			if _, ok := fieldSeen[partner.FieldExternalID]; !ok {
				selectedFields = append(selectedFields, partner.FieldExternalID)
				fieldSeen[partner.FieldExternalID] = struct{}{}
			}
		case "creatorID":
			if _, ok := fieldSeen[partner.FieldCreatorID]; !ok {
				selectedFields = append(selectedFields, partner.FieldCreatorID)
				fieldSeen[partner.FieldCreatorID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[partner.FieldType]; !ok {
				selectedFields = append(selectedFields, partner.FieldType)
				fieldSeen[partner.FieldType] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[partner.FieldName]; !ok {
				selectedFields = append(selectedFields, partner.FieldName)
				fieldSeen[partner.FieldName] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[partner.FieldAddress]; !ok {
				selectedFields = append(selectedFields, partner.FieldAddress)
				fieldSeen[partner.FieldAddress] = struct{}{}
			}
		case "website":
			if _, ok := fieldSeen[partner.FieldWebsite]; !ok {
				selectedFields = append(selectedFields, partner.FieldWebsite)
				fieldSeen[partner.FieldWebsite] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[partner.FieldPhone]; !ok {
				selectedFields = append(selectedFields, partner.FieldPhone)
				fieldSeen[partner.FieldPhone] = struct{}{}
			}
		case "latitude":
			if _, ok := fieldSeen[partner.FieldLatitude]; !ok {
				selectedFields = append(selectedFields, partner.FieldLatitude)
				fieldSeen[partner.FieldLatitude] = struct{}{}
			}
		case "longitude":
			if _, ok := fieldSeen[partner.FieldLongitude]; !ok {
				selectedFields = append(selectedFields, partner.FieldLongitude)
				fieldSeen[partner.FieldLongitude] = struct{}{}
			}
		case "isNationWide":
			if _, ok := fieldSeen[partner.FieldIsNationWide]; !ok {
				selectedFields = append(selectedFields, partner.FieldIsNationWide)
				fieldSeen[partner.FieldIsNationWide] = struct{}{}
			}
		case "crewCount":
			if _, ok := fieldSeen[partner.FieldCrewCount]; !ok {
				selectedFields = append(selectedFields, partner.FieldCrewCount)
				fieldSeen[partner.FieldCrewCount] = struct{}{}
			}
		case "yearsInBusiness":
			if _, ok := fieldSeen[partner.FieldYearsInBusiness]; !ok {
				selectedFields = append(selectedFields, partner.FieldYearsInBusiness)
				fieldSeen[partner.FieldYearsInBusiness] = struct{}{}
			}
		case "jobCapacity":
			if _, ok := fieldSeen[partner.FieldJobCapacity]; !ok {
				selectedFields = append(selectedFields, partner.FieldJobCapacity)
				fieldSeen[partner.FieldJobCapacity] = struct{}{}
			}
		case "asphaltLeadT":
			if _, ok := fieldSeen[partner.FieldAsphaltLeadT]; !ok {
				selectedFields = append(selectedFields, partner.FieldAsphaltLeadT)
				fieldSeen[partner.FieldAsphaltLeadT] = struct{}{}
			}
		case "metalLeadT":
			if _, ok := fieldSeen[partner.FieldMetalLeadT]; !ok {
				selectedFields = append(selectedFields, partner.FieldMetalLeadT)
				fieldSeen[partner.FieldMetalLeadT] = struct{}{}
			}
		case "tileLeadT":
			if _, ok := fieldSeen[partner.FieldTileLeadT]; !ok {
				selectedFields = append(selectedFields, partner.FieldTileLeadT)
				fieldSeen[partner.FieldTileLeadT] = struct{}{}
			}
		case "setupStepsCompleted":
			if _, ok := fieldSeen[partner.FieldSetupStepsCompleted]; !ok {
				selectedFields = append(selectedFields, partner.FieldSetupStepsCompleted)
				fieldSeen[partner.FieldSetupStepsCompleted] = struct{}{}
			}
		case "salesVolume":
			if _, ok := fieldSeen[partner.FieldSalesVolume]; !ok {
				selectedFields = append(selectedFields, partner.FieldSalesVolume)
				fieldSeen[partner.FieldSalesVolume] = struct{}{}
			}
		case "downPayment":
			if _, ok := fieldSeen[partner.FieldDownPayment]; !ok {
				selectedFields = append(selectedFields, partner.FieldDownPayment)
				fieldSeen[partner.FieldDownPayment] = struct{}{}
			}
		case "pif":
			if _, ok := fieldSeen[partner.FieldPif]; !ok {
				selectedFields = append(selectedFields, partner.FieldPif)
				fieldSeen[partner.FieldPif] = struct{}{}
			}
		case "installInHouse":
			if _, ok := fieldSeen[partner.FieldInstallInHouse]; !ok {
				selectedFields = append(selectedFields, partner.FieldInstallInHouse)
				fieldSeen[partner.FieldInstallInHouse] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[partner.FieldStatus]; !ok {
				selectedFields = append(selectedFields, partner.FieldStatus)
				fieldSeen[partner.FieldStatus] = struct{}{}
			}
		case "epcStatus":
			if _, ok := fieldSeen[partner.FieldEpcStatus]; !ok {
				selectedFields = append(selectedFields, partner.FieldEpcStatus)
				fieldSeen[partner.FieldEpcStatus] = struct{}{}
			}
		case "mobileAppSettings":
			if _, ok := fieldSeen[partner.FieldMobileAppSettings]; !ok {
				selectedFields = append(selectedFields, partner.FieldMobileAppSettings)
				fieldSeen[partner.FieldMobileAppSettings] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pa.Select(selectedFields...)
	}
	return nil
}

type partnerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PartnerPaginateOption
}

func newPartnerPaginateArgs(rv map[string]any) *partnerPaginateArgs {
	args := &partnerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PartnerOrder{Field: &PartnerOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPartnerOrder(order))
			}
		case *PartnerOrder:
			if v != nil {
				args.opts = append(args.opts, WithPartnerOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PartnerWhereInput); ok {
		args.opts = append(args.opts, WithPartnerFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pa *PartnerActivityQuery) CollectFields(ctx context.Context, satisfies ...string) (*PartnerActivityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pa, nil
	}
	if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pa, nil
}

func (pa *PartnerActivityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(partneractivity.Columns))
		selectedFields = []string{partneractivity.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.withPartner = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.withCreator = query
		case "creatorAPI":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.withCreatorAPI = query
		case "createdAt":
			if _, ok := fieldSeen[partneractivity.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, partneractivity.FieldCreatedAt)
				fieldSeen[partneractivity.FieldCreatedAt] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[partneractivity.FieldDescription]; !ok {
				selectedFields = append(selectedFields, partneractivity.FieldDescription)
				fieldSeen[partneractivity.FieldDescription] = struct{}{}
			}
		case "raw":
			if _, ok := fieldSeen[partneractivity.FieldRaw]; !ok {
				selectedFields = append(selectedFields, partneractivity.FieldRaw)
				fieldSeen[partneractivity.FieldRaw] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pa.Select(selectedFields...)
	}
	return nil
}

type partneractivityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PartnerActivityPaginateOption
}

func newPartnerActivityPaginateArgs(rv map[string]any) *partneractivityPaginateArgs {
	args := &partneractivityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PartnerActivityOrder{Field: &PartnerActivityOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPartnerActivityOrder(order))
			}
		case *PartnerActivityOrder:
			if v != nil {
				args.opts = append(args.opts, WithPartnerActivityOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PartnerActivityWhereInput); ok {
		args.opts = append(args.opts, WithPartnerActivityFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pc *PartnerContactQuery) CollectFields(ctx context.Context, satisfies ...string) (*PartnerContactQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pc, nil
	}
	if err := pc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pc, nil
}

func (pc *PartnerContactQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(partnercontact.Columns))
		selectedFields = []string{partnercontact.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pc.withUser = query
			if _, ok := fieldSeen[partnercontact.FieldUserID]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldUserID)
				fieldSeen[partnercontact.FieldUserID] = struct{}{}
			}
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: pc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pc.withPartner = query
			if _, ok := fieldSeen[partnercontact.FieldPartnerID]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldPartnerID)
				fieldSeen[partnercontact.FieldPartnerID] = struct{}{}
			}
		case "sessions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserSessionClient{config: pc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pc.WithNamedSessions(alias, func(wq *UserSessionQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[partnercontact.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldCreatedAt)
				fieldSeen[partnercontact.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[partnercontact.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldUpdatedAt)
				fieldSeen[partnercontact.FieldUpdatedAt] = struct{}{}
			}
		case "partnerID":
			if _, ok := fieldSeen[partnercontact.FieldPartnerID]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldPartnerID)
				fieldSeen[partnercontact.FieldPartnerID] = struct{}{}
			}
		case "userID":
			if _, ok := fieldSeen[partnercontact.FieldUserID]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldUserID)
				fieldSeen[partnercontact.FieldUserID] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[partnercontact.FieldRole]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldRole)
				fieldSeen[partnercontact.FieldRole] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[partnercontact.FieldType]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldType)
				fieldSeen[partnercontact.FieldType] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[partnercontact.FieldTitle]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldTitle)
				fieldSeen[partnercontact.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[partnercontact.FieldDescription]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldDescription)
				fieldSeen[partnercontact.FieldDescription] = struct{}{}
			}
		case "invoicingEmail":
			if _, ok := fieldSeen[partnercontact.FieldInvoicingEmail]; !ok {
				selectedFields = append(selectedFields, partnercontact.FieldInvoicingEmail)
				fieldSeen[partnercontact.FieldInvoicingEmail] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pc.Select(selectedFields...)
	}
	return nil
}

type partnercontactPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PartnerContactPaginateOption
}

func newPartnerContactPaginateArgs(rv map[string]any) *partnercontactPaginateArgs {
	args := &partnercontactPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PartnerContactOrder{Field: &PartnerContactOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPartnerContactOrder(order))
			}
		case *PartnerContactOrder:
			if v != nil {
				args.opts = append(args.opts, WithPartnerContactOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PartnerContactWhereInput); ok {
		args.opts = append(args.opts, WithPartnerContactFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ps *PartnerServiceQuery) CollectFields(ctx context.Context, satisfies ...string) (*PartnerServiceQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ps, nil
	}
	if err := ps.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ps, nil
}

func (ps *PartnerServiceQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(partnerservice.Columns))
		selectedFields = []string{partnerservice.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ps.withPartner = query
		case "createdAt":
			if _, ok := fieldSeen[partnerservice.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, partnerservice.FieldCreatedAt)
				fieldSeen[partnerservice.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[partnerservice.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, partnerservice.FieldUpdatedAt)
				fieldSeen[partnerservice.FieldUpdatedAt] = struct{}{}
			}
		case "serviceID":
			if _, ok := fieldSeen[partnerservice.FieldServiceID]; !ok {
				selectedFields = append(selectedFields, partnerservice.FieldServiceID)
				fieldSeen[partnerservice.FieldServiceID] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[partnerservice.FieldActive]; !ok {
				selectedFields = append(selectedFields, partnerservice.FieldActive)
				fieldSeen[partnerservice.FieldActive] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ps.Select(selectedFields...)
	}
	return nil
}

type partnerservicePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PartnerServicePaginateOption
}

func newPartnerServicePaginateArgs(rv map[string]any) *partnerservicePaginateArgs {
	args := &partnerservicePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PartnerServiceOrder{Field: &PartnerServiceOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPartnerServiceOrder(order))
			}
		case *PartnerServiceOrder:
			if v != nil {
				args.opts = append(args.opts, WithPartnerServiceOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PartnerServiceWhereInput); ok {
		args.opts = append(args.opts, WithPartnerServiceFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (psc *PartnerServiceCityQuery) CollectFields(ctx context.Context, satisfies ...string) (*PartnerServiceCityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return psc, nil
	}
	if err := psc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return psc, nil
}

func (psc *PartnerServiceCityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(partnerservicecity.Columns))
		selectedFields = []string{partnerservicecity.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: psc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			psc.withPartner = query
		case "createdAt":
			if _, ok := fieldSeen[partnerservicecity.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, partnerservicecity.FieldCreatedAt)
				fieldSeen[partnerservicecity.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[partnerservicecity.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, partnerservicecity.FieldUpdatedAt)
				fieldSeen[partnerservicecity.FieldUpdatedAt] = struct{}{}
			}
		case "postalID":
			if _, ok := fieldSeen[partnerservicecity.FieldPostalID]; !ok {
				selectedFields = append(selectedFields, partnerservicecity.FieldPostalID)
				fieldSeen[partnerservicecity.FieldPostalID] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[partnerservicecity.FieldActive]; !ok {
				selectedFields = append(selectedFields, partnerservicecity.FieldActive)
				fieldSeen[partnerservicecity.FieldActive] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[partnerservicecity.FieldName]; !ok {
				selectedFields = append(selectedFields, partnerservicecity.FieldName)
				fieldSeen[partnerservicecity.FieldName] = struct{}{}
			}
		case "naicsCode":
			if _, ok := fieldSeen[partnerservicecity.FieldNaicsCode]; !ok {
				selectedFields = append(selectedFields, partnerservicecity.FieldNaicsCode)
				fieldSeen[partnerservicecity.FieldNaicsCode] = struct{}{}
			}
		case "licenseNo":
			if _, ok := fieldSeen[partnerservicecity.FieldLicenseNo]; !ok {
				selectedFields = append(selectedFields, partnerservicecity.FieldLicenseNo)
				fieldSeen[partnerservicecity.FieldLicenseNo] = struct{}{}
			}
		case "proofDocID":
			if _, ok := fieldSeen[partnerservicecity.FieldProofDocID]; !ok {
				selectedFields = append(selectedFields, partnerservicecity.FieldProofDocID)
				fieldSeen[partnerservicecity.FieldProofDocID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		psc.Select(selectedFields...)
	}
	return nil
}

type partnerservicecityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PartnerServiceCityPaginateOption
}

func newPartnerServiceCityPaginateArgs(rv map[string]any) *partnerservicecityPaginateArgs {
	args := &partnerservicecityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PartnerServiceCityOrder{Field: &PartnerServiceCityOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPartnerServiceCityOrder(order))
			}
		case *PartnerServiceCityOrder:
			if v != nil {
				args.opts = append(args.opts, WithPartnerServiceCityOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PartnerServiceCityWhereInput); ok {
		args.opts = append(args.opts, WithPartnerServiceCityFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pss *PartnerServiceStateQuery) CollectFields(ctx context.Context, satisfies ...string) (*PartnerServiceStateQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pss, nil
	}
	if err := pss.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pss, nil
}

func (pss *PartnerServiceStateQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(partnerservicestate.Columns))
		selectedFields = []string{partnerservicestate.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: pss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pss.withPartner = query
		case "createdAt":
			if _, ok := fieldSeen[partnerservicestate.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, partnerservicestate.FieldCreatedAt)
				fieldSeen[partnerservicestate.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[partnerservicestate.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, partnerservicestate.FieldUpdatedAt)
				fieldSeen[partnerservicestate.FieldUpdatedAt] = struct{}{}
			}
		case "country":
			if _, ok := fieldSeen[partnerservicestate.FieldCountry]; !ok {
				selectedFields = append(selectedFields, partnerservicestate.FieldCountry)
				fieldSeen[partnerservicestate.FieldCountry] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[partnerservicestate.FieldState]; !ok {
				selectedFields = append(selectedFields, partnerservicestate.FieldState)
				fieldSeen[partnerservicestate.FieldState] = struct{}{}
			}
		case "licenseNo":
			if _, ok := fieldSeen[partnerservicestate.FieldLicenseNo]; !ok {
				selectedFields = append(selectedFields, partnerservicestate.FieldLicenseNo)
				fieldSeen[partnerservicestate.FieldLicenseNo] = struct{}{}
			}
		case "licenseExpDate":
			if _, ok := fieldSeen[partnerservicestate.FieldLicenseExpDate]; !ok {
				selectedFields = append(selectedFields, partnerservicestate.FieldLicenseExpDate)
				fieldSeen[partnerservicestate.FieldLicenseExpDate] = struct{}{}
			}
		case "proofDocID":
			if _, ok := fieldSeen[partnerservicestate.FieldProofDocID]; !ok {
				selectedFields = append(selectedFields, partnerservicestate.FieldProofDocID)
				fieldSeen[partnerservicestate.FieldProofDocID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pss.Select(selectedFields...)
	}
	return nil
}

type partnerservicestatePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PartnerServiceStatePaginateOption
}

func newPartnerServiceStatePaginateArgs(rv map[string]any) *partnerservicestatePaginateArgs {
	args := &partnerservicestatePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PartnerServiceStateOrder{Field: &PartnerServiceStateOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPartnerServiceStateOrder(order))
			}
		case *PartnerServiceStateOrder:
			if v != nil {
				args.opts = append(args.opts, WithPartnerServiceStateOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PartnerServiceStateWhereInput); ok {
		args.opts = append(args.opts, WithPartnerServiceStateFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ptv *PartnerTrainingVideoQuery) CollectFields(ctx context.Context, satisfies ...string) (*PartnerTrainingVideoQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ptv, nil
	}
	if err := ptv.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ptv, nil
}

func (ptv *PartnerTrainingVideoQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(partnertrainingvideo.Columns))
		selectedFields = []string{partnertrainingvideo.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "video":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TrainingVideoClient{config: ptv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ptv.withVideo = query
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: ptv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ptv.withPartner = query
		case "createdAt":
			if _, ok := fieldSeen[partnertrainingvideo.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, partnertrainingvideo.FieldCreatedAt)
				fieldSeen[partnertrainingvideo.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[partnertrainingvideo.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, partnertrainingvideo.FieldUpdatedAt)
				fieldSeen[partnertrainingvideo.FieldUpdatedAt] = struct{}{}
			}
		case "enabled":
			if _, ok := fieldSeen[partnertrainingvideo.FieldEnabled]; !ok {
				selectedFields = append(selectedFields, partnertrainingvideo.FieldEnabled)
				fieldSeen[partnertrainingvideo.FieldEnabled] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ptv.Select(selectedFields...)
	}
	return nil
}

type partnertrainingvideoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PartnerTrainingVideoPaginateOption
}

func newPartnerTrainingVideoPaginateArgs(rv map[string]any) *partnertrainingvideoPaginateArgs {
	args := &partnertrainingvideoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PartnerTrainingVideoOrder{Field: &PartnerTrainingVideoOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPartnerTrainingVideoOrder(order))
			}
		case *PartnerTrainingVideoOrder:
			if v != nil {
				args.opts = append(args.opts, WithPartnerTrainingVideoOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PartnerTrainingVideoWhereInput); ok {
		args.opts = append(args.opts, WithPartnerTrainingVideoFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pa *PaymentQuery) CollectFields(ctx context.Context, satisfies ...string) (*PaymentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pa, nil
	}
	if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pa, nil
}

func (pa *PaymentQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(payment.Columns))
		selectedFields = []string{payment.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "job":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pa.withJob = query
		case "createdAt":
			if _, ok := fieldSeen[payment.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, payment.FieldCreatedAt)
				fieldSeen[payment.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[payment.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, payment.FieldUpdatedAt)
				fieldSeen[payment.FieldUpdatedAt] = struct{}{}
			}
		case "amount":
			if _, ok := fieldSeen[payment.FieldAmount]; !ok {
				selectedFields = append(selectedFields, payment.FieldAmount)
				fieldSeen[payment.FieldAmount] = struct{}{}
			}
		case "statusID":
			if _, ok := fieldSeen[payment.FieldStatusID]; !ok {
				selectedFields = append(selectedFields, payment.FieldStatusID)
				fieldSeen[payment.FieldStatusID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pa.Select(selectedFields...)
	}
	return nil
}

type paymentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PaymentPaginateOption
}

func newPaymentPaginateArgs(rv map[string]any) *paymentPaginateArgs {
	args := &paymentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PaymentOrder{Field: &PaymentOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPaymentOrder(order))
			}
		case *PaymentOrder:
			if v != nil {
				args.opts = append(args.opts, WithPaymentOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PaymentWhereInput); ok {
		args.opts = append(args.opts, WithPaymentFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pc *PostalCodeQuery) CollectFields(ctx context.Context, satisfies ...string) (*PostalCodeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pc, nil
	}
	if err := pc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pc, nil
}

func (pc *PostalCodeQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(postalcode.Columns))
		selectedFields = []string{postalcode.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "pricing":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PricingClient{config: pc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pc.WithNamedPricing(alias, func(wq *PricingQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[postalcode.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldCreatedAt)
				fieldSeen[postalcode.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[postalcode.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldUpdatedAt)
				fieldSeen[postalcode.FieldUpdatedAt] = struct{}{}
			}
		case "country":
			if _, ok := fieldSeen[postalcode.FieldCountry]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldCountry)
				fieldSeen[postalcode.FieldCountry] = struct{}{}
			}
		case "code":
			if _, ok := fieldSeen[postalcode.FieldCode]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldCode)
				fieldSeen[postalcode.FieldCode] = struct{}{}
			}
		case "city":
			if _, ok := fieldSeen[postalcode.FieldCity]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldCity)
				fieldSeen[postalcode.FieldCity] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[postalcode.FieldState]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldState)
				fieldSeen[postalcode.FieldState] = struct{}{}
			}
		case "stateAbr":
			if _, ok := fieldSeen[postalcode.FieldStateAbr]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldStateAbr)
				fieldSeen[postalcode.FieldStateAbr] = struct{}{}
			}
		case "regionID":
			if _, ok := fieldSeen[postalcode.FieldRegionID]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldRegionID)
				fieldSeen[postalcode.FieldRegionID] = struct{}{}
			}
		case "latitude":
			if _, ok := fieldSeen[postalcode.FieldLatitude]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldLatitude)
				fieldSeen[postalcode.FieldLatitude] = struct{}{}
			}
		case "longitude":
			if _, ok := fieldSeen[postalcode.FieldLongitude]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldLongitude)
				fieldSeen[postalcode.FieldLongitude] = struct{}{}
			}
		case "accuracy":
			if _, ok := fieldSeen[postalcode.FieldAccuracy]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldAccuracy)
				fieldSeen[postalcode.FieldAccuracy] = struct{}{}
			}
		case "serviceArea":
			if _, ok := fieldSeen[postalcode.FieldServiceArea]; !ok {
				selectedFields = append(selectedFields, postalcode.FieldServiceArea)
				fieldSeen[postalcode.FieldServiceArea] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pc.Select(selectedFields...)
	}
	return nil
}

type postalcodePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PostalCodePaginateOption
}

func newPostalCodePaginateArgs(rv map[string]any) *postalcodePaginateArgs {
	args := &postalcodePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PostalCodeOrder{Field: &PostalCodeOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPostalCodeOrder(order))
			}
		case *PostalCodeOrder:
			if v != nil {
				args.opts = append(args.opts, WithPostalCodeOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PostalCodeWhereInput); ok {
		args.opts = append(args.opts, WithPostalCodeFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *PricingQuery) CollectFields(ctx context.Context, satisfies ...string) (*PricingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *PricingQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(pricing.Columns))
		selectedFields = []string{pricing.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "postal":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PostalCodeClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pr.withPostal = query
		case "createdAt":
			if _, ok := fieldSeen[pricing.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, pricing.FieldCreatedAt)
				fieldSeen[pricing.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[pricing.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, pricing.FieldUpdatedAt)
				fieldSeen[pricing.FieldUpdatedAt] = struct{}{}
			}
		case "postalCountry":
			if _, ok := fieldSeen[pricing.FieldPostalCountry]; !ok {
				selectedFields = append(selectedFields, pricing.FieldPostalCountry)
				fieldSeen[pricing.FieldPostalCountry] = struct{}{}
			}
		case "postalCode":
			if _, ok := fieldSeen[pricing.FieldPostalCode]; !ok {
				selectedFields = append(selectedFields, pricing.FieldPostalCode)
				fieldSeen[pricing.FieldPostalCode] = struct{}{}
			}
		case "productID":
			if _, ok := fieldSeen[pricing.FieldProductID]; !ok {
				selectedFields = append(selectedFields, pricing.FieldProductID)
				fieldSeen[pricing.FieldProductID] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[pricing.FieldDescription]; !ok {
				selectedFields = append(selectedFields, pricing.FieldDescription)
				fieldSeen[pricing.FieldDescription] = struct{}{}
			}
		case "price":
			if _, ok := fieldSeen[pricing.FieldPrice]; !ok {
				selectedFields = append(selectedFields, pricing.FieldPrice)
				fieldSeen[pricing.FieldPrice] = struct{}{}
			}
		case "pricePer":
			if _, ok := fieldSeen[pricing.FieldPricePer]; !ok {
				selectedFields = append(selectedFields, pricing.FieldPricePer)
				fieldSeen[pricing.FieldPricePer] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type pricingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PricingPaginateOption
}

func newPricingPaginateArgs(rv map[string]any) *pricingPaginateArgs {
	args := &pricingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &PricingOrder{Field: &PricingOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithPricingOrder(order))
			}
		case *PricingOrder:
			if v != nil {
				args.opts = append(args.opts, WithPricingOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*PricingWhereInput); ok {
		args.opts = append(args.opts, WithPricingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *ProductQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProductQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *ProductQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(product.Columns))
		selectedFields = []string{product.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "package":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductPackageClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pr.WithNamedPackage(alias, func(wq *ProductPackageQuery) {
				*wq = *query
			})
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pr.withCreator = query
		case "image":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pr.withImage = query
		case "createdAt":
			if _, ok := fieldSeen[product.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, product.FieldCreatedAt)
				fieldSeen[product.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[product.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, product.FieldUpdatedAt)
				fieldSeen[product.FieldUpdatedAt] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[product.FieldType]; !ok {
				selectedFields = append(selectedFields, product.FieldType)
				fieldSeen[product.FieldType] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[product.FieldName]; !ok {
				selectedFields = append(selectedFields, product.FieldName)
				fieldSeen[product.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[product.FieldDescription]; !ok {
				selectedFields = append(selectedFields, product.FieldDescription)
				fieldSeen[product.FieldDescription] = struct{}{}
			}
		case "features":
			if _, ok := fieldSeen[product.FieldFeatures]; !ok {
				selectedFields = append(selectedFields, product.FieldFeatures)
				fieldSeen[product.FieldFeatures] = struct{}{}
			}
		case "specialNote":
			if _, ok := fieldSeen[product.FieldSpecialNote]; !ok {
				selectedFields = append(selectedFields, product.FieldSpecialNote)
				fieldSeen[product.FieldSpecialNote] = struct{}{}
			}
		case "unitPrice":
			if _, ok := fieldSeen[product.FieldUnitPrice]; !ok {
				selectedFields = append(selectedFields, product.FieldUnitPrice)
				fieldSeen[product.FieldUnitPrice] = struct{}{}
			}
		case "unitsInStock":
			if _, ok := fieldSeen[product.FieldUnitsInStock]; !ok {
				selectedFields = append(selectedFields, product.FieldUnitsInStock)
				fieldSeen[product.FieldUnitsInStock] = struct{}{}
			}
		case "unitsOnOrder":
			if _, ok := fieldSeen[product.FieldUnitsOnOrder]; !ok {
				selectedFields = append(selectedFields, product.FieldUnitsOnOrder)
				fieldSeen[product.FieldUnitsOnOrder] = struct{}{}
			}
		case "discontinued":
			if _, ok := fieldSeen[product.FieldDiscontinued]; !ok {
				selectedFields = append(selectedFields, product.FieldDiscontinued)
				fieldSeen[product.FieldDiscontinued] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type productPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProductPaginateOption
}

func newProductPaginateArgs(rv map[string]any) *productPaginateArgs {
	args := &productPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ProductOrder{Field: &ProductOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithProductOrder(order))
			}
		case *ProductOrder:
			if v != nil {
				args.opts = append(args.opts, WithProductOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ProductWhereInput); ok {
		args.opts = append(args.opts, WithProductFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pp *ProductPackageQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProductPackageQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pp, nil
	}
	if err := pp.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pp, nil
}

func (pp *ProductPackageQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(productpackage.Columns))
		selectedFields = []string{productpackage.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "items":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductClient{config: pp.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pp.WithNamedItems(alias, func(wq *ProductQuery) {
				*wq = *query
			})
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: pp.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			pp.withCreator = query
		case "createdAt":
			if _, ok := fieldSeen[productpackage.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, productpackage.FieldCreatedAt)
				fieldSeen[productpackage.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[productpackage.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, productpackage.FieldUpdatedAt)
				fieldSeen[productpackage.FieldUpdatedAt] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[productpackage.FieldType]; !ok {
				selectedFields = append(selectedFields, productpackage.FieldType)
				fieldSeen[productpackage.FieldType] = struct{}{}
			}
		case "soldAs":
			if _, ok := fieldSeen[productpackage.FieldSoldAs]; !ok {
				selectedFields = append(selectedFields, productpackage.FieldSoldAs)
				fieldSeen[productpackage.FieldSoldAs] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[productpackage.FieldName]; !ok {
				selectedFields = append(selectedFields, productpackage.FieldName)
				fieldSeen[productpackage.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[productpackage.FieldDescription]; !ok {
				selectedFields = append(selectedFields, productpackage.FieldDescription)
				fieldSeen[productpackage.FieldDescription] = struct{}{}
			}
		case "features":
			if _, ok := fieldSeen[productpackage.FieldFeatures]; !ok {
				selectedFields = append(selectedFields, productpackage.FieldFeatures)
				fieldSeen[productpackage.FieldFeatures] = struct{}{}
			}
		case "price":
			if _, ok := fieldSeen[productpackage.FieldPrice]; !ok {
				selectedFields = append(selectedFields, productpackage.FieldPrice)
				fieldSeen[productpackage.FieldPrice] = struct{}{}
			}
		case "discontinued":
			if _, ok := fieldSeen[productpackage.FieldDiscontinued]; !ok {
				selectedFields = append(selectedFields, productpackage.FieldDiscontinued)
				fieldSeen[productpackage.FieldDiscontinued] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pp.Select(selectedFields...)
	}
	return nil
}

type productpackagePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProductPackagePaginateOption
}

func newProductPackagePaginateArgs(rv map[string]any) *productpackagePaginateArgs {
	args := &productpackagePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ProductPackageOrder{Field: &ProductPackageOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithProductPackageOrder(order))
			}
		case *ProductPackageOrder:
			if v != nil {
				args.opts = append(args.opts, WithProductPackageOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ProductPackageWhereInput); ok {
		args.opts = append(args.opts, WithProductPackageFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *SurveyQuery) CollectFields(ctx context.Context, satisfies ...string) (*SurveyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *SurveyQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(survey.Columns))
		selectedFields = []string{survey.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "progressHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SurveyProgressClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.WithNamedProgressHistory(alias, func(wq *SurveyProgressQuery) {
				*wq = *query
			})
		case "createdBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withCreatedBy = query
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			s.withPartner = query
		case "createdAt":
			if _, ok := fieldSeen[survey.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, survey.FieldCreatedAt)
				fieldSeen[survey.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[survey.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, survey.FieldUpdatedAt)
				fieldSeen[survey.FieldUpdatedAt] = struct{}{}
			}
		case "date":
			if _, ok := fieldSeen[survey.FieldDate]; !ok {
				selectedFields = append(selectedFields, survey.FieldDate)
				fieldSeen[survey.FieldDate] = struct{}{}
			}
		case "slot":
			if _, ok := fieldSeen[survey.FieldSlot]; !ok {
				selectedFields = append(selectedFields, survey.FieldSlot)
				fieldSeen[survey.FieldSlot] = struct{}{}
			}
		case "slotID":
			if _, ok := fieldSeen[survey.FieldSlotID]; !ok {
				selectedFields = append(selectedFields, survey.FieldSlotID)
				fieldSeen[survey.FieldSlotID] = struct{}{}
			}
		case "from":
			if _, ok := fieldSeen[survey.FieldFrom]; !ok {
				selectedFields = append(selectedFields, survey.FieldFrom)
				fieldSeen[survey.FieldFrom] = struct{}{}
			}
		case "to":
			if _, ok := fieldSeen[survey.FieldTo]; !ok {
				selectedFields = append(selectedFields, survey.FieldTo)
				fieldSeen[survey.FieldTo] = struct{}{}
			}
		case "until":
			if _, ok := fieldSeen[survey.FieldUntil]; !ok {
				selectedFields = append(selectedFields, survey.FieldUntil)
				fieldSeen[survey.FieldUntil] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[survey.FieldName]; !ok {
				selectedFields = append(selectedFields, survey.FieldName)
				fieldSeen[survey.FieldName] = struct{}{}
			}
		case "address":
			if _, ok := fieldSeen[survey.FieldAddress]; !ok {
				selectedFields = append(selectedFields, survey.FieldAddress)
				fieldSeen[survey.FieldAddress] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[survey.FieldPhone]; !ok {
				selectedFields = append(selectedFields, survey.FieldPhone)
				fieldSeen[survey.FieldPhone] = struct{}{}
			}
		case "notes":
			if _, ok := fieldSeen[survey.FieldNotes]; !ok {
				selectedFields = append(selectedFields, survey.FieldNotes)
				fieldSeen[survey.FieldNotes] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[survey.FieldStatus]; !ok {
				selectedFields = append(selectedFields, survey.FieldStatus)
				fieldSeen[survey.FieldStatus] = struct{}{}
			}
		case "progress":
			if _, ok := fieldSeen[survey.FieldProgress]; !ok {
				selectedFields = append(selectedFields, survey.FieldProgress)
				fieldSeen[survey.FieldProgress] = struct{}{}
			}
		case "progressAt":
			if _, ok := fieldSeen[survey.FieldProgressAt]; !ok {
				selectedFields = append(selectedFields, survey.FieldProgressAt)
				fieldSeen[survey.FieldProgressAt] = struct{}{}
			}
		case "progressFlagAt":
			if _, ok := fieldSeen[survey.FieldProgressFlagAt]; !ok {
				selectedFields = append(selectedFields, survey.FieldProgressFlagAt)
				fieldSeen[survey.FieldProgressFlagAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type surveyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SurveyPaginateOption
}

func newSurveyPaginateArgs(rv map[string]any) *surveyPaginateArgs {
	args := &surveyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &SurveyOrder{Field: &SurveyOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithSurveyOrder(order))
			}
		case *SurveyOrder:
			if v != nil {
				args.opts = append(args.opts, WithSurveyOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*SurveyWhereInput); ok {
		args.opts = append(args.opts, WithSurveyFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sp *SurveyProgressQuery) CollectFields(ctx context.Context, satisfies ...string) (*SurveyProgressQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sp, nil
	}
	if err := sp.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sp, nil
}

func (sp *SurveyProgressQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(surveyprogress.Columns))
		selectedFields = []string{surveyprogress.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "survey":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SurveyClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sp.withSurvey = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sp.withCreator = query
		case "creatorAPI":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			sp.withCreatorAPI = query
		case "createdAt":
			if _, ok := fieldSeen[surveyprogress.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, surveyprogress.FieldCreatedAt)
				fieldSeen[surveyprogress.FieldCreatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[surveyprogress.FieldStatus]; !ok {
				selectedFields = append(selectedFields, surveyprogress.FieldStatus)
				fieldSeen[surveyprogress.FieldStatus] = struct{}{}
			}
		case "complete":
			if _, ok := fieldSeen[surveyprogress.FieldComplete]; !ok {
				selectedFields = append(selectedFields, surveyprogress.FieldComplete)
				fieldSeen[surveyprogress.FieldComplete] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[surveyprogress.FieldNote]; !ok {
				selectedFields = append(selectedFields, surveyprogress.FieldNote)
				fieldSeen[surveyprogress.FieldNote] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sp.Select(selectedFields...)
	}
	return nil
}

type surveyprogressPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SurveyProgressPaginateOption
}

func newSurveyProgressPaginateArgs(rv map[string]any) *surveyprogressPaginateArgs {
	args := &surveyprogressPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &SurveyProgressOrder{Field: &SurveyProgressOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithSurveyProgressOrder(order))
			}
		case *SurveyProgressOrder:
			if v != nil {
				args.opts = append(args.opts, WithSurveyProgressOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*SurveyProgressWhereInput); ok {
		args.opts = append(args.opts, WithSurveyProgressFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*TokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TokenQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(token.Columns))
		selectedFields = []string{token.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "createdAt":
			if _, ok := fieldSeen[token.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, token.FieldCreatedAt)
				fieldSeen[token.FieldCreatedAt] = struct{}{}
			}
		case "confirmedAt":
			if _, ok := fieldSeen[token.FieldConfirmedAt]; !ok {
				selectedFields = append(selectedFields, token.FieldConfirmedAt)
				fieldSeen[token.FieldConfirmedAt] = struct{}{}
			}
		case "action":
			if _, ok := fieldSeen[token.FieldAction]; !ok {
				selectedFields = append(selectedFields, token.FieldAction)
				fieldSeen[token.FieldAction] = struct{}{}
			}
		case "data":
			if _, ok := fieldSeen[token.FieldData]; !ok {
				selectedFields = append(selectedFields, token.FieldData)
				fieldSeen[token.FieldData] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type tokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TokenPaginateOption
}

func newTokenPaginateArgs(rv map[string]any) *tokenPaginateArgs {
	args := &tokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TokenOrder{Field: &TokenOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTokenOrder(order))
			}
		case *TokenOrder:
			if v != nil {
				args.opts = append(args.opts, WithTokenOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TokenWhereInput); ok {
		args.opts = append(args.opts, WithTokenFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tc *TrainingCourseQuery) CollectFields(ctx context.Context, satisfies ...string) (*TrainingCourseQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tc, nil
	}
	if err := tc.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tc, nil
}

func (tc *TrainingCourseQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(trainingcourse.Columns))
		selectedFields = []string{trainingcourse.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "trainingVideos":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TrainingVideoClient{config: tc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			tc.WithNamedTrainingVideos(alias, func(wq *TrainingVideoQuery) {
				*wq = *query
			})
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: tc.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			tc.withCreator = query
		case "createdAt":
			if _, ok := fieldSeen[trainingcourse.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, trainingcourse.FieldCreatedAt)
				fieldSeen[trainingcourse.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[trainingcourse.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, trainingcourse.FieldUpdatedAt)
				fieldSeen[trainingcourse.FieldUpdatedAt] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[trainingcourse.FieldName]; !ok {
				selectedFields = append(selectedFields, trainingcourse.FieldName)
				fieldSeen[trainingcourse.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tc.Select(selectedFields...)
	}
	return nil
}

type trainingcoursePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TrainingCoursePaginateOption
}

func newTrainingCoursePaginateArgs(rv map[string]any) *trainingcoursePaginateArgs {
	args := &trainingcoursePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TrainingCourseOrder{Field: &TrainingCourseOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTrainingCourseOrder(order))
			}
		case *TrainingCourseOrder:
			if v != nil {
				args.opts = append(args.opts, WithTrainingCourseOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TrainingCourseWhereInput); ok {
		args.opts = append(args.opts, WithTrainingCourseFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (tv *TrainingVideoQuery) CollectFields(ctx context.Context, satisfies ...string) (*TrainingVideoQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return tv, nil
	}
	if err := tv.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return tv, nil
}

func (tv *TrainingVideoQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(trainingvideo.Columns))
		selectedFields = []string{trainingvideo.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "trainingVideos":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerTrainingVideoClient{config: tv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			tv.WithNamedTrainingVideos(alias, func(wq *PartnerTrainingVideoQuery) {
				*wq = *query
			})
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: tv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			tv.withCreator = query
		case "course":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TrainingCourseClient{config: tv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			tv.withCourse = query
		case "poster":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: tv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			tv.withPoster = query
		case "video":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: tv.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			tv.withVideo = query
		case "createdAt":
			if _, ok := fieldSeen[trainingvideo.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, trainingvideo.FieldCreatedAt)
				fieldSeen[trainingvideo.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[trainingvideo.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, trainingvideo.FieldUpdatedAt)
				fieldSeen[trainingvideo.FieldUpdatedAt] = struct{}{}
			}
		case "kind":
			if _, ok := fieldSeen[trainingvideo.FieldKind]; !ok {
				selectedFields = append(selectedFields, trainingvideo.FieldKind)
				fieldSeen[trainingvideo.FieldKind] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[trainingvideo.FieldTitle]; !ok {
				selectedFields = append(selectedFields, trainingvideo.FieldTitle)
				fieldSeen[trainingvideo.FieldTitle] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[trainingvideo.FieldDescription]; !ok {
				selectedFields = append(selectedFields, trainingvideo.FieldDescription)
				fieldSeen[trainingvideo.FieldDescription] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		tv.Select(selectedFields...)
	}
	return nil
}

type trainingvideoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TrainingVideoPaginateOption
}

func newTrainingVideoPaginateArgs(rv map[string]any) *trainingvideoPaginateArgs {
	args := &trainingvideoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &TrainingVideoOrder{Field: &TrainingVideoOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithTrainingVideoOrder(order))
			}
		case *TrainingVideoOrder:
			if v != nil {
				args.opts = append(args.opts, WithTrainingVideoOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*TrainingVideoWhereInput); ok {
		args.opts = append(args.opts, WithTrainingVideoFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "auths":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserAuthClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.withAuths = query
		case "sessions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserSessionClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedSessions(alias, func(wq *UserSessionQuery) {
				*wq = *query
			})
		case "auditLogs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AuditLogClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedAuditLogs(alias, func(wq *AuditLogQuery) {
				*wq = *query
			})
		case "notify":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NotifySettingClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedNotify(alias, func(wq *NotifySettingQuery) {
				*wq = *query
			})
		case "createdJobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedCreatedJobs(alias, func(wq *JobQuery) {
				*wq = *query
			})
		case "createdEstimates":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedCreatedEstimates(alias, func(wq *EstimateQuery) {
				*wq = *query
			})
		case "salesRepEstimates":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedSalesRepEstimates(alias, func(wq *EstimateQuery) {
				*wq = *query
			})
		case "sales":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedSales(alias, func(wq *JobQuery) {
				*wq = *query
			})
		case "createdInstallationJobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InstallationJobClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedCreatedInstallationJobs(alias, func(wq *InstallationJobQuery) {
				*wq = *query
			})
		case "installationLeads":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InstallationJobClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedInstallationLeads(alias, func(wq *InstallationJobQuery) {
				*wq = *query
			})
		case "estimateActivities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EstimateActivityClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedEstimateActivities(alias, func(wq *EstimateActivityQuery) {
				*wq = *query
			})
		case "jobActivities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobActivityClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedJobActivities(alias, func(wq *JobActivityQuery) {
				*wq = *query
			})
		case "partnerActivities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerActivityClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedPartnerActivities(alias, func(wq *PartnerActivityQuery) {
				*wq = *query
			})
		case "userActivities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserActivityClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedUserActivities(alias, func(wq *UserActivityQuery) {
				*wq = *query
			})
		case "activities":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserActivityClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedActivities(alias, func(wq *UserActivityQuery) {
				*wq = *query
			})
		case "jobProgressHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobProgressHistoryClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedJobProgressHistory(alias, func(wq *JobProgressHistoryQuery) {
				*wq = *query
			})
		case "installationJobStatusChanger":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InstallationJobProgressClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedInstallationJobStatusChanger(alias, func(wq *InstallationJobProgressQuery) {
				*wq = *query
			})
		case "contactUsRequests":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContactUsClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedContactUsRequests(alias, func(wq *ContactUsQuery) {
				*wq = *query
			})
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedPartner(alias, func(wq *PartnerQuery) {
				*wq = *query
			})
		case "surveys":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SurveyClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedSurveys(alias, func(wq *SurveyQuery) {
				*wq = *query
			})
		case "surveyProgress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SurveyProgressClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedSurveyProgress(alias, func(wq *SurveyProgressQuery) {
				*wq = *query
			})
		case "createdTrainingVideos":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TrainingVideoClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedCreatedTrainingVideos(alias, func(wq *TrainingVideoQuery) {
				*wq = *query
			})
		case "createdTrainingCourses":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TrainingCourseClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedCreatedTrainingCourses(alias, func(wq *TrainingCourseQuery) {
				*wq = *query
			})
		case "jobNotes":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobNoteClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedJobNotes(alias, func(wq *JobNoteQuery) {
				*wq = *query
			})
		case "chatChannels":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelSubClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedChatChannels(alias, func(wq *ChannelSubQuery) {
				*wq = *query
			})
		case "sentMessages":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelMessageClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedSentMessages(alias, func(wq *ChannelMessageQuery) {
				*wq = *query
			})
		case "receivedMessages":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelMessageClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedReceivedMessages(alias, func(wq *ChannelMessageQuery) {
				*wq = *query
			})
		case "channelMessageRead":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChannelMessageReadClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedChannelMessageRead(alias, func(wq *ChannelMessageReadQuery) {
				*wq = *query
			})
		case "productsCreated":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedProductsCreated(alias, func(wq *ProductQuery) {
				*wq = *query
			})
		case "productPkgCreated":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductPackageClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedProductPkgCreated(alias, func(wq *ProductPackageQuery) {
				*wq = *query
			})
		case "jobDocUrls":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&JobDocURLClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedJobDocUrls(alias, func(wq *JobDocURLQuery) {
				*wq = *query
			})
		case "partnerContacts":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerContactClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			u.WithNamedPartnerContacts(alias, func(wq *PartnerContactQuery) {
				*wq = *query
			})
		case "createdAt":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "deletedAt":
			if _, ok := fieldSeen[user.FieldDeletedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldDeletedAt)
				fieldSeen[user.FieldDeletedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[user.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldUpdatedAt)
				fieldSeen[user.FieldUpdatedAt] = struct{}{}
			}
		case "externalID":
			if _, ok := fieldSeen[user.FieldExternalID]; !ok {
				selectedFields = append(selectedFields, user.FieldExternalID)
				fieldSeen[user.FieldExternalID] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "phone":
			if _, ok := fieldSeen[user.FieldPhone]; !ok {
				selectedFields = append(selectedFields, user.FieldPhone)
				fieldSeen[user.FieldPhone] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[user.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, user.FieldFirstName)
				fieldSeen[user.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[user.FieldLastName]; !ok {
				selectedFields = append(selectedFields, user.FieldLastName)
				fieldSeen[user.FieldLastName] = struct{}{}
			}
		case "emailVerified":
			if _, ok := fieldSeen[user.FieldEmailVerified]; !ok {
				selectedFields = append(selectedFields, user.FieldEmailVerified)
				fieldSeen[user.FieldEmailVerified] = struct{}{}
			}
		case "phoneVerified":
			if _, ok := fieldSeen[user.FieldPhoneVerified]; !ok {
				selectedFields = append(selectedFields, user.FieldPhoneVerified)
				fieldSeen[user.FieldPhoneVerified] = struct{}{}
			}
		case "picture":
			if _, ok := fieldSeen[user.FieldPicture]; !ok {
				selectedFields = append(selectedFields, user.FieldPicture)
				fieldSeen[user.FieldPicture] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[user.FieldStatus]; !ok {
				selectedFields = append(selectedFields, user.FieldStatus)
				fieldSeen[user.FieldStatus] = struct{}{}
			}
		case "role":
			if _, ok := fieldSeen[user.FieldRole]; !ok {
				selectedFields = append(selectedFields, user.FieldRole)
				fieldSeen[user.FieldRole] = struct{}{}
			}
		case "note":
			if _, ok := fieldSeen[user.FieldNote]; !ok {
				selectedFields = append(selectedFields, user.FieldNote)
				fieldSeen[user.FieldNote] = struct{}{}
			}
		case "wrongAttempts":
			if _, ok := fieldSeen[user.FieldWrongAttempts]; !ok {
				selectedFields = append(selectedFields, user.FieldWrongAttempts)
				fieldSeen[user.FieldWrongAttempts] = struct{}{}
			}
		case "wrongAttemptAt":
			if _, ok := fieldSeen[user.FieldWrongAttemptAt]; !ok {
				selectedFields = append(selectedFields, user.FieldWrongAttemptAt)
				fieldSeen[user.FieldWrongAttemptAt] = struct{}{}
			}
		case "lockedUntil":
			if _, ok := fieldSeen[user.FieldLockedUntil]; !ok {
				selectedFields = append(selectedFields, user.FieldLockedUntil)
				fieldSeen[user.FieldLockedUntil] = struct{}{}
			}
		case "location":
			if _, ok := fieldSeen[user.FieldLocation]; !ok {
				selectedFields = append(selectedFields, user.FieldLocation)
				fieldSeen[user.FieldLocation] = struct{}{}
			}
		case "acceptedGeneralTerms":
			if _, ok := fieldSeen[user.FieldAcceptedGeneralTerms]; !ok {
				selectedFields = append(selectedFields, user.FieldAcceptedGeneralTerms)
				fieldSeen[user.FieldAcceptedGeneralTerms] = struct{}{}
			}
		case "acceptedTermsNPrivacy":
			if _, ok := fieldSeen[user.FieldAcceptedTermsNPrivacy]; !ok {
				selectedFields = append(selectedFields, user.FieldAcceptedTermsNPrivacy)
				fieldSeen[user.FieldAcceptedTermsNPrivacy] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserOrder{Field: &UserOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserOrder(order))
			}
		case *UserOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserWhereInput); ok {
		args.opts = append(args.opts, WithUserFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ua *UserActivityQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserActivityQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ua, nil
	}
	if err := ua.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ua, nil
}

func (ua *UserActivityQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(useractivity.Columns))
		selectedFields = []string{useractivity.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ua.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ua.withUser = query
		case "creator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ua.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ua.withCreator = query
		case "creatorAPI":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ApiUserClient{config: ua.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ua.withCreatorAPI = query
		case "createdAt":
			if _, ok := fieldSeen[useractivity.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, useractivity.FieldCreatedAt)
				fieldSeen[useractivity.FieldCreatedAt] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[useractivity.FieldDescription]; !ok {
				selectedFields = append(selectedFields, useractivity.FieldDescription)
				fieldSeen[useractivity.FieldDescription] = struct{}{}
			}
		case "raw":
			if _, ok := fieldSeen[useractivity.FieldRaw]; !ok {
				selectedFields = append(selectedFields, useractivity.FieldRaw)
				fieldSeen[useractivity.FieldRaw] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ua.Select(selectedFields...)
	}
	return nil
}

type useractivityPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserActivityPaginateOption
}

func newUserActivityPaginateArgs(rv map[string]any) *useractivityPaginateArgs {
	args := &useractivityPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserActivityOrder{Field: &UserActivityOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserActivityOrder(order))
			}
		case *UserActivityOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserActivityOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserActivityWhereInput); ok {
		args.opts = append(args.opts, WithUserActivityFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ua *UserAuthQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserAuthQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ua, nil
	}
	if err := ua.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ua, nil
}

func (ua *UserAuthQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(userauth.Columns))
		selectedFields = []string{userauth.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ua.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			ua.withUser = query
		case "providerID":
			if _, ok := fieldSeen[userauth.FieldProviderID]; !ok {
				selectedFields = append(selectedFields, userauth.FieldProviderID)
				fieldSeen[userauth.FieldProviderID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[userauth.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, userauth.FieldCreatedAt)
				fieldSeen[userauth.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ua.Select(selectedFields...)
	}
	return nil
}

type userauthPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserAuthPaginateOption
}

func newUserAuthPaginateArgs(rv map[string]any) *userauthPaginateArgs {
	args := &userauthPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserAuthOrder{Field: &UserAuthOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserAuthOrder(order))
			}
		case *UserAuthOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserAuthOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserAuthWhereInput); ok {
		args.opts = append(args.opts, WithUserAuthFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (us *UserSessionQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserSessionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return us, nil
	}
	if err := us.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return us, nil
}

func (us *UserSessionQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(usersession.Columns))
		selectedFields = []string{usersession.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "sockets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserSessionSocketClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			us.WithNamedSockets(alias, func(wq *UserSessionSocketQuery) {
				*wq = *query
			})
		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			us.withUser = query
		case "partner":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			us.withPartner = query
		case "partnerContact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PartnerContactClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			us.withPartnerContact = query
		case "createdAt":
			if _, ok := fieldSeen[usersession.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, usersession.FieldCreatedAt)
				fieldSeen[usersession.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[usersession.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, usersession.FieldUpdatedAt)
				fieldSeen[usersession.FieldUpdatedAt] = struct{}{}
			}
		case "expiresAt":
			if _, ok := fieldSeen[usersession.FieldExpiresAt]; !ok {
				selectedFields = append(selectedFields, usersession.FieldExpiresAt)
				fieldSeen[usersession.FieldExpiresAt] = struct{}{}
			}
		case "ip":
			if _, ok := fieldSeen[usersession.FieldIP]; !ok {
				selectedFields = append(selectedFields, usersession.FieldIP)
				fieldSeen[usersession.FieldIP] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		us.Select(selectedFields...)
	}
	return nil
}

type usersessionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserSessionPaginateOption
}

func newUserSessionPaginateArgs(rv map[string]any) *usersessionPaginateArgs {
	args := &usersessionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserSessionOrder{Field: &UserSessionOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserSessionOrder(order))
			}
		case *UserSessionOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserSessionOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserSessionWhereInput); ok {
		args.opts = append(args.opts, WithUserSessionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (uss *UserSessionSocketQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserSessionSocketQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return uss, nil
	}
	if err := uss.collectField(ctx, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return uss, nil
}

func (uss *UserSessionSocketQuery) collectField(ctx context.Context, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(usersessionsocket.Columns))
		selectedFields = []string{usersessionsocket.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "session":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserSessionClient{config: uss.config}).Query()
			)
			if err := query.collectField(ctx, opCtx, field, path, satisfies...); err != nil {
				return err
			}
			uss.withSession = query
		case "createdAt":
			if _, ok := fieldSeen[usersessionsocket.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, usersessionsocket.FieldCreatedAt)
				fieldSeen[usersessionsocket.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[usersessionsocket.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, usersessionsocket.FieldUpdatedAt)
				fieldSeen[usersessionsocket.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		uss.Select(selectedFields...)
	}
	return nil
}

type usersessionsocketPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserSessionSocketPaginateOption
}

func newUserSessionSocketPaginateArgs(rv map[string]any) *usersessionsocketPaginateArgs {
	args := &usersessionsocketPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &UserSessionSocketOrder{Field: &UserSessionSocketOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithUserSessionSocketOrder(order))
			}
		case *UserSessionSocketOrder:
			if v != nil {
				args.opts = append(args.opts, WithUserSessionSocketOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*UserSessionSocketWhereInput); ok {
		args.opts = append(args.opts, WithUserSessionSocketFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

func limitRows(partitionBy string, limit int, orderBy ...sql.Querier) func(s *sql.Selector) {
	return func(s *sql.Selector) {
		d := sql.Dialect(s.Dialect())
		s.SetDistinct(false)
		with := d.With("src_query").
			As(s.Clone()).
			With("limited_query").
			As(
				d.Select("*").
					AppendSelectExprAs(
						sql.RowNumber().PartitionBy(partitionBy).OrderExpr(orderBy...),
						"row_number",
					).
					From(d.Table("src_query")),
			)
		t := d.Table("limited_query").As(s.TableName())
		*s = *d.Select(s.UnqualifiedColumns()...).
			From(t).
			Where(sql.LTE(t.C("row_number"), limit)).
			Prefix(with)
	}
}

// mayAddCondition appends another type condition to the satisfies list
// if condition is enabled (Node/Nodes) and it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond string) []string {
	if len(satisfies) == 0 {
		return satisfies
	}
	for _, s := range satisfies {
		if typeCond == s {
			return satisfies
		}
	}
	return append(satisfies, typeCond)
}
