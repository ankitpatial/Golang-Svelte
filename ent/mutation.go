// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"roofix/ent/apiaccess"
	"roofix/ent/apiuser"
	"roofix/ent/apiusertoken"
	"roofix/ent/auditlog"
	"roofix/ent/channel"
	"roofix/ent/channelmessage"
	"roofix/ent/channelmessageread"
	"roofix/ent/channelsub"
	"roofix/ent/contactus"
	"roofix/ent/document"
	"roofix/ent/estimate"
	"roofix/ent/estimateactivity"
	"roofix/ent/homeowner"
	"roofix/ent/installationjob"
	"roofix/ent/installationjobitem"
	"roofix/ent/installationjobprogress"
	"roofix/ent/job"
	"roofix/ent/jobactivity"
	"roofix/ent/jobassignmenthistory"
	"roofix/ent/jobdocurl"
	"roofix/ent/jobnote"
	"roofix/ent/jobprogresshistory"
	"roofix/ent/notifysetting"
	"roofix/ent/optionlist"
	"roofix/ent/partner"
	"roofix/ent/partneractivity"
	"roofix/ent/partnercontact"
	"roofix/ent/partnerservice"
	"roofix/ent/partnerservicecity"
	"roofix/ent/partnerservicestate"
	"roofix/ent/partnertrainingvideo"
	"roofix/ent/payment"
	"roofix/ent/postalcode"
	"roofix/ent/predicate"
	"roofix/ent/pricing"
	"roofix/ent/product"
	"roofix/ent/productpackage"
	"roofix/ent/schema"
	"roofix/ent/survey"
	"roofix/ent/surveyprogress"
	"roofix/ent/token"
	"roofix/ent/trainingcourse"
	"roofix/ent/trainingvideo"
	"roofix/ent/user"
	"roofix/ent/useractivity"
	"roofix/ent/userauth"
	"roofix/ent/usersession"
	"roofix/ent/usersessionsocket"
	"roofix/pkg/enum"
	"roofix/pkg/model"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApiAccess               = "ApiAccess"
	TypeApiUser                 = "ApiUser"
	TypeApiUserToken            = "ApiUserToken"
	TypeAuditLog                = "AuditLog"
	TypeChannel                 = "Channel"
	TypeChannelMessage          = "ChannelMessage"
	TypeChannelMessageRead      = "ChannelMessageRead"
	TypeChannelSub              = "ChannelSub"
	TypeContactUs               = "ContactUs"
	TypeDocument                = "Document"
	TypeEstimate                = "Estimate"
	TypeEstimateActivity        = "EstimateActivity"
	TypeHomeOwner               = "HomeOwner"
	TypeInstallationJob         = "InstallationJob"
	TypeInstallationJobItem     = "InstallationJobItem"
	TypeInstallationJobProgress = "InstallationJobProgress"
	TypeJob                     = "Job"
	TypeJobActivity             = "JobActivity"
	TypeJobAssignmentHistory    = "JobAssignmentHistory"
	TypeJobDocURL               = "JobDocURL"
	TypeJobNote                 = "JobNote"
	TypeJobProgressHistory      = "JobProgressHistory"
	TypeNotifySetting           = "NotifySetting"
	TypeOptionList              = "OptionList"
	TypePartner                 = "Partner"
	TypePartnerActivity         = "PartnerActivity"
	TypePartnerContact          = "PartnerContact"
	TypePartnerService          = "PartnerService"
	TypePartnerServiceCity      = "PartnerServiceCity"
	TypePartnerServiceState     = "PartnerServiceState"
	TypePartnerTrainingVideo    = "PartnerTrainingVideo"
	TypePayment                 = "Payment"
	TypePostalCode              = "PostalCode"
	TypePricing                 = "Pricing"
	TypeProduct                 = "Product"
	TypeProductPackage          = "ProductPackage"
	TypeSurvey                  = "Survey"
	TypeSurveyProgress          = "SurveyProgress"
	TypeToken                   = "Token"
	TypeTrainingCourse          = "TrainingCourse"
	TypeTrainingVideo           = "TrainingVideo"
	TypeUser                    = "User"
	TypeUserActivity            = "UserActivity"
	TypeUserAuth                = "UserAuth"
	TypeUserSession             = "UserSession"
	TypeUserSessionSocket       = "UserSessionSocket"
)

// ApiAccessMutation represents an operation that mutates the ApiAccess nodes in the graph.
type ApiAccessMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	url           *string
	username      *string
	password      *string
	key           *string
	secret        *string
	access_token  *string
	refresh_token *string
	expires_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ApiAccess, error)
	predicates    []predicate.ApiAccess
}

var _ ent.Mutation = (*ApiAccessMutation)(nil)

// apiaccessOption allows management of the mutation configuration using functional options.
type apiaccessOption func(*ApiAccessMutation)

// newApiAccessMutation creates new mutation for the ApiAccess entity.
func newApiAccessMutation(c config, op Op, opts ...apiaccessOption) *ApiAccessMutation {
	m := &ApiAccessMutation{
		config:        c,
		op:            op,
		typ:           TypeApiAccess,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiAccessID sets the ID field of the mutation.
func withApiAccessID(id string) apiaccessOption {
	return func(m *ApiAccessMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiAccess
		)
		m.oldValue = func(ctx context.Context) (*ApiAccess, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiAccess.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiAccess sets the old ApiAccess of the mutation.
func withApiAccess(node *ApiAccess) apiaccessOption {
	return func(m *ApiAccessMutation) {
		m.oldValue = func(context.Context) (*ApiAccess, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiAccessMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiAccessMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiAccess entities.
func (m *ApiAccessMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiAccessMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiAccessMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiAccess.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiAccessMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiAccessMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiAccess entity.
// If the ApiAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAccessMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiAccessMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApiAccessMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApiAccessMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApiAccess entity.
// If the ApiAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAccessMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApiAccessMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetURL sets the "url" field.
func (m *ApiAccessMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ApiAccessMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the ApiAccess entity.
// If the ApiAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAccessMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ApiAccessMutation) ResetURL() {
	m.url = nil
}

// SetUsername sets the "username" field.
func (m *ApiAccessMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ApiAccessMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the ApiAccess entity.
// If the ApiAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAccessMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *ApiAccessMutation) ResetUsername() {
	m.username = nil
}

// SetPassword sets the "password" field.
func (m *ApiAccessMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *ApiAccessMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the ApiAccess entity.
// If the ApiAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAccessMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *ApiAccessMutation) ResetPassword() {
	m.password = nil
}

// SetKey sets the "key" field.
func (m *ApiAccessMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *ApiAccessMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the ApiAccess entity.
// If the ApiAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAccessMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *ApiAccessMutation) ResetKey() {
	m.key = nil
}

// SetSecret sets the "secret" field.
func (m *ApiAccessMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *ApiAccessMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the ApiAccess entity.
// If the ApiAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAccessMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *ApiAccessMutation) ResetSecret() {
	m.secret = nil
}

// SetAccessToken sets the "access_token" field.
func (m *ApiAccessMutation) SetAccessToken(s string) {
	m.access_token = &s
}

// AccessToken returns the value of the "access_token" field in the mutation.
func (m *ApiAccessMutation) AccessToken() (r string, exists bool) {
	v := m.access_token
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessToken returns the old "access_token" field's value of the ApiAccess entity.
// If the ApiAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAccessMutation) OldAccessToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessToken: %w", err)
	}
	return oldValue.AccessToken, nil
}

// ClearAccessToken clears the value of the "access_token" field.
func (m *ApiAccessMutation) ClearAccessToken() {
	m.access_token = nil
	m.clearedFields[apiaccess.FieldAccessToken] = struct{}{}
}

// AccessTokenCleared returns if the "access_token" field was cleared in this mutation.
func (m *ApiAccessMutation) AccessTokenCleared() bool {
	_, ok := m.clearedFields[apiaccess.FieldAccessToken]
	return ok
}

// ResetAccessToken resets all changes to the "access_token" field.
func (m *ApiAccessMutation) ResetAccessToken() {
	m.access_token = nil
	delete(m.clearedFields, apiaccess.FieldAccessToken)
}

// SetRefreshToken sets the "refresh_token" field.
func (m *ApiAccessMutation) SetRefreshToken(s string) {
	m.refresh_token = &s
}

// RefreshToken returns the value of the "refresh_token" field in the mutation.
func (m *ApiAccessMutation) RefreshToken() (r string, exists bool) {
	v := m.refresh_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshToken returns the old "refresh_token" field's value of the ApiAccess entity.
// If the ApiAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAccessMutation) OldRefreshToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshToken: %w", err)
	}
	return oldValue.RefreshToken, nil
}

// ClearRefreshToken clears the value of the "refresh_token" field.
func (m *ApiAccessMutation) ClearRefreshToken() {
	m.refresh_token = nil
	m.clearedFields[apiaccess.FieldRefreshToken] = struct{}{}
}

// RefreshTokenCleared returns if the "refresh_token" field was cleared in this mutation.
func (m *ApiAccessMutation) RefreshTokenCleared() bool {
	_, ok := m.clearedFields[apiaccess.FieldRefreshToken]
	return ok
}

// ResetRefreshToken resets all changes to the "refresh_token" field.
func (m *ApiAccessMutation) ResetRefreshToken() {
	m.refresh_token = nil
	delete(m.clearedFields, apiaccess.FieldRefreshToken)
}

// SetExpiresAt sets the "expires_at" field.
func (m *ApiAccessMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *ApiAccessMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the ApiAccess entity.
// If the ApiAccess object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiAccessMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *ApiAccessMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[apiaccess.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *ApiAccessMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[apiaccess.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *ApiAccessMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, apiaccess.FieldExpiresAt)
}

// Where appends a list predicates to the ApiAccessMutation builder.
func (m *ApiAccessMutation) Where(ps ...predicate.ApiAccess) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiAccessMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiAccessMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiAccess, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiAccessMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiAccessMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiAccess).
func (m *ApiAccessMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiAccessMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, apiaccess.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, apiaccess.FieldUpdatedAt)
	}
	if m.url != nil {
		fields = append(fields, apiaccess.FieldURL)
	}
	if m.username != nil {
		fields = append(fields, apiaccess.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, apiaccess.FieldPassword)
	}
	if m.key != nil {
		fields = append(fields, apiaccess.FieldKey)
	}
	if m.secret != nil {
		fields = append(fields, apiaccess.FieldSecret)
	}
	if m.access_token != nil {
		fields = append(fields, apiaccess.FieldAccessToken)
	}
	if m.refresh_token != nil {
		fields = append(fields, apiaccess.FieldRefreshToken)
	}
	if m.expires_at != nil {
		fields = append(fields, apiaccess.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiAccessMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apiaccess.FieldCreatedAt:
		return m.CreatedAt()
	case apiaccess.FieldUpdatedAt:
		return m.UpdatedAt()
	case apiaccess.FieldURL:
		return m.URL()
	case apiaccess.FieldUsername:
		return m.Username()
	case apiaccess.FieldPassword:
		return m.Password()
	case apiaccess.FieldKey:
		return m.Key()
	case apiaccess.FieldSecret:
		return m.Secret()
	case apiaccess.FieldAccessToken:
		return m.AccessToken()
	case apiaccess.FieldRefreshToken:
		return m.RefreshToken()
	case apiaccess.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiAccessMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apiaccess.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apiaccess.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case apiaccess.FieldURL:
		return m.OldURL(ctx)
	case apiaccess.FieldUsername:
		return m.OldUsername(ctx)
	case apiaccess.FieldPassword:
		return m.OldPassword(ctx)
	case apiaccess.FieldKey:
		return m.OldKey(ctx)
	case apiaccess.FieldSecret:
		return m.OldSecret(ctx)
	case apiaccess.FieldAccessToken:
		return m.OldAccessToken(ctx)
	case apiaccess.FieldRefreshToken:
		return m.OldRefreshToken(ctx)
	case apiaccess.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown ApiAccess field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiAccessMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apiaccess.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apiaccess.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case apiaccess.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case apiaccess.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case apiaccess.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case apiaccess.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case apiaccess.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case apiaccess.FieldAccessToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessToken(v)
		return nil
	case apiaccess.FieldRefreshToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshToken(v)
		return nil
	case apiaccess.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown ApiAccess field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiAccessMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiAccessMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiAccessMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiAccess numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiAccessMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apiaccess.FieldAccessToken) {
		fields = append(fields, apiaccess.FieldAccessToken)
	}
	if m.FieldCleared(apiaccess.FieldRefreshToken) {
		fields = append(fields, apiaccess.FieldRefreshToken)
	}
	if m.FieldCleared(apiaccess.FieldExpiresAt) {
		fields = append(fields, apiaccess.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiAccessMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiAccessMutation) ClearField(name string) error {
	switch name {
	case apiaccess.FieldAccessToken:
		m.ClearAccessToken()
		return nil
	case apiaccess.FieldRefreshToken:
		m.ClearRefreshToken()
		return nil
	case apiaccess.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ApiAccess nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiAccessMutation) ResetField(name string) error {
	switch name {
	case apiaccess.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apiaccess.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case apiaccess.FieldURL:
		m.ResetURL()
		return nil
	case apiaccess.FieldUsername:
		m.ResetUsername()
		return nil
	case apiaccess.FieldPassword:
		m.ResetPassword()
		return nil
	case apiaccess.FieldKey:
		m.ResetKey()
		return nil
	case apiaccess.FieldSecret:
		m.ResetSecret()
		return nil
	case apiaccess.FieldAccessToken:
		m.ResetAccessToken()
		return nil
	case apiaccess.FieldRefreshToken:
		m.ResetRefreshToken()
		return nil
	case apiaccess.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown ApiAccess field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiAccessMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiAccessMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiAccessMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiAccessMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiAccessMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiAccessMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiAccessMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApiAccess unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiAccessMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApiAccess edge %s", name)
}

// ApiUserMutation represents an operation that mutates the ApiUser nodes in the graph.
type ApiUserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	created_at                  *time.Time
	username                    *string
	pwd_hash                    *string
	active                      *bool
	cb_api_url                  *string
	cb_api_auth                 *apiuser.CbAPIAuth
	cb_api_user                 *string
	cb_api_pwd                  *string
	cb_api_token                *string
	cb_api_endpoints            *map[string]string
	clearedFields               map[string]struct{}
	tokens                      map[string]struct{}
	removedtokens               map[string]struct{}
	clearedtokens               bool
	audit_logs                  map[string]struct{}
	removedaudit_logs           map[string]struct{}
	clearedaudit_logs           bool
	created_estimates           map[string]struct{}
	removedcreated_estimates    map[string]struct{}
	clearedcreated_estimates    bool
	created_jobs                map[string]struct{}
	removedcreated_jobs         map[string]struct{}
	clearedcreated_jobs         bool
	created_partners            map[string]struct{}
	removedcreated_partners     map[string]struct{}
	clearedcreated_partners     bool
	survey_progress             map[string]struct{}
	removedsurvey_progress      map[string]struct{}
	clearedsurvey_progress      bool
	estimate_activities         map[string]struct{}
	removedestimate_activities  map[string]struct{}
	clearedestimate_activities  bool
	user_activities             map[string]struct{}
	removeduser_activities      map[string]struct{}
	cleareduser_activities      bool
	partner_activities          map[string]struct{}
	removedpartner_activities   map[string]struct{}
	clearedpartner_activities   bool
	job_activities              map[string]struct{}
	removedjob_activities       map[string]struct{}
	clearedjob_activities       bool
	notifications               map[string]struct{}
	removednotifications        map[string]struct{}
	clearednotifications        bool
	job_progress_history        map[string]struct{}
	removedjob_progress_history map[string]struct{}
	clearedjob_progress_history bool
	done                        bool
	oldValue                    func(context.Context) (*ApiUser, error)
	predicates                  []predicate.ApiUser
}

var _ ent.Mutation = (*ApiUserMutation)(nil)

// apiuserOption allows management of the mutation configuration using functional options.
type apiuserOption func(*ApiUserMutation)

// newApiUserMutation creates new mutation for the ApiUser entity.
func newApiUserMutation(c config, op Op, opts ...apiuserOption) *ApiUserMutation {
	m := &ApiUserMutation{
		config:        c,
		op:            op,
		typ:           TypeApiUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiUserID sets the ID field of the mutation.
func withApiUserID(id string) apiuserOption {
	return func(m *ApiUserMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiUser
		)
		m.oldValue = func(ctx context.Context) (*ApiUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiUser sets the old ApiUser of the mutation.
func withApiUser(node *ApiUser) apiuserOption {
	return func(m *ApiUserMutation) {
		m.oldValue = func(context.Context) (*ApiUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiUser entities.
func (m *ApiUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiUser entity.
// If the ApiUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiUserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUsername sets the "username" field.
func (m *ApiUserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *ApiUserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the ApiUser entity.
// If the ApiUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *ApiUserMutation) ResetUsername() {
	m.username = nil
}

// SetPwdHash sets the "pwd_hash" field.
func (m *ApiUserMutation) SetPwdHash(s string) {
	m.pwd_hash = &s
}

// PwdHash returns the value of the "pwd_hash" field in the mutation.
func (m *ApiUserMutation) PwdHash() (r string, exists bool) {
	v := m.pwd_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPwdHash returns the old "pwd_hash" field's value of the ApiUser entity.
// If the ApiUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserMutation) OldPwdHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPwdHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPwdHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPwdHash: %w", err)
	}
	return oldValue.PwdHash, nil
}

// ResetPwdHash resets all changes to the "pwd_hash" field.
func (m *ApiUserMutation) ResetPwdHash() {
	m.pwd_hash = nil
}

// SetActive sets the "active" field.
func (m *ApiUserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *ApiUserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the ApiUser entity.
// If the ApiUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *ApiUserMutation) ResetActive() {
	m.active = nil
}

// SetCbAPIURL sets the "cb_api_url" field.
func (m *ApiUserMutation) SetCbAPIURL(s string) {
	m.cb_api_url = &s
}

// CbAPIURL returns the value of the "cb_api_url" field in the mutation.
func (m *ApiUserMutation) CbAPIURL() (r string, exists bool) {
	v := m.cb_api_url
	if v == nil {
		return
	}
	return *v, true
}

// OldCbAPIURL returns the old "cb_api_url" field's value of the ApiUser entity.
// If the ApiUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserMutation) OldCbAPIURL(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCbAPIURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCbAPIURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCbAPIURL: %w", err)
	}
	return oldValue.CbAPIURL, nil
}

// ClearCbAPIURL clears the value of the "cb_api_url" field.
func (m *ApiUserMutation) ClearCbAPIURL() {
	m.cb_api_url = nil
	m.clearedFields[apiuser.FieldCbAPIURL] = struct{}{}
}

// CbAPIURLCleared returns if the "cb_api_url" field was cleared in this mutation.
func (m *ApiUserMutation) CbAPIURLCleared() bool {
	_, ok := m.clearedFields[apiuser.FieldCbAPIURL]
	return ok
}

// ResetCbAPIURL resets all changes to the "cb_api_url" field.
func (m *ApiUserMutation) ResetCbAPIURL() {
	m.cb_api_url = nil
	delete(m.clearedFields, apiuser.FieldCbAPIURL)
}

// SetCbAPIAuth sets the "cb_api_auth" field.
func (m *ApiUserMutation) SetCbAPIAuth(aaa apiuser.CbAPIAuth) {
	m.cb_api_auth = &aaa
}

// CbAPIAuth returns the value of the "cb_api_auth" field in the mutation.
func (m *ApiUserMutation) CbAPIAuth() (r apiuser.CbAPIAuth, exists bool) {
	v := m.cb_api_auth
	if v == nil {
		return
	}
	return *v, true
}

// OldCbAPIAuth returns the old "cb_api_auth" field's value of the ApiUser entity.
// If the ApiUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserMutation) OldCbAPIAuth(ctx context.Context) (v apiuser.CbAPIAuth, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCbAPIAuth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCbAPIAuth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCbAPIAuth: %w", err)
	}
	return oldValue.CbAPIAuth, nil
}

// ClearCbAPIAuth clears the value of the "cb_api_auth" field.
func (m *ApiUserMutation) ClearCbAPIAuth() {
	m.cb_api_auth = nil
	m.clearedFields[apiuser.FieldCbAPIAuth] = struct{}{}
}

// CbAPIAuthCleared returns if the "cb_api_auth" field was cleared in this mutation.
func (m *ApiUserMutation) CbAPIAuthCleared() bool {
	_, ok := m.clearedFields[apiuser.FieldCbAPIAuth]
	return ok
}

// ResetCbAPIAuth resets all changes to the "cb_api_auth" field.
func (m *ApiUserMutation) ResetCbAPIAuth() {
	m.cb_api_auth = nil
	delete(m.clearedFields, apiuser.FieldCbAPIAuth)
}

// SetCbAPIUser sets the "cb_api_user" field.
func (m *ApiUserMutation) SetCbAPIUser(s string) {
	m.cb_api_user = &s
}

// CbAPIUser returns the value of the "cb_api_user" field in the mutation.
func (m *ApiUserMutation) CbAPIUser() (r string, exists bool) {
	v := m.cb_api_user
	if v == nil {
		return
	}
	return *v, true
}

// OldCbAPIUser returns the old "cb_api_user" field's value of the ApiUser entity.
// If the ApiUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserMutation) OldCbAPIUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCbAPIUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCbAPIUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCbAPIUser: %w", err)
	}
	return oldValue.CbAPIUser, nil
}

// ClearCbAPIUser clears the value of the "cb_api_user" field.
func (m *ApiUserMutation) ClearCbAPIUser() {
	m.cb_api_user = nil
	m.clearedFields[apiuser.FieldCbAPIUser] = struct{}{}
}

// CbAPIUserCleared returns if the "cb_api_user" field was cleared in this mutation.
func (m *ApiUserMutation) CbAPIUserCleared() bool {
	_, ok := m.clearedFields[apiuser.FieldCbAPIUser]
	return ok
}

// ResetCbAPIUser resets all changes to the "cb_api_user" field.
func (m *ApiUserMutation) ResetCbAPIUser() {
	m.cb_api_user = nil
	delete(m.clearedFields, apiuser.FieldCbAPIUser)
}

// SetCbAPIPwd sets the "cb_api_pwd" field.
func (m *ApiUserMutation) SetCbAPIPwd(s string) {
	m.cb_api_pwd = &s
}

// CbAPIPwd returns the value of the "cb_api_pwd" field in the mutation.
func (m *ApiUserMutation) CbAPIPwd() (r string, exists bool) {
	v := m.cb_api_pwd
	if v == nil {
		return
	}
	return *v, true
}

// OldCbAPIPwd returns the old "cb_api_pwd" field's value of the ApiUser entity.
// If the ApiUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserMutation) OldCbAPIPwd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCbAPIPwd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCbAPIPwd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCbAPIPwd: %w", err)
	}
	return oldValue.CbAPIPwd, nil
}

// ClearCbAPIPwd clears the value of the "cb_api_pwd" field.
func (m *ApiUserMutation) ClearCbAPIPwd() {
	m.cb_api_pwd = nil
	m.clearedFields[apiuser.FieldCbAPIPwd] = struct{}{}
}

// CbAPIPwdCleared returns if the "cb_api_pwd" field was cleared in this mutation.
func (m *ApiUserMutation) CbAPIPwdCleared() bool {
	_, ok := m.clearedFields[apiuser.FieldCbAPIPwd]
	return ok
}

// ResetCbAPIPwd resets all changes to the "cb_api_pwd" field.
func (m *ApiUserMutation) ResetCbAPIPwd() {
	m.cb_api_pwd = nil
	delete(m.clearedFields, apiuser.FieldCbAPIPwd)
}

// SetCbAPIToken sets the "cb_api_token" field.
func (m *ApiUserMutation) SetCbAPIToken(s string) {
	m.cb_api_token = &s
}

// CbAPIToken returns the value of the "cb_api_token" field in the mutation.
func (m *ApiUserMutation) CbAPIToken() (r string, exists bool) {
	v := m.cb_api_token
	if v == nil {
		return
	}
	return *v, true
}

// OldCbAPIToken returns the old "cb_api_token" field's value of the ApiUser entity.
// If the ApiUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserMutation) OldCbAPIToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCbAPIToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCbAPIToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCbAPIToken: %w", err)
	}
	return oldValue.CbAPIToken, nil
}

// ClearCbAPIToken clears the value of the "cb_api_token" field.
func (m *ApiUserMutation) ClearCbAPIToken() {
	m.cb_api_token = nil
	m.clearedFields[apiuser.FieldCbAPIToken] = struct{}{}
}

// CbAPITokenCleared returns if the "cb_api_token" field was cleared in this mutation.
func (m *ApiUserMutation) CbAPITokenCleared() bool {
	_, ok := m.clearedFields[apiuser.FieldCbAPIToken]
	return ok
}

// ResetCbAPIToken resets all changes to the "cb_api_token" field.
func (m *ApiUserMutation) ResetCbAPIToken() {
	m.cb_api_token = nil
	delete(m.clearedFields, apiuser.FieldCbAPIToken)
}

// SetCbAPIEndpoints sets the "cb_api_endpoints" field.
func (m *ApiUserMutation) SetCbAPIEndpoints(value map[string]string) {
	m.cb_api_endpoints = &value
}

// CbAPIEndpoints returns the value of the "cb_api_endpoints" field in the mutation.
func (m *ApiUserMutation) CbAPIEndpoints() (r map[string]string, exists bool) {
	v := m.cb_api_endpoints
	if v == nil {
		return
	}
	return *v, true
}

// OldCbAPIEndpoints returns the old "cb_api_endpoints" field's value of the ApiUser entity.
// If the ApiUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserMutation) OldCbAPIEndpoints(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCbAPIEndpoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCbAPIEndpoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCbAPIEndpoints: %w", err)
	}
	return oldValue.CbAPIEndpoints, nil
}

// ClearCbAPIEndpoints clears the value of the "cb_api_endpoints" field.
func (m *ApiUserMutation) ClearCbAPIEndpoints() {
	m.cb_api_endpoints = nil
	m.clearedFields[apiuser.FieldCbAPIEndpoints] = struct{}{}
}

// CbAPIEndpointsCleared returns if the "cb_api_endpoints" field was cleared in this mutation.
func (m *ApiUserMutation) CbAPIEndpointsCleared() bool {
	_, ok := m.clearedFields[apiuser.FieldCbAPIEndpoints]
	return ok
}

// ResetCbAPIEndpoints resets all changes to the "cb_api_endpoints" field.
func (m *ApiUserMutation) ResetCbAPIEndpoints() {
	m.cb_api_endpoints = nil
	delete(m.clearedFields, apiuser.FieldCbAPIEndpoints)
}

// AddTokenIDs adds the "tokens" edge to the ApiUserToken entity by ids.
func (m *ApiUserMutation) AddTokenIDs(ids ...string) {
	if m.tokens == nil {
		m.tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the ApiUserToken entity.
func (m *ApiUserMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the ApiUserToken entity was cleared.
func (m *ApiUserMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the ApiUserToken entity by IDs.
func (m *ApiUserMutation) RemoveTokenIDs(ids ...string) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the ApiUserToken entity.
func (m *ApiUserMutation) RemovedTokensIDs() (ids []string) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *ApiUserMutation) TokensIDs() (ids []string) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *ApiUserMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// AddAuditLogIDs adds the "audit_logs" edge to the AuditLog entity by ids.
func (m *ApiUserMutation) AddAuditLogIDs(ids ...string) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[string]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the AuditLog entity.
func (m *ApiUserMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the AuditLog entity was cleared.
func (m *ApiUserMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the AuditLog entity by IDs.
func (m *ApiUserMutation) RemoveAuditLogIDs(ids ...string) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the AuditLog entity.
func (m *ApiUserMutation) RemovedAuditLogsIDs() (ids []string) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *ApiUserMutation) AuditLogsIDs() (ids []string) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *ApiUserMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddCreatedEstimateIDs adds the "created_estimates" edge to the Estimate entity by ids.
func (m *ApiUserMutation) AddCreatedEstimateIDs(ids ...string) {
	if m.created_estimates == nil {
		m.created_estimates = make(map[string]struct{})
	}
	for i := range ids {
		m.created_estimates[ids[i]] = struct{}{}
	}
}

// ClearCreatedEstimates clears the "created_estimates" edge to the Estimate entity.
func (m *ApiUserMutation) ClearCreatedEstimates() {
	m.clearedcreated_estimates = true
}

// CreatedEstimatesCleared reports if the "created_estimates" edge to the Estimate entity was cleared.
func (m *ApiUserMutation) CreatedEstimatesCleared() bool {
	return m.clearedcreated_estimates
}

// RemoveCreatedEstimateIDs removes the "created_estimates" edge to the Estimate entity by IDs.
func (m *ApiUserMutation) RemoveCreatedEstimateIDs(ids ...string) {
	if m.removedcreated_estimates == nil {
		m.removedcreated_estimates = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_estimates, ids[i])
		m.removedcreated_estimates[ids[i]] = struct{}{}
	}
}

// RemovedCreatedEstimates returns the removed IDs of the "created_estimates" edge to the Estimate entity.
func (m *ApiUserMutation) RemovedCreatedEstimatesIDs() (ids []string) {
	for id := range m.removedcreated_estimates {
		ids = append(ids, id)
	}
	return
}

// CreatedEstimatesIDs returns the "created_estimates" edge IDs in the mutation.
func (m *ApiUserMutation) CreatedEstimatesIDs() (ids []string) {
	for id := range m.created_estimates {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedEstimates resets all changes to the "created_estimates" edge.
func (m *ApiUserMutation) ResetCreatedEstimates() {
	m.created_estimates = nil
	m.clearedcreated_estimates = false
	m.removedcreated_estimates = nil
}

// AddCreatedJobIDs adds the "created_jobs" edge to the Job entity by ids.
func (m *ApiUserMutation) AddCreatedJobIDs(ids ...string) {
	if m.created_jobs == nil {
		m.created_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.created_jobs[ids[i]] = struct{}{}
	}
}

// ClearCreatedJobs clears the "created_jobs" edge to the Job entity.
func (m *ApiUserMutation) ClearCreatedJobs() {
	m.clearedcreated_jobs = true
}

// CreatedJobsCleared reports if the "created_jobs" edge to the Job entity was cleared.
func (m *ApiUserMutation) CreatedJobsCleared() bool {
	return m.clearedcreated_jobs
}

// RemoveCreatedJobIDs removes the "created_jobs" edge to the Job entity by IDs.
func (m *ApiUserMutation) RemoveCreatedJobIDs(ids ...string) {
	if m.removedcreated_jobs == nil {
		m.removedcreated_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_jobs, ids[i])
		m.removedcreated_jobs[ids[i]] = struct{}{}
	}
}

// RemovedCreatedJobs returns the removed IDs of the "created_jobs" edge to the Job entity.
func (m *ApiUserMutation) RemovedCreatedJobsIDs() (ids []string) {
	for id := range m.removedcreated_jobs {
		ids = append(ids, id)
	}
	return
}

// CreatedJobsIDs returns the "created_jobs" edge IDs in the mutation.
func (m *ApiUserMutation) CreatedJobsIDs() (ids []string) {
	for id := range m.created_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedJobs resets all changes to the "created_jobs" edge.
func (m *ApiUserMutation) ResetCreatedJobs() {
	m.created_jobs = nil
	m.clearedcreated_jobs = false
	m.removedcreated_jobs = nil
}

// AddCreatedPartnerIDs adds the "created_partners" edge to the Partner entity by ids.
func (m *ApiUserMutation) AddCreatedPartnerIDs(ids ...string) {
	if m.created_partners == nil {
		m.created_partners = make(map[string]struct{})
	}
	for i := range ids {
		m.created_partners[ids[i]] = struct{}{}
	}
}

// ClearCreatedPartners clears the "created_partners" edge to the Partner entity.
func (m *ApiUserMutation) ClearCreatedPartners() {
	m.clearedcreated_partners = true
}

// CreatedPartnersCleared reports if the "created_partners" edge to the Partner entity was cleared.
func (m *ApiUserMutation) CreatedPartnersCleared() bool {
	return m.clearedcreated_partners
}

// RemoveCreatedPartnerIDs removes the "created_partners" edge to the Partner entity by IDs.
func (m *ApiUserMutation) RemoveCreatedPartnerIDs(ids ...string) {
	if m.removedcreated_partners == nil {
		m.removedcreated_partners = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_partners, ids[i])
		m.removedcreated_partners[ids[i]] = struct{}{}
	}
}

// RemovedCreatedPartners returns the removed IDs of the "created_partners" edge to the Partner entity.
func (m *ApiUserMutation) RemovedCreatedPartnersIDs() (ids []string) {
	for id := range m.removedcreated_partners {
		ids = append(ids, id)
	}
	return
}

// CreatedPartnersIDs returns the "created_partners" edge IDs in the mutation.
func (m *ApiUserMutation) CreatedPartnersIDs() (ids []string) {
	for id := range m.created_partners {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedPartners resets all changes to the "created_partners" edge.
func (m *ApiUserMutation) ResetCreatedPartners() {
	m.created_partners = nil
	m.clearedcreated_partners = false
	m.removedcreated_partners = nil
}

// AddSurveyProgresIDs adds the "survey_progress" edge to the SurveyProgress entity by ids.
func (m *ApiUserMutation) AddSurveyProgresIDs(ids ...string) {
	if m.survey_progress == nil {
		m.survey_progress = make(map[string]struct{})
	}
	for i := range ids {
		m.survey_progress[ids[i]] = struct{}{}
	}
}

// ClearSurveyProgress clears the "survey_progress" edge to the SurveyProgress entity.
func (m *ApiUserMutation) ClearSurveyProgress() {
	m.clearedsurvey_progress = true
}

// SurveyProgressCleared reports if the "survey_progress" edge to the SurveyProgress entity was cleared.
func (m *ApiUserMutation) SurveyProgressCleared() bool {
	return m.clearedsurvey_progress
}

// RemoveSurveyProgresIDs removes the "survey_progress" edge to the SurveyProgress entity by IDs.
func (m *ApiUserMutation) RemoveSurveyProgresIDs(ids ...string) {
	if m.removedsurvey_progress == nil {
		m.removedsurvey_progress = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.survey_progress, ids[i])
		m.removedsurvey_progress[ids[i]] = struct{}{}
	}
}

// RemovedSurveyProgress returns the removed IDs of the "survey_progress" edge to the SurveyProgress entity.
func (m *ApiUserMutation) RemovedSurveyProgressIDs() (ids []string) {
	for id := range m.removedsurvey_progress {
		ids = append(ids, id)
	}
	return
}

// SurveyProgressIDs returns the "survey_progress" edge IDs in the mutation.
func (m *ApiUserMutation) SurveyProgressIDs() (ids []string) {
	for id := range m.survey_progress {
		ids = append(ids, id)
	}
	return
}

// ResetSurveyProgress resets all changes to the "survey_progress" edge.
func (m *ApiUserMutation) ResetSurveyProgress() {
	m.survey_progress = nil
	m.clearedsurvey_progress = false
	m.removedsurvey_progress = nil
}

// AddEstimateActivityIDs adds the "estimate_activities" edge to the EstimateActivity entity by ids.
func (m *ApiUserMutation) AddEstimateActivityIDs(ids ...string) {
	if m.estimate_activities == nil {
		m.estimate_activities = make(map[string]struct{})
	}
	for i := range ids {
		m.estimate_activities[ids[i]] = struct{}{}
	}
}

// ClearEstimateActivities clears the "estimate_activities" edge to the EstimateActivity entity.
func (m *ApiUserMutation) ClearEstimateActivities() {
	m.clearedestimate_activities = true
}

// EstimateActivitiesCleared reports if the "estimate_activities" edge to the EstimateActivity entity was cleared.
func (m *ApiUserMutation) EstimateActivitiesCleared() bool {
	return m.clearedestimate_activities
}

// RemoveEstimateActivityIDs removes the "estimate_activities" edge to the EstimateActivity entity by IDs.
func (m *ApiUserMutation) RemoveEstimateActivityIDs(ids ...string) {
	if m.removedestimate_activities == nil {
		m.removedestimate_activities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.estimate_activities, ids[i])
		m.removedestimate_activities[ids[i]] = struct{}{}
	}
}

// RemovedEstimateActivities returns the removed IDs of the "estimate_activities" edge to the EstimateActivity entity.
func (m *ApiUserMutation) RemovedEstimateActivitiesIDs() (ids []string) {
	for id := range m.removedestimate_activities {
		ids = append(ids, id)
	}
	return
}

// EstimateActivitiesIDs returns the "estimate_activities" edge IDs in the mutation.
func (m *ApiUserMutation) EstimateActivitiesIDs() (ids []string) {
	for id := range m.estimate_activities {
		ids = append(ids, id)
	}
	return
}

// ResetEstimateActivities resets all changes to the "estimate_activities" edge.
func (m *ApiUserMutation) ResetEstimateActivities() {
	m.estimate_activities = nil
	m.clearedestimate_activities = false
	m.removedestimate_activities = nil
}

// AddUserActivityIDs adds the "user_activities" edge to the UserActivity entity by ids.
func (m *ApiUserMutation) AddUserActivityIDs(ids ...string) {
	if m.user_activities == nil {
		m.user_activities = make(map[string]struct{})
	}
	for i := range ids {
		m.user_activities[ids[i]] = struct{}{}
	}
}

// ClearUserActivities clears the "user_activities" edge to the UserActivity entity.
func (m *ApiUserMutation) ClearUserActivities() {
	m.cleareduser_activities = true
}

// UserActivitiesCleared reports if the "user_activities" edge to the UserActivity entity was cleared.
func (m *ApiUserMutation) UserActivitiesCleared() bool {
	return m.cleareduser_activities
}

// RemoveUserActivityIDs removes the "user_activities" edge to the UserActivity entity by IDs.
func (m *ApiUserMutation) RemoveUserActivityIDs(ids ...string) {
	if m.removeduser_activities == nil {
		m.removeduser_activities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_activities, ids[i])
		m.removeduser_activities[ids[i]] = struct{}{}
	}
}

// RemovedUserActivities returns the removed IDs of the "user_activities" edge to the UserActivity entity.
func (m *ApiUserMutation) RemovedUserActivitiesIDs() (ids []string) {
	for id := range m.removeduser_activities {
		ids = append(ids, id)
	}
	return
}

// UserActivitiesIDs returns the "user_activities" edge IDs in the mutation.
func (m *ApiUserMutation) UserActivitiesIDs() (ids []string) {
	for id := range m.user_activities {
		ids = append(ids, id)
	}
	return
}

// ResetUserActivities resets all changes to the "user_activities" edge.
func (m *ApiUserMutation) ResetUserActivities() {
	m.user_activities = nil
	m.cleareduser_activities = false
	m.removeduser_activities = nil
}

// AddPartnerActivityIDs adds the "partner_activities" edge to the PartnerActivity entity by ids.
func (m *ApiUserMutation) AddPartnerActivityIDs(ids ...string) {
	if m.partner_activities == nil {
		m.partner_activities = make(map[string]struct{})
	}
	for i := range ids {
		m.partner_activities[ids[i]] = struct{}{}
	}
}

// ClearPartnerActivities clears the "partner_activities" edge to the PartnerActivity entity.
func (m *ApiUserMutation) ClearPartnerActivities() {
	m.clearedpartner_activities = true
}

// PartnerActivitiesCleared reports if the "partner_activities" edge to the PartnerActivity entity was cleared.
func (m *ApiUserMutation) PartnerActivitiesCleared() bool {
	return m.clearedpartner_activities
}

// RemovePartnerActivityIDs removes the "partner_activities" edge to the PartnerActivity entity by IDs.
func (m *ApiUserMutation) RemovePartnerActivityIDs(ids ...string) {
	if m.removedpartner_activities == nil {
		m.removedpartner_activities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.partner_activities, ids[i])
		m.removedpartner_activities[ids[i]] = struct{}{}
	}
}

// RemovedPartnerActivities returns the removed IDs of the "partner_activities" edge to the PartnerActivity entity.
func (m *ApiUserMutation) RemovedPartnerActivitiesIDs() (ids []string) {
	for id := range m.removedpartner_activities {
		ids = append(ids, id)
	}
	return
}

// PartnerActivitiesIDs returns the "partner_activities" edge IDs in the mutation.
func (m *ApiUserMutation) PartnerActivitiesIDs() (ids []string) {
	for id := range m.partner_activities {
		ids = append(ids, id)
	}
	return
}

// ResetPartnerActivities resets all changes to the "partner_activities" edge.
func (m *ApiUserMutation) ResetPartnerActivities() {
	m.partner_activities = nil
	m.clearedpartner_activities = false
	m.removedpartner_activities = nil
}

// AddJobActivityIDs adds the "job_activities" edge to the JobActivity entity by ids.
func (m *ApiUserMutation) AddJobActivityIDs(ids ...string) {
	if m.job_activities == nil {
		m.job_activities = make(map[string]struct{})
	}
	for i := range ids {
		m.job_activities[ids[i]] = struct{}{}
	}
}

// ClearJobActivities clears the "job_activities" edge to the JobActivity entity.
func (m *ApiUserMutation) ClearJobActivities() {
	m.clearedjob_activities = true
}

// JobActivitiesCleared reports if the "job_activities" edge to the JobActivity entity was cleared.
func (m *ApiUserMutation) JobActivitiesCleared() bool {
	return m.clearedjob_activities
}

// RemoveJobActivityIDs removes the "job_activities" edge to the JobActivity entity by IDs.
func (m *ApiUserMutation) RemoveJobActivityIDs(ids ...string) {
	if m.removedjob_activities == nil {
		m.removedjob_activities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.job_activities, ids[i])
		m.removedjob_activities[ids[i]] = struct{}{}
	}
}

// RemovedJobActivities returns the removed IDs of the "job_activities" edge to the JobActivity entity.
func (m *ApiUserMutation) RemovedJobActivitiesIDs() (ids []string) {
	for id := range m.removedjob_activities {
		ids = append(ids, id)
	}
	return
}

// JobActivitiesIDs returns the "job_activities" edge IDs in the mutation.
func (m *ApiUserMutation) JobActivitiesIDs() (ids []string) {
	for id := range m.job_activities {
		ids = append(ids, id)
	}
	return
}

// ResetJobActivities resets all changes to the "job_activities" edge.
func (m *ApiUserMutation) ResetJobActivities() {
	m.job_activities = nil
	m.clearedjob_activities = false
	m.removedjob_activities = nil
}

// AddNotificationIDs adds the "notifications" edge to the ChannelMessage entity by ids.
func (m *ApiUserMutation) AddNotificationIDs(ids ...string) {
	if m.notifications == nil {
		m.notifications = make(map[string]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the ChannelMessage entity.
func (m *ApiUserMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the ChannelMessage entity was cleared.
func (m *ApiUserMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the ChannelMessage entity by IDs.
func (m *ApiUserMutation) RemoveNotificationIDs(ids ...string) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the ChannelMessage entity.
func (m *ApiUserMutation) RemovedNotificationsIDs() (ids []string) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *ApiUserMutation) NotificationsIDs() (ids []string) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *ApiUserMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// AddJobProgressHistoryIDs adds the "job_progress_history" edge to the JobProgressHistory entity by ids.
func (m *ApiUserMutation) AddJobProgressHistoryIDs(ids ...string) {
	if m.job_progress_history == nil {
		m.job_progress_history = make(map[string]struct{})
	}
	for i := range ids {
		m.job_progress_history[ids[i]] = struct{}{}
	}
}

// ClearJobProgressHistory clears the "job_progress_history" edge to the JobProgressHistory entity.
func (m *ApiUserMutation) ClearJobProgressHistory() {
	m.clearedjob_progress_history = true
}

// JobProgressHistoryCleared reports if the "job_progress_history" edge to the JobProgressHistory entity was cleared.
func (m *ApiUserMutation) JobProgressHistoryCleared() bool {
	return m.clearedjob_progress_history
}

// RemoveJobProgressHistoryIDs removes the "job_progress_history" edge to the JobProgressHistory entity by IDs.
func (m *ApiUserMutation) RemoveJobProgressHistoryIDs(ids ...string) {
	if m.removedjob_progress_history == nil {
		m.removedjob_progress_history = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.job_progress_history, ids[i])
		m.removedjob_progress_history[ids[i]] = struct{}{}
	}
}

// RemovedJobProgressHistory returns the removed IDs of the "job_progress_history" edge to the JobProgressHistory entity.
func (m *ApiUserMutation) RemovedJobProgressHistoryIDs() (ids []string) {
	for id := range m.removedjob_progress_history {
		ids = append(ids, id)
	}
	return
}

// JobProgressHistoryIDs returns the "job_progress_history" edge IDs in the mutation.
func (m *ApiUserMutation) JobProgressHistoryIDs() (ids []string) {
	for id := range m.job_progress_history {
		ids = append(ids, id)
	}
	return
}

// ResetJobProgressHistory resets all changes to the "job_progress_history" edge.
func (m *ApiUserMutation) ResetJobProgressHistory() {
	m.job_progress_history = nil
	m.clearedjob_progress_history = false
	m.removedjob_progress_history = nil
}

// Where appends a list predicates to the ApiUserMutation builder.
func (m *ApiUserMutation) Where(ps ...predicate.ApiUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiUser).
func (m *ApiUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiUserMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, apiuser.FieldCreatedAt)
	}
	if m.username != nil {
		fields = append(fields, apiuser.FieldUsername)
	}
	if m.pwd_hash != nil {
		fields = append(fields, apiuser.FieldPwdHash)
	}
	if m.active != nil {
		fields = append(fields, apiuser.FieldActive)
	}
	if m.cb_api_url != nil {
		fields = append(fields, apiuser.FieldCbAPIURL)
	}
	if m.cb_api_auth != nil {
		fields = append(fields, apiuser.FieldCbAPIAuth)
	}
	if m.cb_api_user != nil {
		fields = append(fields, apiuser.FieldCbAPIUser)
	}
	if m.cb_api_pwd != nil {
		fields = append(fields, apiuser.FieldCbAPIPwd)
	}
	if m.cb_api_token != nil {
		fields = append(fields, apiuser.FieldCbAPIToken)
	}
	if m.cb_api_endpoints != nil {
		fields = append(fields, apiuser.FieldCbAPIEndpoints)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apiuser.FieldCreatedAt:
		return m.CreatedAt()
	case apiuser.FieldUsername:
		return m.Username()
	case apiuser.FieldPwdHash:
		return m.PwdHash()
	case apiuser.FieldActive:
		return m.Active()
	case apiuser.FieldCbAPIURL:
		return m.CbAPIURL()
	case apiuser.FieldCbAPIAuth:
		return m.CbAPIAuth()
	case apiuser.FieldCbAPIUser:
		return m.CbAPIUser()
	case apiuser.FieldCbAPIPwd:
		return m.CbAPIPwd()
	case apiuser.FieldCbAPIToken:
		return m.CbAPIToken()
	case apiuser.FieldCbAPIEndpoints:
		return m.CbAPIEndpoints()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apiuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apiuser.FieldUsername:
		return m.OldUsername(ctx)
	case apiuser.FieldPwdHash:
		return m.OldPwdHash(ctx)
	case apiuser.FieldActive:
		return m.OldActive(ctx)
	case apiuser.FieldCbAPIURL:
		return m.OldCbAPIURL(ctx)
	case apiuser.FieldCbAPIAuth:
		return m.OldCbAPIAuth(ctx)
	case apiuser.FieldCbAPIUser:
		return m.OldCbAPIUser(ctx)
	case apiuser.FieldCbAPIPwd:
		return m.OldCbAPIPwd(ctx)
	case apiuser.FieldCbAPIToken:
		return m.OldCbAPIToken(ctx)
	case apiuser.FieldCbAPIEndpoints:
		return m.OldCbAPIEndpoints(ctx)
	}
	return nil, fmt.Errorf("unknown ApiUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apiuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apiuser.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case apiuser.FieldPwdHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPwdHash(v)
		return nil
	case apiuser.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case apiuser.FieldCbAPIURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCbAPIURL(v)
		return nil
	case apiuser.FieldCbAPIAuth:
		v, ok := value.(apiuser.CbAPIAuth)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCbAPIAuth(v)
		return nil
	case apiuser.FieldCbAPIUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCbAPIUser(v)
		return nil
	case apiuser.FieldCbAPIPwd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCbAPIPwd(v)
		return nil
	case apiuser.FieldCbAPIToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCbAPIToken(v)
		return nil
	case apiuser.FieldCbAPIEndpoints:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCbAPIEndpoints(v)
		return nil
	}
	return fmt.Errorf("unknown ApiUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apiuser.FieldCbAPIURL) {
		fields = append(fields, apiuser.FieldCbAPIURL)
	}
	if m.FieldCleared(apiuser.FieldCbAPIAuth) {
		fields = append(fields, apiuser.FieldCbAPIAuth)
	}
	if m.FieldCleared(apiuser.FieldCbAPIUser) {
		fields = append(fields, apiuser.FieldCbAPIUser)
	}
	if m.FieldCleared(apiuser.FieldCbAPIPwd) {
		fields = append(fields, apiuser.FieldCbAPIPwd)
	}
	if m.FieldCleared(apiuser.FieldCbAPIToken) {
		fields = append(fields, apiuser.FieldCbAPIToken)
	}
	if m.FieldCleared(apiuser.FieldCbAPIEndpoints) {
		fields = append(fields, apiuser.FieldCbAPIEndpoints)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiUserMutation) ClearField(name string) error {
	switch name {
	case apiuser.FieldCbAPIURL:
		m.ClearCbAPIURL()
		return nil
	case apiuser.FieldCbAPIAuth:
		m.ClearCbAPIAuth()
		return nil
	case apiuser.FieldCbAPIUser:
		m.ClearCbAPIUser()
		return nil
	case apiuser.FieldCbAPIPwd:
		m.ClearCbAPIPwd()
		return nil
	case apiuser.FieldCbAPIToken:
		m.ClearCbAPIToken()
		return nil
	case apiuser.FieldCbAPIEndpoints:
		m.ClearCbAPIEndpoints()
		return nil
	}
	return fmt.Errorf("unknown ApiUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiUserMutation) ResetField(name string) error {
	switch name {
	case apiuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apiuser.FieldUsername:
		m.ResetUsername()
		return nil
	case apiuser.FieldPwdHash:
		m.ResetPwdHash()
		return nil
	case apiuser.FieldActive:
		m.ResetActive()
		return nil
	case apiuser.FieldCbAPIURL:
		m.ResetCbAPIURL()
		return nil
	case apiuser.FieldCbAPIAuth:
		m.ResetCbAPIAuth()
		return nil
	case apiuser.FieldCbAPIUser:
		m.ResetCbAPIUser()
		return nil
	case apiuser.FieldCbAPIPwd:
		m.ResetCbAPIPwd()
		return nil
	case apiuser.FieldCbAPIToken:
		m.ResetCbAPIToken()
		return nil
	case apiuser.FieldCbAPIEndpoints:
		m.ResetCbAPIEndpoints()
		return nil
	}
	return fmt.Errorf("unknown ApiUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.tokens != nil {
		edges = append(edges, apiuser.EdgeTokens)
	}
	if m.audit_logs != nil {
		edges = append(edges, apiuser.EdgeAuditLogs)
	}
	if m.created_estimates != nil {
		edges = append(edges, apiuser.EdgeCreatedEstimates)
	}
	if m.created_jobs != nil {
		edges = append(edges, apiuser.EdgeCreatedJobs)
	}
	if m.created_partners != nil {
		edges = append(edges, apiuser.EdgeCreatedPartners)
	}
	if m.survey_progress != nil {
		edges = append(edges, apiuser.EdgeSurveyProgress)
	}
	if m.estimate_activities != nil {
		edges = append(edges, apiuser.EdgeEstimateActivities)
	}
	if m.user_activities != nil {
		edges = append(edges, apiuser.EdgeUserActivities)
	}
	if m.partner_activities != nil {
		edges = append(edges, apiuser.EdgePartnerActivities)
	}
	if m.job_activities != nil {
		edges = append(edges, apiuser.EdgeJobActivities)
	}
	if m.notifications != nil {
		edges = append(edges, apiuser.EdgeNotifications)
	}
	if m.job_progress_history != nil {
		edges = append(edges, apiuser.EdgeJobProgressHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apiuser.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeCreatedEstimates:
		ids := make([]ent.Value, 0, len(m.created_estimates))
		for id := range m.created_estimates {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeCreatedJobs:
		ids := make([]ent.Value, 0, len(m.created_jobs))
		for id := range m.created_jobs {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeCreatedPartners:
		ids := make([]ent.Value, 0, len(m.created_partners))
		for id := range m.created_partners {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeSurveyProgress:
		ids := make([]ent.Value, 0, len(m.survey_progress))
		for id := range m.survey_progress {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeEstimateActivities:
		ids := make([]ent.Value, 0, len(m.estimate_activities))
		for id := range m.estimate_activities {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeUserActivities:
		ids := make([]ent.Value, 0, len(m.user_activities))
		for id := range m.user_activities {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgePartnerActivities:
		ids := make([]ent.Value, 0, len(m.partner_activities))
		for id := range m.partner_activities {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeJobActivities:
		ids := make([]ent.Value, 0, len(m.job_activities))
		for id := range m.job_activities {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeJobProgressHistory:
		ids := make([]ent.Value, 0, len(m.job_progress_history))
		for id := range m.job_progress_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedtokens != nil {
		edges = append(edges, apiuser.EdgeTokens)
	}
	if m.removedaudit_logs != nil {
		edges = append(edges, apiuser.EdgeAuditLogs)
	}
	if m.removedcreated_estimates != nil {
		edges = append(edges, apiuser.EdgeCreatedEstimates)
	}
	if m.removedcreated_jobs != nil {
		edges = append(edges, apiuser.EdgeCreatedJobs)
	}
	if m.removedcreated_partners != nil {
		edges = append(edges, apiuser.EdgeCreatedPartners)
	}
	if m.removedsurvey_progress != nil {
		edges = append(edges, apiuser.EdgeSurveyProgress)
	}
	if m.removedestimate_activities != nil {
		edges = append(edges, apiuser.EdgeEstimateActivities)
	}
	if m.removeduser_activities != nil {
		edges = append(edges, apiuser.EdgeUserActivities)
	}
	if m.removedpartner_activities != nil {
		edges = append(edges, apiuser.EdgePartnerActivities)
	}
	if m.removedjob_activities != nil {
		edges = append(edges, apiuser.EdgeJobActivities)
	}
	if m.removednotifications != nil {
		edges = append(edges, apiuser.EdgeNotifications)
	}
	if m.removedjob_progress_history != nil {
		edges = append(edges, apiuser.EdgeJobProgressHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case apiuser.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeCreatedEstimates:
		ids := make([]ent.Value, 0, len(m.removedcreated_estimates))
		for id := range m.removedcreated_estimates {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeCreatedJobs:
		ids := make([]ent.Value, 0, len(m.removedcreated_jobs))
		for id := range m.removedcreated_jobs {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeCreatedPartners:
		ids := make([]ent.Value, 0, len(m.removedcreated_partners))
		for id := range m.removedcreated_partners {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeSurveyProgress:
		ids := make([]ent.Value, 0, len(m.removedsurvey_progress))
		for id := range m.removedsurvey_progress {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeEstimateActivities:
		ids := make([]ent.Value, 0, len(m.removedestimate_activities))
		for id := range m.removedestimate_activities {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeUserActivities:
		ids := make([]ent.Value, 0, len(m.removeduser_activities))
		for id := range m.removeduser_activities {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgePartnerActivities:
		ids := make([]ent.Value, 0, len(m.removedpartner_activities))
		for id := range m.removedpartner_activities {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeJobActivities:
		ids := make([]ent.Value, 0, len(m.removedjob_activities))
		for id := range m.removedjob_activities {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case apiuser.EdgeJobProgressHistory:
		ids := make([]ent.Value, 0, len(m.removedjob_progress_history))
		for id := range m.removedjob_progress_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.clearedtokens {
		edges = append(edges, apiuser.EdgeTokens)
	}
	if m.clearedaudit_logs {
		edges = append(edges, apiuser.EdgeAuditLogs)
	}
	if m.clearedcreated_estimates {
		edges = append(edges, apiuser.EdgeCreatedEstimates)
	}
	if m.clearedcreated_jobs {
		edges = append(edges, apiuser.EdgeCreatedJobs)
	}
	if m.clearedcreated_partners {
		edges = append(edges, apiuser.EdgeCreatedPartners)
	}
	if m.clearedsurvey_progress {
		edges = append(edges, apiuser.EdgeSurveyProgress)
	}
	if m.clearedestimate_activities {
		edges = append(edges, apiuser.EdgeEstimateActivities)
	}
	if m.cleareduser_activities {
		edges = append(edges, apiuser.EdgeUserActivities)
	}
	if m.clearedpartner_activities {
		edges = append(edges, apiuser.EdgePartnerActivities)
	}
	if m.clearedjob_activities {
		edges = append(edges, apiuser.EdgeJobActivities)
	}
	if m.clearednotifications {
		edges = append(edges, apiuser.EdgeNotifications)
	}
	if m.clearedjob_progress_history {
		edges = append(edges, apiuser.EdgeJobProgressHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiUserMutation) EdgeCleared(name string) bool {
	switch name {
	case apiuser.EdgeTokens:
		return m.clearedtokens
	case apiuser.EdgeAuditLogs:
		return m.clearedaudit_logs
	case apiuser.EdgeCreatedEstimates:
		return m.clearedcreated_estimates
	case apiuser.EdgeCreatedJobs:
		return m.clearedcreated_jobs
	case apiuser.EdgeCreatedPartners:
		return m.clearedcreated_partners
	case apiuser.EdgeSurveyProgress:
		return m.clearedsurvey_progress
	case apiuser.EdgeEstimateActivities:
		return m.clearedestimate_activities
	case apiuser.EdgeUserActivities:
		return m.cleareduser_activities
	case apiuser.EdgePartnerActivities:
		return m.clearedpartner_activities
	case apiuser.EdgeJobActivities:
		return m.clearedjob_activities
	case apiuser.EdgeNotifications:
		return m.clearednotifications
	case apiuser.EdgeJobProgressHistory:
		return m.clearedjob_progress_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiUserMutation) ResetEdge(name string) error {
	switch name {
	case apiuser.EdgeTokens:
		m.ResetTokens()
		return nil
	case apiuser.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case apiuser.EdgeCreatedEstimates:
		m.ResetCreatedEstimates()
		return nil
	case apiuser.EdgeCreatedJobs:
		m.ResetCreatedJobs()
		return nil
	case apiuser.EdgeCreatedPartners:
		m.ResetCreatedPartners()
		return nil
	case apiuser.EdgeSurveyProgress:
		m.ResetSurveyProgress()
		return nil
	case apiuser.EdgeEstimateActivities:
		m.ResetEstimateActivities()
		return nil
	case apiuser.EdgeUserActivities:
		m.ResetUserActivities()
		return nil
	case apiuser.EdgePartnerActivities:
		m.ResetPartnerActivities()
		return nil
	case apiuser.EdgeJobActivities:
		m.ResetJobActivities()
		return nil
	case apiuser.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case apiuser.EdgeJobProgressHistory:
		m.ResetJobProgressHistory()
		return nil
	}
	return fmt.Errorf("unknown ApiUser edge %s", name)
}

// ApiUserTokenMutation represents an operation that mutates the ApiUserToken nodes in the graph.
type ApiUserTokenMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	token_type       *string
	token_id         *string
	refresh_token_id *string
	clearedFields    map[string]struct{}
	api_user         *string
	clearedapi_user  bool
	done             bool
	oldValue         func(context.Context) (*ApiUserToken, error)
	predicates       []predicate.ApiUserToken
}

var _ ent.Mutation = (*ApiUserTokenMutation)(nil)

// apiusertokenOption allows management of the mutation configuration using functional options.
type apiusertokenOption func(*ApiUserTokenMutation)

// newApiUserTokenMutation creates new mutation for the ApiUserToken entity.
func newApiUserTokenMutation(c config, op Op, opts ...apiusertokenOption) *ApiUserTokenMutation {
	m := &ApiUserTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeApiUserToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApiUserTokenID sets the ID field of the mutation.
func withApiUserTokenID(id string) apiusertokenOption {
	return func(m *ApiUserTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *ApiUserToken
		)
		m.oldValue = func(ctx context.Context) (*ApiUserToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApiUserToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApiUserToken sets the old ApiUserToken of the mutation.
func withApiUserToken(node *ApiUserToken) apiusertokenOption {
	return func(m *ApiUserTokenMutation) {
		m.oldValue = func(context.Context) (*ApiUserToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApiUserTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApiUserTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApiUserToken entities.
func (m *ApiUserTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApiUserTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApiUserTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApiUserToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApiUserTokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApiUserTokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApiUserToken entity.
// If the ApiUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserTokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApiUserTokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTokenType sets the "token_type" field.
func (m *ApiUserTokenMutation) SetTokenType(s string) {
	m.token_type = &s
}

// TokenType returns the value of the "token_type" field in the mutation.
func (m *ApiUserTokenMutation) TokenType() (r string, exists bool) {
	v := m.token_type
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenType returns the old "token_type" field's value of the ApiUserToken entity.
// If the ApiUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserTokenMutation) OldTokenType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenType: %w", err)
	}
	return oldValue.TokenType, nil
}

// ResetTokenType resets all changes to the "token_type" field.
func (m *ApiUserTokenMutation) ResetTokenType() {
	m.token_type = nil
}

// SetTokenID sets the "token_id" field.
func (m *ApiUserTokenMutation) SetTokenID(s string) {
	m.token_id = &s
}

// TokenID returns the value of the "token_id" field in the mutation.
func (m *ApiUserTokenMutation) TokenID() (r string, exists bool) {
	v := m.token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTokenID returns the old "token_id" field's value of the ApiUserToken entity.
// If the ApiUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserTokenMutation) OldTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTokenID: %w", err)
	}
	return oldValue.TokenID, nil
}

// ResetTokenID resets all changes to the "token_id" field.
func (m *ApiUserTokenMutation) ResetTokenID() {
	m.token_id = nil
}

// SetRefreshTokenID sets the "refresh_token_id" field.
func (m *ApiUserTokenMutation) SetRefreshTokenID(s string) {
	m.refresh_token_id = &s
}

// RefreshTokenID returns the value of the "refresh_token_id" field in the mutation.
func (m *ApiUserTokenMutation) RefreshTokenID() (r string, exists bool) {
	v := m.refresh_token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenID returns the old "refresh_token_id" field's value of the ApiUserToken entity.
// If the ApiUserToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApiUserTokenMutation) OldRefreshTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenID: %w", err)
	}
	return oldValue.RefreshTokenID, nil
}

// ResetRefreshTokenID resets all changes to the "refresh_token_id" field.
func (m *ApiUserTokenMutation) ResetRefreshTokenID() {
	m.refresh_token_id = nil
}

// SetAPIUserID sets the "api_user" edge to the ApiUser entity by id.
func (m *ApiUserTokenMutation) SetAPIUserID(id string) {
	m.api_user = &id
}

// ClearAPIUser clears the "api_user" edge to the ApiUser entity.
func (m *ApiUserTokenMutation) ClearAPIUser() {
	m.clearedapi_user = true
}

// APIUserCleared reports if the "api_user" edge to the ApiUser entity was cleared.
func (m *ApiUserTokenMutation) APIUserCleared() bool {
	return m.clearedapi_user
}

// APIUserID returns the "api_user" edge ID in the mutation.
func (m *ApiUserTokenMutation) APIUserID() (id string, exists bool) {
	if m.api_user != nil {
		return *m.api_user, true
	}
	return
}

// APIUserIDs returns the "api_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APIUserID instead. It exists only for internal usage by the builders.
func (m *ApiUserTokenMutation) APIUserIDs() (ids []string) {
	if id := m.api_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPIUser resets all changes to the "api_user" edge.
func (m *ApiUserTokenMutation) ResetAPIUser() {
	m.api_user = nil
	m.clearedapi_user = false
}

// Where appends a list predicates to the ApiUserTokenMutation builder.
func (m *ApiUserTokenMutation) Where(ps ...predicate.ApiUserToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApiUserTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApiUserTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApiUserToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApiUserTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApiUserTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApiUserToken).
func (m *ApiUserTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApiUserTokenMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, apiusertoken.FieldCreatedAt)
	}
	if m.token_type != nil {
		fields = append(fields, apiusertoken.FieldTokenType)
	}
	if m.token_id != nil {
		fields = append(fields, apiusertoken.FieldTokenID)
	}
	if m.refresh_token_id != nil {
		fields = append(fields, apiusertoken.FieldRefreshTokenID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApiUserTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apiusertoken.FieldCreatedAt:
		return m.CreatedAt()
	case apiusertoken.FieldTokenType:
		return m.TokenType()
	case apiusertoken.FieldTokenID:
		return m.TokenID()
	case apiusertoken.FieldRefreshTokenID:
		return m.RefreshTokenID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApiUserTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apiusertoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apiusertoken.FieldTokenType:
		return m.OldTokenType(ctx)
	case apiusertoken.FieldTokenID:
		return m.OldTokenID(ctx)
	case apiusertoken.FieldRefreshTokenID:
		return m.OldRefreshTokenID(ctx)
	}
	return nil, fmt.Errorf("unknown ApiUserToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiUserTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apiusertoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apiusertoken.FieldTokenType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenType(v)
		return nil
	case apiusertoken.FieldTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTokenID(v)
		return nil
	case apiusertoken.FieldRefreshTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenID(v)
		return nil
	}
	return fmt.Errorf("unknown ApiUserToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApiUserTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApiUserTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApiUserTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApiUserToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApiUserTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApiUserTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApiUserTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApiUserToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApiUserTokenMutation) ResetField(name string) error {
	switch name {
	case apiusertoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apiusertoken.FieldTokenType:
		m.ResetTokenType()
		return nil
	case apiusertoken.FieldTokenID:
		m.ResetTokenID()
		return nil
	case apiusertoken.FieldRefreshTokenID:
		m.ResetRefreshTokenID()
		return nil
	}
	return fmt.Errorf("unknown ApiUserToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApiUserTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.api_user != nil {
		edges = append(edges, apiusertoken.EdgeAPIUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApiUserTokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apiusertoken.EdgeAPIUser:
		if id := m.api_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApiUserTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApiUserTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApiUserTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedapi_user {
		edges = append(edges, apiusertoken.EdgeAPIUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApiUserTokenMutation) EdgeCleared(name string) bool {
	switch name {
	case apiusertoken.EdgeAPIUser:
		return m.clearedapi_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApiUserTokenMutation) ClearEdge(name string) error {
	switch name {
	case apiusertoken.EdgeAPIUser:
		m.ClearAPIUser()
		return nil
	}
	return fmt.Errorf("unknown ApiUserToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApiUserTokenMutation) ResetEdge(name string) error {
	switch name {
	case apiusertoken.EdgeAPIUser:
		m.ResetAPIUser()
		return nil
	}
	return fmt.Errorf("unknown ApiUserToken edge %s", name)
}

// AuditLogMutation represents an operation that mutates the AuditLog nodes in the graph.
type AuditLogMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	action          *string
	description     *string
	ip              *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	api_user        *string
	clearedapi_user bool
	done            bool
	oldValue        func(context.Context) (*AuditLog, error)
	predicates      []predicate.AuditLog
}

var _ ent.Mutation = (*AuditLogMutation)(nil)

// auditlogOption allows management of the mutation configuration using functional options.
type auditlogOption func(*AuditLogMutation)

// newAuditLogMutation creates new mutation for the AuditLog entity.
func newAuditLogMutation(c config, op Op, opts ...auditlogOption) *AuditLogMutation {
	m := &AuditLogMutation{
		config:        c,
		op:            op,
		typ:           TypeAuditLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuditLogID sets the ID field of the mutation.
func withAuditLogID(id string) auditlogOption {
	return func(m *AuditLogMutation) {
		var (
			err   error
			once  sync.Once
			value *AuditLog
		)
		m.oldValue = func(ctx context.Context) (*AuditLog, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuditLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuditLog sets the old AuditLog of the mutation.
func withAuditLog(node *AuditLog) auditlogOption {
	return func(m *AuditLogMutation) {
		m.oldValue = func(context.Context) (*AuditLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuditLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuditLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuditLog entities.
func (m *AuditLogMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuditLogMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuditLogMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuditLog.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuditLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuditLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuditLogMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAction sets the "action" field.
func (m *AuditLogMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *AuditLogMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *AuditLogMutation) ResetAction() {
	m.action = nil
}

// SetDescription sets the "description" field.
func (m *AuditLogMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AuditLogMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *AuditLogMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[auditlog.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *AuditLogMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *AuditLogMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, auditlog.FieldDescription)
}

// SetIP sets the "ip" field.
func (m *AuditLogMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *AuditLogMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the AuditLog entity.
// If the AuditLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuditLogMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *AuditLogMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[auditlog.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *AuditLogMutation) IPCleared() bool {
	_, ok := m.clearedFields[auditlog.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *AuditLogMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, auditlog.FieldIP)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *AuditLogMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *AuditLogMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *AuditLogMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *AuditLogMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *AuditLogMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *AuditLogMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetAPIUserID sets the "api_user" edge to the ApiUser entity by id.
func (m *AuditLogMutation) SetAPIUserID(id string) {
	m.api_user = &id
}

// ClearAPIUser clears the "api_user" edge to the ApiUser entity.
func (m *AuditLogMutation) ClearAPIUser() {
	m.clearedapi_user = true
}

// APIUserCleared reports if the "api_user" edge to the ApiUser entity was cleared.
func (m *AuditLogMutation) APIUserCleared() bool {
	return m.clearedapi_user
}

// APIUserID returns the "api_user" edge ID in the mutation.
func (m *AuditLogMutation) APIUserID() (id string, exists bool) {
	if m.api_user != nil {
		return *m.api_user, true
	}
	return
}

// APIUserIDs returns the "api_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// APIUserID instead. It exists only for internal usage by the builders.
func (m *AuditLogMutation) APIUserIDs() (ids []string) {
	if id := m.api_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAPIUser resets all changes to the "api_user" edge.
func (m *AuditLogMutation) ResetAPIUser() {
	m.api_user = nil
	m.clearedapi_user = false
}

// Where appends a list predicates to the AuditLogMutation builder.
func (m *AuditLogMutation) Where(ps ...predicate.AuditLog) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuditLogMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuditLogMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuditLog, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuditLogMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuditLogMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuditLog).
func (m *AuditLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuditLogMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, auditlog.FieldCreatedAt)
	}
	if m.action != nil {
		fields = append(fields, auditlog.FieldAction)
	}
	if m.description != nil {
		fields = append(fields, auditlog.FieldDescription)
	}
	if m.ip != nil {
		fields = append(fields, auditlog.FieldIP)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuditLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.CreatedAt()
	case auditlog.FieldAction:
		return m.Action()
	case auditlog.FieldDescription:
		return m.Description()
	case auditlog.FieldIP:
		return m.IP()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuditLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case auditlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case auditlog.FieldAction:
		return m.OldAction(ctx)
	case auditlog.FieldDescription:
		return m.OldDescription(ctx)
	case auditlog.FieldIP:
		return m.OldIP(ctx)
	}
	return nil, fmt.Errorf("unknown AuditLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case auditlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case auditlog.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case auditlog.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case auditlog.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuditLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuditLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuditLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuditLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuditLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(auditlog.FieldDescription) {
		fields = append(fields, auditlog.FieldDescription)
	}
	if m.FieldCleared(auditlog.FieldIP) {
		fields = append(fields, auditlog.FieldIP)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuditLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuditLogMutation) ClearField(name string) error {
	switch name {
	case auditlog.FieldDescription:
		m.ClearDescription()
		return nil
	case auditlog.FieldIP:
		m.ClearIP()
		return nil
	}
	return fmt.Errorf("unknown AuditLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuditLogMutation) ResetField(name string) error {
	switch name {
	case auditlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case auditlog.FieldAction:
		m.ResetAction()
		return nil
	case auditlog.FieldDescription:
		m.ResetDescription()
		return nil
	case auditlog.FieldIP:
		m.ResetIP()
		return nil
	}
	return fmt.Errorf("unknown AuditLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuditLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, auditlog.EdgeUser)
	}
	if m.api_user != nil {
		edges = append(edges, auditlog.EdgeAPIUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuditLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case auditlog.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case auditlog.EdgeAPIUser:
		if id := m.api_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuditLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuditLogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuditLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, auditlog.EdgeUser)
	}
	if m.clearedapi_user {
		edges = append(edges, auditlog.EdgeAPIUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuditLogMutation) EdgeCleared(name string) bool {
	switch name {
	case auditlog.EdgeUser:
		return m.cleareduser
	case auditlog.EdgeAPIUser:
		return m.clearedapi_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuditLogMutation) ClearEdge(name string) error {
	switch name {
	case auditlog.EdgeUser:
		m.ClearUser()
		return nil
	case auditlog.EdgeAPIUser:
		m.ClearAPIUser()
		return nil
	}
	return fmt.Errorf("unknown AuditLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuditLogMutation) ResetEdge(name string) error {
	switch name {
	case auditlog.EdgeUser:
		m.ResetUser()
		return nil
	case auditlog.EdgeAPIUser:
		m.ResetAPIUser()
		return nil
	}
	return fmt.Errorf("unknown AuditLog edge %s", name)
}

// ChannelMutation represents an operation that mutates the Channel nodes in the graph.
type ChannelMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	name                 *enum.Channel
	topic                *enum.Topic
	ref_id               *string
	clearedFields        map[string]struct{}
	subscriptions        map[string]struct{}
	removedsubscriptions map[string]struct{}
	clearedsubscriptions bool
	messages             map[string]struct{}
	removedmessages      map[string]struct{}
	clearedmessages      bool
	done                 bool
	oldValue             func(context.Context) (*Channel, error)
	predicates           []predicate.Channel
}

var _ ent.Mutation = (*ChannelMutation)(nil)

// channelOption allows management of the mutation configuration using functional options.
type channelOption func(*ChannelMutation)

// newChannelMutation creates new mutation for the Channel entity.
func newChannelMutation(c config, op Op, opts ...channelOption) *ChannelMutation {
	m := &ChannelMutation{
		config:        c,
		op:            op,
		typ:           TypeChannel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelID sets the ID field of the mutation.
func withChannelID(id string) channelOption {
	return func(m *ChannelMutation) {
		var (
			err   error
			once  sync.Once
			value *Channel
		)
		m.oldValue = func(ctx context.Context) (*Channel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Channel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannel sets the old Channel of the mutation.
func withChannel(node *Channel) channelOption {
	return func(m *ChannelMutation) {
		m.oldValue = func(context.Context) (*Channel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Channel entities.
func (m *ChannelMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Channel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ChannelMutation) SetName(e enum.Channel) {
	m.name = &e
}

// Name returns the value of the "name" field in the mutation.
func (m *ChannelMutation) Name() (r enum.Channel, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldName(ctx context.Context) (v enum.Channel, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChannelMutation) ResetName() {
	m.name = nil
}

// SetTopic sets the "topic" field.
func (m *ChannelMutation) SetTopic(e enum.Topic) {
	m.topic = &e
}

// Topic returns the value of the "topic" field in the mutation.
func (m *ChannelMutation) Topic() (r enum.Topic, exists bool) {
	v := m.topic
	if v == nil {
		return
	}
	return *v, true
}

// OldTopic returns the old "topic" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldTopic(ctx context.Context) (v enum.Topic, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopic: %w", err)
	}
	return oldValue.Topic, nil
}

// ResetTopic resets all changes to the "topic" field.
func (m *ChannelMutation) ResetTopic() {
	m.topic = nil
}

// SetRefID sets the "ref_id" field.
func (m *ChannelMutation) SetRefID(s string) {
	m.ref_id = &s
}

// RefID returns the value of the "ref_id" field in the mutation.
func (m *ChannelMutation) RefID() (r string, exists bool) {
	v := m.ref_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRefID returns the old "ref_id" field's value of the Channel entity.
// If the Channel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMutation) OldRefID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefID: %w", err)
	}
	return oldValue.RefID, nil
}

// ClearRefID clears the value of the "ref_id" field.
func (m *ChannelMutation) ClearRefID() {
	m.ref_id = nil
	m.clearedFields[channel.FieldRefID] = struct{}{}
}

// RefIDCleared returns if the "ref_id" field was cleared in this mutation.
func (m *ChannelMutation) RefIDCleared() bool {
	_, ok := m.clearedFields[channel.FieldRefID]
	return ok
}

// ResetRefID resets all changes to the "ref_id" field.
func (m *ChannelMutation) ResetRefID() {
	m.ref_id = nil
	delete(m.clearedFields, channel.FieldRefID)
}

// AddSubscriptionIDs adds the "subscriptions" edge to the ChannelSub entity by ids.
func (m *ChannelMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[string]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the ChannelSub entity.
func (m *ChannelMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the ChannelSub entity was cleared.
func (m *ChannelMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the ChannelSub entity by IDs.
func (m *ChannelMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the ChannelSub entity.
func (m *ChannelMutation) RemovedSubscriptionsIDs() (ids []string) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *ChannelMutation) SubscriptionsIDs() (ids []string) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *ChannelMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddMessageIDs adds the "messages" edge to the ChannelMessage entity by ids.
func (m *ChannelMutation) AddMessageIDs(ids ...string) {
	if m.messages == nil {
		m.messages = make(map[string]struct{})
	}
	for i := range ids {
		m.messages[ids[i]] = struct{}{}
	}
}

// ClearMessages clears the "messages" edge to the ChannelMessage entity.
func (m *ChannelMutation) ClearMessages() {
	m.clearedmessages = true
}

// MessagesCleared reports if the "messages" edge to the ChannelMessage entity was cleared.
func (m *ChannelMutation) MessagesCleared() bool {
	return m.clearedmessages
}

// RemoveMessageIDs removes the "messages" edge to the ChannelMessage entity by IDs.
func (m *ChannelMutation) RemoveMessageIDs(ids ...string) {
	if m.removedmessages == nil {
		m.removedmessages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.messages, ids[i])
		m.removedmessages[ids[i]] = struct{}{}
	}
}

// RemovedMessages returns the removed IDs of the "messages" edge to the ChannelMessage entity.
func (m *ChannelMutation) RemovedMessagesIDs() (ids []string) {
	for id := range m.removedmessages {
		ids = append(ids, id)
	}
	return
}

// MessagesIDs returns the "messages" edge IDs in the mutation.
func (m *ChannelMutation) MessagesIDs() (ids []string) {
	for id := range m.messages {
		ids = append(ids, id)
	}
	return
}

// ResetMessages resets all changes to the "messages" edge.
func (m *ChannelMutation) ResetMessages() {
	m.messages = nil
	m.clearedmessages = false
	m.removedmessages = nil
}

// Where appends a list predicates to the ChannelMutation builder.
func (m *ChannelMutation) Where(ps ...predicate.Channel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Channel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Channel).
func (m *ChannelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, channel.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channel.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, channel.FieldName)
	}
	if m.topic != nil {
		fields = append(fields, channel.FieldTopic)
	}
	if m.ref_id != nil {
		fields = append(fields, channel.FieldRefID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channel.FieldCreatedAt:
		return m.CreatedAt()
	case channel.FieldUpdatedAt:
		return m.UpdatedAt()
	case channel.FieldName:
		return m.Name()
	case channel.FieldTopic:
		return m.Topic()
	case channel.FieldRefID:
		return m.RefID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channel.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channel.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channel.FieldName:
		return m.OldName(ctx)
	case channel.FieldTopic:
		return m.OldTopic(ctx)
	case channel.FieldRefID:
		return m.OldRefID(ctx)
	}
	return nil, fmt.Errorf("unknown Channel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channel.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channel.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channel.FieldName:
		v, ok := value.(enum.Channel)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case channel.FieldTopic:
		v, ok := value.(enum.Topic)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopic(v)
		return nil
	case channel.FieldRefID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefID(v)
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channel.FieldRefID) {
		fields = append(fields, channel.FieldRefID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMutation) ClearField(name string) error {
	switch name {
	case channel.FieldRefID:
		m.ClearRefID()
		return nil
	}
	return fmt.Errorf("unknown Channel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMutation) ResetField(name string) error {
	switch name {
	case channel.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channel.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channel.FieldName:
		m.ResetName()
		return nil
	case channel.FieldTopic:
		m.ResetTopic()
		return nil
	case channel.FieldRefID:
		m.ResetRefID()
		return nil
	}
	return fmt.Errorf("unknown Channel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.subscriptions != nil {
		edges = append(edges, channel.EdgeSubscriptions)
	}
	if m.messages != nil {
		edges = append(edges, channel.EdgeMessages)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.messages))
		for id := range m.messages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsubscriptions != nil {
		edges = append(edges, channel.EdgeSubscriptions)
	}
	if m.removedmessages != nil {
		edges = append(edges, channel.EdgeMessages)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channel.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case channel.EdgeMessages:
		ids := make([]ent.Value, 0, len(m.removedmessages))
		for id := range m.removedmessages {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsubscriptions {
		edges = append(edges, channel.EdgeSubscriptions)
	}
	if m.clearedmessages {
		edges = append(edges, channel.EdgeMessages)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMutation) EdgeCleared(name string) bool {
	switch name {
	case channel.EdgeSubscriptions:
		return m.clearedsubscriptions
	case channel.EdgeMessages:
		return m.clearedmessages
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Channel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMutation) ResetEdge(name string) error {
	switch name {
	case channel.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case channel.EdgeMessages:
		m.ResetMessages()
		return nil
	}
	return fmt.Errorf("unknown Channel edge %s", name)
}

// ChannelMessageMutation represents an operation that mutates the ChannelMessage nodes in the graph.
type ChannelMessageMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	title                *string
	message              *string
	from_name            *string
	to_name              *string
	private              *bool
	unread               *bool
	clearedFields        map[string]struct{}
	reads                map[string]struct{}
	removedreads         map[string]struct{}
	clearedreads         bool
	channel              *string
	clearedchannel       bool
	from                 *string
	clearedfrom          bool
	from_api_user        *string
	clearedfrom_api_user bool
	to                   *string
	clearedto            bool
	done                 bool
	oldValue             func(context.Context) (*ChannelMessage, error)
	predicates           []predicate.ChannelMessage
}

var _ ent.Mutation = (*ChannelMessageMutation)(nil)

// channelmessageOption allows management of the mutation configuration using functional options.
type channelmessageOption func(*ChannelMessageMutation)

// newChannelMessageMutation creates new mutation for the ChannelMessage entity.
func newChannelMessageMutation(c config, op Op, opts ...channelmessageOption) *ChannelMessageMutation {
	m := &ChannelMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelMessageID sets the ID field of the mutation.
func withChannelMessageID(id string) channelmessageOption {
	return func(m *ChannelMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelMessage
		)
		m.oldValue = func(ctx context.Context) (*ChannelMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelMessage sets the old ChannelMessage of the mutation.
func withChannelMessage(node *ChannelMessage) channelmessageOption {
	return func(m *ChannelMessageMutation) {
		m.oldValue = func(context.Context) (*ChannelMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChannelMessage entities.
func (m *ChannelMessageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMessageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMessageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelMessage entity.
// If the ChannelMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelMessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelMessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelMessage entity.
// If the ChannelMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelMessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTitle sets the "title" field.
func (m *ChannelMessageMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ChannelMessageMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ChannelMessage entity.
// If the ChannelMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMessageMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *ChannelMessageMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[channelmessage.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *ChannelMessageMutation) TitleCleared() bool {
	_, ok := m.clearedFields[channelmessage.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *ChannelMessageMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, channelmessage.FieldTitle)
}

// SetMessage sets the "message" field.
func (m *ChannelMessageMutation) SetMessage(s string) {
	m.message = &s
}

// Message returns the value of the "message" field in the mutation.
func (m *ChannelMessageMutation) Message() (r string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the ChannelMessage entity.
// If the ChannelMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMessageMutation) OldMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *ChannelMessageMutation) ResetMessage() {
	m.message = nil
}

// SetFromName sets the "from_name" field.
func (m *ChannelMessageMutation) SetFromName(s string) {
	m.from_name = &s
}

// FromName returns the value of the "from_name" field in the mutation.
func (m *ChannelMessageMutation) FromName() (r string, exists bool) {
	v := m.from_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFromName returns the old "from_name" field's value of the ChannelMessage entity.
// If the ChannelMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMessageMutation) OldFromName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromName: %w", err)
	}
	return oldValue.FromName, nil
}

// ResetFromName resets all changes to the "from_name" field.
func (m *ChannelMessageMutation) ResetFromName() {
	m.from_name = nil
}

// SetToName sets the "to_name" field.
func (m *ChannelMessageMutation) SetToName(s string) {
	m.to_name = &s
}

// ToName returns the value of the "to_name" field in the mutation.
func (m *ChannelMessageMutation) ToName() (r string, exists bool) {
	v := m.to_name
	if v == nil {
		return
	}
	return *v, true
}

// OldToName returns the old "to_name" field's value of the ChannelMessage entity.
// If the ChannelMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMessageMutation) OldToName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToName: %w", err)
	}
	return oldValue.ToName, nil
}

// ClearToName clears the value of the "to_name" field.
func (m *ChannelMessageMutation) ClearToName() {
	m.to_name = nil
	m.clearedFields[channelmessage.FieldToName] = struct{}{}
}

// ToNameCleared returns if the "to_name" field was cleared in this mutation.
func (m *ChannelMessageMutation) ToNameCleared() bool {
	_, ok := m.clearedFields[channelmessage.FieldToName]
	return ok
}

// ResetToName resets all changes to the "to_name" field.
func (m *ChannelMessageMutation) ResetToName() {
	m.to_name = nil
	delete(m.clearedFields, channelmessage.FieldToName)
}

// SetPrivate sets the "private" field.
func (m *ChannelMessageMutation) SetPrivate(b bool) {
	m.private = &b
}

// Private returns the value of the "private" field in the mutation.
func (m *ChannelMessageMutation) Private() (r bool, exists bool) {
	v := m.private
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivate returns the old "private" field's value of the ChannelMessage entity.
// If the ChannelMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMessageMutation) OldPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivate: %w", err)
	}
	return oldValue.Private, nil
}

// ResetPrivate resets all changes to the "private" field.
func (m *ChannelMessageMutation) ResetPrivate() {
	m.private = nil
}

// SetUnread sets the "unread" field.
func (m *ChannelMessageMutation) SetUnread(b bool) {
	m.unread = &b
}

// Unread returns the value of the "unread" field in the mutation.
func (m *ChannelMessageMutation) Unread() (r bool, exists bool) {
	v := m.unread
	if v == nil {
		return
	}
	return *v, true
}

// OldUnread returns the old "unread" field's value of the ChannelMessage entity.
// If the ChannelMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMessageMutation) OldUnread(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnread is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnread requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnread: %w", err)
	}
	return oldValue.Unread, nil
}

// ClearUnread clears the value of the "unread" field.
func (m *ChannelMessageMutation) ClearUnread() {
	m.unread = nil
	m.clearedFields[channelmessage.FieldUnread] = struct{}{}
}

// UnreadCleared returns if the "unread" field was cleared in this mutation.
func (m *ChannelMessageMutation) UnreadCleared() bool {
	_, ok := m.clearedFields[channelmessage.FieldUnread]
	return ok
}

// ResetUnread resets all changes to the "unread" field.
func (m *ChannelMessageMutation) ResetUnread() {
	m.unread = nil
	delete(m.clearedFields, channelmessage.FieldUnread)
}

// AddReadIDs adds the "reads" edge to the ChannelMessageRead entity by ids.
func (m *ChannelMessageMutation) AddReadIDs(ids ...string) {
	if m.reads == nil {
		m.reads = make(map[string]struct{})
	}
	for i := range ids {
		m.reads[ids[i]] = struct{}{}
	}
}

// ClearReads clears the "reads" edge to the ChannelMessageRead entity.
func (m *ChannelMessageMutation) ClearReads() {
	m.clearedreads = true
}

// ReadsCleared reports if the "reads" edge to the ChannelMessageRead entity was cleared.
func (m *ChannelMessageMutation) ReadsCleared() bool {
	return m.clearedreads
}

// RemoveReadIDs removes the "reads" edge to the ChannelMessageRead entity by IDs.
func (m *ChannelMessageMutation) RemoveReadIDs(ids ...string) {
	if m.removedreads == nil {
		m.removedreads = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.reads, ids[i])
		m.removedreads[ids[i]] = struct{}{}
	}
}

// RemovedReads returns the removed IDs of the "reads" edge to the ChannelMessageRead entity.
func (m *ChannelMessageMutation) RemovedReadsIDs() (ids []string) {
	for id := range m.removedreads {
		ids = append(ids, id)
	}
	return
}

// ReadsIDs returns the "reads" edge IDs in the mutation.
func (m *ChannelMessageMutation) ReadsIDs() (ids []string) {
	for id := range m.reads {
		ids = append(ids, id)
	}
	return
}

// ResetReads resets all changes to the "reads" edge.
func (m *ChannelMessageMutation) ResetReads() {
	m.reads = nil
	m.clearedreads = false
	m.removedreads = nil
}

// SetChannelID sets the "channel" edge to the Channel entity by id.
func (m *ChannelMessageMutation) SetChannelID(id string) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *ChannelMessageMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *ChannelMessageMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *ChannelMessageMutation) ChannelID() (id string, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *ChannelMessageMutation) ChannelIDs() (ids []string) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *ChannelMessageMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// SetFromID sets the "from" edge to the User entity by id.
func (m *ChannelMessageMutation) SetFromID(id string) {
	m.from = &id
}

// ClearFrom clears the "from" edge to the User entity.
func (m *ChannelMessageMutation) ClearFrom() {
	m.clearedfrom = true
}

// FromCleared reports if the "from" edge to the User entity was cleared.
func (m *ChannelMessageMutation) FromCleared() bool {
	return m.clearedfrom
}

// FromID returns the "from" edge ID in the mutation.
func (m *ChannelMessageMutation) FromID() (id string, exists bool) {
	if m.from != nil {
		return *m.from, true
	}
	return
}

// FromIDs returns the "from" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromID instead. It exists only for internal usage by the builders.
func (m *ChannelMessageMutation) FromIDs() (ids []string) {
	if id := m.from; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFrom resets all changes to the "from" edge.
func (m *ChannelMessageMutation) ResetFrom() {
	m.from = nil
	m.clearedfrom = false
}

// SetFromAPIUserID sets the "from_api_user" edge to the ApiUser entity by id.
func (m *ChannelMessageMutation) SetFromAPIUserID(id string) {
	m.from_api_user = &id
}

// ClearFromAPIUser clears the "from_api_user" edge to the ApiUser entity.
func (m *ChannelMessageMutation) ClearFromAPIUser() {
	m.clearedfrom_api_user = true
}

// FromAPIUserCleared reports if the "from_api_user" edge to the ApiUser entity was cleared.
func (m *ChannelMessageMutation) FromAPIUserCleared() bool {
	return m.clearedfrom_api_user
}

// FromAPIUserID returns the "from_api_user" edge ID in the mutation.
func (m *ChannelMessageMutation) FromAPIUserID() (id string, exists bool) {
	if m.from_api_user != nil {
		return *m.from_api_user, true
	}
	return
}

// FromAPIUserIDs returns the "from_api_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FromAPIUserID instead. It exists only for internal usage by the builders.
func (m *ChannelMessageMutation) FromAPIUserIDs() (ids []string) {
	if id := m.from_api_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFromAPIUser resets all changes to the "from_api_user" edge.
func (m *ChannelMessageMutation) ResetFromAPIUser() {
	m.from_api_user = nil
	m.clearedfrom_api_user = false
}

// SetToID sets the "to" edge to the User entity by id.
func (m *ChannelMessageMutation) SetToID(id string) {
	m.to = &id
}

// ClearTo clears the "to" edge to the User entity.
func (m *ChannelMessageMutation) ClearTo() {
	m.clearedto = true
}

// ToCleared reports if the "to" edge to the User entity was cleared.
func (m *ChannelMessageMutation) ToCleared() bool {
	return m.clearedto
}

// ToID returns the "to" edge ID in the mutation.
func (m *ChannelMessageMutation) ToID() (id string, exists bool) {
	if m.to != nil {
		return *m.to, true
	}
	return
}

// ToIDs returns the "to" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ToID instead. It exists only for internal usage by the builders.
func (m *ChannelMessageMutation) ToIDs() (ids []string) {
	if id := m.to; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTo resets all changes to the "to" edge.
func (m *ChannelMessageMutation) ResetTo() {
	m.to = nil
	m.clearedto = false
}

// Where appends a list predicates to the ChannelMessageMutation builder.
func (m *ChannelMessageMutation) Where(ps ...predicate.ChannelMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelMessage).
func (m *ChannelMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMessageMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, channelmessage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channelmessage.FieldUpdatedAt)
	}
	if m.title != nil {
		fields = append(fields, channelmessage.FieldTitle)
	}
	if m.message != nil {
		fields = append(fields, channelmessage.FieldMessage)
	}
	if m.from_name != nil {
		fields = append(fields, channelmessage.FieldFromName)
	}
	if m.to_name != nil {
		fields = append(fields, channelmessage.FieldToName)
	}
	if m.private != nil {
		fields = append(fields, channelmessage.FieldPrivate)
	}
	if m.unread != nil {
		fields = append(fields, channelmessage.FieldUnread)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelmessage.FieldCreatedAt:
		return m.CreatedAt()
	case channelmessage.FieldUpdatedAt:
		return m.UpdatedAt()
	case channelmessage.FieldTitle:
		return m.Title()
	case channelmessage.FieldMessage:
		return m.Message()
	case channelmessage.FieldFromName:
		return m.FromName()
	case channelmessage.FieldToName:
		return m.ToName()
	case channelmessage.FieldPrivate:
		return m.Private()
	case channelmessage.FieldUnread:
		return m.Unread()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelmessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channelmessage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channelmessage.FieldTitle:
		return m.OldTitle(ctx)
	case channelmessage.FieldMessage:
		return m.OldMessage(ctx)
	case channelmessage.FieldFromName:
		return m.OldFromName(ctx)
	case channelmessage.FieldToName:
		return m.OldToName(ctx)
	case channelmessage.FieldPrivate:
		return m.OldPrivate(ctx)
	case channelmessage.FieldUnread:
		return m.OldUnread(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelmessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channelmessage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channelmessage.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case channelmessage.FieldMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case channelmessage.FieldFromName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromName(v)
		return nil
	case channelmessage.FieldToName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToName(v)
		return nil
	case channelmessage.FieldPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivate(v)
		return nil
	case channelmessage.FieldUnread:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnread(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMessageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMessageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChannelMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channelmessage.FieldTitle) {
		fields = append(fields, channelmessage.FieldTitle)
	}
	if m.FieldCleared(channelmessage.FieldToName) {
		fields = append(fields, channelmessage.FieldToName)
	}
	if m.FieldCleared(channelmessage.FieldUnread) {
		fields = append(fields, channelmessage.FieldUnread)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMessageMutation) ClearField(name string) error {
	switch name {
	case channelmessage.FieldTitle:
		m.ClearTitle()
		return nil
	case channelmessage.FieldToName:
		m.ClearToName()
		return nil
	case channelmessage.FieldUnread:
		m.ClearUnread()
		return nil
	}
	return fmt.Errorf("unknown ChannelMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMessageMutation) ResetField(name string) error {
	switch name {
	case channelmessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channelmessage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channelmessage.FieldTitle:
		m.ResetTitle()
		return nil
	case channelmessage.FieldMessage:
		m.ResetMessage()
		return nil
	case channelmessage.FieldFromName:
		m.ResetFromName()
		return nil
	case channelmessage.FieldToName:
		m.ResetToName()
		return nil
	case channelmessage.FieldPrivate:
		m.ResetPrivate()
		return nil
	case channelmessage.FieldUnread:
		m.ResetUnread()
		return nil
	}
	return fmt.Errorf("unknown ChannelMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.reads != nil {
		edges = append(edges, channelmessage.EdgeReads)
	}
	if m.channel != nil {
		edges = append(edges, channelmessage.EdgeChannel)
	}
	if m.from != nil {
		edges = append(edges, channelmessage.EdgeFrom)
	}
	if m.from_api_user != nil {
		edges = append(edges, channelmessage.EdgeFromAPIUser)
	}
	if m.to != nil {
		edges = append(edges, channelmessage.EdgeTo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMessageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelmessage.EdgeReads:
		ids := make([]ent.Value, 0, len(m.reads))
		for id := range m.reads {
			ids = append(ids, id)
		}
		return ids
	case channelmessage.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case channelmessage.EdgeFrom:
		if id := m.from; id != nil {
			return []ent.Value{*id}
		}
	case channelmessage.EdgeFromAPIUser:
		if id := m.from_api_user; id != nil {
			return []ent.Value{*id}
		}
	case channelmessage.EdgeTo:
		if id := m.to; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedreads != nil {
		edges = append(edges, channelmessage.EdgeReads)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMessageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case channelmessage.EdgeReads:
		ids := make([]ent.Value, 0, len(m.removedreads))
		for id := range m.removedreads {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedreads {
		edges = append(edges, channelmessage.EdgeReads)
	}
	if m.clearedchannel {
		edges = append(edges, channelmessage.EdgeChannel)
	}
	if m.clearedfrom {
		edges = append(edges, channelmessage.EdgeFrom)
	}
	if m.clearedfrom_api_user {
		edges = append(edges, channelmessage.EdgeFromAPIUser)
	}
	if m.clearedto {
		edges = append(edges, channelmessage.EdgeTo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMessageMutation) EdgeCleared(name string) bool {
	switch name {
	case channelmessage.EdgeReads:
		return m.clearedreads
	case channelmessage.EdgeChannel:
		return m.clearedchannel
	case channelmessage.EdgeFrom:
		return m.clearedfrom
	case channelmessage.EdgeFromAPIUser:
		return m.clearedfrom_api_user
	case channelmessage.EdgeTo:
		return m.clearedto
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMessageMutation) ClearEdge(name string) error {
	switch name {
	case channelmessage.EdgeChannel:
		m.ClearChannel()
		return nil
	case channelmessage.EdgeFrom:
		m.ClearFrom()
		return nil
	case channelmessage.EdgeFromAPIUser:
		m.ClearFromAPIUser()
		return nil
	case channelmessage.EdgeTo:
		m.ClearTo()
		return nil
	}
	return fmt.Errorf("unknown ChannelMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMessageMutation) ResetEdge(name string) error {
	switch name {
	case channelmessage.EdgeReads:
		m.ResetReads()
		return nil
	case channelmessage.EdgeChannel:
		m.ResetChannel()
		return nil
	case channelmessage.EdgeFrom:
		m.ResetFrom()
		return nil
	case channelmessage.EdgeFromAPIUser:
		m.ResetFromAPIUser()
		return nil
	case channelmessage.EdgeTo:
		m.ResetTo()
		return nil
	}
	return fmt.Errorf("unknown ChannelMessage edge %s", name)
}

// ChannelMessageReadMutation represents an operation that mutates the ChannelMessageRead nodes in the graph.
type ChannelMessageReadMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	read                   *bool
	clearedFields          map[string]struct{}
	channel_message        *string
	clearedchannel_message bool
	user                   *string
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*ChannelMessageRead, error)
	predicates             []predicate.ChannelMessageRead
}

var _ ent.Mutation = (*ChannelMessageReadMutation)(nil)

// channelmessagereadOption allows management of the mutation configuration using functional options.
type channelmessagereadOption func(*ChannelMessageReadMutation)

// newChannelMessageReadMutation creates new mutation for the ChannelMessageRead entity.
func newChannelMessageReadMutation(c config, op Op, opts ...channelmessagereadOption) *ChannelMessageReadMutation {
	m := &ChannelMessageReadMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelMessageRead,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelMessageReadID sets the ID field of the mutation.
func withChannelMessageReadID(id string) channelmessagereadOption {
	return func(m *ChannelMessageReadMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelMessageRead
		)
		m.oldValue = func(ctx context.Context) (*ChannelMessageRead, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelMessageRead.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelMessageRead sets the old ChannelMessageRead of the mutation.
func withChannelMessageRead(node *ChannelMessageRead) channelmessagereadOption {
	return func(m *ChannelMessageReadMutation) {
		m.oldValue = func(context.Context) (*ChannelMessageRead, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelMessageReadMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelMessageReadMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChannelMessageRead entities.
func (m *ChannelMessageReadMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelMessageReadMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelMessageReadMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelMessageRead.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelMessageReadMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelMessageReadMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelMessageRead entity.
// If the ChannelMessageRead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMessageReadMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelMessageReadMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetRead sets the "read" field.
func (m *ChannelMessageReadMutation) SetRead(b bool) {
	m.read = &b
}

// Read returns the value of the "read" field in the mutation.
func (m *ChannelMessageReadMutation) Read() (r bool, exists bool) {
	v := m.read
	if v == nil {
		return
	}
	return *v, true
}

// OldRead returns the old "read" field's value of the ChannelMessageRead entity.
// If the ChannelMessageRead object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelMessageReadMutation) OldRead(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRead is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRead requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRead: %w", err)
	}
	return oldValue.Read, nil
}

// ResetRead resets all changes to the "read" field.
func (m *ChannelMessageReadMutation) ResetRead() {
	m.read = nil
}

// SetChannelMessageID sets the "channel_message" edge to the ChannelMessage entity by id.
func (m *ChannelMessageReadMutation) SetChannelMessageID(id string) {
	m.channel_message = &id
}

// ClearChannelMessage clears the "channel_message" edge to the ChannelMessage entity.
func (m *ChannelMessageReadMutation) ClearChannelMessage() {
	m.clearedchannel_message = true
}

// ChannelMessageCleared reports if the "channel_message" edge to the ChannelMessage entity was cleared.
func (m *ChannelMessageReadMutation) ChannelMessageCleared() bool {
	return m.clearedchannel_message
}

// ChannelMessageID returns the "channel_message" edge ID in the mutation.
func (m *ChannelMessageReadMutation) ChannelMessageID() (id string, exists bool) {
	if m.channel_message != nil {
		return *m.channel_message, true
	}
	return
}

// ChannelMessageIDs returns the "channel_message" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelMessageID instead. It exists only for internal usage by the builders.
func (m *ChannelMessageReadMutation) ChannelMessageIDs() (ids []string) {
	if id := m.channel_message; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannelMessage resets all changes to the "channel_message" edge.
func (m *ChannelMessageReadMutation) ResetChannelMessage() {
	m.channel_message = nil
	m.clearedchannel_message = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ChannelMessageReadMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChannelMessageReadMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChannelMessageReadMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ChannelMessageReadMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ChannelMessageReadMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChannelMessageReadMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ChannelMessageReadMutation builder.
func (m *ChannelMessageReadMutation) Where(ps ...predicate.ChannelMessageRead) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelMessageReadMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelMessageReadMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelMessageRead, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelMessageReadMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelMessageReadMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelMessageRead).
func (m *ChannelMessageReadMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelMessageReadMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, channelmessageread.FieldCreatedAt)
	}
	if m.read != nil {
		fields = append(fields, channelmessageread.FieldRead)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelMessageReadMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelmessageread.FieldCreatedAt:
		return m.CreatedAt()
	case channelmessageread.FieldRead:
		return m.Read()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelMessageReadMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelmessageread.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channelmessageread.FieldRead:
		return m.OldRead(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelMessageRead field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMessageReadMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelmessageread.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channelmessageread.FieldRead:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRead(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelMessageRead field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelMessageReadMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelMessageReadMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelMessageReadMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChannelMessageRead numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelMessageReadMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelMessageReadMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelMessageReadMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChannelMessageRead nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelMessageReadMutation) ResetField(name string) error {
	switch name {
	case channelmessageread.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channelmessageread.FieldRead:
		m.ResetRead()
		return nil
	}
	return fmt.Errorf("unknown ChannelMessageRead field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelMessageReadMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.channel_message != nil {
		edges = append(edges, channelmessageread.EdgeChannelMessage)
	}
	if m.user != nil {
		edges = append(edges, channelmessageread.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelMessageReadMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelmessageread.EdgeChannelMessage:
		if id := m.channel_message; id != nil {
			return []ent.Value{*id}
		}
	case channelmessageread.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelMessageReadMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelMessageReadMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelMessageReadMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchannel_message {
		edges = append(edges, channelmessageread.EdgeChannelMessage)
	}
	if m.cleareduser {
		edges = append(edges, channelmessageread.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelMessageReadMutation) EdgeCleared(name string) bool {
	switch name {
	case channelmessageread.EdgeChannelMessage:
		return m.clearedchannel_message
	case channelmessageread.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelMessageReadMutation) ClearEdge(name string) error {
	switch name {
	case channelmessageread.EdgeChannelMessage:
		m.ClearChannelMessage()
		return nil
	case channelmessageread.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ChannelMessageRead unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelMessageReadMutation) ResetEdge(name string) error {
	switch name {
	case channelmessageread.EdgeChannelMessage:
		m.ResetChannelMessage()
		return nil
	case channelmessageread.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown ChannelMessageRead edge %s", name)
}

// ChannelSubMutation represents an operation that mutates the ChannelSub nodes in the graph.
type ChannelSubMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	role           *enum.Role
	clearedFields  map[string]struct{}
	channel        *string
	clearedchannel bool
	user           *string
	cleareduser    bool
	partner        *string
	clearedpartner bool
	done           bool
	oldValue       func(context.Context) (*ChannelSub, error)
	predicates     []predicate.ChannelSub
}

var _ ent.Mutation = (*ChannelSubMutation)(nil)

// channelsubOption allows management of the mutation configuration using functional options.
type channelsubOption func(*ChannelSubMutation)

// newChannelSubMutation creates new mutation for the ChannelSub entity.
func newChannelSubMutation(c config, op Op, opts ...channelsubOption) *ChannelSubMutation {
	m := &ChannelSubMutation{
		config:        c,
		op:            op,
		typ:           TypeChannelSub,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChannelSubID sets the ID field of the mutation.
func withChannelSubID(id string) channelsubOption {
	return func(m *ChannelSubMutation) {
		var (
			err   error
			once  sync.Once
			value *ChannelSub
		)
		m.oldValue = func(ctx context.Context) (*ChannelSub, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChannelSub.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChannelSub sets the old ChannelSub of the mutation.
func withChannelSub(node *ChannelSub) channelsubOption {
	return func(m *ChannelSubMutation) {
		m.oldValue = func(context.Context) (*ChannelSub, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChannelSubMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChannelSubMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChannelSub entities.
func (m *ChannelSubMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChannelSubMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChannelSubMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChannelSub.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ChannelSubMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChannelSubMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChannelSub entity.
// If the ChannelSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelSubMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChannelSubMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ChannelSubMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ChannelSubMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ChannelSub entity.
// If the ChannelSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelSubMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ChannelSubMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRole sets the "role" field.
func (m *ChannelSubMutation) SetRole(e enum.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *ChannelSubMutation) Role() (r enum.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the ChannelSub entity.
// If the ChannelSub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChannelSubMutation) OldRole(ctx context.Context) (v *enum.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *ChannelSubMutation) ClearRole() {
	m.role = nil
	m.clearedFields[channelsub.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *ChannelSubMutation) RoleCleared() bool {
	_, ok := m.clearedFields[channelsub.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *ChannelSubMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, channelsub.FieldRole)
}

// SetChannelID sets the "channel" edge to the Channel entity by id.
func (m *ChannelSubMutation) SetChannelID(id string) {
	m.channel = &id
}

// ClearChannel clears the "channel" edge to the Channel entity.
func (m *ChannelSubMutation) ClearChannel() {
	m.clearedchannel = true
}

// ChannelCleared reports if the "channel" edge to the Channel entity was cleared.
func (m *ChannelSubMutation) ChannelCleared() bool {
	return m.clearedchannel
}

// ChannelID returns the "channel" edge ID in the mutation.
func (m *ChannelSubMutation) ChannelID() (id string, exists bool) {
	if m.channel != nil {
		return *m.channel, true
	}
	return
}

// ChannelIDs returns the "channel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChannelID instead. It exists only for internal usage by the builders.
func (m *ChannelSubMutation) ChannelIDs() (ids []string) {
	if id := m.channel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChannel resets all changes to the "channel" edge.
func (m *ChannelSubMutation) ResetChannel() {
	m.channel = nil
	m.clearedchannel = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ChannelSubMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChannelSubMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChannelSubMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ChannelSubMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ChannelSubMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChannelSubMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *ChannelSubMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *ChannelSubMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *ChannelSubMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *ChannelSubMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *ChannelSubMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *ChannelSubMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// Where appends a list predicates to the ChannelSubMutation builder.
func (m *ChannelSubMutation) Where(ps ...predicate.ChannelSub) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChannelSubMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChannelSubMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChannelSub, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChannelSubMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChannelSubMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChannelSub).
func (m *ChannelSubMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChannelSubMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, channelsub.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, channelsub.FieldUpdatedAt)
	}
	if m.role != nil {
		fields = append(fields, channelsub.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChannelSubMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case channelsub.FieldCreatedAt:
		return m.CreatedAt()
	case channelsub.FieldUpdatedAt:
		return m.UpdatedAt()
	case channelsub.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChannelSubMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case channelsub.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case channelsub.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case channelsub.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown ChannelSub field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelSubMutation) SetField(name string, value ent.Value) error {
	switch name {
	case channelsub.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case channelsub.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case channelsub.FieldRole:
		v, ok := value.(enum.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown ChannelSub field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChannelSubMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChannelSubMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChannelSubMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChannelSub numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChannelSubMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(channelsub.FieldRole) {
		fields = append(fields, channelsub.FieldRole)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChannelSubMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChannelSubMutation) ClearField(name string) error {
	switch name {
	case channelsub.FieldRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown ChannelSub nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChannelSubMutation) ResetField(name string) error {
	switch name {
	case channelsub.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case channelsub.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case channelsub.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown ChannelSub field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChannelSubMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.channel != nil {
		edges = append(edges, channelsub.EdgeChannel)
	}
	if m.user != nil {
		edges = append(edges, channelsub.EdgeUser)
	}
	if m.partner != nil {
		edges = append(edges, channelsub.EdgePartner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChannelSubMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case channelsub.EdgeChannel:
		if id := m.channel; id != nil {
			return []ent.Value{*id}
		}
	case channelsub.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case channelsub.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChannelSubMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChannelSubMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChannelSubMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchannel {
		edges = append(edges, channelsub.EdgeChannel)
	}
	if m.cleareduser {
		edges = append(edges, channelsub.EdgeUser)
	}
	if m.clearedpartner {
		edges = append(edges, channelsub.EdgePartner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChannelSubMutation) EdgeCleared(name string) bool {
	switch name {
	case channelsub.EdgeChannel:
		return m.clearedchannel
	case channelsub.EdgeUser:
		return m.cleareduser
	case channelsub.EdgePartner:
		return m.clearedpartner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChannelSubMutation) ClearEdge(name string) error {
	switch name {
	case channelsub.EdgeChannel:
		m.ClearChannel()
		return nil
	case channelsub.EdgeUser:
		m.ClearUser()
		return nil
	case channelsub.EdgePartner:
		m.ClearPartner()
		return nil
	}
	return fmt.Errorf("unknown ChannelSub unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChannelSubMutation) ResetEdge(name string) error {
	switch name {
	case channelsub.EdgeChannel:
		m.ResetChannel()
		return nil
	case channelsub.EdgeUser:
		m.ResetUser()
		return nil
	case channelsub.EdgePartner:
		m.ResetPartner()
		return nil
	}
	return fmt.Errorf("unknown ChannelSub edge %s", name)
}

// ContactUsMutation represents an operation that mutates the ContactUs nodes in the graph.
type ContactUsMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	reason         *string
	clearedFields  map[string]struct{}
	partner        *string
	clearedpartner bool
	creator        *string
	clearedcreator bool
	done           bool
	oldValue       func(context.Context) (*ContactUs, error)
	predicates     []predicate.ContactUs
}

var _ ent.Mutation = (*ContactUsMutation)(nil)

// contactusOption allows management of the mutation configuration using functional options.
type contactusOption func(*ContactUsMutation)

// newContactUsMutation creates new mutation for the ContactUs entity.
func newContactUsMutation(c config, op Op, opts ...contactusOption) *ContactUsMutation {
	m := &ContactUsMutation{
		config:        c,
		op:            op,
		typ:           TypeContactUs,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactUsID sets the ID field of the mutation.
func withContactUsID(id string) contactusOption {
	return func(m *ContactUsMutation) {
		var (
			err   error
			once  sync.Once
			value *ContactUs
		)
		m.oldValue = func(ctx context.Context) (*ContactUs, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ContactUs.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContactUs sets the old ContactUs of the mutation.
func withContactUs(node *ContactUs) contactusOption {
	return func(m *ContactUsMutation) {
		m.oldValue = func(context.Context) (*ContactUs, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactUsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactUsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ContactUs entities.
func (m *ContactUsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactUsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactUsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ContactUs.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ContactUsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ContactUsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ContactUs entity.
// If the ContactUs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactUsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ContactUsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ContactUsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ContactUsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ContactUs entity.
// If the ContactUs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactUsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ContactUsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetReason sets the "reason" field.
func (m *ContactUsMutation) SetReason(s string) {
	m.reason = &s
}

// Reason returns the value of the "reason" field in the mutation.
func (m *ContactUsMutation) Reason() (r string, exists bool) {
	v := m.reason
	if v == nil {
		return
	}
	return *v, true
}

// OldReason returns the old "reason" field's value of the ContactUs entity.
// If the ContactUs object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactUsMutation) OldReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReason: %w", err)
	}
	return oldValue.Reason, nil
}

// ResetReason resets all changes to the "reason" field.
func (m *ContactUsMutation) ResetReason() {
	m.reason = nil
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *ContactUsMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *ContactUsMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *ContactUsMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *ContactUsMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *ContactUsMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *ContactUsMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *ContactUsMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *ContactUsMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *ContactUsMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *ContactUsMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *ContactUsMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *ContactUsMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the ContactUsMutation builder.
func (m *ContactUsMutation) Where(ps ...predicate.ContactUs) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactUsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactUsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ContactUs, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactUsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactUsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ContactUs).
func (m *ContactUsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactUsMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, contactus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, contactus.FieldUpdatedAt)
	}
	if m.reason != nil {
		fields = append(fields, contactus.FieldReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactUsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contactus.FieldCreatedAt:
		return m.CreatedAt()
	case contactus.FieldUpdatedAt:
		return m.UpdatedAt()
	case contactus.FieldReason:
		return m.Reason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactUsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contactus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case contactus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case contactus.FieldReason:
		return m.OldReason(ctx)
	}
	return nil, fmt.Errorf("unknown ContactUs field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactUsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contactus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case contactus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case contactus.FieldReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReason(v)
		return nil
	}
	return fmt.Errorf("unknown ContactUs field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactUsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactUsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactUsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ContactUs numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactUsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactUsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactUsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ContactUs nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactUsMutation) ResetField(name string) error {
	switch name {
	case contactus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case contactus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case contactus.FieldReason:
		m.ResetReason()
		return nil
	}
	return fmt.Errorf("unknown ContactUs field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactUsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.partner != nil {
		edges = append(edges, contactus.EdgePartner)
	}
	if m.creator != nil {
		edges = append(edges, contactus.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactUsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contactus.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	case contactus.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactUsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactUsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactUsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpartner {
		edges = append(edges, contactus.EdgePartner)
	}
	if m.clearedcreator {
		edges = append(edges, contactus.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactUsMutation) EdgeCleared(name string) bool {
	switch name {
	case contactus.EdgePartner:
		return m.clearedpartner
	case contactus.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactUsMutation) ClearEdge(name string) error {
	switch name {
	case contactus.EdgePartner:
		m.ClearPartner()
		return nil
	case contactus.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown ContactUs unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactUsMutation) ResetEdge(name string) error {
	switch name {
	case contactus.EdgePartner:
		m.ResetPartner()
		return nil
	case contactus.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown ContactUs edge %s", name)
}

// DocumentMutation represents an operation that mutates the Document nodes in the graph.
type DocumentMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *string
	created_at                         *time.Time
	updated_at                         *time.Time
	bucket                             *string
	key                                *string
	folder                             *enum.DocFolder
	dir                                *string
	section                            *enum.DocSection
	name                               *string
	filename                           *string
	content_type                       *string
	content_size                       *int64
	addcontent_size                    *int64
	ready                              *bool
	creator_id                         *string
	updater_id                         *string
	clearedFields                      map[string]struct{}
	training_video                     *string
	clearedtraining_video              bool
	training_video_poster              *string
	clearedtraining_video_poster       bool
	products_image                     *string
	clearedproducts_image              bool
	installation_job_item_image        *string
	clearedinstallation_job_item_image bool
	estimate_pdf                       *string
	clearedestimate_pdf                bool
	job_estimate_pdf                   *string
	clearedjob_estimate_pdf            bool
	done                               bool
	oldValue                           func(context.Context) (*Document, error)
	predicates                         []predicate.Document
}

var _ ent.Mutation = (*DocumentMutation)(nil)

// documentOption allows management of the mutation configuration using functional options.
type documentOption func(*DocumentMutation)

// newDocumentMutation creates new mutation for the Document entity.
func newDocumentMutation(c config, op Op, opts ...documentOption) *DocumentMutation {
	m := &DocumentMutation{
		config:        c,
		op:            op,
		typ:           TypeDocument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentID sets the ID field of the mutation.
func withDocumentID(id string) documentOption {
	return func(m *DocumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Document
		)
		m.oldValue = func(ctx context.Context) (*Document, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Document.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocument sets the old Document of the mutation.
func withDocument(node *Document) documentOption {
	return func(m *DocumentMutation) {
		m.oldValue = func(context.Context) (*Document, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Document entities.
func (m *DocumentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Document.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DocumentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DocumentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DocumentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetBucket sets the "bucket" field.
func (m *DocumentMutation) SetBucket(s string) {
	m.bucket = &s
}

// Bucket returns the value of the "bucket" field in the mutation.
func (m *DocumentMutation) Bucket() (r string, exists bool) {
	v := m.bucket
	if v == nil {
		return
	}
	return *v, true
}

// OldBucket returns the old "bucket" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldBucket(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucket is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucket requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucket: %w", err)
	}
	return oldValue.Bucket, nil
}

// ResetBucket resets all changes to the "bucket" field.
func (m *DocumentMutation) ResetBucket() {
	m.bucket = nil
}

// SetKey sets the "key" field.
func (m *DocumentMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *DocumentMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *DocumentMutation) ResetKey() {
	m.key = nil
}

// SetFolder sets the "folder" field.
func (m *DocumentMutation) SetFolder(ef enum.DocFolder) {
	m.folder = &ef
}

// Folder returns the value of the "folder" field in the mutation.
func (m *DocumentMutation) Folder() (r enum.DocFolder, exists bool) {
	v := m.folder
	if v == nil {
		return
	}
	return *v, true
}

// OldFolder returns the old "folder" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldFolder(ctx context.Context) (v enum.DocFolder, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFolder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFolder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFolder: %w", err)
	}
	return oldValue.Folder, nil
}

// ResetFolder resets all changes to the "folder" field.
func (m *DocumentMutation) ResetFolder() {
	m.folder = nil
}

// SetDir sets the "dir" field.
func (m *DocumentMutation) SetDir(s string) {
	m.dir = &s
}

// Dir returns the value of the "dir" field in the mutation.
func (m *DocumentMutation) Dir() (r string, exists bool) {
	v := m.dir
	if v == nil {
		return
	}
	return *v, true
}

// OldDir returns the old "dir" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldDir(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDir: %w", err)
	}
	return oldValue.Dir, nil
}

// ClearDir clears the value of the "dir" field.
func (m *DocumentMutation) ClearDir() {
	m.dir = nil
	m.clearedFields[document.FieldDir] = struct{}{}
}

// DirCleared returns if the "dir" field was cleared in this mutation.
func (m *DocumentMutation) DirCleared() bool {
	_, ok := m.clearedFields[document.FieldDir]
	return ok
}

// ResetDir resets all changes to the "dir" field.
func (m *DocumentMutation) ResetDir() {
	m.dir = nil
	delete(m.clearedFields, document.FieldDir)
}

// SetSection sets the "section" field.
func (m *DocumentMutation) SetSection(es enum.DocSection) {
	m.section = &es
}

// Section returns the value of the "section" field in the mutation.
func (m *DocumentMutation) Section() (r enum.DocSection, exists bool) {
	v := m.section
	if v == nil {
		return
	}
	return *v, true
}

// OldSection returns the old "section" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldSection(ctx context.Context) (v enum.DocSection, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSection is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSection requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSection: %w", err)
	}
	return oldValue.Section, nil
}

// ResetSection resets all changes to the "section" field.
func (m *DocumentMutation) ResetSection() {
	m.section = nil
}

// SetName sets the "name" field.
func (m *DocumentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DocumentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DocumentMutation) ResetName() {
	m.name = nil
}

// SetFilename sets the "filename" field.
func (m *DocumentMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *DocumentMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *DocumentMutation) ResetFilename() {
	m.filename = nil
}

// SetContentType sets the "content_type" field.
func (m *DocumentMutation) SetContentType(s string) {
	m.content_type = &s
}

// ContentType returns the value of the "content_type" field in the mutation.
func (m *DocumentMutation) ContentType() (r string, exists bool) {
	v := m.content_type
	if v == nil {
		return
	}
	return *v, true
}

// OldContentType returns the old "content_type" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldContentType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentType: %w", err)
	}
	return oldValue.ContentType, nil
}

// ClearContentType clears the value of the "content_type" field.
func (m *DocumentMutation) ClearContentType() {
	m.content_type = nil
	m.clearedFields[document.FieldContentType] = struct{}{}
}

// ContentTypeCleared returns if the "content_type" field was cleared in this mutation.
func (m *DocumentMutation) ContentTypeCleared() bool {
	_, ok := m.clearedFields[document.FieldContentType]
	return ok
}

// ResetContentType resets all changes to the "content_type" field.
func (m *DocumentMutation) ResetContentType() {
	m.content_type = nil
	delete(m.clearedFields, document.FieldContentType)
}

// SetContentSize sets the "content_size" field.
func (m *DocumentMutation) SetContentSize(i int64) {
	m.content_size = &i
	m.addcontent_size = nil
}

// ContentSize returns the value of the "content_size" field in the mutation.
func (m *DocumentMutation) ContentSize() (r int64, exists bool) {
	v := m.content_size
	if v == nil {
		return
	}
	return *v, true
}

// OldContentSize returns the old "content_size" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldContentSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContentSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContentSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContentSize: %w", err)
	}
	return oldValue.ContentSize, nil
}

// AddContentSize adds i to the "content_size" field.
func (m *DocumentMutation) AddContentSize(i int64) {
	if m.addcontent_size != nil {
		*m.addcontent_size += i
	} else {
		m.addcontent_size = &i
	}
}

// AddedContentSize returns the value that was added to the "content_size" field in this mutation.
func (m *DocumentMutation) AddedContentSize() (r int64, exists bool) {
	v := m.addcontent_size
	if v == nil {
		return
	}
	return *v, true
}

// ResetContentSize resets all changes to the "content_size" field.
func (m *DocumentMutation) ResetContentSize() {
	m.content_size = nil
	m.addcontent_size = nil
}

// SetReady sets the "ready" field.
func (m *DocumentMutation) SetReady(b bool) {
	m.ready = &b
}

// Ready returns the value of the "ready" field in the mutation.
func (m *DocumentMutation) Ready() (r bool, exists bool) {
	v := m.ready
	if v == nil {
		return
	}
	return *v, true
}

// OldReady returns the old "ready" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldReady(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReady is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReady requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReady: %w", err)
	}
	return oldValue.Ready, nil
}

// ResetReady resets all changes to the "ready" field.
func (m *DocumentMutation) ResetReady() {
	m.ready = nil
}

// SetCreatorID sets the "creator_id" field.
func (m *DocumentMutation) SetCreatorID(s string) {
	m.creator_id = &s
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *DocumentMutation) CreatorID() (r string, exists bool) {
	v := m.creator_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldCreatorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *DocumentMutation) ResetCreatorID() {
	m.creator_id = nil
}

// SetUpdaterID sets the "updater_id" field.
func (m *DocumentMutation) SetUpdaterID(s string) {
	m.updater_id = &s
}

// UpdaterID returns the value of the "updater_id" field in the mutation.
func (m *DocumentMutation) UpdaterID() (r string, exists bool) {
	v := m.updater_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdaterID returns the old "updater_id" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldUpdaterID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdaterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdaterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdaterID: %w", err)
	}
	return oldValue.UpdaterID, nil
}

// ClearUpdaterID clears the value of the "updater_id" field.
func (m *DocumentMutation) ClearUpdaterID() {
	m.updater_id = nil
	m.clearedFields[document.FieldUpdaterID] = struct{}{}
}

// UpdaterIDCleared returns if the "updater_id" field was cleared in this mutation.
func (m *DocumentMutation) UpdaterIDCleared() bool {
	_, ok := m.clearedFields[document.FieldUpdaterID]
	return ok
}

// ResetUpdaterID resets all changes to the "updater_id" field.
func (m *DocumentMutation) ResetUpdaterID() {
	m.updater_id = nil
	delete(m.clearedFields, document.FieldUpdaterID)
}

// SetTrainingVideoID sets the "training_video" edge to the TrainingVideo entity by id.
func (m *DocumentMutation) SetTrainingVideoID(id string) {
	m.training_video = &id
}

// ClearTrainingVideo clears the "training_video" edge to the TrainingVideo entity.
func (m *DocumentMutation) ClearTrainingVideo() {
	m.clearedtraining_video = true
}

// TrainingVideoCleared reports if the "training_video" edge to the TrainingVideo entity was cleared.
func (m *DocumentMutation) TrainingVideoCleared() bool {
	return m.clearedtraining_video
}

// TrainingVideoID returns the "training_video" edge ID in the mutation.
func (m *DocumentMutation) TrainingVideoID() (id string, exists bool) {
	if m.training_video != nil {
		return *m.training_video, true
	}
	return
}

// TrainingVideoIDs returns the "training_video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TrainingVideoID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) TrainingVideoIDs() (ids []string) {
	if id := m.training_video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrainingVideo resets all changes to the "training_video" edge.
func (m *DocumentMutation) ResetTrainingVideo() {
	m.training_video = nil
	m.clearedtraining_video = false
}

// SetTrainingVideoPosterID sets the "training_video_poster" edge to the TrainingVideo entity by id.
func (m *DocumentMutation) SetTrainingVideoPosterID(id string) {
	m.training_video_poster = &id
}

// ClearTrainingVideoPoster clears the "training_video_poster" edge to the TrainingVideo entity.
func (m *DocumentMutation) ClearTrainingVideoPoster() {
	m.clearedtraining_video_poster = true
}

// TrainingVideoPosterCleared reports if the "training_video_poster" edge to the TrainingVideo entity was cleared.
func (m *DocumentMutation) TrainingVideoPosterCleared() bool {
	return m.clearedtraining_video_poster
}

// TrainingVideoPosterID returns the "training_video_poster" edge ID in the mutation.
func (m *DocumentMutation) TrainingVideoPosterID() (id string, exists bool) {
	if m.training_video_poster != nil {
		return *m.training_video_poster, true
	}
	return
}

// TrainingVideoPosterIDs returns the "training_video_poster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TrainingVideoPosterID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) TrainingVideoPosterIDs() (ids []string) {
	if id := m.training_video_poster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTrainingVideoPoster resets all changes to the "training_video_poster" edge.
func (m *DocumentMutation) ResetTrainingVideoPoster() {
	m.training_video_poster = nil
	m.clearedtraining_video_poster = false
}

// SetProductsImageID sets the "products_image" edge to the Product entity by id.
func (m *DocumentMutation) SetProductsImageID(id string) {
	m.products_image = &id
}

// ClearProductsImage clears the "products_image" edge to the Product entity.
func (m *DocumentMutation) ClearProductsImage() {
	m.clearedproducts_image = true
}

// ProductsImageCleared reports if the "products_image" edge to the Product entity was cleared.
func (m *DocumentMutation) ProductsImageCleared() bool {
	return m.clearedproducts_image
}

// ProductsImageID returns the "products_image" edge ID in the mutation.
func (m *DocumentMutation) ProductsImageID() (id string, exists bool) {
	if m.products_image != nil {
		return *m.products_image, true
	}
	return
}

// ProductsImageIDs returns the "products_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductsImageID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) ProductsImageIDs() (ids []string) {
	if id := m.products_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductsImage resets all changes to the "products_image" edge.
func (m *DocumentMutation) ResetProductsImage() {
	m.products_image = nil
	m.clearedproducts_image = false
}

// SetInstallationJobItemImageID sets the "installation_job_item_image" edge to the InstallationJobItem entity by id.
func (m *DocumentMutation) SetInstallationJobItemImageID(id string) {
	m.installation_job_item_image = &id
}

// ClearInstallationJobItemImage clears the "installation_job_item_image" edge to the InstallationJobItem entity.
func (m *DocumentMutation) ClearInstallationJobItemImage() {
	m.clearedinstallation_job_item_image = true
}

// InstallationJobItemImageCleared reports if the "installation_job_item_image" edge to the InstallationJobItem entity was cleared.
func (m *DocumentMutation) InstallationJobItemImageCleared() bool {
	return m.clearedinstallation_job_item_image
}

// InstallationJobItemImageID returns the "installation_job_item_image" edge ID in the mutation.
func (m *DocumentMutation) InstallationJobItemImageID() (id string, exists bool) {
	if m.installation_job_item_image != nil {
		return *m.installation_job_item_image, true
	}
	return
}

// InstallationJobItemImageIDs returns the "installation_job_item_image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstallationJobItemImageID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) InstallationJobItemImageIDs() (ids []string) {
	if id := m.installation_job_item_image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstallationJobItemImage resets all changes to the "installation_job_item_image" edge.
func (m *DocumentMutation) ResetInstallationJobItemImage() {
	m.installation_job_item_image = nil
	m.clearedinstallation_job_item_image = false
}

// SetEstimatePdfID sets the "estimate_pdf" edge to the Estimate entity by id.
func (m *DocumentMutation) SetEstimatePdfID(id string) {
	m.estimate_pdf = &id
}

// ClearEstimatePdf clears the "estimate_pdf" edge to the Estimate entity.
func (m *DocumentMutation) ClearEstimatePdf() {
	m.clearedestimate_pdf = true
}

// EstimatePdfCleared reports if the "estimate_pdf" edge to the Estimate entity was cleared.
func (m *DocumentMutation) EstimatePdfCleared() bool {
	return m.clearedestimate_pdf
}

// EstimatePdfID returns the "estimate_pdf" edge ID in the mutation.
func (m *DocumentMutation) EstimatePdfID() (id string, exists bool) {
	if m.estimate_pdf != nil {
		return *m.estimate_pdf, true
	}
	return
}

// EstimatePdfIDs returns the "estimate_pdf" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EstimatePdfID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) EstimatePdfIDs() (ids []string) {
	if id := m.estimate_pdf; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEstimatePdf resets all changes to the "estimate_pdf" edge.
func (m *DocumentMutation) ResetEstimatePdf() {
	m.estimate_pdf = nil
	m.clearedestimate_pdf = false
}

// SetJobEstimatePdfID sets the "job_estimate_pdf" edge to the Job entity by id.
func (m *DocumentMutation) SetJobEstimatePdfID(id string) {
	m.job_estimate_pdf = &id
}

// ClearJobEstimatePdf clears the "job_estimate_pdf" edge to the Job entity.
func (m *DocumentMutation) ClearJobEstimatePdf() {
	m.clearedjob_estimate_pdf = true
}

// JobEstimatePdfCleared reports if the "job_estimate_pdf" edge to the Job entity was cleared.
func (m *DocumentMutation) JobEstimatePdfCleared() bool {
	return m.clearedjob_estimate_pdf
}

// JobEstimatePdfID returns the "job_estimate_pdf" edge ID in the mutation.
func (m *DocumentMutation) JobEstimatePdfID() (id string, exists bool) {
	if m.job_estimate_pdf != nil {
		return *m.job_estimate_pdf, true
	}
	return
}

// JobEstimatePdfIDs returns the "job_estimate_pdf" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobEstimatePdfID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) JobEstimatePdfIDs() (ids []string) {
	if id := m.job_estimate_pdf; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobEstimatePdf resets all changes to the "job_estimate_pdf" edge.
func (m *DocumentMutation) ResetJobEstimatePdf() {
	m.job_estimate_pdf = nil
	m.clearedjob_estimate_pdf = false
}

// Where appends a list predicates to the DocumentMutation builder.
func (m *DocumentMutation) Where(ps ...predicate.Document) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Document, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Document).
func (m *DocumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, document.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, document.FieldUpdatedAt)
	}
	if m.bucket != nil {
		fields = append(fields, document.FieldBucket)
	}
	if m.key != nil {
		fields = append(fields, document.FieldKey)
	}
	if m.folder != nil {
		fields = append(fields, document.FieldFolder)
	}
	if m.dir != nil {
		fields = append(fields, document.FieldDir)
	}
	if m.section != nil {
		fields = append(fields, document.FieldSection)
	}
	if m.name != nil {
		fields = append(fields, document.FieldName)
	}
	if m.filename != nil {
		fields = append(fields, document.FieldFilename)
	}
	if m.content_type != nil {
		fields = append(fields, document.FieldContentType)
	}
	if m.content_size != nil {
		fields = append(fields, document.FieldContentSize)
	}
	if m.ready != nil {
		fields = append(fields, document.FieldReady)
	}
	if m.creator_id != nil {
		fields = append(fields, document.FieldCreatorID)
	}
	if m.updater_id != nil {
		fields = append(fields, document.FieldUpdaterID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case document.FieldCreatedAt:
		return m.CreatedAt()
	case document.FieldUpdatedAt:
		return m.UpdatedAt()
	case document.FieldBucket:
		return m.Bucket()
	case document.FieldKey:
		return m.Key()
	case document.FieldFolder:
		return m.Folder()
	case document.FieldDir:
		return m.Dir()
	case document.FieldSection:
		return m.Section()
	case document.FieldName:
		return m.Name()
	case document.FieldFilename:
		return m.Filename()
	case document.FieldContentType:
		return m.ContentType()
	case document.FieldContentSize:
		return m.ContentSize()
	case document.FieldReady:
		return m.Ready()
	case document.FieldCreatorID:
		return m.CreatorID()
	case document.FieldUpdaterID:
		return m.UpdaterID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case document.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case document.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case document.FieldBucket:
		return m.OldBucket(ctx)
	case document.FieldKey:
		return m.OldKey(ctx)
	case document.FieldFolder:
		return m.OldFolder(ctx)
	case document.FieldDir:
		return m.OldDir(ctx)
	case document.FieldSection:
		return m.OldSection(ctx)
	case document.FieldName:
		return m.OldName(ctx)
	case document.FieldFilename:
		return m.OldFilename(ctx)
	case document.FieldContentType:
		return m.OldContentType(ctx)
	case document.FieldContentSize:
		return m.OldContentSize(ctx)
	case document.FieldReady:
		return m.OldReady(ctx)
	case document.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case document.FieldUpdaterID:
		return m.OldUpdaterID(ctx)
	}
	return nil, fmt.Errorf("unknown Document field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case document.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case document.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case document.FieldBucket:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucket(v)
		return nil
	case document.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case document.FieldFolder:
		v, ok := value.(enum.DocFolder)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFolder(v)
		return nil
	case document.FieldDir:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDir(v)
		return nil
	case document.FieldSection:
		v, ok := value.(enum.DocSection)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSection(v)
		return nil
	case document.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case document.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case document.FieldContentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentType(v)
		return nil
	case document.FieldContentSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContentSize(v)
		return nil
	case document.FieldReady:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReady(v)
		return nil
	case document.FieldCreatorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case document.FieldUpdaterID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdaterID(v)
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentMutation) AddedFields() []string {
	var fields []string
	if m.addcontent_size != nil {
		fields = append(fields, document.FieldContentSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case document.FieldContentSize:
		return m.AddedContentSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case document.FieldContentSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContentSize(v)
		return nil
	}
	return fmt.Errorf("unknown Document numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(document.FieldDir) {
		fields = append(fields, document.FieldDir)
	}
	if m.FieldCleared(document.FieldContentType) {
		fields = append(fields, document.FieldContentType)
	}
	if m.FieldCleared(document.FieldUpdaterID) {
		fields = append(fields, document.FieldUpdaterID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentMutation) ClearField(name string) error {
	switch name {
	case document.FieldDir:
		m.ClearDir()
		return nil
	case document.FieldContentType:
		m.ClearContentType()
		return nil
	case document.FieldUpdaterID:
		m.ClearUpdaterID()
		return nil
	}
	return fmt.Errorf("unknown Document nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentMutation) ResetField(name string) error {
	switch name {
	case document.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case document.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case document.FieldBucket:
		m.ResetBucket()
		return nil
	case document.FieldKey:
		m.ResetKey()
		return nil
	case document.FieldFolder:
		m.ResetFolder()
		return nil
	case document.FieldDir:
		m.ResetDir()
		return nil
	case document.FieldSection:
		m.ResetSection()
		return nil
	case document.FieldName:
		m.ResetName()
		return nil
	case document.FieldFilename:
		m.ResetFilename()
		return nil
	case document.FieldContentType:
		m.ResetContentType()
		return nil
	case document.FieldContentSize:
		m.ResetContentSize()
		return nil
	case document.FieldReady:
		m.ResetReady()
		return nil
	case document.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case document.FieldUpdaterID:
		m.ResetUpdaterID()
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.training_video != nil {
		edges = append(edges, document.EdgeTrainingVideo)
	}
	if m.training_video_poster != nil {
		edges = append(edges, document.EdgeTrainingVideoPoster)
	}
	if m.products_image != nil {
		edges = append(edges, document.EdgeProductsImage)
	}
	if m.installation_job_item_image != nil {
		edges = append(edges, document.EdgeInstallationJobItemImage)
	}
	if m.estimate_pdf != nil {
		edges = append(edges, document.EdgeEstimatePdf)
	}
	if m.job_estimate_pdf != nil {
		edges = append(edges, document.EdgeJobEstimatePdf)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeTrainingVideo:
		if id := m.training_video; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeTrainingVideoPoster:
		if id := m.training_video_poster; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeProductsImage:
		if id := m.products_image; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeInstallationJobItemImage:
		if id := m.installation_job_item_image; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeEstimatePdf:
		if id := m.estimate_pdf; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeJobEstimatePdf:
		if id := m.job_estimate_pdf; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtraining_video {
		edges = append(edges, document.EdgeTrainingVideo)
	}
	if m.clearedtraining_video_poster {
		edges = append(edges, document.EdgeTrainingVideoPoster)
	}
	if m.clearedproducts_image {
		edges = append(edges, document.EdgeProductsImage)
	}
	if m.clearedinstallation_job_item_image {
		edges = append(edges, document.EdgeInstallationJobItemImage)
	}
	if m.clearedestimate_pdf {
		edges = append(edges, document.EdgeEstimatePdf)
	}
	if m.clearedjob_estimate_pdf {
		edges = append(edges, document.EdgeJobEstimatePdf)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentMutation) EdgeCleared(name string) bool {
	switch name {
	case document.EdgeTrainingVideo:
		return m.clearedtraining_video
	case document.EdgeTrainingVideoPoster:
		return m.clearedtraining_video_poster
	case document.EdgeProductsImage:
		return m.clearedproducts_image
	case document.EdgeInstallationJobItemImage:
		return m.clearedinstallation_job_item_image
	case document.EdgeEstimatePdf:
		return m.clearedestimate_pdf
	case document.EdgeJobEstimatePdf:
		return m.clearedjob_estimate_pdf
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentMutation) ClearEdge(name string) error {
	switch name {
	case document.EdgeTrainingVideo:
		m.ClearTrainingVideo()
		return nil
	case document.EdgeTrainingVideoPoster:
		m.ClearTrainingVideoPoster()
		return nil
	case document.EdgeProductsImage:
		m.ClearProductsImage()
		return nil
	case document.EdgeInstallationJobItemImage:
		m.ClearInstallationJobItemImage()
		return nil
	case document.EdgeEstimatePdf:
		m.ClearEstimatePdf()
		return nil
	case document.EdgeJobEstimatePdf:
		m.ClearJobEstimatePdf()
		return nil
	}
	return fmt.Errorf("unknown Document unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentMutation) ResetEdge(name string) error {
	switch name {
	case document.EdgeTrainingVideo:
		m.ResetTrainingVideo()
		return nil
	case document.EdgeTrainingVideoPoster:
		m.ResetTrainingVideoPoster()
		return nil
	case document.EdgeProductsImage:
		m.ResetProductsImage()
		return nil
	case document.EdgeInstallationJobItemImage:
		m.ResetInstallationJobItemImage()
		return nil
	case document.EdgeEstimatePdf:
		m.ResetEstimatePdf()
		return nil
	case document.EdgeJobEstimatePdf:
		m.ResetJobEstimatePdf()
		return nil
	}
	return fmt.Errorf("unknown Document edge %s", name)
}

// EstimateMutation represents an operation that mutates the Estimate nodes in the graph.
type EstimateMutation struct {
	config
	op                             Op
	typ                            string
	id                             *string
	created_at                     *time.Time
	updated_at                     *time.Time
	region_id                      *uint8
	addregion_id                   *int8
	status                         *enum.EstimateStatus
	current_material               *string
	new_roofing_material           *string
	lowSlope                       *bool
	current_material_low_slope     *string
	new_roofing_material_low_slope *string
	redeck                         *bool
	layers                         *uint8
	addlayers                      *int8
	layer2_material                *string
	layer3_material                *string
	partial_percentage             *float64
	addpartial_percentage          *float64
	material_mapping_note          *string
	measure_type                   *enum.Measure
	extra_charge_type              *enum.ExtraCharge
	extra_charges                  *float64
	addextra_charges               *float64
	extra_charge_cond              *[]*model.ExtraChargeCondition
	appendextra_charge_cond        []*model.ExtraChargeCondition
	extra_charge_note              *string
	estimator                      *string
	estimator_order_id             *uint
	addestimator_order_id          *int
	estimator_report_id            *uint
	addestimator_report_id         *int
	total_squares                  *float64
	addtotal_squares               *float64
	primary_pitch                  *float64
	addprimary_pitch               *float64
	price                          *float64
	addprice                       *float64
	price_summary                  *string
	bounds                         *[]schema.Point
	appendbounds                   []schema.Point
	estimator_raw_response         *map[string]interface{}
	override                       *bool
	override_total_squares         *float64
	addoverride_total_squares      *float64
	override_primary_pitch         *float64
	addoverride_primary_pitch      *float64
	override_price                 *float64
	addoverride_price              *float64
	override_price_summary         *string
	company_ref_id                 *string
	company_ref_name               *string
	failure_reason                 *string
	clearedFields                  map[string]struct{}
	activities                     map[string]struct{}
	removedactivities              map[string]struct{}
	clearedactivities              bool
	job_info                       *string
	clearedjob_info                bool
	partner                        *string
	clearedpartner                 bool
	home_owner                     *string
	clearedhome_owner              bool
	sales_rep                      *string
	clearedsales_rep               bool
	creator                        *string
	clearedcreator                 bool
	creator_api                    *string
	clearedcreator_api             bool
	pdf                            *string
	clearedpdf                     bool
	done                           bool
	oldValue                       func(context.Context) (*Estimate, error)
	predicates                     []predicate.Estimate
}

var _ ent.Mutation = (*EstimateMutation)(nil)

// estimateOption allows management of the mutation configuration using functional options.
type estimateOption func(*EstimateMutation)

// newEstimateMutation creates new mutation for the Estimate entity.
func newEstimateMutation(c config, op Op, opts ...estimateOption) *EstimateMutation {
	m := &EstimateMutation{
		config:        c,
		op:            op,
		typ:           TypeEstimate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEstimateID sets the ID field of the mutation.
func withEstimateID(id string) estimateOption {
	return func(m *EstimateMutation) {
		var (
			err   error
			once  sync.Once
			value *Estimate
		)
		m.oldValue = func(ctx context.Context) (*Estimate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Estimate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEstimate sets the old Estimate of the mutation.
func withEstimate(node *Estimate) estimateOption {
	return func(m *EstimateMutation) {
		m.oldValue = func(context.Context) (*Estimate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EstimateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EstimateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Estimate entities.
func (m *EstimateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EstimateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EstimateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Estimate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EstimateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EstimateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EstimateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EstimateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EstimateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EstimateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetRegionID sets the "region_id" field.
func (m *EstimateMutation) SetRegionID(u uint8) {
	m.region_id = &u
	m.addregion_id = nil
}

// RegionID returns the value of the "region_id" field in the mutation.
func (m *EstimateMutation) RegionID() (r uint8, exists bool) {
	v := m.region_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionID returns the old "region_id" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldRegionID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionID: %w", err)
	}
	return oldValue.RegionID, nil
}

// AddRegionID adds u to the "region_id" field.
func (m *EstimateMutation) AddRegionID(u int8) {
	if m.addregion_id != nil {
		*m.addregion_id += u
	} else {
		m.addregion_id = &u
	}
}

// AddedRegionID returns the value that was added to the "region_id" field in this mutation.
func (m *EstimateMutation) AddedRegionID() (r int8, exists bool) {
	v := m.addregion_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegionID resets all changes to the "region_id" field.
func (m *EstimateMutation) ResetRegionID() {
	m.region_id = nil
	m.addregion_id = nil
}

// SetStatus sets the "status" field.
func (m *EstimateMutation) SetStatus(es enum.EstimateStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *EstimateMutation) Status() (r enum.EstimateStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldStatus(ctx context.Context) (v enum.EstimateStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EstimateMutation) ResetStatus() {
	m.status = nil
}

// SetCurrentMaterial sets the "current_material" field.
func (m *EstimateMutation) SetCurrentMaterial(s string) {
	m.current_material = &s
}

// CurrentMaterial returns the value of the "current_material" field in the mutation.
func (m *EstimateMutation) CurrentMaterial() (r string, exists bool) {
	v := m.current_material
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentMaterial returns the old "current_material" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldCurrentMaterial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentMaterial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentMaterial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentMaterial: %w", err)
	}
	return oldValue.CurrentMaterial, nil
}

// ClearCurrentMaterial clears the value of the "current_material" field.
func (m *EstimateMutation) ClearCurrentMaterial() {
	m.current_material = nil
	m.clearedFields[estimate.FieldCurrentMaterial] = struct{}{}
}

// CurrentMaterialCleared returns if the "current_material" field was cleared in this mutation.
func (m *EstimateMutation) CurrentMaterialCleared() bool {
	_, ok := m.clearedFields[estimate.FieldCurrentMaterial]
	return ok
}

// ResetCurrentMaterial resets all changes to the "current_material" field.
func (m *EstimateMutation) ResetCurrentMaterial() {
	m.current_material = nil
	delete(m.clearedFields, estimate.FieldCurrentMaterial)
}

// SetNewRoofingMaterial sets the "new_roofing_material" field.
func (m *EstimateMutation) SetNewRoofingMaterial(s string) {
	m.new_roofing_material = &s
}

// NewRoofingMaterial returns the value of the "new_roofing_material" field in the mutation.
func (m *EstimateMutation) NewRoofingMaterial() (r string, exists bool) {
	v := m.new_roofing_material
	if v == nil {
		return
	}
	return *v, true
}

// OldNewRoofingMaterial returns the old "new_roofing_material" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldNewRoofingMaterial(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewRoofingMaterial is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewRoofingMaterial requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewRoofingMaterial: %w", err)
	}
	return oldValue.NewRoofingMaterial, nil
}

// ClearNewRoofingMaterial clears the value of the "new_roofing_material" field.
func (m *EstimateMutation) ClearNewRoofingMaterial() {
	m.new_roofing_material = nil
	m.clearedFields[estimate.FieldNewRoofingMaterial] = struct{}{}
}

// NewRoofingMaterialCleared returns if the "new_roofing_material" field was cleared in this mutation.
func (m *EstimateMutation) NewRoofingMaterialCleared() bool {
	_, ok := m.clearedFields[estimate.FieldNewRoofingMaterial]
	return ok
}

// ResetNewRoofingMaterial resets all changes to the "new_roofing_material" field.
func (m *EstimateMutation) ResetNewRoofingMaterial() {
	m.new_roofing_material = nil
	delete(m.clearedFields, estimate.FieldNewRoofingMaterial)
}

// SetLowSlope sets the "lowSlope" field.
func (m *EstimateMutation) SetLowSlope(b bool) {
	m.lowSlope = &b
}

// LowSlope returns the value of the "lowSlope" field in the mutation.
func (m *EstimateMutation) LowSlope() (r bool, exists bool) {
	v := m.lowSlope
	if v == nil {
		return
	}
	return *v, true
}

// OldLowSlope returns the old "lowSlope" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldLowSlope(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLowSlope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLowSlope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLowSlope: %w", err)
	}
	return oldValue.LowSlope, nil
}

// ResetLowSlope resets all changes to the "lowSlope" field.
func (m *EstimateMutation) ResetLowSlope() {
	m.lowSlope = nil
}

// SetCurrentMaterialLowSlope sets the "current_material_low_slope" field.
func (m *EstimateMutation) SetCurrentMaterialLowSlope(s string) {
	m.current_material_low_slope = &s
}

// CurrentMaterialLowSlope returns the value of the "current_material_low_slope" field in the mutation.
func (m *EstimateMutation) CurrentMaterialLowSlope() (r string, exists bool) {
	v := m.current_material_low_slope
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentMaterialLowSlope returns the old "current_material_low_slope" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldCurrentMaterialLowSlope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrentMaterialLowSlope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrentMaterialLowSlope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentMaterialLowSlope: %w", err)
	}
	return oldValue.CurrentMaterialLowSlope, nil
}

// ClearCurrentMaterialLowSlope clears the value of the "current_material_low_slope" field.
func (m *EstimateMutation) ClearCurrentMaterialLowSlope() {
	m.current_material_low_slope = nil
	m.clearedFields[estimate.FieldCurrentMaterialLowSlope] = struct{}{}
}

// CurrentMaterialLowSlopeCleared returns if the "current_material_low_slope" field was cleared in this mutation.
func (m *EstimateMutation) CurrentMaterialLowSlopeCleared() bool {
	_, ok := m.clearedFields[estimate.FieldCurrentMaterialLowSlope]
	return ok
}

// ResetCurrentMaterialLowSlope resets all changes to the "current_material_low_slope" field.
func (m *EstimateMutation) ResetCurrentMaterialLowSlope() {
	m.current_material_low_slope = nil
	delete(m.clearedFields, estimate.FieldCurrentMaterialLowSlope)
}

// SetNewRoofingMaterialLowSlope sets the "new_roofing_material_low_slope" field.
func (m *EstimateMutation) SetNewRoofingMaterialLowSlope(s string) {
	m.new_roofing_material_low_slope = &s
}

// NewRoofingMaterialLowSlope returns the value of the "new_roofing_material_low_slope" field in the mutation.
func (m *EstimateMutation) NewRoofingMaterialLowSlope() (r string, exists bool) {
	v := m.new_roofing_material_low_slope
	if v == nil {
		return
	}
	return *v, true
}

// OldNewRoofingMaterialLowSlope returns the old "new_roofing_material_low_slope" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldNewRoofingMaterialLowSlope(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNewRoofingMaterialLowSlope is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNewRoofingMaterialLowSlope requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNewRoofingMaterialLowSlope: %w", err)
	}
	return oldValue.NewRoofingMaterialLowSlope, nil
}

// ClearNewRoofingMaterialLowSlope clears the value of the "new_roofing_material_low_slope" field.
func (m *EstimateMutation) ClearNewRoofingMaterialLowSlope() {
	m.new_roofing_material_low_slope = nil
	m.clearedFields[estimate.FieldNewRoofingMaterialLowSlope] = struct{}{}
}

// NewRoofingMaterialLowSlopeCleared returns if the "new_roofing_material_low_slope" field was cleared in this mutation.
func (m *EstimateMutation) NewRoofingMaterialLowSlopeCleared() bool {
	_, ok := m.clearedFields[estimate.FieldNewRoofingMaterialLowSlope]
	return ok
}

// ResetNewRoofingMaterialLowSlope resets all changes to the "new_roofing_material_low_slope" field.
func (m *EstimateMutation) ResetNewRoofingMaterialLowSlope() {
	m.new_roofing_material_low_slope = nil
	delete(m.clearedFields, estimate.FieldNewRoofingMaterialLowSlope)
}

// SetRedeck sets the "redeck" field.
func (m *EstimateMutation) SetRedeck(b bool) {
	m.redeck = &b
}

// Redeck returns the value of the "redeck" field in the mutation.
func (m *EstimateMutation) Redeck() (r bool, exists bool) {
	v := m.redeck
	if v == nil {
		return
	}
	return *v, true
}

// OldRedeck returns the old "redeck" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldRedeck(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedeck is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedeck requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedeck: %w", err)
	}
	return oldValue.Redeck, nil
}

// ResetRedeck resets all changes to the "redeck" field.
func (m *EstimateMutation) ResetRedeck() {
	m.redeck = nil
}

// SetLayers sets the "layers" field.
func (m *EstimateMutation) SetLayers(u uint8) {
	m.layers = &u
	m.addlayers = nil
}

// Layers returns the value of the "layers" field in the mutation.
func (m *EstimateMutation) Layers() (r uint8, exists bool) {
	v := m.layers
	if v == nil {
		return
	}
	return *v, true
}

// OldLayers returns the old "layers" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldLayers(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayers: %w", err)
	}
	return oldValue.Layers, nil
}

// AddLayers adds u to the "layers" field.
func (m *EstimateMutation) AddLayers(u int8) {
	if m.addlayers != nil {
		*m.addlayers += u
	} else {
		m.addlayers = &u
	}
}

// AddedLayers returns the value that was added to the "layers" field in this mutation.
func (m *EstimateMutation) AddedLayers() (r int8, exists bool) {
	v := m.addlayers
	if v == nil {
		return
	}
	return *v, true
}

// ResetLayers resets all changes to the "layers" field.
func (m *EstimateMutation) ResetLayers() {
	m.layers = nil
	m.addlayers = nil
}

// SetLayer2Material sets the "layer2_material" field.
func (m *EstimateMutation) SetLayer2Material(s string) {
	m.layer2_material = &s
}

// Layer2Material returns the value of the "layer2_material" field in the mutation.
func (m *EstimateMutation) Layer2Material() (r string, exists bool) {
	v := m.layer2_material
	if v == nil {
		return
	}
	return *v, true
}

// OldLayer2Material returns the old "layer2_material" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldLayer2Material(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayer2Material is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayer2Material requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayer2Material: %w", err)
	}
	return oldValue.Layer2Material, nil
}

// ClearLayer2Material clears the value of the "layer2_material" field.
func (m *EstimateMutation) ClearLayer2Material() {
	m.layer2_material = nil
	m.clearedFields[estimate.FieldLayer2Material] = struct{}{}
}

// Layer2MaterialCleared returns if the "layer2_material" field was cleared in this mutation.
func (m *EstimateMutation) Layer2MaterialCleared() bool {
	_, ok := m.clearedFields[estimate.FieldLayer2Material]
	return ok
}

// ResetLayer2Material resets all changes to the "layer2_material" field.
func (m *EstimateMutation) ResetLayer2Material() {
	m.layer2_material = nil
	delete(m.clearedFields, estimate.FieldLayer2Material)
}

// SetLayer3Material sets the "layer3_material" field.
func (m *EstimateMutation) SetLayer3Material(s string) {
	m.layer3_material = &s
}

// Layer3Material returns the value of the "layer3_material" field in the mutation.
func (m *EstimateMutation) Layer3Material() (r string, exists bool) {
	v := m.layer3_material
	if v == nil {
		return
	}
	return *v, true
}

// OldLayer3Material returns the old "layer3_material" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldLayer3Material(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLayer3Material is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLayer3Material requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLayer3Material: %w", err)
	}
	return oldValue.Layer3Material, nil
}

// ClearLayer3Material clears the value of the "layer3_material" field.
func (m *EstimateMutation) ClearLayer3Material() {
	m.layer3_material = nil
	m.clearedFields[estimate.FieldLayer3Material] = struct{}{}
}

// Layer3MaterialCleared returns if the "layer3_material" field was cleared in this mutation.
func (m *EstimateMutation) Layer3MaterialCleared() bool {
	_, ok := m.clearedFields[estimate.FieldLayer3Material]
	return ok
}

// ResetLayer3Material resets all changes to the "layer3_material" field.
func (m *EstimateMutation) ResetLayer3Material() {
	m.layer3_material = nil
	delete(m.clearedFields, estimate.FieldLayer3Material)
}

// SetPartialPercentage sets the "partial_percentage" field.
func (m *EstimateMutation) SetPartialPercentage(f float64) {
	m.partial_percentage = &f
	m.addpartial_percentage = nil
}

// PartialPercentage returns the value of the "partial_percentage" field in the mutation.
func (m *EstimateMutation) PartialPercentage() (r float64, exists bool) {
	v := m.partial_percentage
	if v == nil {
		return
	}
	return *v, true
}

// OldPartialPercentage returns the old "partial_percentage" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldPartialPercentage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartialPercentage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartialPercentage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartialPercentage: %w", err)
	}
	return oldValue.PartialPercentage, nil
}

// AddPartialPercentage adds f to the "partial_percentage" field.
func (m *EstimateMutation) AddPartialPercentage(f float64) {
	if m.addpartial_percentage != nil {
		*m.addpartial_percentage += f
	} else {
		m.addpartial_percentage = &f
	}
}

// AddedPartialPercentage returns the value that was added to the "partial_percentage" field in this mutation.
func (m *EstimateMutation) AddedPartialPercentage() (r float64, exists bool) {
	v := m.addpartial_percentage
	if v == nil {
		return
	}
	return *v, true
}

// ClearPartialPercentage clears the value of the "partial_percentage" field.
func (m *EstimateMutation) ClearPartialPercentage() {
	m.partial_percentage = nil
	m.addpartial_percentage = nil
	m.clearedFields[estimate.FieldPartialPercentage] = struct{}{}
}

// PartialPercentageCleared returns if the "partial_percentage" field was cleared in this mutation.
func (m *EstimateMutation) PartialPercentageCleared() bool {
	_, ok := m.clearedFields[estimate.FieldPartialPercentage]
	return ok
}

// ResetPartialPercentage resets all changes to the "partial_percentage" field.
func (m *EstimateMutation) ResetPartialPercentage() {
	m.partial_percentage = nil
	m.addpartial_percentage = nil
	delete(m.clearedFields, estimate.FieldPartialPercentage)
}

// SetMaterialMappingNote sets the "material_mapping_note" field.
func (m *EstimateMutation) SetMaterialMappingNote(s string) {
	m.material_mapping_note = &s
}

// MaterialMappingNote returns the value of the "material_mapping_note" field in the mutation.
func (m *EstimateMutation) MaterialMappingNote() (r string, exists bool) {
	v := m.material_mapping_note
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialMappingNote returns the old "material_mapping_note" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldMaterialMappingNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterialMappingNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterialMappingNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialMappingNote: %w", err)
	}
	return oldValue.MaterialMappingNote, nil
}

// ClearMaterialMappingNote clears the value of the "material_mapping_note" field.
func (m *EstimateMutation) ClearMaterialMappingNote() {
	m.material_mapping_note = nil
	m.clearedFields[estimate.FieldMaterialMappingNote] = struct{}{}
}

// MaterialMappingNoteCleared returns if the "material_mapping_note" field was cleared in this mutation.
func (m *EstimateMutation) MaterialMappingNoteCleared() bool {
	_, ok := m.clearedFields[estimate.FieldMaterialMappingNote]
	return ok
}

// ResetMaterialMappingNote resets all changes to the "material_mapping_note" field.
func (m *EstimateMutation) ResetMaterialMappingNote() {
	m.material_mapping_note = nil
	delete(m.clearedFields, estimate.FieldMaterialMappingNote)
}

// SetMeasureType sets the "measure_type" field.
func (m *EstimateMutation) SetMeasureType(e enum.Measure) {
	m.measure_type = &e
}

// MeasureType returns the value of the "measure_type" field in the mutation.
func (m *EstimateMutation) MeasureType() (r enum.Measure, exists bool) {
	v := m.measure_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMeasureType returns the old "measure_type" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldMeasureType(ctx context.Context) (v enum.Measure, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeasureType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeasureType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeasureType: %w", err)
	}
	return oldValue.MeasureType, nil
}

// ResetMeasureType resets all changes to the "measure_type" field.
func (m *EstimateMutation) ResetMeasureType() {
	m.measure_type = nil
}

// SetExtraChargeType sets the "extra_charge_type" field.
func (m *EstimateMutation) SetExtraChargeType(ec enum.ExtraCharge) {
	m.extra_charge_type = &ec
}

// ExtraChargeType returns the value of the "extra_charge_type" field in the mutation.
func (m *EstimateMutation) ExtraChargeType() (r enum.ExtraCharge, exists bool) {
	v := m.extra_charge_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraChargeType returns the old "extra_charge_type" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldExtraChargeType(ctx context.Context) (v enum.ExtraCharge, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraChargeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraChargeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraChargeType: %w", err)
	}
	return oldValue.ExtraChargeType, nil
}

// ClearExtraChargeType clears the value of the "extra_charge_type" field.
func (m *EstimateMutation) ClearExtraChargeType() {
	m.extra_charge_type = nil
	m.clearedFields[estimate.FieldExtraChargeType] = struct{}{}
}

// ExtraChargeTypeCleared returns if the "extra_charge_type" field was cleared in this mutation.
func (m *EstimateMutation) ExtraChargeTypeCleared() bool {
	_, ok := m.clearedFields[estimate.FieldExtraChargeType]
	return ok
}

// ResetExtraChargeType resets all changes to the "extra_charge_type" field.
func (m *EstimateMutation) ResetExtraChargeType() {
	m.extra_charge_type = nil
	delete(m.clearedFields, estimate.FieldExtraChargeType)
}

// SetExtraCharges sets the "extra_charges" field.
func (m *EstimateMutation) SetExtraCharges(f float64) {
	m.extra_charges = &f
	m.addextra_charges = nil
}

// ExtraCharges returns the value of the "extra_charges" field in the mutation.
func (m *EstimateMutation) ExtraCharges() (r float64, exists bool) {
	v := m.extra_charges
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraCharges returns the old "extra_charges" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldExtraCharges(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraCharges is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraCharges requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraCharges: %w", err)
	}
	return oldValue.ExtraCharges, nil
}

// AddExtraCharges adds f to the "extra_charges" field.
func (m *EstimateMutation) AddExtraCharges(f float64) {
	if m.addextra_charges != nil {
		*m.addextra_charges += f
	} else {
		m.addextra_charges = &f
	}
}

// AddedExtraCharges returns the value that was added to the "extra_charges" field in this mutation.
func (m *EstimateMutation) AddedExtraCharges() (r float64, exists bool) {
	v := m.addextra_charges
	if v == nil {
		return
	}
	return *v, true
}

// ClearExtraCharges clears the value of the "extra_charges" field.
func (m *EstimateMutation) ClearExtraCharges() {
	m.extra_charges = nil
	m.addextra_charges = nil
	m.clearedFields[estimate.FieldExtraCharges] = struct{}{}
}

// ExtraChargesCleared returns if the "extra_charges" field was cleared in this mutation.
func (m *EstimateMutation) ExtraChargesCleared() bool {
	_, ok := m.clearedFields[estimate.FieldExtraCharges]
	return ok
}

// ResetExtraCharges resets all changes to the "extra_charges" field.
func (m *EstimateMutation) ResetExtraCharges() {
	m.extra_charges = nil
	m.addextra_charges = nil
	delete(m.clearedFields, estimate.FieldExtraCharges)
}

// SetExtraChargeCond sets the "extra_charge_cond" field.
func (m *EstimateMutation) SetExtraChargeCond(mcc []*model.ExtraChargeCondition) {
	m.extra_charge_cond = &mcc
	m.appendextra_charge_cond = nil
}

// ExtraChargeCond returns the value of the "extra_charge_cond" field in the mutation.
func (m *EstimateMutation) ExtraChargeCond() (r []*model.ExtraChargeCondition, exists bool) {
	v := m.extra_charge_cond
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraChargeCond returns the old "extra_charge_cond" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldExtraChargeCond(ctx context.Context) (v []*model.ExtraChargeCondition, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraChargeCond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraChargeCond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraChargeCond: %w", err)
	}
	return oldValue.ExtraChargeCond, nil
}

// AppendExtraChargeCond adds mcc to the "extra_charge_cond" field.
func (m *EstimateMutation) AppendExtraChargeCond(mcc []*model.ExtraChargeCondition) {
	m.appendextra_charge_cond = append(m.appendextra_charge_cond, mcc...)
}

// AppendedExtraChargeCond returns the list of values that were appended to the "extra_charge_cond" field in this mutation.
func (m *EstimateMutation) AppendedExtraChargeCond() ([]*model.ExtraChargeCondition, bool) {
	if len(m.appendextra_charge_cond) == 0 {
		return nil, false
	}
	return m.appendextra_charge_cond, true
}

// ClearExtraChargeCond clears the value of the "extra_charge_cond" field.
func (m *EstimateMutation) ClearExtraChargeCond() {
	m.extra_charge_cond = nil
	m.appendextra_charge_cond = nil
	m.clearedFields[estimate.FieldExtraChargeCond] = struct{}{}
}

// ExtraChargeCondCleared returns if the "extra_charge_cond" field was cleared in this mutation.
func (m *EstimateMutation) ExtraChargeCondCleared() bool {
	_, ok := m.clearedFields[estimate.FieldExtraChargeCond]
	return ok
}

// ResetExtraChargeCond resets all changes to the "extra_charge_cond" field.
func (m *EstimateMutation) ResetExtraChargeCond() {
	m.extra_charge_cond = nil
	m.appendextra_charge_cond = nil
	delete(m.clearedFields, estimate.FieldExtraChargeCond)
}

// SetExtraChargeNote sets the "extra_charge_note" field.
func (m *EstimateMutation) SetExtraChargeNote(s string) {
	m.extra_charge_note = &s
}

// ExtraChargeNote returns the value of the "extra_charge_note" field in the mutation.
func (m *EstimateMutation) ExtraChargeNote() (r string, exists bool) {
	v := m.extra_charge_note
	if v == nil {
		return
	}
	return *v, true
}

// OldExtraChargeNote returns the old "extra_charge_note" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldExtraChargeNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtraChargeNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtraChargeNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtraChargeNote: %w", err)
	}
	return oldValue.ExtraChargeNote, nil
}

// ClearExtraChargeNote clears the value of the "extra_charge_note" field.
func (m *EstimateMutation) ClearExtraChargeNote() {
	m.extra_charge_note = nil
	m.clearedFields[estimate.FieldExtraChargeNote] = struct{}{}
}

// ExtraChargeNoteCleared returns if the "extra_charge_note" field was cleared in this mutation.
func (m *EstimateMutation) ExtraChargeNoteCleared() bool {
	_, ok := m.clearedFields[estimate.FieldExtraChargeNote]
	return ok
}

// ResetExtraChargeNote resets all changes to the "extra_charge_note" field.
func (m *EstimateMutation) ResetExtraChargeNote() {
	m.extra_charge_note = nil
	delete(m.clearedFields, estimate.FieldExtraChargeNote)
}

// SetEstimator sets the "estimator" field.
func (m *EstimateMutation) SetEstimator(s string) {
	m.estimator = &s
}

// Estimator returns the value of the "estimator" field in the mutation.
func (m *EstimateMutation) Estimator() (r string, exists bool) {
	v := m.estimator
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimator returns the old "estimator" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldEstimator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimator: %w", err)
	}
	return oldValue.Estimator, nil
}

// ClearEstimator clears the value of the "estimator" field.
func (m *EstimateMutation) ClearEstimator() {
	m.estimator = nil
	m.clearedFields[estimate.FieldEstimator] = struct{}{}
}

// EstimatorCleared returns if the "estimator" field was cleared in this mutation.
func (m *EstimateMutation) EstimatorCleared() bool {
	_, ok := m.clearedFields[estimate.FieldEstimator]
	return ok
}

// ResetEstimator resets all changes to the "estimator" field.
func (m *EstimateMutation) ResetEstimator() {
	m.estimator = nil
	delete(m.clearedFields, estimate.FieldEstimator)
}

// SetEstimatorOrderID sets the "estimator_order_id" field.
func (m *EstimateMutation) SetEstimatorOrderID(u uint) {
	m.estimator_order_id = &u
	m.addestimator_order_id = nil
}

// EstimatorOrderID returns the value of the "estimator_order_id" field in the mutation.
func (m *EstimateMutation) EstimatorOrderID() (r uint, exists bool) {
	v := m.estimator_order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatorOrderID returns the old "estimator_order_id" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldEstimatorOrderID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatorOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatorOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatorOrderID: %w", err)
	}
	return oldValue.EstimatorOrderID, nil
}

// AddEstimatorOrderID adds u to the "estimator_order_id" field.
func (m *EstimateMutation) AddEstimatorOrderID(u int) {
	if m.addestimator_order_id != nil {
		*m.addestimator_order_id += u
	} else {
		m.addestimator_order_id = &u
	}
}

// AddedEstimatorOrderID returns the value that was added to the "estimator_order_id" field in this mutation.
func (m *EstimateMutation) AddedEstimatorOrderID() (r int, exists bool) {
	v := m.addestimator_order_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatorOrderID clears the value of the "estimator_order_id" field.
func (m *EstimateMutation) ClearEstimatorOrderID() {
	m.estimator_order_id = nil
	m.addestimator_order_id = nil
	m.clearedFields[estimate.FieldEstimatorOrderID] = struct{}{}
}

// EstimatorOrderIDCleared returns if the "estimator_order_id" field was cleared in this mutation.
func (m *EstimateMutation) EstimatorOrderIDCleared() bool {
	_, ok := m.clearedFields[estimate.FieldEstimatorOrderID]
	return ok
}

// ResetEstimatorOrderID resets all changes to the "estimator_order_id" field.
func (m *EstimateMutation) ResetEstimatorOrderID() {
	m.estimator_order_id = nil
	m.addestimator_order_id = nil
	delete(m.clearedFields, estimate.FieldEstimatorOrderID)
}

// SetEstimatorReportID sets the "estimator_report_id" field.
func (m *EstimateMutation) SetEstimatorReportID(u uint) {
	m.estimator_report_id = &u
	m.addestimator_report_id = nil
}

// EstimatorReportID returns the value of the "estimator_report_id" field in the mutation.
func (m *EstimateMutation) EstimatorReportID() (r uint, exists bool) {
	v := m.estimator_report_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatorReportID returns the old "estimator_report_id" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldEstimatorReportID(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatorReportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatorReportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatorReportID: %w", err)
	}
	return oldValue.EstimatorReportID, nil
}

// AddEstimatorReportID adds u to the "estimator_report_id" field.
func (m *EstimateMutation) AddEstimatorReportID(u int) {
	if m.addestimator_report_id != nil {
		*m.addestimator_report_id += u
	} else {
		m.addestimator_report_id = &u
	}
}

// AddedEstimatorReportID returns the value that was added to the "estimator_report_id" field in this mutation.
func (m *EstimateMutation) AddedEstimatorReportID() (r int, exists bool) {
	v := m.addestimator_report_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearEstimatorReportID clears the value of the "estimator_report_id" field.
func (m *EstimateMutation) ClearEstimatorReportID() {
	m.estimator_report_id = nil
	m.addestimator_report_id = nil
	m.clearedFields[estimate.FieldEstimatorReportID] = struct{}{}
}

// EstimatorReportIDCleared returns if the "estimator_report_id" field was cleared in this mutation.
func (m *EstimateMutation) EstimatorReportIDCleared() bool {
	_, ok := m.clearedFields[estimate.FieldEstimatorReportID]
	return ok
}

// ResetEstimatorReportID resets all changes to the "estimator_report_id" field.
func (m *EstimateMutation) ResetEstimatorReportID() {
	m.estimator_report_id = nil
	m.addestimator_report_id = nil
	delete(m.clearedFields, estimate.FieldEstimatorReportID)
}

// SetTotalSquares sets the "total_squares" field.
func (m *EstimateMutation) SetTotalSquares(f float64) {
	m.total_squares = &f
	m.addtotal_squares = nil
}

// TotalSquares returns the value of the "total_squares" field in the mutation.
func (m *EstimateMutation) TotalSquares() (r float64, exists bool) {
	v := m.total_squares
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalSquares returns the old "total_squares" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldTotalSquares(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalSquares is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalSquares requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalSquares: %w", err)
	}
	return oldValue.TotalSquares, nil
}

// AddTotalSquares adds f to the "total_squares" field.
func (m *EstimateMutation) AddTotalSquares(f float64) {
	if m.addtotal_squares != nil {
		*m.addtotal_squares += f
	} else {
		m.addtotal_squares = &f
	}
}

// AddedTotalSquares returns the value that was added to the "total_squares" field in this mutation.
func (m *EstimateMutation) AddedTotalSquares() (r float64, exists bool) {
	v := m.addtotal_squares
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalSquares resets all changes to the "total_squares" field.
func (m *EstimateMutation) ResetTotalSquares() {
	m.total_squares = nil
	m.addtotal_squares = nil
}

// SetPrimaryPitch sets the "primary_pitch" field.
func (m *EstimateMutation) SetPrimaryPitch(f float64) {
	m.primary_pitch = &f
	m.addprimary_pitch = nil
}

// PrimaryPitch returns the value of the "primary_pitch" field in the mutation.
func (m *EstimateMutation) PrimaryPitch() (r float64, exists bool) {
	v := m.primary_pitch
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryPitch returns the old "primary_pitch" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldPrimaryPitch(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryPitch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryPitch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryPitch: %w", err)
	}
	return oldValue.PrimaryPitch, nil
}

// AddPrimaryPitch adds f to the "primary_pitch" field.
func (m *EstimateMutation) AddPrimaryPitch(f float64) {
	if m.addprimary_pitch != nil {
		*m.addprimary_pitch += f
	} else {
		m.addprimary_pitch = &f
	}
}

// AddedPrimaryPitch returns the value that was added to the "primary_pitch" field in this mutation.
func (m *EstimateMutation) AddedPrimaryPitch() (r float64, exists bool) {
	v := m.addprimary_pitch
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrimaryPitch resets all changes to the "primary_pitch" field.
func (m *EstimateMutation) ResetPrimaryPitch() {
	m.primary_pitch = nil
	m.addprimary_pitch = nil
}

// SetPrice sets the "price" field.
func (m *EstimateMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *EstimateMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *EstimateMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *EstimateMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *EstimateMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetPriceSummary sets the "price_summary" field.
func (m *EstimateMutation) SetPriceSummary(s string) {
	m.price_summary = &s
}

// PriceSummary returns the value of the "price_summary" field in the mutation.
func (m *EstimateMutation) PriceSummary() (r string, exists bool) {
	v := m.price_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceSummary returns the old "price_summary" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldPriceSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceSummary: %w", err)
	}
	return oldValue.PriceSummary, nil
}

// ClearPriceSummary clears the value of the "price_summary" field.
func (m *EstimateMutation) ClearPriceSummary() {
	m.price_summary = nil
	m.clearedFields[estimate.FieldPriceSummary] = struct{}{}
}

// PriceSummaryCleared returns if the "price_summary" field was cleared in this mutation.
func (m *EstimateMutation) PriceSummaryCleared() bool {
	_, ok := m.clearedFields[estimate.FieldPriceSummary]
	return ok
}

// ResetPriceSummary resets all changes to the "price_summary" field.
func (m *EstimateMutation) ResetPriceSummary() {
	m.price_summary = nil
	delete(m.clearedFields, estimate.FieldPriceSummary)
}

// SetBounds sets the "bounds" field.
func (m *EstimateMutation) SetBounds(s []schema.Point) {
	m.bounds = &s
	m.appendbounds = nil
}

// Bounds returns the value of the "bounds" field in the mutation.
func (m *EstimateMutation) Bounds() (r []schema.Point, exists bool) {
	v := m.bounds
	if v == nil {
		return
	}
	return *v, true
}

// OldBounds returns the old "bounds" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldBounds(ctx context.Context) (v []schema.Point, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBounds is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBounds requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBounds: %w", err)
	}
	return oldValue.Bounds, nil
}

// AppendBounds adds s to the "bounds" field.
func (m *EstimateMutation) AppendBounds(s []schema.Point) {
	m.appendbounds = append(m.appendbounds, s...)
}

// AppendedBounds returns the list of values that were appended to the "bounds" field in this mutation.
func (m *EstimateMutation) AppendedBounds() ([]schema.Point, bool) {
	if len(m.appendbounds) == 0 {
		return nil, false
	}
	return m.appendbounds, true
}

// ClearBounds clears the value of the "bounds" field.
func (m *EstimateMutation) ClearBounds() {
	m.bounds = nil
	m.appendbounds = nil
	m.clearedFields[estimate.FieldBounds] = struct{}{}
}

// BoundsCleared returns if the "bounds" field was cleared in this mutation.
func (m *EstimateMutation) BoundsCleared() bool {
	_, ok := m.clearedFields[estimate.FieldBounds]
	return ok
}

// ResetBounds resets all changes to the "bounds" field.
func (m *EstimateMutation) ResetBounds() {
	m.bounds = nil
	m.appendbounds = nil
	delete(m.clearedFields, estimate.FieldBounds)
}

// SetEstimatorRawResponse sets the "estimator_raw_response" field.
func (m *EstimateMutation) SetEstimatorRawResponse(value map[string]interface{}) {
	m.estimator_raw_response = &value
}

// EstimatorRawResponse returns the value of the "estimator_raw_response" field in the mutation.
func (m *EstimateMutation) EstimatorRawResponse() (r map[string]interface{}, exists bool) {
	v := m.estimator_raw_response
	if v == nil {
		return
	}
	return *v, true
}

// OldEstimatorRawResponse returns the old "estimator_raw_response" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldEstimatorRawResponse(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstimatorRawResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstimatorRawResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstimatorRawResponse: %w", err)
	}
	return oldValue.EstimatorRawResponse, nil
}

// ClearEstimatorRawResponse clears the value of the "estimator_raw_response" field.
func (m *EstimateMutation) ClearEstimatorRawResponse() {
	m.estimator_raw_response = nil
	m.clearedFields[estimate.FieldEstimatorRawResponse] = struct{}{}
}

// EstimatorRawResponseCleared returns if the "estimator_raw_response" field was cleared in this mutation.
func (m *EstimateMutation) EstimatorRawResponseCleared() bool {
	_, ok := m.clearedFields[estimate.FieldEstimatorRawResponse]
	return ok
}

// ResetEstimatorRawResponse resets all changes to the "estimator_raw_response" field.
func (m *EstimateMutation) ResetEstimatorRawResponse() {
	m.estimator_raw_response = nil
	delete(m.clearedFields, estimate.FieldEstimatorRawResponse)
}

// SetOverride sets the "override" field.
func (m *EstimateMutation) SetOverride(b bool) {
	m.override = &b
}

// Override returns the value of the "override" field in the mutation.
func (m *EstimateMutation) Override() (r bool, exists bool) {
	v := m.override
	if v == nil {
		return
	}
	return *v, true
}

// OldOverride returns the old "override" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldOverride(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverride is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverride requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverride: %w", err)
	}
	return oldValue.Override, nil
}

// ClearOverride clears the value of the "override" field.
func (m *EstimateMutation) ClearOverride() {
	m.override = nil
	m.clearedFields[estimate.FieldOverride] = struct{}{}
}

// OverrideCleared returns if the "override" field was cleared in this mutation.
func (m *EstimateMutation) OverrideCleared() bool {
	_, ok := m.clearedFields[estimate.FieldOverride]
	return ok
}

// ResetOverride resets all changes to the "override" field.
func (m *EstimateMutation) ResetOverride() {
	m.override = nil
	delete(m.clearedFields, estimate.FieldOverride)
}

// SetOverrideTotalSquares sets the "override_total_squares" field.
func (m *EstimateMutation) SetOverrideTotalSquares(f float64) {
	m.override_total_squares = &f
	m.addoverride_total_squares = nil
}

// OverrideTotalSquares returns the value of the "override_total_squares" field in the mutation.
func (m *EstimateMutation) OverrideTotalSquares() (r float64, exists bool) {
	v := m.override_total_squares
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideTotalSquares returns the old "override_total_squares" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldOverrideTotalSquares(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverrideTotalSquares is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverrideTotalSquares requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideTotalSquares: %w", err)
	}
	return oldValue.OverrideTotalSquares, nil
}

// AddOverrideTotalSquares adds f to the "override_total_squares" field.
func (m *EstimateMutation) AddOverrideTotalSquares(f float64) {
	if m.addoverride_total_squares != nil {
		*m.addoverride_total_squares += f
	} else {
		m.addoverride_total_squares = &f
	}
}

// AddedOverrideTotalSquares returns the value that was added to the "override_total_squares" field in this mutation.
func (m *EstimateMutation) AddedOverrideTotalSquares() (r float64, exists bool) {
	v := m.addoverride_total_squares
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverrideTotalSquares resets all changes to the "override_total_squares" field.
func (m *EstimateMutation) ResetOverrideTotalSquares() {
	m.override_total_squares = nil
	m.addoverride_total_squares = nil
}

// SetOverridePrimaryPitch sets the "override_primary_pitch" field.
func (m *EstimateMutation) SetOverridePrimaryPitch(f float64) {
	m.override_primary_pitch = &f
	m.addoverride_primary_pitch = nil
}

// OverridePrimaryPitch returns the value of the "override_primary_pitch" field in the mutation.
func (m *EstimateMutation) OverridePrimaryPitch() (r float64, exists bool) {
	v := m.override_primary_pitch
	if v == nil {
		return
	}
	return *v, true
}

// OldOverridePrimaryPitch returns the old "override_primary_pitch" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldOverridePrimaryPitch(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverridePrimaryPitch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverridePrimaryPitch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverridePrimaryPitch: %w", err)
	}
	return oldValue.OverridePrimaryPitch, nil
}

// AddOverridePrimaryPitch adds f to the "override_primary_pitch" field.
func (m *EstimateMutation) AddOverridePrimaryPitch(f float64) {
	if m.addoverride_primary_pitch != nil {
		*m.addoverride_primary_pitch += f
	} else {
		m.addoverride_primary_pitch = &f
	}
}

// AddedOverridePrimaryPitch returns the value that was added to the "override_primary_pitch" field in this mutation.
func (m *EstimateMutation) AddedOverridePrimaryPitch() (r float64, exists bool) {
	v := m.addoverride_primary_pitch
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverridePrimaryPitch resets all changes to the "override_primary_pitch" field.
func (m *EstimateMutation) ResetOverridePrimaryPitch() {
	m.override_primary_pitch = nil
	m.addoverride_primary_pitch = nil
}

// SetOverridePrice sets the "override_price" field.
func (m *EstimateMutation) SetOverridePrice(f float64) {
	m.override_price = &f
	m.addoverride_price = nil
}

// OverridePrice returns the value of the "override_price" field in the mutation.
func (m *EstimateMutation) OverridePrice() (r float64, exists bool) {
	v := m.override_price
	if v == nil {
		return
	}
	return *v, true
}

// OldOverridePrice returns the old "override_price" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldOverridePrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverridePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverridePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverridePrice: %w", err)
	}
	return oldValue.OverridePrice, nil
}

// AddOverridePrice adds f to the "override_price" field.
func (m *EstimateMutation) AddOverridePrice(f float64) {
	if m.addoverride_price != nil {
		*m.addoverride_price += f
	} else {
		m.addoverride_price = &f
	}
}

// AddedOverridePrice returns the value that was added to the "override_price" field in this mutation.
func (m *EstimateMutation) AddedOverridePrice() (r float64, exists bool) {
	v := m.addoverride_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetOverridePrice resets all changes to the "override_price" field.
func (m *EstimateMutation) ResetOverridePrice() {
	m.override_price = nil
	m.addoverride_price = nil
}

// SetOverridePriceSummary sets the "override_price_summary" field.
func (m *EstimateMutation) SetOverridePriceSummary(s string) {
	m.override_price_summary = &s
}

// OverridePriceSummary returns the value of the "override_price_summary" field in the mutation.
func (m *EstimateMutation) OverridePriceSummary() (r string, exists bool) {
	v := m.override_price_summary
	if v == nil {
		return
	}
	return *v, true
}

// OldOverridePriceSummary returns the old "override_price_summary" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldOverridePriceSummary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverridePriceSummary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverridePriceSummary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverridePriceSummary: %w", err)
	}
	return oldValue.OverridePriceSummary, nil
}

// ClearOverridePriceSummary clears the value of the "override_price_summary" field.
func (m *EstimateMutation) ClearOverridePriceSummary() {
	m.override_price_summary = nil
	m.clearedFields[estimate.FieldOverridePriceSummary] = struct{}{}
}

// OverridePriceSummaryCleared returns if the "override_price_summary" field was cleared in this mutation.
func (m *EstimateMutation) OverridePriceSummaryCleared() bool {
	_, ok := m.clearedFields[estimate.FieldOverridePriceSummary]
	return ok
}

// ResetOverridePriceSummary resets all changes to the "override_price_summary" field.
func (m *EstimateMutation) ResetOverridePriceSummary() {
	m.override_price_summary = nil
	delete(m.clearedFields, estimate.FieldOverridePriceSummary)
}

// SetCompanyRefID sets the "company_ref_id" field.
func (m *EstimateMutation) SetCompanyRefID(s string) {
	m.company_ref_id = &s
}

// CompanyRefID returns the value of the "company_ref_id" field in the mutation.
func (m *EstimateMutation) CompanyRefID() (r string, exists bool) {
	v := m.company_ref_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyRefID returns the old "company_ref_id" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldCompanyRefID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyRefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyRefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyRefID: %w", err)
	}
	return oldValue.CompanyRefID, nil
}

// ClearCompanyRefID clears the value of the "company_ref_id" field.
func (m *EstimateMutation) ClearCompanyRefID() {
	m.company_ref_id = nil
	m.clearedFields[estimate.FieldCompanyRefID] = struct{}{}
}

// CompanyRefIDCleared returns if the "company_ref_id" field was cleared in this mutation.
func (m *EstimateMutation) CompanyRefIDCleared() bool {
	_, ok := m.clearedFields[estimate.FieldCompanyRefID]
	return ok
}

// ResetCompanyRefID resets all changes to the "company_ref_id" field.
func (m *EstimateMutation) ResetCompanyRefID() {
	m.company_ref_id = nil
	delete(m.clearedFields, estimate.FieldCompanyRefID)
}

// SetCompanyRefName sets the "company_ref_name" field.
func (m *EstimateMutation) SetCompanyRefName(s string) {
	m.company_ref_name = &s
}

// CompanyRefName returns the value of the "company_ref_name" field in the mutation.
func (m *EstimateMutation) CompanyRefName() (r string, exists bool) {
	v := m.company_ref_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyRefName returns the old "company_ref_name" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldCompanyRefName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyRefName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyRefName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyRefName: %w", err)
	}
	return oldValue.CompanyRefName, nil
}

// ClearCompanyRefName clears the value of the "company_ref_name" field.
func (m *EstimateMutation) ClearCompanyRefName() {
	m.company_ref_name = nil
	m.clearedFields[estimate.FieldCompanyRefName] = struct{}{}
}

// CompanyRefNameCleared returns if the "company_ref_name" field was cleared in this mutation.
func (m *EstimateMutation) CompanyRefNameCleared() bool {
	_, ok := m.clearedFields[estimate.FieldCompanyRefName]
	return ok
}

// ResetCompanyRefName resets all changes to the "company_ref_name" field.
func (m *EstimateMutation) ResetCompanyRefName() {
	m.company_ref_name = nil
	delete(m.clearedFields, estimate.FieldCompanyRefName)
}

// SetFailureReason sets the "failure_reason" field.
func (m *EstimateMutation) SetFailureReason(s string) {
	m.failure_reason = &s
}

// FailureReason returns the value of the "failure_reason" field in the mutation.
func (m *EstimateMutation) FailureReason() (r string, exists bool) {
	v := m.failure_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldFailureReason returns the old "failure_reason" field's value of the Estimate entity.
// If the Estimate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateMutation) OldFailureReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFailureReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFailureReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFailureReason: %w", err)
	}
	return oldValue.FailureReason, nil
}

// ClearFailureReason clears the value of the "failure_reason" field.
func (m *EstimateMutation) ClearFailureReason() {
	m.failure_reason = nil
	m.clearedFields[estimate.FieldFailureReason] = struct{}{}
}

// FailureReasonCleared returns if the "failure_reason" field was cleared in this mutation.
func (m *EstimateMutation) FailureReasonCleared() bool {
	_, ok := m.clearedFields[estimate.FieldFailureReason]
	return ok
}

// ResetFailureReason resets all changes to the "failure_reason" field.
func (m *EstimateMutation) ResetFailureReason() {
	m.failure_reason = nil
	delete(m.clearedFields, estimate.FieldFailureReason)
}

// AddActivityIDs adds the "activities" edge to the EstimateActivity entity by ids.
func (m *EstimateMutation) AddActivityIDs(ids ...string) {
	if m.activities == nil {
		m.activities = make(map[string]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the EstimateActivity entity.
func (m *EstimateMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the EstimateActivity entity was cleared.
func (m *EstimateMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the EstimateActivity entity by IDs.
func (m *EstimateMutation) RemoveActivityIDs(ids ...string) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the EstimateActivity entity.
func (m *EstimateMutation) RemovedActivitiesIDs() (ids []string) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *EstimateMutation) ActivitiesIDs() (ids []string) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *EstimateMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// SetJobInfoID sets the "job_info" edge to the Job entity by id.
func (m *EstimateMutation) SetJobInfoID(id string) {
	m.job_info = &id
}

// ClearJobInfo clears the "job_info" edge to the Job entity.
func (m *EstimateMutation) ClearJobInfo() {
	m.clearedjob_info = true
}

// JobInfoCleared reports if the "job_info" edge to the Job entity was cleared.
func (m *EstimateMutation) JobInfoCleared() bool {
	return m.clearedjob_info
}

// JobInfoID returns the "job_info" edge ID in the mutation.
func (m *EstimateMutation) JobInfoID() (id string, exists bool) {
	if m.job_info != nil {
		return *m.job_info, true
	}
	return
}

// JobInfoIDs returns the "job_info" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobInfoID instead. It exists only for internal usage by the builders.
func (m *EstimateMutation) JobInfoIDs() (ids []string) {
	if id := m.job_info; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJobInfo resets all changes to the "job_info" edge.
func (m *EstimateMutation) ResetJobInfo() {
	m.job_info = nil
	m.clearedjob_info = false
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *EstimateMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *EstimateMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *EstimateMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *EstimateMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *EstimateMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *EstimateMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// SetHomeOwnerID sets the "home_owner" edge to the HomeOwner entity by id.
func (m *EstimateMutation) SetHomeOwnerID(id string) {
	m.home_owner = &id
}

// ClearHomeOwner clears the "home_owner" edge to the HomeOwner entity.
func (m *EstimateMutation) ClearHomeOwner() {
	m.clearedhome_owner = true
}

// HomeOwnerCleared reports if the "home_owner" edge to the HomeOwner entity was cleared.
func (m *EstimateMutation) HomeOwnerCleared() bool {
	return m.clearedhome_owner
}

// HomeOwnerID returns the "home_owner" edge ID in the mutation.
func (m *EstimateMutation) HomeOwnerID() (id string, exists bool) {
	if m.home_owner != nil {
		return *m.home_owner, true
	}
	return
}

// HomeOwnerIDs returns the "home_owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HomeOwnerID instead. It exists only for internal usage by the builders.
func (m *EstimateMutation) HomeOwnerIDs() (ids []string) {
	if id := m.home_owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHomeOwner resets all changes to the "home_owner" edge.
func (m *EstimateMutation) ResetHomeOwner() {
	m.home_owner = nil
	m.clearedhome_owner = false
}

// SetSalesRepID sets the "sales_rep" edge to the User entity by id.
func (m *EstimateMutation) SetSalesRepID(id string) {
	m.sales_rep = &id
}

// ClearSalesRep clears the "sales_rep" edge to the User entity.
func (m *EstimateMutation) ClearSalesRep() {
	m.clearedsales_rep = true
}

// SalesRepCleared reports if the "sales_rep" edge to the User entity was cleared.
func (m *EstimateMutation) SalesRepCleared() bool {
	return m.clearedsales_rep
}

// SalesRepID returns the "sales_rep" edge ID in the mutation.
func (m *EstimateMutation) SalesRepID() (id string, exists bool) {
	if m.sales_rep != nil {
		return *m.sales_rep, true
	}
	return
}

// SalesRepIDs returns the "sales_rep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SalesRepID instead. It exists only for internal usage by the builders.
func (m *EstimateMutation) SalesRepIDs() (ids []string) {
	if id := m.sales_rep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSalesRep resets all changes to the "sales_rep" edge.
func (m *EstimateMutation) ResetSalesRep() {
	m.sales_rep = nil
	m.clearedsales_rep = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *EstimateMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *EstimateMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *EstimateMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *EstimateMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EstimateMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EstimateMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetCreatorAPIID sets the "creator_api" edge to the ApiUser entity by id.
func (m *EstimateMutation) SetCreatorAPIID(id string) {
	m.creator_api = &id
}

// ClearCreatorAPI clears the "creator_api" edge to the ApiUser entity.
func (m *EstimateMutation) ClearCreatorAPI() {
	m.clearedcreator_api = true
}

// CreatorAPICleared reports if the "creator_api" edge to the ApiUser entity was cleared.
func (m *EstimateMutation) CreatorAPICleared() bool {
	return m.clearedcreator_api
}

// CreatorAPIID returns the "creator_api" edge ID in the mutation.
func (m *EstimateMutation) CreatorAPIID() (id string, exists bool) {
	if m.creator_api != nil {
		return *m.creator_api, true
	}
	return
}

// CreatorAPIIDs returns the "creator_api" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorAPIID instead. It exists only for internal usage by the builders.
func (m *EstimateMutation) CreatorAPIIDs() (ids []string) {
	if id := m.creator_api; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatorAPI resets all changes to the "creator_api" edge.
func (m *EstimateMutation) ResetCreatorAPI() {
	m.creator_api = nil
	m.clearedcreator_api = false
}

// SetPdfID sets the "pdf" edge to the Document entity by id.
func (m *EstimateMutation) SetPdfID(id string) {
	m.pdf = &id
}

// ClearPdf clears the "pdf" edge to the Document entity.
func (m *EstimateMutation) ClearPdf() {
	m.clearedpdf = true
}

// PdfCleared reports if the "pdf" edge to the Document entity was cleared.
func (m *EstimateMutation) PdfCleared() bool {
	return m.clearedpdf
}

// PdfID returns the "pdf" edge ID in the mutation.
func (m *EstimateMutation) PdfID() (id string, exists bool) {
	if m.pdf != nil {
		return *m.pdf, true
	}
	return
}

// PdfIDs returns the "pdf" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PdfID instead. It exists only for internal usage by the builders.
func (m *EstimateMutation) PdfIDs() (ids []string) {
	if id := m.pdf; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPdf resets all changes to the "pdf" edge.
func (m *EstimateMutation) ResetPdf() {
	m.pdf = nil
	m.clearedpdf = false
}

// Where appends a list predicates to the EstimateMutation builder.
func (m *EstimateMutation) Where(ps ...predicate.Estimate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EstimateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EstimateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Estimate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EstimateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EstimateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Estimate).
func (m *EstimateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EstimateMutation) Fields() []string {
	fields := make([]string, 0, 37)
	if m.created_at != nil {
		fields = append(fields, estimate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, estimate.FieldUpdatedAt)
	}
	if m.region_id != nil {
		fields = append(fields, estimate.FieldRegionID)
	}
	if m.status != nil {
		fields = append(fields, estimate.FieldStatus)
	}
	if m.current_material != nil {
		fields = append(fields, estimate.FieldCurrentMaterial)
	}
	if m.new_roofing_material != nil {
		fields = append(fields, estimate.FieldNewRoofingMaterial)
	}
	if m.lowSlope != nil {
		fields = append(fields, estimate.FieldLowSlope)
	}
	if m.current_material_low_slope != nil {
		fields = append(fields, estimate.FieldCurrentMaterialLowSlope)
	}
	if m.new_roofing_material_low_slope != nil {
		fields = append(fields, estimate.FieldNewRoofingMaterialLowSlope)
	}
	if m.redeck != nil {
		fields = append(fields, estimate.FieldRedeck)
	}
	if m.layers != nil {
		fields = append(fields, estimate.FieldLayers)
	}
	if m.layer2_material != nil {
		fields = append(fields, estimate.FieldLayer2Material)
	}
	if m.layer3_material != nil {
		fields = append(fields, estimate.FieldLayer3Material)
	}
	if m.partial_percentage != nil {
		fields = append(fields, estimate.FieldPartialPercentage)
	}
	if m.material_mapping_note != nil {
		fields = append(fields, estimate.FieldMaterialMappingNote)
	}
	if m.measure_type != nil {
		fields = append(fields, estimate.FieldMeasureType)
	}
	if m.extra_charge_type != nil {
		fields = append(fields, estimate.FieldExtraChargeType)
	}
	if m.extra_charges != nil {
		fields = append(fields, estimate.FieldExtraCharges)
	}
	if m.extra_charge_cond != nil {
		fields = append(fields, estimate.FieldExtraChargeCond)
	}
	if m.extra_charge_note != nil {
		fields = append(fields, estimate.FieldExtraChargeNote)
	}
	if m.estimator != nil {
		fields = append(fields, estimate.FieldEstimator)
	}
	if m.estimator_order_id != nil {
		fields = append(fields, estimate.FieldEstimatorOrderID)
	}
	if m.estimator_report_id != nil {
		fields = append(fields, estimate.FieldEstimatorReportID)
	}
	if m.total_squares != nil {
		fields = append(fields, estimate.FieldTotalSquares)
	}
	if m.primary_pitch != nil {
		fields = append(fields, estimate.FieldPrimaryPitch)
	}
	if m.price != nil {
		fields = append(fields, estimate.FieldPrice)
	}
	if m.price_summary != nil {
		fields = append(fields, estimate.FieldPriceSummary)
	}
	if m.bounds != nil {
		fields = append(fields, estimate.FieldBounds)
	}
	if m.estimator_raw_response != nil {
		fields = append(fields, estimate.FieldEstimatorRawResponse)
	}
	if m.override != nil {
		fields = append(fields, estimate.FieldOverride)
	}
	if m.override_total_squares != nil {
		fields = append(fields, estimate.FieldOverrideTotalSquares)
	}
	if m.override_primary_pitch != nil {
		fields = append(fields, estimate.FieldOverridePrimaryPitch)
	}
	if m.override_price != nil {
		fields = append(fields, estimate.FieldOverridePrice)
	}
	if m.override_price_summary != nil {
		fields = append(fields, estimate.FieldOverridePriceSummary)
	}
	if m.company_ref_id != nil {
		fields = append(fields, estimate.FieldCompanyRefID)
	}
	if m.company_ref_name != nil {
		fields = append(fields, estimate.FieldCompanyRefName)
	}
	if m.failure_reason != nil {
		fields = append(fields, estimate.FieldFailureReason)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EstimateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case estimate.FieldCreatedAt:
		return m.CreatedAt()
	case estimate.FieldUpdatedAt:
		return m.UpdatedAt()
	case estimate.FieldRegionID:
		return m.RegionID()
	case estimate.FieldStatus:
		return m.Status()
	case estimate.FieldCurrentMaterial:
		return m.CurrentMaterial()
	case estimate.FieldNewRoofingMaterial:
		return m.NewRoofingMaterial()
	case estimate.FieldLowSlope:
		return m.LowSlope()
	case estimate.FieldCurrentMaterialLowSlope:
		return m.CurrentMaterialLowSlope()
	case estimate.FieldNewRoofingMaterialLowSlope:
		return m.NewRoofingMaterialLowSlope()
	case estimate.FieldRedeck:
		return m.Redeck()
	case estimate.FieldLayers:
		return m.Layers()
	case estimate.FieldLayer2Material:
		return m.Layer2Material()
	case estimate.FieldLayer3Material:
		return m.Layer3Material()
	case estimate.FieldPartialPercentage:
		return m.PartialPercentage()
	case estimate.FieldMaterialMappingNote:
		return m.MaterialMappingNote()
	case estimate.FieldMeasureType:
		return m.MeasureType()
	case estimate.FieldExtraChargeType:
		return m.ExtraChargeType()
	case estimate.FieldExtraCharges:
		return m.ExtraCharges()
	case estimate.FieldExtraChargeCond:
		return m.ExtraChargeCond()
	case estimate.FieldExtraChargeNote:
		return m.ExtraChargeNote()
	case estimate.FieldEstimator:
		return m.Estimator()
	case estimate.FieldEstimatorOrderID:
		return m.EstimatorOrderID()
	case estimate.FieldEstimatorReportID:
		return m.EstimatorReportID()
	case estimate.FieldTotalSquares:
		return m.TotalSquares()
	case estimate.FieldPrimaryPitch:
		return m.PrimaryPitch()
	case estimate.FieldPrice:
		return m.Price()
	case estimate.FieldPriceSummary:
		return m.PriceSummary()
	case estimate.FieldBounds:
		return m.Bounds()
	case estimate.FieldEstimatorRawResponse:
		return m.EstimatorRawResponse()
	case estimate.FieldOverride:
		return m.Override()
	case estimate.FieldOverrideTotalSquares:
		return m.OverrideTotalSquares()
	case estimate.FieldOverridePrimaryPitch:
		return m.OverridePrimaryPitch()
	case estimate.FieldOverridePrice:
		return m.OverridePrice()
	case estimate.FieldOverridePriceSummary:
		return m.OverridePriceSummary()
	case estimate.FieldCompanyRefID:
		return m.CompanyRefID()
	case estimate.FieldCompanyRefName:
		return m.CompanyRefName()
	case estimate.FieldFailureReason:
		return m.FailureReason()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EstimateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case estimate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case estimate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case estimate.FieldRegionID:
		return m.OldRegionID(ctx)
	case estimate.FieldStatus:
		return m.OldStatus(ctx)
	case estimate.FieldCurrentMaterial:
		return m.OldCurrentMaterial(ctx)
	case estimate.FieldNewRoofingMaterial:
		return m.OldNewRoofingMaterial(ctx)
	case estimate.FieldLowSlope:
		return m.OldLowSlope(ctx)
	case estimate.FieldCurrentMaterialLowSlope:
		return m.OldCurrentMaterialLowSlope(ctx)
	case estimate.FieldNewRoofingMaterialLowSlope:
		return m.OldNewRoofingMaterialLowSlope(ctx)
	case estimate.FieldRedeck:
		return m.OldRedeck(ctx)
	case estimate.FieldLayers:
		return m.OldLayers(ctx)
	case estimate.FieldLayer2Material:
		return m.OldLayer2Material(ctx)
	case estimate.FieldLayer3Material:
		return m.OldLayer3Material(ctx)
	case estimate.FieldPartialPercentage:
		return m.OldPartialPercentage(ctx)
	case estimate.FieldMaterialMappingNote:
		return m.OldMaterialMappingNote(ctx)
	case estimate.FieldMeasureType:
		return m.OldMeasureType(ctx)
	case estimate.FieldExtraChargeType:
		return m.OldExtraChargeType(ctx)
	case estimate.FieldExtraCharges:
		return m.OldExtraCharges(ctx)
	case estimate.FieldExtraChargeCond:
		return m.OldExtraChargeCond(ctx)
	case estimate.FieldExtraChargeNote:
		return m.OldExtraChargeNote(ctx)
	case estimate.FieldEstimator:
		return m.OldEstimator(ctx)
	case estimate.FieldEstimatorOrderID:
		return m.OldEstimatorOrderID(ctx)
	case estimate.FieldEstimatorReportID:
		return m.OldEstimatorReportID(ctx)
	case estimate.FieldTotalSquares:
		return m.OldTotalSquares(ctx)
	case estimate.FieldPrimaryPitch:
		return m.OldPrimaryPitch(ctx)
	case estimate.FieldPrice:
		return m.OldPrice(ctx)
	case estimate.FieldPriceSummary:
		return m.OldPriceSummary(ctx)
	case estimate.FieldBounds:
		return m.OldBounds(ctx)
	case estimate.FieldEstimatorRawResponse:
		return m.OldEstimatorRawResponse(ctx)
	case estimate.FieldOverride:
		return m.OldOverride(ctx)
	case estimate.FieldOverrideTotalSquares:
		return m.OldOverrideTotalSquares(ctx)
	case estimate.FieldOverridePrimaryPitch:
		return m.OldOverridePrimaryPitch(ctx)
	case estimate.FieldOverridePrice:
		return m.OldOverridePrice(ctx)
	case estimate.FieldOverridePriceSummary:
		return m.OldOverridePriceSummary(ctx)
	case estimate.FieldCompanyRefID:
		return m.OldCompanyRefID(ctx)
	case estimate.FieldCompanyRefName:
		return m.OldCompanyRefName(ctx)
	case estimate.FieldFailureReason:
		return m.OldFailureReason(ctx)
	}
	return nil, fmt.Errorf("unknown Estimate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EstimateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case estimate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case estimate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case estimate.FieldRegionID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionID(v)
		return nil
	case estimate.FieldStatus:
		v, ok := value.(enum.EstimateStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case estimate.FieldCurrentMaterial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentMaterial(v)
		return nil
	case estimate.FieldNewRoofingMaterial:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewRoofingMaterial(v)
		return nil
	case estimate.FieldLowSlope:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLowSlope(v)
		return nil
	case estimate.FieldCurrentMaterialLowSlope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentMaterialLowSlope(v)
		return nil
	case estimate.FieldNewRoofingMaterialLowSlope:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNewRoofingMaterialLowSlope(v)
		return nil
	case estimate.FieldRedeck:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedeck(v)
		return nil
	case estimate.FieldLayers:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayers(v)
		return nil
	case estimate.FieldLayer2Material:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayer2Material(v)
		return nil
	case estimate.FieldLayer3Material:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLayer3Material(v)
		return nil
	case estimate.FieldPartialPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartialPercentage(v)
		return nil
	case estimate.FieldMaterialMappingNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialMappingNote(v)
		return nil
	case estimate.FieldMeasureType:
		v, ok := value.(enum.Measure)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeasureType(v)
		return nil
	case estimate.FieldExtraChargeType:
		v, ok := value.(enum.ExtraCharge)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraChargeType(v)
		return nil
	case estimate.FieldExtraCharges:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraCharges(v)
		return nil
	case estimate.FieldExtraChargeCond:
		v, ok := value.([]*model.ExtraChargeCondition)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraChargeCond(v)
		return nil
	case estimate.FieldExtraChargeNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtraChargeNote(v)
		return nil
	case estimate.FieldEstimator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimator(v)
		return nil
	case estimate.FieldEstimatorOrderID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatorOrderID(v)
		return nil
	case estimate.FieldEstimatorReportID:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatorReportID(v)
		return nil
	case estimate.FieldTotalSquares:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalSquares(v)
		return nil
	case estimate.FieldPrimaryPitch:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryPitch(v)
		return nil
	case estimate.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case estimate.FieldPriceSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceSummary(v)
		return nil
	case estimate.FieldBounds:
		v, ok := value.([]schema.Point)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBounds(v)
		return nil
	case estimate.FieldEstimatorRawResponse:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstimatorRawResponse(v)
		return nil
	case estimate.FieldOverride:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverride(v)
		return nil
	case estimate.FieldOverrideTotalSquares:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideTotalSquares(v)
		return nil
	case estimate.FieldOverridePrimaryPitch:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverridePrimaryPitch(v)
		return nil
	case estimate.FieldOverridePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverridePrice(v)
		return nil
	case estimate.FieldOverridePriceSummary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverridePriceSummary(v)
		return nil
	case estimate.FieldCompanyRefID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyRefID(v)
		return nil
	case estimate.FieldCompanyRefName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyRefName(v)
		return nil
	case estimate.FieldFailureReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFailureReason(v)
		return nil
	}
	return fmt.Errorf("unknown Estimate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EstimateMutation) AddedFields() []string {
	var fields []string
	if m.addregion_id != nil {
		fields = append(fields, estimate.FieldRegionID)
	}
	if m.addlayers != nil {
		fields = append(fields, estimate.FieldLayers)
	}
	if m.addpartial_percentage != nil {
		fields = append(fields, estimate.FieldPartialPercentage)
	}
	if m.addextra_charges != nil {
		fields = append(fields, estimate.FieldExtraCharges)
	}
	if m.addestimator_order_id != nil {
		fields = append(fields, estimate.FieldEstimatorOrderID)
	}
	if m.addestimator_report_id != nil {
		fields = append(fields, estimate.FieldEstimatorReportID)
	}
	if m.addtotal_squares != nil {
		fields = append(fields, estimate.FieldTotalSquares)
	}
	if m.addprimary_pitch != nil {
		fields = append(fields, estimate.FieldPrimaryPitch)
	}
	if m.addprice != nil {
		fields = append(fields, estimate.FieldPrice)
	}
	if m.addoverride_total_squares != nil {
		fields = append(fields, estimate.FieldOverrideTotalSquares)
	}
	if m.addoverride_primary_pitch != nil {
		fields = append(fields, estimate.FieldOverridePrimaryPitch)
	}
	if m.addoverride_price != nil {
		fields = append(fields, estimate.FieldOverridePrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EstimateMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case estimate.FieldRegionID:
		return m.AddedRegionID()
	case estimate.FieldLayers:
		return m.AddedLayers()
	case estimate.FieldPartialPercentage:
		return m.AddedPartialPercentage()
	case estimate.FieldExtraCharges:
		return m.AddedExtraCharges()
	case estimate.FieldEstimatorOrderID:
		return m.AddedEstimatorOrderID()
	case estimate.FieldEstimatorReportID:
		return m.AddedEstimatorReportID()
	case estimate.FieldTotalSquares:
		return m.AddedTotalSquares()
	case estimate.FieldPrimaryPitch:
		return m.AddedPrimaryPitch()
	case estimate.FieldPrice:
		return m.AddedPrice()
	case estimate.FieldOverrideTotalSquares:
		return m.AddedOverrideTotalSquares()
	case estimate.FieldOverridePrimaryPitch:
		return m.AddedOverridePrimaryPitch()
	case estimate.FieldOverridePrice:
		return m.AddedOverridePrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EstimateMutation) AddField(name string, value ent.Value) error {
	switch name {
	case estimate.FieldRegionID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionID(v)
		return nil
	case estimate.FieldLayers:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLayers(v)
		return nil
	case estimate.FieldPartialPercentage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPartialPercentage(v)
		return nil
	case estimate.FieldExtraCharges:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExtraCharges(v)
		return nil
	case estimate.FieldEstimatorOrderID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatorOrderID(v)
		return nil
	case estimate.FieldEstimatorReportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEstimatorReportID(v)
		return nil
	case estimate.FieldTotalSquares:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalSquares(v)
		return nil
	case estimate.FieldPrimaryPitch:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrimaryPitch(v)
		return nil
	case estimate.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case estimate.FieldOverrideTotalSquares:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverrideTotalSquares(v)
		return nil
	case estimate.FieldOverridePrimaryPitch:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverridePrimaryPitch(v)
		return nil
	case estimate.FieldOverridePrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOverridePrice(v)
		return nil
	}
	return fmt.Errorf("unknown Estimate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EstimateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(estimate.FieldCurrentMaterial) {
		fields = append(fields, estimate.FieldCurrentMaterial)
	}
	if m.FieldCleared(estimate.FieldNewRoofingMaterial) {
		fields = append(fields, estimate.FieldNewRoofingMaterial)
	}
	if m.FieldCleared(estimate.FieldCurrentMaterialLowSlope) {
		fields = append(fields, estimate.FieldCurrentMaterialLowSlope)
	}
	if m.FieldCleared(estimate.FieldNewRoofingMaterialLowSlope) {
		fields = append(fields, estimate.FieldNewRoofingMaterialLowSlope)
	}
	if m.FieldCleared(estimate.FieldLayer2Material) {
		fields = append(fields, estimate.FieldLayer2Material)
	}
	if m.FieldCleared(estimate.FieldLayer3Material) {
		fields = append(fields, estimate.FieldLayer3Material)
	}
	if m.FieldCleared(estimate.FieldPartialPercentage) {
		fields = append(fields, estimate.FieldPartialPercentage)
	}
	if m.FieldCleared(estimate.FieldMaterialMappingNote) {
		fields = append(fields, estimate.FieldMaterialMappingNote)
	}
	if m.FieldCleared(estimate.FieldExtraChargeType) {
		fields = append(fields, estimate.FieldExtraChargeType)
	}
	if m.FieldCleared(estimate.FieldExtraCharges) {
		fields = append(fields, estimate.FieldExtraCharges)
	}
	if m.FieldCleared(estimate.FieldExtraChargeCond) {
		fields = append(fields, estimate.FieldExtraChargeCond)
	}
	if m.FieldCleared(estimate.FieldExtraChargeNote) {
		fields = append(fields, estimate.FieldExtraChargeNote)
	}
	if m.FieldCleared(estimate.FieldEstimator) {
		fields = append(fields, estimate.FieldEstimator)
	}
	if m.FieldCleared(estimate.FieldEstimatorOrderID) {
		fields = append(fields, estimate.FieldEstimatorOrderID)
	}
	if m.FieldCleared(estimate.FieldEstimatorReportID) {
		fields = append(fields, estimate.FieldEstimatorReportID)
	}
	if m.FieldCleared(estimate.FieldPriceSummary) {
		fields = append(fields, estimate.FieldPriceSummary)
	}
	if m.FieldCleared(estimate.FieldBounds) {
		fields = append(fields, estimate.FieldBounds)
	}
	if m.FieldCleared(estimate.FieldEstimatorRawResponse) {
		fields = append(fields, estimate.FieldEstimatorRawResponse)
	}
	if m.FieldCleared(estimate.FieldOverride) {
		fields = append(fields, estimate.FieldOverride)
	}
	if m.FieldCleared(estimate.FieldOverridePriceSummary) {
		fields = append(fields, estimate.FieldOverridePriceSummary)
	}
	if m.FieldCleared(estimate.FieldCompanyRefID) {
		fields = append(fields, estimate.FieldCompanyRefID)
	}
	if m.FieldCleared(estimate.FieldCompanyRefName) {
		fields = append(fields, estimate.FieldCompanyRefName)
	}
	if m.FieldCleared(estimate.FieldFailureReason) {
		fields = append(fields, estimate.FieldFailureReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EstimateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EstimateMutation) ClearField(name string) error {
	switch name {
	case estimate.FieldCurrentMaterial:
		m.ClearCurrentMaterial()
		return nil
	case estimate.FieldNewRoofingMaterial:
		m.ClearNewRoofingMaterial()
		return nil
	case estimate.FieldCurrentMaterialLowSlope:
		m.ClearCurrentMaterialLowSlope()
		return nil
	case estimate.FieldNewRoofingMaterialLowSlope:
		m.ClearNewRoofingMaterialLowSlope()
		return nil
	case estimate.FieldLayer2Material:
		m.ClearLayer2Material()
		return nil
	case estimate.FieldLayer3Material:
		m.ClearLayer3Material()
		return nil
	case estimate.FieldPartialPercentage:
		m.ClearPartialPercentage()
		return nil
	case estimate.FieldMaterialMappingNote:
		m.ClearMaterialMappingNote()
		return nil
	case estimate.FieldExtraChargeType:
		m.ClearExtraChargeType()
		return nil
	case estimate.FieldExtraCharges:
		m.ClearExtraCharges()
		return nil
	case estimate.FieldExtraChargeCond:
		m.ClearExtraChargeCond()
		return nil
	case estimate.FieldExtraChargeNote:
		m.ClearExtraChargeNote()
		return nil
	case estimate.FieldEstimator:
		m.ClearEstimator()
		return nil
	case estimate.FieldEstimatorOrderID:
		m.ClearEstimatorOrderID()
		return nil
	case estimate.FieldEstimatorReportID:
		m.ClearEstimatorReportID()
		return nil
	case estimate.FieldPriceSummary:
		m.ClearPriceSummary()
		return nil
	case estimate.FieldBounds:
		m.ClearBounds()
		return nil
	case estimate.FieldEstimatorRawResponse:
		m.ClearEstimatorRawResponse()
		return nil
	case estimate.FieldOverride:
		m.ClearOverride()
		return nil
	case estimate.FieldOverridePriceSummary:
		m.ClearOverridePriceSummary()
		return nil
	case estimate.FieldCompanyRefID:
		m.ClearCompanyRefID()
		return nil
	case estimate.FieldCompanyRefName:
		m.ClearCompanyRefName()
		return nil
	case estimate.FieldFailureReason:
		m.ClearFailureReason()
		return nil
	}
	return fmt.Errorf("unknown Estimate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EstimateMutation) ResetField(name string) error {
	switch name {
	case estimate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case estimate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case estimate.FieldRegionID:
		m.ResetRegionID()
		return nil
	case estimate.FieldStatus:
		m.ResetStatus()
		return nil
	case estimate.FieldCurrentMaterial:
		m.ResetCurrentMaterial()
		return nil
	case estimate.FieldNewRoofingMaterial:
		m.ResetNewRoofingMaterial()
		return nil
	case estimate.FieldLowSlope:
		m.ResetLowSlope()
		return nil
	case estimate.FieldCurrentMaterialLowSlope:
		m.ResetCurrentMaterialLowSlope()
		return nil
	case estimate.FieldNewRoofingMaterialLowSlope:
		m.ResetNewRoofingMaterialLowSlope()
		return nil
	case estimate.FieldRedeck:
		m.ResetRedeck()
		return nil
	case estimate.FieldLayers:
		m.ResetLayers()
		return nil
	case estimate.FieldLayer2Material:
		m.ResetLayer2Material()
		return nil
	case estimate.FieldLayer3Material:
		m.ResetLayer3Material()
		return nil
	case estimate.FieldPartialPercentage:
		m.ResetPartialPercentage()
		return nil
	case estimate.FieldMaterialMappingNote:
		m.ResetMaterialMappingNote()
		return nil
	case estimate.FieldMeasureType:
		m.ResetMeasureType()
		return nil
	case estimate.FieldExtraChargeType:
		m.ResetExtraChargeType()
		return nil
	case estimate.FieldExtraCharges:
		m.ResetExtraCharges()
		return nil
	case estimate.FieldExtraChargeCond:
		m.ResetExtraChargeCond()
		return nil
	case estimate.FieldExtraChargeNote:
		m.ResetExtraChargeNote()
		return nil
	case estimate.FieldEstimator:
		m.ResetEstimator()
		return nil
	case estimate.FieldEstimatorOrderID:
		m.ResetEstimatorOrderID()
		return nil
	case estimate.FieldEstimatorReportID:
		m.ResetEstimatorReportID()
		return nil
	case estimate.FieldTotalSquares:
		m.ResetTotalSquares()
		return nil
	case estimate.FieldPrimaryPitch:
		m.ResetPrimaryPitch()
		return nil
	case estimate.FieldPrice:
		m.ResetPrice()
		return nil
	case estimate.FieldPriceSummary:
		m.ResetPriceSummary()
		return nil
	case estimate.FieldBounds:
		m.ResetBounds()
		return nil
	case estimate.FieldEstimatorRawResponse:
		m.ResetEstimatorRawResponse()
		return nil
	case estimate.FieldOverride:
		m.ResetOverride()
		return nil
	case estimate.FieldOverrideTotalSquares:
		m.ResetOverrideTotalSquares()
		return nil
	case estimate.FieldOverridePrimaryPitch:
		m.ResetOverridePrimaryPitch()
		return nil
	case estimate.FieldOverridePrice:
		m.ResetOverridePrice()
		return nil
	case estimate.FieldOverridePriceSummary:
		m.ResetOverridePriceSummary()
		return nil
	case estimate.FieldCompanyRefID:
		m.ResetCompanyRefID()
		return nil
	case estimate.FieldCompanyRefName:
		m.ResetCompanyRefName()
		return nil
	case estimate.FieldFailureReason:
		m.ResetFailureReason()
		return nil
	}
	return fmt.Errorf("unknown Estimate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EstimateMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.activities != nil {
		edges = append(edges, estimate.EdgeActivities)
	}
	if m.job_info != nil {
		edges = append(edges, estimate.EdgeJobInfo)
	}
	if m.partner != nil {
		edges = append(edges, estimate.EdgePartner)
	}
	if m.home_owner != nil {
		edges = append(edges, estimate.EdgeHomeOwner)
	}
	if m.sales_rep != nil {
		edges = append(edges, estimate.EdgeSalesRep)
	}
	if m.creator != nil {
		edges = append(edges, estimate.EdgeCreator)
	}
	if m.creator_api != nil {
		edges = append(edges, estimate.EdgeCreatorAPI)
	}
	if m.pdf != nil {
		edges = append(edges, estimate.EdgePdf)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EstimateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case estimate.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	case estimate.EdgeJobInfo:
		if id := m.job_info; id != nil {
			return []ent.Value{*id}
		}
	case estimate.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	case estimate.EdgeHomeOwner:
		if id := m.home_owner; id != nil {
			return []ent.Value{*id}
		}
	case estimate.EdgeSalesRep:
		if id := m.sales_rep; id != nil {
			return []ent.Value{*id}
		}
	case estimate.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case estimate.EdgeCreatorAPI:
		if id := m.creator_api; id != nil {
			return []ent.Value{*id}
		}
	case estimate.EdgePdf:
		if id := m.pdf; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EstimateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedactivities != nil {
		edges = append(edges, estimate.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EstimateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case estimate.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EstimateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedactivities {
		edges = append(edges, estimate.EdgeActivities)
	}
	if m.clearedjob_info {
		edges = append(edges, estimate.EdgeJobInfo)
	}
	if m.clearedpartner {
		edges = append(edges, estimate.EdgePartner)
	}
	if m.clearedhome_owner {
		edges = append(edges, estimate.EdgeHomeOwner)
	}
	if m.clearedsales_rep {
		edges = append(edges, estimate.EdgeSalesRep)
	}
	if m.clearedcreator {
		edges = append(edges, estimate.EdgeCreator)
	}
	if m.clearedcreator_api {
		edges = append(edges, estimate.EdgeCreatorAPI)
	}
	if m.clearedpdf {
		edges = append(edges, estimate.EdgePdf)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EstimateMutation) EdgeCleared(name string) bool {
	switch name {
	case estimate.EdgeActivities:
		return m.clearedactivities
	case estimate.EdgeJobInfo:
		return m.clearedjob_info
	case estimate.EdgePartner:
		return m.clearedpartner
	case estimate.EdgeHomeOwner:
		return m.clearedhome_owner
	case estimate.EdgeSalesRep:
		return m.clearedsales_rep
	case estimate.EdgeCreator:
		return m.clearedcreator
	case estimate.EdgeCreatorAPI:
		return m.clearedcreator_api
	case estimate.EdgePdf:
		return m.clearedpdf
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EstimateMutation) ClearEdge(name string) error {
	switch name {
	case estimate.EdgeJobInfo:
		m.ClearJobInfo()
		return nil
	case estimate.EdgePartner:
		m.ClearPartner()
		return nil
	case estimate.EdgeHomeOwner:
		m.ClearHomeOwner()
		return nil
	case estimate.EdgeSalesRep:
		m.ClearSalesRep()
		return nil
	case estimate.EdgeCreator:
		m.ClearCreator()
		return nil
	case estimate.EdgeCreatorAPI:
		m.ClearCreatorAPI()
		return nil
	case estimate.EdgePdf:
		m.ClearPdf()
		return nil
	}
	return fmt.Errorf("unknown Estimate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EstimateMutation) ResetEdge(name string) error {
	switch name {
	case estimate.EdgeActivities:
		m.ResetActivities()
		return nil
	case estimate.EdgeJobInfo:
		m.ResetJobInfo()
		return nil
	case estimate.EdgePartner:
		m.ResetPartner()
		return nil
	case estimate.EdgeHomeOwner:
		m.ResetHomeOwner()
		return nil
	case estimate.EdgeSalesRep:
		m.ResetSalesRep()
		return nil
	case estimate.EdgeCreator:
		m.ResetCreator()
		return nil
	case estimate.EdgeCreatorAPI:
		m.ResetCreatorAPI()
		return nil
	case estimate.EdgePdf:
		m.ResetPdf()
		return nil
	}
	return fmt.Errorf("unknown Estimate edge %s", name)
}

// EstimateActivityMutation represents an operation that mutates the EstimateActivity nodes in the graph.
type EstimateActivityMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	description        *string
	raw                *map[string]interface{}
	clearedFields      map[string]struct{}
	estimate           *string
	clearedestimate    bool
	creator            *string
	clearedcreator     bool
	creator_api        *string
	clearedcreator_api bool
	done               bool
	oldValue           func(context.Context) (*EstimateActivity, error)
	predicates         []predicate.EstimateActivity
}

var _ ent.Mutation = (*EstimateActivityMutation)(nil)

// estimateactivityOption allows management of the mutation configuration using functional options.
type estimateactivityOption func(*EstimateActivityMutation)

// newEstimateActivityMutation creates new mutation for the EstimateActivity entity.
func newEstimateActivityMutation(c config, op Op, opts ...estimateactivityOption) *EstimateActivityMutation {
	m := &EstimateActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeEstimateActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEstimateActivityID sets the ID field of the mutation.
func withEstimateActivityID(id string) estimateactivityOption {
	return func(m *EstimateActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *EstimateActivity
		)
		m.oldValue = func(ctx context.Context) (*EstimateActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EstimateActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEstimateActivity sets the old EstimateActivity of the mutation.
func withEstimateActivity(node *EstimateActivity) estimateactivityOption {
	return func(m *EstimateActivityMutation) {
		m.oldValue = func(context.Context) (*EstimateActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EstimateActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EstimateActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EstimateActivity entities.
func (m *EstimateActivityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EstimateActivityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EstimateActivityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EstimateActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *EstimateActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EstimateActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EstimateActivity entity.
// If the EstimateActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EstimateActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDescription sets the "description" field.
func (m *EstimateActivityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *EstimateActivityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the EstimateActivity entity.
// If the EstimateActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateActivityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *EstimateActivityMutation) ResetDescription() {
	m.description = nil
}

// SetRaw sets the "raw" field.
func (m *EstimateActivityMutation) SetRaw(value map[string]interface{}) {
	m.raw = &value
}

// Raw returns the value of the "raw" field in the mutation.
func (m *EstimateActivityMutation) Raw() (r map[string]interface{}, exists bool) {
	v := m.raw
	if v == nil {
		return
	}
	return *v, true
}

// OldRaw returns the old "raw" field's value of the EstimateActivity entity.
// If the EstimateActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EstimateActivityMutation) OldRaw(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRaw: %w", err)
	}
	return oldValue.Raw, nil
}

// ClearRaw clears the value of the "raw" field.
func (m *EstimateActivityMutation) ClearRaw() {
	m.raw = nil
	m.clearedFields[estimateactivity.FieldRaw] = struct{}{}
}

// RawCleared returns if the "raw" field was cleared in this mutation.
func (m *EstimateActivityMutation) RawCleared() bool {
	_, ok := m.clearedFields[estimateactivity.FieldRaw]
	return ok
}

// ResetRaw resets all changes to the "raw" field.
func (m *EstimateActivityMutation) ResetRaw() {
	m.raw = nil
	delete(m.clearedFields, estimateactivity.FieldRaw)
}

// SetEstimateID sets the "estimate" edge to the Estimate entity by id.
func (m *EstimateActivityMutation) SetEstimateID(id string) {
	m.estimate = &id
}

// ClearEstimate clears the "estimate" edge to the Estimate entity.
func (m *EstimateActivityMutation) ClearEstimate() {
	m.clearedestimate = true
}

// EstimateCleared reports if the "estimate" edge to the Estimate entity was cleared.
func (m *EstimateActivityMutation) EstimateCleared() bool {
	return m.clearedestimate
}

// EstimateID returns the "estimate" edge ID in the mutation.
func (m *EstimateActivityMutation) EstimateID() (id string, exists bool) {
	if m.estimate != nil {
		return *m.estimate, true
	}
	return
}

// EstimateIDs returns the "estimate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EstimateID instead. It exists only for internal usage by the builders.
func (m *EstimateActivityMutation) EstimateIDs() (ids []string) {
	if id := m.estimate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEstimate resets all changes to the "estimate" edge.
func (m *EstimateActivityMutation) ResetEstimate() {
	m.estimate = nil
	m.clearedestimate = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *EstimateActivityMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *EstimateActivityMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *EstimateActivityMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *EstimateActivityMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *EstimateActivityMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *EstimateActivityMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetCreatorAPIID sets the "creator_api" edge to the ApiUser entity by id.
func (m *EstimateActivityMutation) SetCreatorAPIID(id string) {
	m.creator_api = &id
}

// ClearCreatorAPI clears the "creator_api" edge to the ApiUser entity.
func (m *EstimateActivityMutation) ClearCreatorAPI() {
	m.clearedcreator_api = true
}

// CreatorAPICleared reports if the "creator_api" edge to the ApiUser entity was cleared.
func (m *EstimateActivityMutation) CreatorAPICleared() bool {
	return m.clearedcreator_api
}

// CreatorAPIID returns the "creator_api" edge ID in the mutation.
func (m *EstimateActivityMutation) CreatorAPIID() (id string, exists bool) {
	if m.creator_api != nil {
		return *m.creator_api, true
	}
	return
}

// CreatorAPIIDs returns the "creator_api" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorAPIID instead. It exists only for internal usage by the builders.
func (m *EstimateActivityMutation) CreatorAPIIDs() (ids []string) {
	if id := m.creator_api; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatorAPI resets all changes to the "creator_api" edge.
func (m *EstimateActivityMutation) ResetCreatorAPI() {
	m.creator_api = nil
	m.clearedcreator_api = false
}

// Where appends a list predicates to the EstimateActivityMutation builder.
func (m *EstimateActivityMutation) Where(ps ...predicate.EstimateActivity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EstimateActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EstimateActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EstimateActivity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EstimateActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EstimateActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EstimateActivity).
func (m *EstimateActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EstimateActivityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, estimateactivity.FieldCreatedAt)
	}
	if m.description != nil {
		fields = append(fields, estimateactivity.FieldDescription)
	}
	if m.raw != nil {
		fields = append(fields, estimateactivity.FieldRaw)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EstimateActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case estimateactivity.FieldCreatedAt:
		return m.CreatedAt()
	case estimateactivity.FieldDescription:
		return m.Description()
	case estimateactivity.FieldRaw:
		return m.Raw()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EstimateActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case estimateactivity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case estimateactivity.FieldDescription:
		return m.OldDescription(ctx)
	case estimateactivity.FieldRaw:
		return m.OldRaw(ctx)
	}
	return nil, fmt.Errorf("unknown EstimateActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EstimateActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case estimateactivity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case estimateactivity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case estimateactivity.FieldRaw:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRaw(v)
		return nil
	}
	return fmt.Errorf("unknown EstimateActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EstimateActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EstimateActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EstimateActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EstimateActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EstimateActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(estimateactivity.FieldRaw) {
		fields = append(fields, estimateactivity.FieldRaw)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EstimateActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EstimateActivityMutation) ClearField(name string) error {
	switch name {
	case estimateactivity.FieldRaw:
		m.ClearRaw()
		return nil
	}
	return fmt.Errorf("unknown EstimateActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EstimateActivityMutation) ResetField(name string) error {
	switch name {
	case estimateactivity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case estimateactivity.FieldDescription:
		m.ResetDescription()
		return nil
	case estimateactivity.FieldRaw:
		m.ResetRaw()
		return nil
	}
	return fmt.Errorf("unknown EstimateActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EstimateActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.estimate != nil {
		edges = append(edges, estimateactivity.EdgeEstimate)
	}
	if m.creator != nil {
		edges = append(edges, estimateactivity.EdgeCreator)
	}
	if m.creator_api != nil {
		edges = append(edges, estimateactivity.EdgeCreatorAPI)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EstimateActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case estimateactivity.EdgeEstimate:
		if id := m.estimate; id != nil {
			return []ent.Value{*id}
		}
	case estimateactivity.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case estimateactivity.EdgeCreatorAPI:
		if id := m.creator_api; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EstimateActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EstimateActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EstimateActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedestimate {
		edges = append(edges, estimateactivity.EdgeEstimate)
	}
	if m.clearedcreator {
		edges = append(edges, estimateactivity.EdgeCreator)
	}
	if m.clearedcreator_api {
		edges = append(edges, estimateactivity.EdgeCreatorAPI)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EstimateActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case estimateactivity.EdgeEstimate:
		return m.clearedestimate
	case estimateactivity.EdgeCreator:
		return m.clearedcreator
	case estimateactivity.EdgeCreatorAPI:
		return m.clearedcreator_api
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EstimateActivityMutation) ClearEdge(name string) error {
	switch name {
	case estimateactivity.EdgeEstimate:
		m.ClearEstimate()
		return nil
	case estimateactivity.EdgeCreator:
		m.ClearCreator()
		return nil
	case estimateactivity.EdgeCreatorAPI:
		m.ClearCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown EstimateActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EstimateActivityMutation) ResetEdge(name string) error {
	switch name {
	case estimateactivity.EdgeEstimate:
		m.ResetEstimate()
		return nil
	case estimateactivity.EdgeCreator:
		m.ResetCreator()
		return nil
	case estimateactivity.EdgeCreatorAPI:
		m.ResetCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown EstimateActivity edge %s", name)
}

// HomeOwnerMutation represents an operation that mutates the HomeOwner nodes in the graph.
type HomeOwnerMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	first_name        *string
	last_name         *string
	email             *string
	phone             *string
	street_number     *string
	street_name       *string
	city              *string
	state             *string
	state_abbr        *string
	zip               *string
	formatted_address *string
	latitude          *float64
	addlatitude       *float64
	longitude         *float64
	addlongitude      *float64
	hash              *string
	clearedFields     map[string]struct{}
	estimates         map[string]struct{}
	removedestimates  map[string]struct{}
	clearedestimates  bool
	jobs              map[string]struct{}
	removedjobs       map[string]struct{}
	clearedjobs       bool
	partner           *string
	clearedpartner    bool
	done              bool
	oldValue          func(context.Context) (*HomeOwner, error)
	predicates        []predicate.HomeOwner
}

var _ ent.Mutation = (*HomeOwnerMutation)(nil)

// homeownerOption allows management of the mutation configuration using functional options.
type homeownerOption func(*HomeOwnerMutation)

// newHomeOwnerMutation creates new mutation for the HomeOwner entity.
func newHomeOwnerMutation(c config, op Op, opts ...homeownerOption) *HomeOwnerMutation {
	m := &HomeOwnerMutation{
		config:        c,
		op:            op,
		typ:           TypeHomeOwner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHomeOwnerID sets the ID field of the mutation.
func withHomeOwnerID(id string) homeownerOption {
	return func(m *HomeOwnerMutation) {
		var (
			err   error
			once  sync.Once
			value *HomeOwner
		)
		m.oldValue = func(ctx context.Context) (*HomeOwner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HomeOwner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHomeOwner sets the old HomeOwner of the mutation.
func withHomeOwner(node *HomeOwner) homeownerOption {
	return func(m *HomeOwnerMutation) {
		m.oldValue = func(context.Context) (*HomeOwner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HomeOwnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HomeOwnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HomeOwner entities.
func (m *HomeOwnerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HomeOwnerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HomeOwnerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HomeOwner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *HomeOwnerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HomeOwnerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HomeOwnerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *HomeOwnerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *HomeOwnerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *HomeOwnerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetFirstName sets the "first_name" field.
func (m *HomeOwnerMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *HomeOwnerMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *HomeOwnerMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *HomeOwnerMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *HomeOwnerMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *HomeOwnerMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *HomeOwnerMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *HomeOwnerMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *HomeOwnerMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[homeowner.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *HomeOwnerMutation) EmailCleared() bool {
	_, ok := m.clearedFields[homeowner.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *HomeOwnerMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, homeowner.FieldEmail)
}

// SetPhone sets the "phone" field.
func (m *HomeOwnerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *HomeOwnerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *HomeOwnerMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[homeowner.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *HomeOwnerMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[homeowner.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *HomeOwnerMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, homeowner.FieldPhone)
}

// SetStreetNumber sets the "street_number" field.
func (m *HomeOwnerMutation) SetStreetNumber(s string) {
	m.street_number = &s
}

// StreetNumber returns the value of the "street_number" field in the mutation.
func (m *HomeOwnerMutation) StreetNumber() (r string, exists bool) {
	v := m.street_number
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetNumber returns the old "street_number" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldStreetNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetNumber: %w", err)
	}
	return oldValue.StreetNumber, nil
}

// ResetStreetNumber resets all changes to the "street_number" field.
func (m *HomeOwnerMutation) ResetStreetNumber() {
	m.street_number = nil
}

// SetStreetName sets the "street_name" field.
func (m *HomeOwnerMutation) SetStreetName(s string) {
	m.street_name = &s
}

// StreetName returns the value of the "street_name" field in the mutation.
func (m *HomeOwnerMutation) StreetName() (r string, exists bool) {
	v := m.street_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStreetName returns the old "street_name" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldStreetName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreetName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreetName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreetName: %w", err)
	}
	return oldValue.StreetName, nil
}

// ResetStreetName resets all changes to the "street_name" field.
func (m *HomeOwnerMutation) ResetStreetName() {
	m.street_name = nil
}

// SetCity sets the "city" field.
func (m *HomeOwnerMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *HomeOwnerMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *HomeOwnerMutation) ResetCity() {
	m.city = nil
}

// SetState sets the "state" field.
func (m *HomeOwnerMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *HomeOwnerMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *HomeOwnerMutation) ResetState() {
	m.state = nil
}

// SetStateAbbr sets the "state_abbr" field.
func (m *HomeOwnerMutation) SetStateAbbr(s string) {
	m.state_abbr = &s
}

// StateAbbr returns the value of the "state_abbr" field in the mutation.
func (m *HomeOwnerMutation) StateAbbr() (r string, exists bool) {
	v := m.state_abbr
	if v == nil {
		return
	}
	return *v, true
}

// OldStateAbbr returns the old "state_abbr" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldStateAbbr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateAbbr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateAbbr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateAbbr: %w", err)
	}
	return oldValue.StateAbbr, nil
}

// ClearStateAbbr clears the value of the "state_abbr" field.
func (m *HomeOwnerMutation) ClearStateAbbr() {
	m.state_abbr = nil
	m.clearedFields[homeowner.FieldStateAbbr] = struct{}{}
}

// StateAbbrCleared returns if the "state_abbr" field was cleared in this mutation.
func (m *HomeOwnerMutation) StateAbbrCleared() bool {
	_, ok := m.clearedFields[homeowner.FieldStateAbbr]
	return ok
}

// ResetStateAbbr resets all changes to the "state_abbr" field.
func (m *HomeOwnerMutation) ResetStateAbbr() {
	m.state_abbr = nil
	delete(m.clearedFields, homeowner.FieldStateAbbr)
}

// SetZip sets the "zip" field.
func (m *HomeOwnerMutation) SetZip(s string) {
	m.zip = &s
}

// Zip returns the value of the "zip" field in the mutation.
func (m *HomeOwnerMutation) Zip() (r string, exists bool) {
	v := m.zip
	if v == nil {
		return
	}
	return *v, true
}

// OldZip returns the old "zip" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldZip(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZip: %w", err)
	}
	return oldValue.Zip, nil
}

// ResetZip resets all changes to the "zip" field.
func (m *HomeOwnerMutation) ResetZip() {
	m.zip = nil
}

// SetFormattedAddress sets the "formatted_address" field.
func (m *HomeOwnerMutation) SetFormattedAddress(s string) {
	m.formatted_address = &s
}

// FormattedAddress returns the value of the "formatted_address" field in the mutation.
func (m *HomeOwnerMutation) FormattedAddress() (r string, exists bool) {
	v := m.formatted_address
	if v == nil {
		return
	}
	return *v, true
}

// OldFormattedAddress returns the old "formatted_address" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldFormattedAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormattedAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormattedAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormattedAddress: %w", err)
	}
	return oldValue.FormattedAddress, nil
}

// ClearFormattedAddress clears the value of the "formatted_address" field.
func (m *HomeOwnerMutation) ClearFormattedAddress() {
	m.formatted_address = nil
	m.clearedFields[homeowner.FieldFormattedAddress] = struct{}{}
}

// FormattedAddressCleared returns if the "formatted_address" field was cleared in this mutation.
func (m *HomeOwnerMutation) FormattedAddressCleared() bool {
	_, ok := m.clearedFields[homeowner.FieldFormattedAddress]
	return ok
}

// ResetFormattedAddress resets all changes to the "formatted_address" field.
func (m *HomeOwnerMutation) ResetFormattedAddress() {
	m.formatted_address = nil
	delete(m.clearedFields, homeowner.FieldFormattedAddress)
}

// SetLatitude sets the "latitude" field.
func (m *HomeOwnerMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *HomeOwnerMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *HomeOwnerMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *HomeOwnerMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *HomeOwnerMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[homeowner.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *HomeOwnerMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[homeowner.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *HomeOwnerMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, homeowner.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *HomeOwnerMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *HomeOwnerMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *HomeOwnerMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *HomeOwnerMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *HomeOwnerMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[homeowner.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *HomeOwnerMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[homeowner.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *HomeOwnerMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, homeowner.FieldLongitude)
}

// SetHash sets the "hash" field.
func (m *HomeOwnerMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *HomeOwnerMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the HomeOwner entity.
// If the HomeOwner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HomeOwnerMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ClearHash clears the value of the "hash" field.
func (m *HomeOwnerMutation) ClearHash() {
	m.hash = nil
	m.clearedFields[homeowner.FieldHash] = struct{}{}
}

// HashCleared returns if the "hash" field was cleared in this mutation.
func (m *HomeOwnerMutation) HashCleared() bool {
	_, ok := m.clearedFields[homeowner.FieldHash]
	return ok
}

// ResetHash resets all changes to the "hash" field.
func (m *HomeOwnerMutation) ResetHash() {
	m.hash = nil
	delete(m.clearedFields, homeowner.FieldHash)
}

// AddEstimateIDs adds the "estimates" edge to the Estimate entity by ids.
func (m *HomeOwnerMutation) AddEstimateIDs(ids ...string) {
	if m.estimates == nil {
		m.estimates = make(map[string]struct{})
	}
	for i := range ids {
		m.estimates[ids[i]] = struct{}{}
	}
}

// ClearEstimates clears the "estimates" edge to the Estimate entity.
func (m *HomeOwnerMutation) ClearEstimates() {
	m.clearedestimates = true
}

// EstimatesCleared reports if the "estimates" edge to the Estimate entity was cleared.
func (m *HomeOwnerMutation) EstimatesCleared() bool {
	return m.clearedestimates
}

// RemoveEstimateIDs removes the "estimates" edge to the Estimate entity by IDs.
func (m *HomeOwnerMutation) RemoveEstimateIDs(ids ...string) {
	if m.removedestimates == nil {
		m.removedestimates = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.estimates, ids[i])
		m.removedestimates[ids[i]] = struct{}{}
	}
}

// RemovedEstimates returns the removed IDs of the "estimates" edge to the Estimate entity.
func (m *HomeOwnerMutation) RemovedEstimatesIDs() (ids []string) {
	for id := range m.removedestimates {
		ids = append(ids, id)
	}
	return
}

// EstimatesIDs returns the "estimates" edge IDs in the mutation.
func (m *HomeOwnerMutation) EstimatesIDs() (ids []string) {
	for id := range m.estimates {
		ids = append(ids, id)
	}
	return
}

// ResetEstimates resets all changes to the "estimates" edge.
func (m *HomeOwnerMutation) ResetEstimates() {
	m.estimates = nil
	m.clearedestimates = false
	m.removedestimates = nil
}

// AddJobIDs adds the "jobs" edge to the Job entity by ids.
func (m *HomeOwnerMutation) AddJobIDs(ids ...string) {
	if m.jobs == nil {
		m.jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.jobs[ids[i]] = struct{}{}
	}
}

// ClearJobs clears the "jobs" edge to the Job entity.
func (m *HomeOwnerMutation) ClearJobs() {
	m.clearedjobs = true
}

// JobsCleared reports if the "jobs" edge to the Job entity was cleared.
func (m *HomeOwnerMutation) JobsCleared() bool {
	return m.clearedjobs
}

// RemoveJobIDs removes the "jobs" edge to the Job entity by IDs.
func (m *HomeOwnerMutation) RemoveJobIDs(ids ...string) {
	if m.removedjobs == nil {
		m.removedjobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.jobs, ids[i])
		m.removedjobs[ids[i]] = struct{}{}
	}
}

// RemovedJobs returns the removed IDs of the "jobs" edge to the Job entity.
func (m *HomeOwnerMutation) RemovedJobsIDs() (ids []string) {
	for id := range m.removedjobs {
		ids = append(ids, id)
	}
	return
}

// JobsIDs returns the "jobs" edge IDs in the mutation.
func (m *HomeOwnerMutation) JobsIDs() (ids []string) {
	for id := range m.jobs {
		ids = append(ids, id)
	}
	return
}

// ResetJobs resets all changes to the "jobs" edge.
func (m *HomeOwnerMutation) ResetJobs() {
	m.jobs = nil
	m.clearedjobs = false
	m.removedjobs = nil
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *HomeOwnerMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *HomeOwnerMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *HomeOwnerMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *HomeOwnerMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *HomeOwnerMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *HomeOwnerMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// Where appends a list predicates to the HomeOwnerMutation builder.
func (m *HomeOwnerMutation) Where(ps ...predicate.HomeOwner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HomeOwnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HomeOwnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HomeOwner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HomeOwnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HomeOwnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HomeOwner).
func (m *HomeOwnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HomeOwnerMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, homeowner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, homeowner.FieldUpdatedAt)
	}
	if m.first_name != nil {
		fields = append(fields, homeowner.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, homeowner.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, homeowner.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, homeowner.FieldPhone)
	}
	if m.street_number != nil {
		fields = append(fields, homeowner.FieldStreetNumber)
	}
	if m.street_name != nil {
		fields = append(fields, homeowner.FieldStreetName)
	}
	if m.city != nil {
		fields = append(fields, homeowner.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, homeowner.FieldState)
	}
	if m.state_abbr != nil {
		fields = append(fields, homeowner.FieldStateAbbr)
	}
	if m.zip != nil {
		fields = append(fields, homeowner.FieldZip)
	}
	if m.formatted_address != nil {
		fields = append(fields, homeowner.FieldFormattedAddress)
	}
	if m.latitude != nil {
		fields = append(fields, homeowner.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, homeowner.FieldLongitude)
	}
	if m.hash != nil {
		fields = append(fields, homeowner.FieldHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HomeOwnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case homeowner.FieldCreatedAt:
		return m.CreatedAt()
	case homeowner.FieldUpdatedAt:
		return m.UpdatedAt()
	case homeowner.FieldFirstName:
		return m.FirstName()
	case homeowner.FieldLastName:
		return m.LastName()
	case homeowner.FieldEmail:
		return m.Email()
	case homeowner.FieldPhone:
		return m.Phone()
	case homeowner.FieldStreetNumber:
		return m.StreetNumber()
	case homeowner.FieldStreetName:
		return m.StreetName()
	case homeowner.FieldCity:
		return m.City()
	case homeowner.FieldState:
		return m.State()
	case homeowner.FieldStateAbbr:
		return m.StateAbbr()
	case homeowner.FieldZip:
		return m.Zip()
	case homeowner.FieldFormattedAddress:
		return m.FormattedAddress()
	case homeowner.FieldLatitude:
		return m.Latitude()
	case homeowner.FieldLongitude:
		return m.Longitude()
	case homeowner.FieldHash:
		return m.Hash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HomeOwnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case homeowner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case homeowner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case homeowner.FieldFirstName:
		return m.OldFirstName(ctx)
	case homeowner.FieldLastName:
		return m.OldLastName(ctx)
	case homeowner.FieldEmail:
		return m.OldEmail(ctx)
	case homeowner.FieldPhone:
		return m.OldPhone(ctx)
	case homeowner.FieldStreetNumber:
		return m.OldStreetNumber(ctx)
	case homeowner.FieldStreetName:
		return m.OldStreetName(ctx)
	case homeowner.FieldCity:
		return m.OldCity(ctx)
	case homeowner.FieldState:
		return m.OldState(ctx)
	case homeowner.FieldStateAbbr:
		return m.OldStateAbbr(ctx)
	case homeowner.FieldZip:
		return m.OldZip(ctx)
	case homeowner.FieldFormattedAddress:
		return m.OldFormattedAddress(ctx)
	case homeowner.FieldLatitude:
		return m.OldLatitude(ctx)
	case homeowner.FieldLongitude:
		return m.OldLongitude(ctx)
	case homeowner.FieldHash:
		return m.OldHash(ctx)
	}
	return nil, fmt.Errorf("unknown HomeOwner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HomeOwnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case homeowner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case homeowner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case homeowner.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case homeowner.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case homeowner.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case homeowner.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case homeowner.FieldStreetNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetNumber(v)
		return nil
	case homeowner.FieldStreetName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreetName(v)
		return nil
	case homeowner.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case homeowner.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case homeowner.FieldStateAbbr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateAbbr(v)
		return nil
	case homeowner.FieldZip:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZip(v)
		return nil
	case homeowner.FieldFormattedAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormattedAddress(v)
		return nil
	case homeowner.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case homeowner.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case homeowner.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	}
	return fmt.Errorf("unknown HomeOwner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HomeOwnerMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, homeowner.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, homeowner.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HomeOwnerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case homeowner.FieldLatitude:
		return m.AddedLatitude()
	case homeowner.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HomeOwnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case homeowner.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case homeowner.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown HomeOwner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HomeOwnerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(homeowner.FieldEmail) {
		fields = append(fields, homeowner.FieldEmail)
	}
	if m.FieldCleared(homeowner.FieldPhone) {
		fields = append(fields, homeowner.FieldPhone)
	}
	if m.FieldCleared(homeowner.FieldStateAbbr) {
		fields = append(fields, homeowner.FieldStateAbbr)
	}
	if m.FieldCleared(homeowner.FieldFormattedAddress) {
		fields = append(fields, homeowner.FieldFormattedAddress)
	}
	if m.FieldCleared(homeowner.FieldLatitude) {
		fields = append(fields, homeowner.FieldLatitude)
	}
	if m.FieldCleared(homeowner.FieldLongitude) {
		fields = append(fields, homeowner.FieldLongitude)
	}
	if m.FieldCleared(homeowner.FieldHash) {
		fields = append(fields, homeowner.FieldHash)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HomeOwnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HomeOwnerMutation) ClearField(name string) error {
	switch name {
	case homeowner.FieldEmail:
		m.ClearEmail()
		return nil
	case homeowner.FieldPhone:
		m.ClearPhone()
		return nil
	case homeowner.FieldStateAbbr:
		m.ClearStateAbbr()
		return nil
	case homeowner.FieldFormattedAddress:
		m.ClearFormattedAddress()
		return nil
	case homeowner.FieldLatitude:
		m.ClearLatitude()
		return nil
	case homeowner.FieldLongitude:
		m.ClearLongitude()
		return nil
	case homeowner.FieldHash:
		m.ClearHash()
		return nil
	}
	return fmt.Errorf("unknown HomeOwner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HomeOwnerMutation) ResetField(name string) error {
	switch name {
	case homeowner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case homeowner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case homeowner.FieldFirstName:
		m.ResetFirstName()
		return nil
	case homeowner.FieldLastName:
		m.ResetLastName()
		return nil
	case homeowner.FieldEmail:
		m.ResetEmail()
		return nil
	case homeowner.FieldPhone:
		m.ResetPhone()
		return nil
	case homeowner.FieldStreetNumber:
		m.ResetStreetNumber()
		return nil
	case homeowner.FieldStreetName:
		m.ResetStreetName()
		return nil
	case homeowner.FieldCity:
		m.ResetCity()
		return nil
	case homeowner.FieldState:
		m.ResetState()
		return nil
	case homeowner.FieldStateAbbr:
		m.ResetStateAbbr()
		return nil
	case homeowner.FieldZip:
		m.ResetZip()
		return nil
	case homeowner.FieldFormattedAddress:
		m.ResetFormattedAddress()
		return nil
	case homeowner.FieldLatitude:
		m.ResetLatitude()
		return nil
	case homeowner.FieldLongitude:
		m.ResetLongitude()
		return nil
	case homeowner.FieldHash:
		m.ResetHash()
		return nil
	}
	return fmt.Errorf("unknown HomeOwner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HomeOwnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.estimates != nil {
		edges = append(edges, homeowner.EdgeEstimates)
	}
	if m.jobs != nil {
		edges = append(edges, homeowner.EdgeJobs)
	}
	if m.partner != nil {
		edges = append(edges, homeowner.EdgePartner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HomeOwnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case homeowner.EdgeEstimates:
		ids := make([]ent.Value, 0, len(m.estimates))
		for id := range m.estimates {
			ids = append(ids, id)
		}
		return ids
	case homeowner.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.jobs))
		for id := range m.jobs {
			ids = append(ids, id)
		}
		return ids
	case homeowner.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HomeOwnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedestimates != nil {
		edges = append(edges, homeowner.EdgeEstimates)
	}
	if m.removedjobs != nil {
		edges = append(edges, homeowner.EdgeJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HomeOwnerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case homeowner.EdgeEstimates:
		ids := make([]ent.Value, 0, len(m.removedestimates))
		for id := range m.removedestimates {
			ids = append(ids, id)
		}
		return ids
	case homeowner.EdgeJobs:
		ids := make([]ent.Value, 0, len(m.removedjobs))
		for id := range m.removedjobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HomeOwnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedestimates {
		edges = append(edges, homeowner.EdgeEstimates)
	}
	if m.clearedjobs {
		edges = append(edges, homeowner.EdgeJobs)
	}
	if m.clearedpartner {
		edges = append(edges, homeowner.EdgePartner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HomeOwnerMutation) EdgeCleared(name string) bool {
	switch name {
	case homeowner.EdgeEstimates:
		return m.clearedestimates
	case homeowner.EdgeJobs:
		return m.clearedjobs
	case homeowner.EdgePartner:
		return m.clearedpartner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HomeOwnerMutation) ClearEdge(name string) error {
	switch name {
	case homeowner.EdgePartner:
		m.ClearPartner()
		return nil
	}
	return fmt.Errorf("unknown HomeOwner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HomeOwnerMutation) ResetEdge(name string) error {
	switch name {
	case homeowner.EdgeEstimates:
		m.ResetEstimates()
		return nil
	case homeowner.EdgeJobs:
		m.ResetJobs()
		return nil
	case homeowner.EdgePartner:
		m.ResetPartner()
		return nil
	}
	return fmt.Errorf("unknown HomeOwner edge %s", name)
}

// InstallationJobMutation represents an operation that mutates the InstallationJob nodes in the graph.
type InstallationJobMutation struct {
	config
	op                        Op
	typ                       string
	id                        *string
	created_at                *time.Time
	updated_at                *time.Time
	_type                     *enum.InstallationType
	owner_name                *string
	owner_phone               *string
	owner_email               *string
	owner_address             *string
	owner_address_lat         *float64
	addowner_address_lat      *float64
	owner_address_lng         *float64
	addowner_address_lng      *float64
	special_note              *string
	pkg                       *string
	pkg_description           *string
	pkg_features              *[]string
	appendpkg_features        []string
	price                     *float64
	addprice                  *float64
	approval                  *enum.Approval
	approval_at               *time.Time
	deny_reason               *string
	status                    *enum.InstallationStatus
	status_at                 *time.Time
	clearedFields             map[string]struct{}
	items                     map[string]struct{}
	removeditems              map[string]struct{}
	cleareditems              bool
	progress_history          map[string]struct{}
	removedprogress_history   map[string]struct{}
	clearedprogress_history   bool
	requesting_partner        *string
	clearedrequesting_partner bool
	assigned_partner          *string
	clearedassigned_partner   bool
	creator                   *string
	clearedcreator            bool
	sales_rep                 *string
	clearedsales_rep          bool
	done                      bool
	oldValue                  func(context.Context) (*InstallationJob, error)
	predicates                []predicate.InstallationJob
}

var _ ent.Mutation = (*InstallationJobMutation)(nil)

// installationjobOption allows management of the mutation configuration using functional options.
type installationjobOption func(*InstallationJobMutation)

// newInstallationJobMutation creates new mutation for the InstallationJob entity.
func newInstallationJobMutation(c config, op Op, opts ...installationjobOption) *InstallationJobMutation {
	m := &InstallationJobMutation{
		config:        c,
		op:            op,
		typ:           TypeInstallationJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstallationJobID sets the ID field of the mutation.
func withInstallationJobID(id string) installationjobOption {
	return func(m *InstallationJobMutation) {
		var (
			err   error
			once  sync.Once
			value *InstallationJob
		)
		m.oldValue = func(ctx context.Context) (*InstallationJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstallationJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstallationJob sets the old InstallationJob of the mutation.
func withInstallationJob(node *InstallationJob) installationjobOption {
	return func(m *InstallationJobMutation) {
		m.oldValue = func(context.Context) (*InstallationJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstallationJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstallationJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InstallationJob entities.
func (m *InstallationJobMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstallationJobMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstallationJobMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InstallationJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InstallationJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InstallationJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InstallationJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InstallationJobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InstallationJobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InstallationJobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *InstallationJobMutation) SetType(et enum.InstallationType) {
	m._type = &et
}

// GetType returns the value of the "type" field in the mutation.
func (m *InstallationJobMutation) GetType() (r enum.InstallationType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldType(ctx context.Context) (v enum.InstallationType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *InstallationJobMutation) ResetType() {
	m._type = nil
}

// SetOwnerName sets the "owner_name" field.
func (m *InstallationJobMutation) SetOwnerName(s string) {
	m.owner_name = &s
}

// OwnerName returns the value of the "owner_name" field in the mutation.
func (m *InstallationJobMutation) OwnerName() (r string, exists bool) {
	v := m.owner_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerName returns the old "owner_name" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldOwnerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerName: %w", err)
	}
	return oldValue.OwnerName, nil
}

// ResetOwnerName resets all changes to the "owner_name" field.
func (m *InstallationJobMutation) ResetOwnerName() {
	m.owner_name = nil
}

// SetOwnerPhone sets the "owner_phone" field.
func (m *InstallationJobMutation) SetOwnerPhone(s string) {
	m.owner_phone = &s
}

// OwnerPhone returns the value of the "owner_phone" field in the mutation.
func (m *InstallationJobMutation) OwnerPhone() (r string, exists bool) {
	v := m.owner_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerPhone returns the old "owner_phone" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldOwnerPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerPhone: %w", err)
	}
	return oldValue.OwnerPhone, nil
}

// ResetOwnerPhone resets all changes to the "owner_phone" field.
func (m *InstallationJobMutation) ResetOwnerPhone() {
	m.owner_phone = nil
}

// SetOwnerEmail sets the "owner_email" field.
func (m *InstallationJobMutation) SetOwnerEmail(s string) {
	m.owner_email = &s
}

// OwnerEmail returns the value of the "owner_email" field in the mutation.
func (m *InstallationJobMutation) OwnerEmail() (r string, exists bool) {
	v := m.owner_email
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerEmail returns the old "owner_email" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldOwnerEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerEmail: %w", err)
	}
	return oldValue.OwnerEmail, nil
}

// ClearOwnerEmail clears the value of the "owner_email" field.
func (m *InstallationJobMutation) ClearOwnerEmail() {
	m.owner_email = nil
	m.clearedFields[installationjob.FieldOwnerEmail] = struct{}{}
}

// OwnerEmailCleared returns if the "owner_email" field was cleared in this mutation.
func (m *InstallationJobMutation) OwnerEmailCleared() bool {
	_, ok := m.clearedFields[installationjob.FieldOwnerEmail]
	return ok
}

// ResetOwnerEmail resets all changes to the "owner_email" field.
func (m *InstallationJobMutation) ResetOwnerEmail() {
	m.owner_email = nil
	delete(m.clearedFields, installationjob.FieldOwnerEmail)
}

// SetOwnerAddress sets the "owner_address" field.
func (m *InstallationJobMutation) SetOwnerAddress(s string) {
	m.owner_address = &s
}

// OwnerAddress returns the value of the "owner_address" field in the mutation.
func (m *InstallationJobMutation) OwnerAddress() (r string, exists bool) {
	v := m.owner_address
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerAddress returns the old "owner_address" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldOwnerAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerAddress: %w", err)
	}
	return oldValue.OwnerAddress, nil
}

// ResetOwnerAddress resets all changes to the "owner_address" field.
func (m *InstallationJobMutation) ResetOwnerAddress() {
	m.owner_address = nil
}

// SetOwnerAddressLat sets the "owner_address_lat" field.
func (m *InstallationJobMutation) SetOwnerAddressLat(f float64) {
	m.owner_address_lat = &f
	m.addowner_address_lat = nil
}

// OwnerAddressLat returns the value of the "owner_address_lat" field in the mutation.
func (m *InstallationJobMutation) OwnerAddressLat() (r float64, exists bool) {
	v := m.owner_address_lat
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerAddressLat returns the old "owner_address_lat" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldOwnerAddressLat(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerAddressLat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerAddressLat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerAddressLat: %w", err)
	}
	return oldValue.OwnerAddressLat, nil
}

// AddOwnerAddressLat adds f to the "owner_address_lat" field.
func (m *InstallationJobMutation) AddOwnerAddressLat(f float64) {
	if m.addowner_address_lat != nil {
		*m.addowner_address_lat += f
	} else {
		m.addowner_address_lat = &f
	}
}

// AddedOwnerAddressLat returns the value that was added to the "owner_address_lat" field in this mutation.
func (m *InstallationJobMutation) AddedOwnerAddressLat() (r float64, exists bool) {
	v := m.addowner_address_lat
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerAddressLat clears the value of the "owner_address_lat" field.
func (m *InstallationJobMutation) ClearOwnerAddressLat() {
	m.owner_address_lat = nil
	m.addowner_address_lat = nil
	m.clearedFields[installationjob.FieldOwnerAddressLat] = struct{}{}
}

// OwnerAddressLatCleared returns if the "owner_address_lat" field was cleared in this mutation.
func (m *InstallationJobMutation) OwnerAddressLatCleared() bool {
	_, ok := m.clearedFields[installationjob.FieldOwnerAddressLat]
	return ok
}

// ResetOwnerAddressLat resets all changes to the "owner_address_lat" field.
func (m *InstallationJobMutation) ResetOwnerAddressLat() {
	m.owner_address_lat = nil
	m.addowner_address_lat = nil
	delete(m.clearedFields, installationjob.FieldOwnerAddressLat)
}

// SetOwnerAddressLng sets the "owner_address_lng" field.
func (m *InstallationJobMutation) SetOwnerAddressLng(f float64) {
	m.owner_address_lng = &f
	m.addowner_address_lng = nil
}

// OwnerAddressLng returns the value of the "owner_address_lng" field in the mutation.
func (m *InstallationJobMutation) OwnerAddressLng() (r float64, exists bool) {
	v := m.owner_address_lng
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerAddressLng returns the old "owner_address_lng" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldOwnerAddressLng(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerAddressLng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerAddressLng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerAddressLng: %w", err)
	}
	return oldValue.OwnerAddressLng, nil
}

// AddOwnerAddressLng adds f to the "owner_address_lng" field.
func (m *InstallationJobMutation) AddOwnerAddressLng(f float64) {
	if m.addowner_address_lng != nil {
		*m.addowner_address_lng += f
	} else {
		m.addowner_address_lng = &f
	}
}

// AddedOwnerAddressLng returns the value that was added to the "owner_address_lng" field in this mutation.
func (m *InstallationJobMutation) AddedOwnerAddressLng() (r float64, exists bool) {
	v := m.addowner_address_lng
	if v == nil {
		return
	}
	return *v, true
}

// ClearOwnerAddressLng clears the value of the "owner_address_lng" field.
func (m *InstallationJobMutation) ClearOwnerAddressLng() {
	m.owner_address_lng = nil
	m.addowner_address_lng = nil
	m.clearedFields[installationjob.FieldOwnerAddressLng] = struct{}{}
}

// OwnerAddressLngCleared returns if the "owner_address_lng" field was cleared in this mutation.
func (m *InstallationJobMutation) OwnerAddressLngCleared() bool {
	_, ok := m.clearedFields[installationjob.FieldOwnerAddressLng]
	return ok
}

// ResetOwnerAddressLng resets all changes to the "owner_address_lng" field.
func (m *InstallationJobMutation) ResetOwnerAddressLng() {
	m.owner_address_lng = nil
	m.addowner_address_lng = nil
	delete(m.clearedFields, installationjob.FieldOwnerAddressLng)
}

// SetSpecialNote sets the "special_note" field.
func (m *InstallationJobMutation) SetSpecialNote(s string) {
	m.special_note = &s
}

// SpecialNote returns the value of the "special_note" field in the mutation.
func (m *InstallationJobMutation) SpecialNote() (r string, exists bool) {
	v := m.special_note
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialNote returns the old "special_note" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldSpecialNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialNote: %w", err)
	}
	return oldValue.SpecialNote, nil
}

// ClearSpecialNote clears the value of the "special_note" field.
func (m *InstallationJobMutation) ClearSpecialNote() {
	m.special_note = nil
	m.clearedFields[installationjob.FieldSpecialNote] = struct{}{}
}

// SpecialNoteCleared returns if the "special_note" field was cleared in this mutation.
func (m *InstallationJobMutation) SpecialNoteCleared() bool {
	_, ok := m.clearedFields[installationjob.FieldSpecialNote]
	return ok
}

// ResetSpecialNote resets all changes to the "special_note" field.
func (m *InstallationJobMutation) ResetSpecialNote() {
	m.special_note = nil
	delete(m.clearedFields, installationjob.FieldSpecialNote)
}

// SetPkg sets the "pkg" field.
func (m *InstallationJobMutation) SetPkg(s string) {
	m.pkg = &s
}

// Pkg returns the value of the "pkg" field in the mutation.
func (m *InstallationJobMutation) Pkg() (r string, exists bool) {
	v := m.pkg
	if v == nil {
		return
	}
	return *v, true
}

// OldPkg returns the old "pkg" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldPkg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkg: %w", err)
	}
	return oldValue.Pkg, nil
}

// ResetPkg resets all changes to the "pkg" field.
func (m *InstallationJobMutation) ResetPkg() {
	m.pkg = nil
}

// SetPkgDescription sets the "pkg_description" field.
func (m *InstallationJobMutation) SetPkgDescription(s string) {
	m.pkg_description = &s
}

// PkgDescription returns the value of the "pkg_description" field in the mutation.
func (m *InstallationJobMutation) PkgDescription() (r string, exists bool) {
	v := m.pkg_description
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgDescription returns the old "pkg_description" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldPkgDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgDescription: %w", err)
	}
	return oldValue.PkgDescription, nil
}

// ClearPkgDescription clears the value of the "pkg_description" field.
func (m *InstallationJobMutation) ClearPkgDescription() {
	m.pkg_description = nil
	m.clearedFields[installationjob.FieldPkgDescription] = struct{}{}
}

// PkgDescriptionCleared returns if the "pkg_description" field was cleared in this mutation.
func (m *InstallationJobMutation) PkgDescriptionCleared() bool {
	_, ok := m.clearedFields[installationjob.FieldPkgDescription]
	return ok
}

// ResetPkgDescription resets all changes to the "pkg_description" field.
func (m *InstallationJobMutation) ResetPkgDescription() {
	m.pkg_description = nil
	delete(m.clearedFields, installationjob.FieldPkgDescription)
}

// SetPkgFeatures sets the "pkg_features" field.
func (m *InstallationJobMutation) SetPkgFeatures(s []string) {
	m.pkg_features = &s
	m.appendpkg_features = nil
}

// PkgFeatures returns the value of the "pkg_features" field in the mutation.
func (m *InstallationJobMutation) PkgFeatures() (r []string, exists bool) {
	v := m.pkg_features
	if v == nil {
		return
	}
	return *v, true
}

// OldPkgFeatures returns the old "pkg_features" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldPkgFeatures(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPkgFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPkgFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPkgFeatures: %w", err)
	}
	return oldValue.PkgFeatures, nil
}

// AppendPkgFeatures adds s to the "pkg_features" field.
func (m *InstallationJobMutation) AppendPkgFeatures(s []string) {
	m.appendpkg_features = append(m.appendpkg_features, s...)
}

// AppendedPkgFeatures returns the list of values that were appended to the "pkg_features" field in this mutation.
func (m *InstallationJobMutation) AppendedPkgFeatures() ([]string, bool) {
	if len(m.appendpkg_features) == 0 {
		return nil, false
	}
	return m.appendpkg_features, true
}

// ClearPkgFeatures clears the value of the "pkg_features" field.
func (m *InstallationJobMutation) ClearPkgFeatures() {
	m.pkg_features = nil
	m.appendpkg_features = nil
	m.clearedFields[installationjob.FieldPkgFeatures] = struct{}{}
}

// PkgFeaturesCleared returns if the "pkg_features" field was cleared in this mutation.
func (m *InstallationJobMutation) PkgFeaturesCleared() bool {
	_, ok := m.clearedFields[installationjob.FieldPkgFeatures]
	return ok
}

// ResetPkgFeatures resets all changes to the "pkg_features" field.
func (m *InstallationJobMutation) ResetPkgFeatures() {
	m.pkg_features = nil
	m.appendpkg_features = nil
	delete(m.clearedFields, installationjob.FieldPkgFeatures)
}

// SetPrice sets the "price" field.
func (m *InstallationJobMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *InstallationJobMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *InstallationJobMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *InstallationJobMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *InstallationJobMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetApproval sets the "approval" field.
func (m *InstallationJobMutation) SetApproval(e enum.Approval) {
	m.approval = &e
}

// Approval returns the value of the "approval" field in the mutation.
func (m *InstallationJobMutation) Approval() (r enum.Approval, exists bool) {
	v := m.approval
	if v == nil {
		return
	}
	return *v, true
}

// OldApproval returns the old "approval" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldApproval(ctx context.Context) (v enum.Approval, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApproval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApproval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproval: %w", err)
	}
	return oldValue.Approval, nil
}

// ResetApproval resets all changes to the "approval" field.
func (m *InstallationJobMutation) ResetApproval() {
	m.approval = nil
}

// SetApprovalAt sets the "approval_at" field.
func (m *InstallationJobMutation) SetApprovalAt(t time.Time) {
	m.approval_at = &t
}

// ApprovalAt returns the value of the "approval_at" field in the mutation.
func (m *InstallationJobMutation) ApprovalAt() (r time.Time, exists bool) {
	v := m.approval_at
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalAt returns the old "approval_at" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldApprovalAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApprovalAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApprovalAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalAt: %w", err)
	}
	return oldValue.ApprovalAt, nil
}

// ResetApprovalAt resets all changes to the "approval_at" field.
func (m *InstallationJobMutation) ResetApprovalAt() {
	m.approval_at = nil
}

// SetDenyReason sets the "deny_reason" field.
func (m *InstallationJobMutation) SetDenyReason(s string) {
	m.deny_reason = &s
}

// DenyReason returns the value of the "deny_reason" field in the mutation.
func (m *InstallationJobMutation) DenyReason() (r string, exists bool) {
	v := m.deny_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldDenyReason returns the old "deny_reason" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldDenyReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDenyReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDenyReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDenyReason: %w", err)
	}
	return oldValue.DenyReason, nil
}

// ClearDenyReason clears the value of the "deny_reason" field.
func (m *InstallationJobMutation) ClearDenyReason() {
	m.deny_reason = nil
	m.clearedFields[installationjob.FieldDenyReason] = struct{}{}
}

// DenyReasonCleared returns if the "deny_reason" field was cleared in this mutation.
func (m *InstallationJobMutation) DenyReasonCleared() bool {
	_, ok := m.clearedFields[installationjob.FieldDenyReason]
	return ok
}

// ResetDenyReason resets all changes to the "deny_reason" field.
func (m *InstallationJobMutation) ResetDenyReason() {
	m.deny_reason = nil
	delete(m.clearedFields, installationjob.FieldDenyReason)
}

// SetStatus sets the "status" field.
func (m *InstallationJobMutation) SetStatus(es enum.InstallationStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *InstallationJobMutation) Status() (r enum.InstallationStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldStatus(ctx context.Context) (v enum.InstallationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InstallationJobMutation) ResetStatus() {
	m.status = nil
}

// SetStatusAt sets the "status_at" field.
func (m *InstallationJobMutation) SetStatusAt(t time.Time) {
	m.status_at = &t
}

// StatusAt returns the value of the "status_at" field in the mutation.
func (m *InstallationJobMutation) StatusAt() (r time.Time, exists bool) {
	v := m.status_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusAt returns the old "status_at" field's value of the InstallationJob entity.
// If the InstallationJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobMutation) OldStatusAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusAt: %w", err)
	}
	return oldValue.StatusAt, nil
}

// ResetStatusAt resets all changes to the "status_at" field.
func (m *InstallationJobMutation) ResetStatusAt() {
	m.status_at = nil
}

// AddItemIDs adds the "items" edge to the InstallationJobItem entity by ids.
func (m *InstallationJobMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the InstallationJobItem entity.
func (m *InstallationJobMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the InstallationJobItem entity was cleared.
func (m *InstallationJobMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the InstallationJobItem entity by IDs.
func (m *InstallationJobMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the InstallationJobItem entity.
func (m *InstallationJobMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *InstallationJobMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *InstallationJobMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// AddProgressHistoryIDs adds the "progress_history" edge to the InstallationJobProgress entity by ids.
func (m *InstallationJobMutation) AddProgressHistoryIDs(ids ...string) {
	if m.progress_history == nil {
		m.progress_history = make(map[string]struct{})
	}
	for i := range ids {
		m.progress_history[ids[i]] = struct{}{}
	}
}

// ClearProgressHistory clears the "progress_history" edge to the InstallationJobProgress entity.
func (m *InstallationJobMutation) ClearProgressHistory() {
	m.clearedprogress_history = true
}

// ProgressHistoryCleared reports if the "progress_history" edge to the InstallationJobProgress entity was cleared.
func (m *InstallationJobMutation) ProgressHistoryCleared() bool {
	return m.clearedprogress_history
}

// RemoveProgressHistoryIDs removes the "progress_history" edge to the InstallationJobProgress entity by IDs.
func (m *InstallationJobMutation) RemoveProgressHistoryIDs(ids ...string) {
	if m.removedprogress_history == nil {
		m.removedprogress_history = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.progress_history, ids[i])
		m.removedprogress_history[ids[i]] = struct{}{}
	}
}

// RemovedProgressHistory returns the removed IDs of the "progress_history" edge to the InstallationJobProgress entity.
func (m *InstallationJobMutation) RemovedProgressHistoryIDs() (ids []string) {
	for id := range m.removedprogress_history {
		ids = append(ids, id)
	}
	return
}

// ProgressHistoryIDs returns the "progress_history" edge IDs in the mutation.
func (m *InstallationJobMutation) ProgressHistoryIDs() (ids []string) {
	for id := range m.progress_history {
		ids = append(ids, id)
	}
	return
}

// ResetProgressHistory resets all changes to the "progress_history" edge.
func (m *InstallationJobMutation) ResetProgressHistory() {
	m.progress_history = nil
	m.clearedprogress_history = false
	m.removedprogress_history = nil
}

// SetRequestingPartnerID sets the "requesting_partner" edge to the Partner entity by id.
func (m *InstallationJobMutation) SetRequestingPartnerID(id string) {
	m.requesting_partner = &id
}

// ClearRequestingPartner clears the "requesting_partner" edge to the Partner entity.
func (m *InstallationJobMutation) ClearRequestingPartner() {
	m.clearedrequesting_partner = true
}

// RequestingPartnerCleared reports if the "requesting_partner" edge to the Partner entity was cleared.
func (m *InstallationJobMutation) RequestingPartnerCleared() bool {
	return m.clearedrequesting_partner
}

// RequestingPartnerID returns the "requesting_partner" edge ID in the mutation.
func (m *InstallationJobMutation) RequestingPartnerID() (id string, exists bool) {
	if m.requesting_partner != nil {
		return *m.requesting_partner, true
	}
	return
}

// RequestingPartnerIDs returns the "requesting_partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestingPartnerID instead. It exists only for internal usage by the builders.
func (m *InstallationJobMutation) RequestingPartnerIDs() (ids []string) {
	if id := m.requesting_partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequestingPartner resets all changes to the "requesting_partner" edge.
func (m *InstallationJobMutation) ResetRequestingPartner() {
	m.requesting_partner = nil
	m.clearedrequesting_partner = false
}

// SetAssignedPartnerID sets the "assigned_partner" edge to the Partner entity by id.
func (m *InstallationJobMutation) SetAssignedPartnerID(id string) {
	m.assigned_partner = &id
}

// ClearAssignedPartner clears the "assigned_partner" edge to the Partner entity.
func (m *InstallationJobMutation) ClearAssignedPartner() {
	m.clearedassigned_partner = true
}

// AssignedPartnerCleared reports if the "assigned_partner" edge to the Partner entity was cleared.
func (m *InstallationJobMutation) AssignedPartnerCleared() bool {
	return m.clearedassigned_partner
}

// AssignedPartnerID returns the "assigned_partner" edge ID in the mutation.
func (m *InstallationJobMutation) AssignedPartnerID() (id string, exists bool) {
	if m.assigned_partner != nil {
		return *m.assigned_partner, true
	}
	return
}

// AssignedPartnerIDs returns the "assigned_partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AssignedPartnerID instead. It exists only for internal usage by the builders.
func (m *InstallationJobMutation) AssignedPartnerIDs() (ids []string) {
	if id := m.assigned_partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAssignedPartner resets all changes to the "assigned_partner" edge.
func (m *InstallationJobMutation) ResetAssignedPartner() {
	m.assigned_partner = nil
	m.clearedassigned_partner = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *InstallationJobMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *InstallationJobMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *InstallationJobMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *InstallationJobMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *InstallationJobMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *InstallationJobMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetSalesRepID sets the "sales_rep" edge to the User entity by id.
func (m *InstallationJobMutation) SetSalesRepID(id string) {
	m.sales_rep = &id
}

// ClearSalesRep clears the "sales_rep" edge to the User entity.
func (m *InstallationJobMutation) ClearSalesRep() {
	m.clearedsales_rep = true
}

// SalesRepCleared reports if the "sales_rep" edge to the User entity was cleared.
func (m *InstallationJobMutation) SalesRepCleared() bool {
	return m.clearedsales_rep
}

// SalesRepID returns the "sales_rep" edge ID in the mutation.
func (m *InstallationJobMutation) SalesRepID() (id string, exists bool) {
	if m.sales_rep != nil {
		return *m.sales_rep, true
	}
	return
}

// SalesRepIDs returns the "sales_rep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SalesRepID instead. It exists only for internal usage by the builders.
func (m *InstallationJobMutation) SalesRepIDs() (ids []string) {
	if id := m.sales_rep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSalesRep resets all changes to the "sales_rep" edge.
func (m *InstallationJobMutation) ResetSalesRep() {
	m.sales_rep = nil
	m.clearedsales_rep = false
}

// Where appends a list predicates to the InstallationJobMutation builder.
func (m *InstallationJobMutation) Where(ps ...predicate.InstallationJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstallationJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstallationJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InstallationJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstallationJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstallationJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InstallationJob).
func (m *InstallationJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstallationJobMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.created_at != nil {
		fields = append(fields, installationjob.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, installationjob.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, installationjob.FieldType)
	}
	if m.owner_name != nil {
		fields = append(fields, installationjob.FieldOwnerName)
	}
	if m.owner_phone != nil {
		fields = append(fields, installationjob.FieldOwnerPhone)
	}
	if m.owner_email != nil {
		fields = append(fields, installationjob.FieldOwnerEmail)
	}
	if m.owner_address != nil {
		fields = append(fields, installationjob.FieldOwnerAddress)
	}
	if m.owner_address_lat != nil {
		fields = append(fields, installationjob.FieldOwnerAddressLat)
	}
	if m.owner_address_lng != nil {
		fields = append(fields, installationjob.FieldOwnerAddressLng)
	}
	if m.special_note != nil {
		fields = append(fields, installationjob.FieldSpecialNote)
	}
	if m.pkg != nil {
		fields = append(fields, installationjob.FieldPkg)
	}
	if m.pkg_description != nil {
		fields = append(fields, installationjob.FieldPkgDescription)
	}
	if m.pkg_features != nil {
		fields = append(fields, installationjob.FieldPkgFeatures)
	}
	if m.price != nil {
		fields = append(fields, installationjob.FieldPrice)
	}
	if m.approval != nil {
		fields = append(fields, installationjob.FieldApproval)
	}
	if m.approval_at != nil {
		fields = append(fields, installationjob.FieldApprovalAt)
	}
	if m.deny_reason != nil {
		fields = append(fields, installationjob.FieldDenyReason)
	}
	if m.status != nil {
		fields = append(fields, installationjob.FieldStatus)
	}
	if m.status_at != nil {
		fields = append(fields, installationjob.FieldStatusAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstallationJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case installationjob.FieldCreatedAt:
		return m.CreatedAt()
	case installationjob.FieldUpdatedAt:
		return m.UpdatedAt()
	case installationjob.FieldType:
		return m.GetType()
	case installationjob.FieldOwnerName:
		return m.OwnerName()
	case installationjob.FieldOwnerPhone:
		return m.OwnerPhone()
	case installationjob.FieldOwnerEmail:
		return m.OwnerEmail()
	case installationjob.FieldOwnerAddress:
		return m.OwnerAddress()
	case installationjob.FieldOwnerAddressLat:
		return m.OwnerAddressLat()
	case installationjob.FieldOwnerAddressLng:
		return m.OwnerAddressLng()
	case installationjob.FieldSpecialNote:
		return m.SpecialNote()
	case installationjob.FieldPkg:
		return m.Pkg()
	case installationjob.FieldPkgDescription:
		return m.PkgDescription()
	case installationjob.FieldPkgFeatures:
		return m.PkgFeatures()
	case installationjob.FieldPrice:
		return m.Price()
	case installationjob.FieldApproval:
		return m.Approval()
	case installationjob.FieldApprovalAt:
		return m.ApprovalAt()
	case installationjob.FieldDenyReason:
		return m.DenyReason()
	case installationjob.FieldStatus:
		return m.Status()
	case installationjob.FieldStatusAt:
		return m.StatusAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstallationJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case installationjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case installationjob.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case installationjob.FieldType:
		return m.OldType(ctx)
	case installationjob.FieldOwnerName:
		return m.OldOwnerName(ctx)
	case installationjob.FieldOwnerPhone:
		return m.OldOwnerPhone(ctx)
	case installationjob.FieldOwnerEmail:
		return m.OldOwnerEmail(ctx)
	case installationjob.FieldOwnerAddress:
		return m.OldOwnerAddress(ctx)
	case installationjob.FieldOwnerAddressLat:
		return m.OldOwnerAddressLat(ctx)
	case installationjob.FieldOwnerAddressLng:
		return m.OldOwnerAddressLng(ctx)
	case installationjob.FieldSpecialNote:
		return m.OldSpecialNote(ctx)
	case installationjob.FieldPkg:
		return m.OldPkg(ctx)
	case installationjob.FieldPkgDescription:
		return m.OldPkgDescription(ctx)
	case installationjob.FieldPkgFeatures:
		return m.OldPkgFeatures(ctx)
	case installationjob.FieldPrice:
		return m.OldPrice(ctx)
	case installationjob.FieldApproval:
		return m.OldApproval(ctx)
	case installationjob.FieldApprovalAt:
		return m.OldApprovalAt(ctx)
	case installationjob.FieldDenyReason:
		return m.OldDenyReason(ctx)
	case installationjob.FieldStatus:
		return m.OldStatus(ctx)
	case installationjob.FieldStatusAt:
		return m.OldStatusAt(ctx)
	}
	return nil, fmt.Errorf("unknown InstallationJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstallationJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case installationjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case installationjob.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case installationjob.FieldType:
		v, ok := value.(enum.InstallationType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case installationjob.FieldOwnerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerName(v)
		return nil
	case installationjob.FieldOwnerPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerPhone(v)
		return nil
	case installationjob.FieldOwnerEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerEmail(v)
		return nil
	case installationjob.FieldOwnerAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerAddress(v)
		return nil
	case installationjob.FieldOwnerAddressLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerAddressLat(v)
		return nil
	case installationjob.FieldOwnerAddressLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerAddressLng(v)
		return nil
	case installationjob.FieldSpecialNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialNote(v)
		return nil
	case installationjob.FieldPkg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkg(v)
		return nil
	case installationjob.FieldPkgDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgDescription(v)
		return nil
	case installationjob.FieldPkgFeatures:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPkgFeatures(v)
		return nil
	case installationjob.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case installationjob.FieldApproval:
		v, ok := value.(enum.Approval)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproval(v)
		return nil
	case installationjob.FieldApprovalAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalAt(v)
		return nil
	case installationjob.FieldDenyReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDenyReason(v)
		return nil
	case installationjob.FieldStatus:
		v, ok := value.(enum.InstallationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case installationjob.FieldStatusAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusAt(v)
		return nil
	}
	return fmt.Errorf("unknown InstallationJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstallationJobMutation) AddedFields() []string {
	var fields []string
	if m.addowner_address_lat != nil {
		fields = append(fields, installationjob.FieldOwnerAddressLat)
	}
	if m.addowner_address_lng != nil {
		fields = append(fields, installationjob.FieldOwnerAddressLng)
	}
	if m.addprice != nil {
		fields = append(fields, installationjob.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstallationJobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case installationjob.FieldOwnerAddressLat:
		return m.AddedOwnerAddressLat()
	case installationjob.FieldOwnerAddressLng:
		return m.AddedOwnerAddressLng()
	case installationjob.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstallationJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case installationjob.FieldOwnerAddressLat:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerAddressLat(v)
		return nil
	case installationjob.FieldOwnerAddressLng:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOwnerAddressLng(v)
		return nil
	case installationjob.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown InstallationJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstallationJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(installationjob.FieldOwnerEmail) {
		fields = append(fields, installationjob.FieldOwnerEmail)
	}
	if m.FieldCleared(installationjob.FieldOwnerAddressLat) {
		fields = append(fields, installationjob.FieldOwnerAddressLat)
	}
	if m.FieldCleared(installationjob.FieldOwnerAddressLng) {
		fields = append(fields, installationjob.FieldOwnerAddressLng)
	}
	if m.FieldCleared(installationjob.FieldSpecialNote) {
		fields = append(fields, installationjob.FieldSpecialNote)
	}
	if m.FieldCleared(installationjob.FieldPkgDescription) {
		fields = append(fields, installationjob.FieldPkgDescription)
	}
	if m.FieldCleared(installationjob.FieldPkgFeatures) {
		fields = append(fields, installationjob.FieldPkgFeatures)
	}
	if m.FieldCleared(installationjob.FieldDenyReason) {
		fields = append(fields, installationjob.FieldDenyReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstallationJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstallationJobMutation) ClearField(name string) error {
	switch name {
	case installationjob.FieldOwnerEmail:
		m.ClearOwnerEmail()
		return nil
	case installationjob.FieldOwnerAddressLat:
		m.ClearOwnerAddressLat()
		return nil
	case installationjob.FieldOwnerAddressLng:
		m.ClearOwnerAddressLng()
		return nil
	case installationjob.FieldSpecialNote:
		m.ClearSpecialNote()
		return nil
	case installationjob.FieldPkgDescription:
		m.ClearPkgDescription()
		return nil
	case installationjob.FieldPkgFeatures:
		m.ClearPkgFeatures()
		return nil
	case installationjob.FieldDenyReason:
		m.ClearDenyReason()
		return nil
	}
	return fmt.Errorf("unknown InstallationJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstallationJobMutation) ResetField(name string) error {
	switch name {
	case installationjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case installationjob.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case installationjob.FieldType:
		m.ResetType()
		return nil
	case installationjob.FieldOwnerName:
		m.ResetOwnerName()
		return nil
	case installationjob.FieldOwnerPhone:
		m.ResetOwnerPhone()
		return nil
	case installationjob.FieldOwnerEmail:
		m.ResetOwnerEmail()
		return nil
	case installationjob.FieldOwnerAddress:
		m.ResetOwnerAddress()
		return nil
	case installationjob.FieldOwnerAddressLat:
		m.ResetOwnerAddressLat()
		return nil
	case installationjob.FieldOwnerAddressLng:
		m.ResetOwnerAddressLng()
		return nil
	case installationjob.FieldSpecialNote:
		m.ResetSpecialNote()
		return nil
	case installationjob.FieldPkg:
		m.ResetPkg()
		return nil
	case installationjob.FieldPkgDescription:
		m.ResetPkgDescription()
		return nil
	case installationjob.FieldPkgFeatures:
		m.ResetPkgFeatures()
		return nil
	case installationjob.FieldPrice:
		m.ResetPrice()
		return nil
	case installationjob.FieldApproval:
		m.ResetApproval()
		return nil
	case installationjob.FieldApprovalAt:
		m.ResetApprovalAt()
		return nil
	case installationjob.FieldDenyReason:
		m.ResetDenyReason()
		return nil
	case installationjob.FieldStatus:
		m.ResetStatus()
		return nil
	case installationjob.FieldStatusAt:
		m.ResetStatusAt()
		return nil
	}
	return fmt.Errorf("unknown InstallationJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstallationJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.items != nil {
		edges = append(edges, installationjob.EdgeItems)
	}
	if m.progress_history != nil {
		edges = append(edges, installationjob.EdgeProgressHistory)
	}
	if m.requesting_partner != nil {
		edges = append(edges, installationjob.EdgeRequestingPartner)
	}
	if m.assigned_partner != nil {
		edges = append(edges, installationjob.EdgeAssignedPartner)
	}
	if m.creator != nil {
		edges = append(edges, installationjob.EdgeCreator)
	}
	if m.sales_rep != nil {
		edges = append(edges, installationjob.EdgeSalesRep)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstallationJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case installationjob.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case installationjob.EdgeProgressHistory:
		ids := make([]ent.Value, 0, len(m.progress_history))
		for id := range m.progress_history {
			ids = append(ids, id)
		}
		return ids
	case installationjob.EdgeRequestingPartner:
		if id := m.requesting_partner; id != nil {
			return []ent.Value{*id}
		}
	case installationjob.EdgeAssignedPartner:
		if id := m.assigned_partner; id != nil {
			return []ent.Value{*id}
		}
	case installationjob.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case installationjob.EdgeSalesRep:
		if id := m.sales_rep; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstallationJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removeditems != nil {
		edges = append(edges, installationjob.EdgeItems)
	}
	if m.removedprogress_history != nil {
		edges = append(edges, installationjob.EdgeProgressHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstallationJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case installationjob.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	case installationjob.EdgeProgressHistory:
		ids := make([]ent.Value, 0, len(m.removedprogress_history))
		for id := range m.removedprogress_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstallationJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.cleareditems {
		edges = append(edges, installationjob.EdgeItems)
	}
	if m.clearedprogress_history {
		edges = append(edges, installationjob.EdgeProgressHistory)
	}
	if m.clearedrequesting_partner {
		edges = append(edges, installationjob.EdgeRequestingPartner)
	}
	if m.clearedassigned_partner {
		edges = append(edges, installationjob.EdgeAssignedPartner)
	}
	if m.clearedcreator {
		edges = append(edges, installationjob.EdgeCreator)
	}
	if m.clearedsales_rep {
		edges = append(edges, installationjob.EdgeSalesRep)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstallationJobMutation) EdgeCleared(name string) bool {
	switch name {
	case installationjob.EdgeItems:
		return m.cleareditems
	case installationjob.EdgeProgressHistory:
		return m.clearedprogress_history
	case installationjob.EdgeRequestingPartner:
		return m.clearedrequesting_partner
	case installationjob.EdgeAssignedPartner:
		return m.clearedassigned_partner
	case installationjob.EdgeCreator:
		return m.clearedcreator
	case installationjob.EdgeSalesRep:
		return m.clearedsales_rep
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstallationJobMutation) ClearEdge(name string) error {
	switch name {
	case installationjob.EdgeRequestingPartner:
		m.ClearRequestingPartner()
		return nil
	case installationjob.EdgeAssignedPartner:
		m.ClearAssignedPartner()
		return nil
	case installationjob.EdgeCreator:
		m.ClearCreator()
		return nil
	case installationjob.EdgeSalesRep:
		m.ClearSalesRep()
		return nil
	}
	return fmt.Errorf("unknown InstallationJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstallationJobMutation) ResetEdge(name string) error {
	switch name {
	case installationjob.EdgeItems:
		m.ResetItems()
		return nil
	case installationjob.EdgeProgressHistory:
		m.ResetProgressHistory()
		return nil
	case installationjob.EdgeRequestingPartner:
		m.ResetRequestingPartner()
		return nil
	case installationjob.EdgeAssignedPartner:
		m.ResetAssignedPartner()
		return nil
	case installationjob.EdgeCreator:
		m.ResetCreator()
		return nil
	case installationjob.EdgeSalesRep:
		m.ResetSalesRep()
		return nil
	}
	return fmt.Errorf("unknown InstallationJob edge %s", name)
}

// InstallationJobItemMutation represents an operation that mutates the InstallationJobItem nodes in the graph.
type InstallationJobItemMutation struct {
	config
	op             Op
	typ            string
	id             *string
	name           *string
	description    *string
	features       *[]string
	appendfeatures []string
	price          *float64
	addprice       *float64
	img_key        *string
	special_note   *string
	clearedFields  map[string]struct{}
	job            *string
	clearedjob     bool
	done           bool
	oldValue       func(context.Context) (*InstallationJobItem, error)
	predicates     []predicate.InstallationJobItem
}

var _ ent.Mutation = (*InstallationJobItemMutation)(nil)

// installationjobitemOption allows management of the mutation configuration using functional options.
type installationjobitemOption func(*InstallationJobItemMutation)

// newInstallationJobItemMutation creates new mutation for the InstallationJobItem entity.
func newInstallationJobItemMutation(c config, op Op, opts ...installationjobitemOption) *InstallationJobItemMutation {
	m := &InstallationJobItemMutation{
		config:        c,
		op:            op,
		typ:           TypeInstallationJobItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstallationJobItemID sets the ID field of the mutation.
func withInstallationJobItemID(id string) installationjobitemOption {
	return func(m *InstallationJobItemMutation) {
		var (
			err   error
			once  sync.Once
			value *InstallationJobItem
		)
		m.oldValue = func(ctx context.Context) (*InstallationJobItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstallationJobItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstallationJobItem sets the old InstallationJobItem of the mutation.
func withInstallationJobItem(node *InstallationJobItem) installationjobitemOption {
	return func(m *InstallationJobItemMutation) {
		m.oldValue = func(context.Context) (*InstallationJobItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstallationJobItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstallationJobItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InstallationJobItem entities.
func (m *InstallationJobItemMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstallationJobItemMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstallationJobItemMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InstallationJobItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *InstallationJobItemMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InstallationJobItemMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the InstallationJobItem entity.
// If the InstallationJobItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobItemMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *InstallationJobItemMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *InstallationJobItemMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *InstallationJobItemMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the InstallationJobItem entity.
// If the InstallationJobItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobItemMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *InstallationJobItemMutation) ResetDescription() {
	m.description = nil
}

// SetFeatures sets the "features" field.
func (m *InstallationJobItemMutation) SetFeatures(s []string) {
	m.features = &s
	m.appendfeatures = nil
}

// Features returns the value of the "features" field in the mutation.
func (m *InstallationJobItemMutation) Features() (r []string, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatures returns the old "features" field's value of the InstallationJobItem entity.
// If the InstallationJobItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobItemMutation) OldFeatures(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatures: %w", err)
	}
	return oldValue.Features, nil
}

// AppendFeatures adds s to the "features" field.
func (m *InstallationJobItemMutation) AppendFeatures(s []string) {
	m.appendfeatures = append(m.appendfeatures, s...)
}

// AppendedFeatures returns the list of values that were appended to the "features" field in this mutation.
func (m *InstallationJobItemMutation) AppendedFeatures() ([]string, bool) {
	if len(m.appendfeatures) == 0 {
		return nil, false
	}
	return m.appendfeatures, true
}

// ResetFeatures resets all changes to the "features" field.
func (m *InstallationJobItemMutation) ResetFeatures() {
	m.features = nil
	m.appendfeatures = nil
}

// SetPrice sets the "price" field.
func (m *InstallationJobItemMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *InstallationJobItemMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the InstallationJobItem entity.
// If the InstallationJobItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobItemMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *InstallationJobItemMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *InstallationJobItemMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *InstallationJobItemMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetImgKey sets the "img_key" field.
func (m *InstallationJobItemMutation) SetImgKey(s string) {
	m.img_key = &s
}

// ImgKey returns the value of the "img_key" field in the mutation.
func (m *InstallationJobItemMutation) ImgKey() (r string, exists bool) {
	v := m.img_key
	if v == nil {
		return
	}
	return *v, true
}

// OldImgKey returns the old "img_key" field's value of the InstallationJobItem entity.
// If the InstallationJobItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobItemMutation) OldImgKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImgKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImgKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImgKey: %w", err)
	}
	return oldValue.ImgKey, nil
}

// ResetImgKey resets all changes to the "img_key" field.
func (m *InstallationJobItemMutation) ResetImgKey() {
	m.img_key = nil
}

// SetSpecialNote sets the "special_note" field.
func (m *InstallationJobItemMutation) SetSpecialNote(s string) {
	m.special_note = &s
}

// SpecialNote returns the value of the "special_note" field in the mutation.
func (m *InstallationJobItemMutation) SpecialNote() (r string, exists bool) {
	v := m.special_note
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialNote returns the old "special_note" field's value of the InstallationJobItem entity.
// If the InstallationJobItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobItemMutation) OldSpecialNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialNote: %w", err)
	}
	return oldValue.SpecialNote, nil
}

// ClearSpecialNote clears the value of the "special_note" field.
func (m *InstallationJobItemMutation) ClearSpecialNote() {
	m.special_note = nil
	m.clearedFields[installationjobitem.FieldSpecialNote] = struct{}{}
}

// SpecialNoteCleared returns if the "special_note" field was cleared in this mutation.
func (m *InstallationJobItemMutation) SpecialNoteCleared() bool {
	_, ok := m.clearedFields[installationjobitem.FieldSpecialNote]
	return ok
}

// ResetSpecialNote resets all changes to the "special_note" field.
func (m *InstallationJobItemMutation) ResetSpecialNote() {
	m.special_note = nil
	delete(m.clearedFields, installationjobitem.FieldSpecialNote)
}

// SetJobID sets the "job" edge to the InstallationJob entity by id.
func (m *InstallationJobItemMutation) SetJobID(id string) {
	m.job = &id
}

// ClearJob clears the "job" edge to the InstallationJob entity.
func (m *InstallationJobItemMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the InstallationJob entity was cleared.
func (m *InstallationJobItemMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *InstallationJobItemMutation) JobID() (id string, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *InstallationJobItemMutation) JobIDs() (ids []string) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *InstallationJobItemMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the InstallationJobItemMutation builder.
func (m *InstallationJobItemMutation) Where(ps ...predicate.InstallationJobItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstallationJobItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstallationJobItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InstallationJobItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstallationJobItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstallationJobItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InstallationJobItem).
func (m *InstallationJobItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstallationJobItemMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, installationjobitem.FieldName)
	}
	if m.description != nil {
		fields = append(fields, installationjobitem.FieldDescription)
	}
	if m.features != nil {
		fields = append(fields, installationjobitem.FieldFeatures)
	}
	if m.price != nil {
		fields = append(fields, installationjobitem.FieldPrice)
	}
	if m.img_key != nil {
		fields = append(fields, installationjobitem.FieldImgKey)
	}
	if m.special_note != nil {
		fields = append(fields, installationjobitem.FieldSpecialNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstallationJobItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case installationjobitem.FieldName:
		return m.Name()
	case installationjobitem.FieldDescription:
		return m.Description()
	case installationjobitem.FieldFeatures:
		return m.Features()
	case installationjobitem.FieldPrice:
		return m.Price()
	case installationjobitem.FieldImgKey:
		return m.ImgKey()
	case installationjobitem.FieldSpecialNote:
		return m.SpecialNote()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstallationJobItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case installationjobitem.FieldName:
		return m.OldName(ctx)
	case installationjobitem.FieldDescription:
		return m.OldDescription(ctx)
	case installationjobitem.FieldFeatures:
		return m.OldFeatures(ctx)
	case installationjobitem.FieldPrice:
		return m.OldPrice(ctx)
	case installationjobitem.FieldImgKey:
		return m.OldImgKey(ctx)
	case installationjobitem.FieldSpecialNote:
		return m.OldSpecialNote(ctx)
	}
	return nil, fmt.Errorf("unknown InstallationJobItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstallationJobItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case installationjobitem.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case installationjobitem.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case installationjobitem.FieldFeatures:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatures(v)
		return nil
	case installationjobitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case installationjobitem.FieldImgKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImgKey(v)
		return nil
	case installationjobitem.FieldSpecialNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialNote(v)
		return nil
	}
	return fmt.Errorf("unknown InstallationJobItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstallationJobItemMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, installationjobitem.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstallationJobItemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case installationjobitem.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstallationJobItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case installationjobitem.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown InstallationJobItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstallationJobItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(installationjobitem.FieldSpecialNote) {
		fields = append(fields, installationjobitem.FieldSpecialNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstallationJobItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstallationJobItemMutation) ClearField(name string) error {
	switch name {
	case installationjobitem.FieldSpecialNote:
		m.ClearSpecialNote()
		return nil
	}
	return fmt.Errorf("unknown InstallationJobItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstallationJobItemMutation) ResetField(name string) error {
	switch name {
	case installationjobitem.FieldName:
		m.ResetName()
		return nil
	case installationjobitem.FieldDescription:
		m.ResetDescription()
		return nil
	case installationjobitem.FieldFeatures:
		m.ResetFeatures()
		return nil
	case installationjobitem.FieldPrice:
		m.ResetPrice()
		return nil
	case installationjobitem.FieldImgKey:
		m.ResetImgKey()
		return nil
	case installationjobitem.FieldSpecialNote:
		m.ResetSpecialNote()
		return nil
	}
	return fmt.Errorf("unknown InstallationJobItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstallationJobItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, installationjobitem.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstallationJobItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case installationjobitem.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstallationJobItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstallationJobItemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstallationJobItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, installationjobitem.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstallationJobItemMutation) EdgeCleared(name string) bool {
	switch name {
	case installationjobitem.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstallationJobItemMutation) ClearEdge(name string) error {
	switch name {
	case installationjobitem.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown InstallationJobItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstallationJobItemMutation) ResetEdge(name string) error {
	switch name {
	case installationjobitem.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown InstallationJobItem edge %s", name)
}

// InstallationJobProgressMutation represents an operation that mutates the InstallationJobProgress nodes in the graph.
type InstallationJobProgressMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	status         *enum.InstallationStatus
	complete       *bool
	note           *string
	clearedFields  map[string]struct{}
	job            *string
	clearedjob     bool
	creator        *string
	clearedcreator bool
	done           bool
	oldValue       func(context.Context) (*InstallationJobProgress, error)
	predicates     []predicate.InstallationJobProgress
}

var _ ent.Mutation = (*InstallationJobProgressMutation)(nil)

// installationjobprogressOption allows management of the mutation configuration using functional options.
type installationjobprogressOption func(*InstallationJobProgressMutation)

// newInstallationJobProgressMutation creates new mutation for the InstallationJobProgress entity.
func newInstallationJobProgressMutation(c config, op Op, opts ...installationjobprogressOption) *InstallationJobProgressMutation {
	m := &InstallationJobProgressMutation{
		config:        c,
		op:            op,
		typ:           TypeInstallationJobProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstallationJobProgressID sets the ID field of the mutation.
func withInstallationJobProgressID(id string) installationjobprogressOption {
	return func(m *InstallationJobProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *InstallationJobProgress
		)
		m.oldValue = func(ctx context.Context) (*InstallationJobProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstallationJobProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstallationJobProgress sets the old InstallationJobProgress of the mutation.
func withInstallationJobProgress(node *InstallationJobProgress) installationjobprogressOption {
	return func(m *InstallationJobProgressMutation) {
		m.oldValue = func(context.Context) (*InstallationJobProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstallationJobProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstallationJobProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InstallationJobProgress entities.
func (m *InstallationJobProgressMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstallationJobProgressMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstallationJobProgressMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InstallationJobProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InstallationJobProgressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InstallationJobProgressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the InstallationJobProgress entity.
// If the InstallationJobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobProgressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InstallationJobProgressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InstallationJobProgressMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InstallationJobProgressMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the InstallationJobProgress entity.
// If the InstallationJobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobProgressMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InstallationJobProgressMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetStatus sets the "status" field.
func (m *InstallationJobProgressMutation) SetStatus(es enum.InstallationStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *InstallationJobProgressMutation) Status() (r enum.InstallationStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the InstallationJobProgress entity.
// If the InstallationJobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobProgressMutation) OldStatus(ctx context.Context) (v enum.InstallationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InstallationJobProgressMutation) ResetStatus() {
	m.status = nil
}

// SetComplete sets the "complete" field.
func (m *InstallationJobProgressMutation) SetComplete(b bool) {
	m.complete = &b
}

// Complete returns the value of the "complete" field in the mutation.
func (m *InstallationJobProgressMutation) Complete() (r bool, exists bool) {
	v := m.complete
	if v == nil {
		return
	}
	return *v, true
}

// OldComplete returns the old "complete" field's value of the InstallationJobProgress entity.
// If the InstallationJobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobProgressMutation) OldComplete(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComplete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComplete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComplete: %w", err)
	}
	return oldValue.Complete, nil
}

// ClearComplete clears the value of the "complete" field.
func (m *InstallationJobProgressMutation) ClearComplete() {
	m.complete = nil
	m.clearedFields[installationjobprogress.FieldComplete] = struct{}{}
}

// CompleteCleared returns if the "complete" field was cleared in this mutation.
func (m *InstallationJobProgressMutation) CompleteCleared() bool {
	_, ok := m.clearedFields[installationjobprogress.FieldComplete]
	return ok
}

// ResetComplete resets all changes to the "complete" field.
func (m *InstallationJobProgressMutation) ResetComplete() {
	m.complete = nil
	delete(m.clearedFields, installationjobprogress.FieldComplete)
}

// SetNote sets the "note" field.
func (m *InstallationJobProgressMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *InstallationJobProgressMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the InstallationJobProgress entity.
// If the InstallationJobProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstallationJobProgressMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *InstallationJobProgressMutation) ClearNote() {
	m.note = nil
	m.clearedFields[installationjobprogress.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *InstallationJobProgressMutation) NoteCleared() bool {
	_, ok := m.clearedFields[installationjobprogress.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *InstallationJobProgressMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, installationjobprogress.FieldNote)
}

// SetJobID sets the "job" edge to the InstallationJob entity by id.
func (m *InstallationJobProgressMutation) SetJobID(id string) {
	m.job = &id
}

// ClearJob clears the "job" edge to the InstallationJob entity.
func (m *InstallationJobProgressMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the InstallationJob entity was cleared.
func (m *InstallationJobProgressMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *InstallationJobProgressMutation) JobID() (id string, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *InstallationJobProgressMutation) JobIDs() (ids []string) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *InstallationJobProgressMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *InstallationJobProgressMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *InstallationJobProgressMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *InstallationJobProgressMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *InstallationJobProgressMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *InstallationJobProgressMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *InstallationJobProgressMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the InstallationJobProgressMutation builder.
func (m *InstallationJobProgressMutation) Where(ps ...predicate.InstallationJobProgress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstallationJobProgressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstallationJobProgressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InstallationJobProgress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstallationJobProgressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstallationJobProgressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InstallationJobProgress).
func (m *InstallationJobProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstallationJobProgressMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, installationjobprogress.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, installationjobprogress.FieldUpdatedAt)
	}
	if m.status != nil {
		fields = append(fields, installationjobprogress.FieldStatus)
	}
	if m.complete != nil {
		fields = append(fields, installationjobprogress.FieldComplete)
	}
	if m.note != nil {
		fields = append(fields, installationjobprogress.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstallationJobProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case installationjobprogress.FieldCreatedAt:
		return m.CreatedAt()
	case installationjobprogress.FieldUpdatedAt:
		return m.UpdatedAt()
	case installationjobprogress.FieldStatus:
		return m.Status()
	case installationjobprogress.FieldComplete:
		return m.Complete()
	case installationjobprogress.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstallationJobProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case installationjobprogress.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case installationjobprogress.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case installationjobprogress.FieldStatus:
		return m.OldStatus(ctx)
	case installationjobprogress.FieldComplete:
		return m.OldComplete(ctx)
	case installationjobprogress.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown InstallationJobProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstallationJobProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case installationjobprogress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case installationjobprogress.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case installationjobprogress.FieldStatus:
		v, ok := value.(enum.InstallationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case installationjobprogress.FieldComplete:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComplete(v)
		return nil
	case installationjobprogress.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown InstallationJobProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstallationJobProgressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstallationJobProgressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstallationJobProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InstallationJobProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstallationJobProgressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(installationjobprogress.FieldComplete) {
		fields = append(fields, installationjobprogress.FieldComplete)
	}
	if m.FieldCleared(installationjobprogress.FieldNote) {
		fields = append(fields, installationjobprogress.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstallationJobProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstallationJobProgressMutation) ClearField(name string) error {
	switch name {
	case installationjobprogress.FieldComplete:
		m.ClearComplete()
		return nil
	case installationjobprogress.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown InstallationJobProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstallationJobProgressMutation) ResetField(name string) error {
	switch name {
	case installationjobprogress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case installationjobprogress.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case installationjobprogress.FieldStatus:
		m.ResetStatus()
		return nil
	case installationjobprogress.FieldComplete:
		m.ResetComplete()
		return nil
	case installationjobprogress.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown InstallationJobProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstallationJobProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.job != nil {
		edges = append(edges, installationjobprogress.EdgeJob)
	}
	if m.creator != nil {
		edges = append(edges, installationjobprogress.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstallationJobProgressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case installationjobprogress.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case installationjobprogress.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstallationJobProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstallationJobProgressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstallationJobProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjob {
		edges = append(edges, installationjobprogress.EdgeJob)
	}
	if m.clearedcreator {
		edges = append(edges, installationjobprogress.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstallationJobProgressMutation) EdgeCleared(name string) bool {
	switch name {
	case installationjobprogress.EdgeJob:
		return m.clearedjob
	case installationjobprogress.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstallationJobProgressMutation) ClearEdge(name string) error {
	switch name {
	case installationjobprogress.EdgeJob:
		m.ClearJob()
		return nil
	case installationjobprogress.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown InstallationJobProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstallationJobProgressMutation) ResetEdge(name string) error {
	switch name {
	case installationjobprogress.EdgeJob:
		m.ResetJob()
		return nil
	case installationjobprogress.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown InstallationJobProgress edge %s", name)
}

// JobMutation represents an operation that mutates the Job nodes in the graph.
type JobMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	created_at                  *time.Time
	updated_at                  *time.Time
	progress                    *enum.JobProgress
	progress_at                 *time.Time
	progress_flag_at            *time.Time
	region_id                   *uint8
	addregion_id                *int8
	company_ref_id              *string
	company_name                *string
	price                       *float64
	addprice                    *float64
	work_order_price            *float64
	addwork_order_price         *float64
	contract_price              *float64
	addcontract_price           *float64
	change_order_price          *float64
	addchange_order_price       *float64
	note                        *string
	shingle_color               *string
	permit_required             *bool
	inspection_required         *bool
	inspection_date             *time.Time
	progress_inspection_date    *time.Time
	install_date                *time.Time
	completion_date             *time.Time
	material_delivery_date      *time.Time
	agree                       *bool
	agree_at                    *time.Time
	po_number                   *string
	roofing_partner_assigned_at *time.Time
	roofing_partner_flag_at     *time.Time
	clearedFields               map[string]struct{}
	payments                    map[string]struct{}
	removedpayments             map[string]struct{}
	clearedpayments             bool
	activities                  map[string]struct{}
	removedactivities           map[string]struct{}
	clearedactivities           bool
	assignment_history          map[string]struct{}
	removedassignment_history   map[string]struct{}
	clearedassignment_history   bool
	progress_history            map[string]struct{}
	removedprogress_history     map[string]struct{}
	clearedprogress_history     bool
	notes                       map[string]struct{}
	removednotes                map[string]struct{}
	clearednotes                bool
	doc_urls                    map[string]struct{}
	removeddoc_urls             map[string]struct{}
	cleareddoc_urls             bool
	estimate                    *string
	clearedestimate             bool
	creator_api                 *string
	clearedcreator_api          bool
	creator                     *string
	clearedcreator              bool
	home_owner                  *string
	clearedhome_owner           bool
	sales_rep                   *string
	clearedsales_rep            bool
	requester                   *string
	clearedrequester            bool
	roofing_partner             *string
	clearedroofing_partner      bool
	integration_partner         *string
	clearedintegration_partner  bool
	epc_partner                 *string
	clearedepc_partner          bool
	epc                         *string
	clearedepc                  bool
	estimate_pdf                *string
	clearedestimate_pdf         bool
	done                        bool
	oldValue                    func(context.Context) (*Job, error)
	predicates                  []predicate.Job
}

var _ ent.Mutation = (*JobMutation)(nil)

// jobOption allows management of the mutation configuration using functional options.
type jobOption func(*JobMutation)

// newJobMutation creates new mutation for the Job entity.
func newJobMutation(c config, op Op, opts ...jobOption) *JobMutation {
	m := &JobMutation{
		config:        c,
		op:            op,
		typ:           TypeJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobID sets the ID field of the mutation.
func withJobID(id string) jobOption {
	return func(m *JobMutation) {
		var (
			err   error
			once  sync.Once
			value *Job
		)
		m.oldValue = func(ctx context.Context) (*Job, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Job.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJob sets the old Job of the mutation.
func withJob(node *Job) jobOption {
	return func(m *JobMutation) {
		m.oldValue = func(context.Context) (*Job, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Job entities.
func (m *JobMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Job.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProgress sets the "progress" field.
func (m *JobMutation) SetProgress(ep enum.JobProgress) {
	m.progress = &ep
}

// Progress returns the value of the "progress" field in the mutation.
func (m *JobMutation) Progress() (r enum.JobProgress, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldProgress(ctx context.Context) (v *enum.JobProgress, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// ClearProgress clears the value of the "progress" field.
func (m *JobMutation) ClearProgress() {
	m.progress = nil
	m.clearedFields[job.FieldProgress] = struct{}{}
}

// ProgressCleared returns if the "progress" field was cleared in this mutation.
func (m *JobMutation) ProgressCleared() bool {
	_, ok := m.clearedFields[job.FieldProgress]
	return ok
}

// ResetProgress resets all changes to the "progress" field.
func (m *JobMutation) ResetProgress() {
	m.progress = nil
	delete(m.clearedFields, job.FieldProgress)
}

// SetProgressAt sets the "progress_at" field.
func (m *JobMutation) SetProgressAt(t time.Time) {
	m.progress_at = &t
}

// ProgressAt returns the value of the "progress_at" field in the mutation.
func (m *JobMutation) ProgressAt() (r time.Time, exists bool) {
	v := m.progress_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProgressAt returns the old "progress_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldProgressAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgressAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgressAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgressAt: %w", err)
	}
	return oldValue.ProgressAt, nil
}

// ClearProgressAt clears the value of the "progress_at" field.
func (m *JobMutation) ClearProgressAt() {
	m.progress_at = nil
	m.clearedFields[job.FieldProgressAt] = struct{}{}
}

// ProgressAtCleared returns if the "progress_at" field was cleared in this mutation.
func (m *JobMutation) ProgressAtCleared() bool {
	_, ok := m.clearedFields[job.FieldProgressAt]
	return ok
}

// ResetProgressAt resets all changes to the "progress_at" field.
func (m *JobMutation) ResetProgressAt() {
	m.progress_at = nil
	delete(m.clearedFields, job.FieldProgressAt)
}

// SetProgressFlagAt sets the "progress_flag_at" field.
func (m *JobMutation) SetProgressFlagAt(t time.Time) {
	m.progress_flag_at = &t
}

// ProgressFlagAt returns the value of the "progress_flag_at" field in the mutation.
func (m *JobMutation) ProgressFlagAt() (r time.Time, exists bool) {
	v := m.progress_flag_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProgressFlagAt returns the old "progress_flag_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldProgressFlagAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgressFlagAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgressFlagAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgressFlagAt: %w", err)
	}
	return oldValue.ProgressFlagAt, nil
}

// ClearProgressFlagAt clears the value of the "progress_flag_at" field.
func (m *JobMutation) ClearProgressFlagAt() {
	m.progress_flag_at = nil
	m.clearedFields[job.FieldProgressFlagAt] = struct{}{}
}

// ProgressFlagAtCleared returns if the "progress_flag_at" field was cleared in this mutation.
func (m *JobMutation) ProgressFlagAtCleared() bool {
	_, ok := m.clearedFields[job.FieldProgressFlagAt]
	return ok
}

// ResetProgressFlagAt resets all changes to the "progress_flag_at" field.
func (m *JobMutation) ResetProgressFlagAt() {
	m.progress_flag_at = nil
	delete(m.clearedFields, job.FieldProgressFlagAt)
}

// SetRegionID sets the "region_id" field.
func (m *JobMutation) SetRegionID(u uint8) {
	m.region_id = &u
	m.addregion_id = nil
}

// RegionID returns the value of the "region_id" field in the mutation.
func (m *JobMutation) RegionID() (r uint8, exists bool) {
	v := m.region_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionID returns the old "region_id" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldRegionID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionID: %w", err)
	}
	return oldValue.RegionID, nil
}

// AddRegionID adds u to the "region_id" field.
func (m *JobMutation) AddRegionID(u int8) {
	if m.addregion_id != nil {
		*m.addregion_id += u
	} else {
		m.addregion_id = &u
	}
}

// AddedRegionID returns the value that was added to the "region_id" field in this mutation.
func (m *JobMutation) AddedRegionID() (r int8, exists bool) {
	v := m.addregion_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearRegionID clears the value of the "region_id" field.
func (m *JobMutation) ClearRegionID() {
	m.region_id = nil
	m.addregion_id = nil
	m.clearedFields[job.FieldRegionID] = struct{}{}
}

// RegionIDCleared returns if the "region_id" field was cleared in this mutation.
func (m *JobMutation) RegionIDCleared() bool {
	_, ok := m.clearedFields[job.FieldRegionID]
	return ok
}

// ResetRegionID resets all changes to the "region_id" field.
func (m *JobMutation) ResetRegionID() {
	m.region_id = nil
	m.addregion_id = nil
	delete(m.clearedFields, job.FieldRegionID)
}

// SetCompanyRefID sets the "company_ref_id" field.
func (m *JobMutation) SetCompanyRefID(s string) {
	m.company_ref_id = &s
}

// CompanyRefID returns the value of the "company_ref_id" field in the mutation.
func (m *JobMutation) CompanyRefID() (r string, exists bool) {
	v := m.company_ref_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyRefID returns the old "company_ref_id" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCompanyRefID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyRefID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyRefID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyRefID: %w", err)
	}
	return oldValue.CompanyRefID, nil
}

// ClearCompanyRefID clears the value of the "company_ref_id" field.
func (m *JobMutation) ClearCompanyRefID() {
	m.company_ref_id = nil
	m.clearedFields[job.FieldCompanyRefID] = struct{}{}
}

// CompanyRefIDCleared returns if the "company_ref_id" field was cleared in this mutation.
func (m *JobMutation) CompanyRefIDCleared() bool {
	_, ok := m.clearedFields[job.FieldCompanyRefID]
	return ok
}

// ResetCompanyRefID resets all changes to the "company_ref_id" field.
func (m *JobMutation) ResetCompanyRefID() {
	m.company_ref_id = nil
	delete(m.clearedFields, job.FieldCompanyRefID)
}

// SetCompanyName sets the "company_name" field.
func (m *JobMutation) SetCompanyName(s string) {
	m.company_name = &s
}

// CompanyName returns the value of the "company_name" field in the mutation.
func (m *JobMutation) CompanyName() (r string, exists bool) {
	v := m.company_name
	if v == nil {
		return
	}
	return *v, true
}

// OldCompanyName returns the old "company_name" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCompanyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompanyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompanyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompanyName: %w", err)
	}
	return oldValue.CompanyName, nil
}

// ClearCompanyName clears the value of the "company_name" field.
func (m *JobMutation) ClearCompanyName() {
	m.company_name = nil
	m.clearedFields[job.FieldCompanyName] = struct{}{}
}

// CompanyNameCleared returns if the "company_name" field was cleared in this mutation.
func (m *JobMutation) CompanyNameCleared() bool {
	_, ok := m.clearedFields[job.FieldCompanyName]
	return ok
}

// ResetCompanyName resets all changes to the "company_name" field.
func (m *JobMutation) ResetCompanyName() {
	m.company_name = nil
	delete(m.clearedFields, job.FieldCompanyName)
}

// SetPrice sets the "price" field.
func (m *JobMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *JobMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *JobMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *JobMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *JobMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetWorkOrderPrice sets the "work_order_price" field.
func (m *JobMutation) SetWorkOrderPrice(f float64) {
	m.work_order_price = &f
	m.addwork_order_price = nil
}

// WorkOrderPrice returns the value of the "work_order_price" field in the mutation.
func (m *JobMutation) WorkOrderPrice() (r float64, exists bool) {
	v := m.work_order_price
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkOrderPrice returns the old "work_order_price" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldWorkOrderPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkOrderPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkOrderPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkOrderPrice: %w", err)
	}
	return oldValue.WorkOrderPrice, nil
}

// AddWorkOrderPrice adds f to the "work_order_price" field.
func (m *JobMutation) AddWorkOrderPrice(f float64) {
	if m.addwork_order_price != nil {
		*m.addwork_order_price += f
	} else {
		m.addwork_order_price = &f
	}
}

// AddedWorkOrderPrice returns the value that was added to the "work_order_price" field in this mutation.
func (m *JobMutation) AddedWorkOrderPrice() (r float64, exists bool) {
	v := m.addwork_order_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetWorkOrderPrice resets all changes to the "work_order_price" field.
func (m *JobMutation) ResetWorkOrderPrice() {
	m.work_order_price = nil
	m.addwork_order_price = nil
}

// SetContractPrice sets the "contract_price" field.
func (m *JobMutation) SetContractPrice(f float64) {
	m.contract_price = &f
	m.addcontract_price = nil
}

// ContractPrice returns the value of the "contract_price" field in the mutation.
func (m *JobMutation) ContractPrice() (r float64, exists bool) {
	v := m.contract_price
	if v == nil {
		return
	}
	return *v, true
}

// OldContractPrice returns the old "contract_price" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldContractPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContractPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContractPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContractPrice: %w", err)
	}
	return oldValue.ContractPrice, nil
}

// AddContractPrice adds f to the "contract_price" field.
func (m *JobMutation) AddContractPrice(f float64) {
	if m.addcontract_price != nil {
		*m.addcontract_price += f
	} else {
		m.addcontract_price = &f
	}
}

// AddedContractPrice returns the value that was added to the "contract_price" field in this mutation.
func (m *JobMutation) AddedContractPrice() (r float64, exists bool) {
	v := m.addcontract_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearContractPrice clears the value of the "contract_price" field.
func (m *JobMutation) ClearContractPrice() {
	m.contract_price = nil
	m.addcontract_price = nil
	m.clearedFields[job.FieldContractPrice] = struct{}{}
}

// ContractPriceCleared returns if the "contract_price" field was cleared in this mutation.
func (m *JobMutation) ContractPriceCleared() bool {
	_, ok := m.clearedFields[job.FieldContractPrice]
	return ok
}

// ResetContractPrice resets all changes to the "contract_price" field.
func (m *JobMutation) ResetContractPrice() {
	m.contract_price = nil
	m.addcontract_price = nil
	delete(m.clearedFields, job.FieldContractPrice)
}

// SetChangeOrderPrice sets the "change_order_price" field.
func (m *JobMutation) SetChangeOrderPrice(f float64) {
	m.change_order_price = &f
	m.addchange_order_price = nil
}

// ChangeOrderPrice returns the value of the "change_order_price" field in the mutation.
func (m *JobMutation) ChangeOrderPrice() (r float64, exists bool) {
	v := m.change_order_price
	if v == nil {
		return
	}
	return *v, true
}

// OldChangeOrderPrice returns the old "change_order_price" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldChangeOrderPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChangeOrderPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChangeOrderPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChangeOrderPrice: %w", err)
	}
	return oldValue.ChangeOrderPrice, nil
}

// AddChangeOrderPrice adds f to the "change_order_price" field.
func (m *JobMutation) AddChangeOrderPrice(f float64) {
	if m.addchange_order_price != nil {
		*m.addchange_order_price += f
	} else {
		m.addchange_order_price = &f
	}
}

// AddedChangeOrderPrice returns the value that was added to the "change_order_price" field in this mutation.
func (m *JobMutation) AddedChangeOrderPrice() (r float64, exists bool) {
	v := m.addchange_order_price
	if v == nil {
		return
	}
	return *v, true
}

// ClearChangeOrderPrice clears the value of the "change_order_price" field.
func (m *JobMutation) ClearChangeOrderPrice() {
	m.change_order_price = nil
	m.addchange_order_price = nil
	m.clearedFields[job.FieldChangeOrderPrice] = struct{}{}
}

// ChangeOrderPriceCleared returns if the "change_order_price" field was cleared in this mutation.
func (m *JobMutation) ChangeOrderPriceCleared() bool {
	_, ok := m.clearedFields[job.FieldChangeOrderPrice]
	return ok
}

// ResetChangeOrderPrice resets all changes to the "change_order_price" field.
func (m *JobMutation) ResetChangeOrderPrice() {
	m.change_order_price = nil
	m.addchange_order_price = nil
	delete(m.clearedFields, job.FieldChangeOrderPrice)
}

// SetNote sets the "note" field.
func (m *JobMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *JobMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *JobMutation) ClearNote() {
	m.note = nil
	m.clearedFields[job.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *JobMutation) NoteCleared() bool {
	_, ok := m.clearedFields[job.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *JobMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, job.FieldNote)
}

// SetShingleColor sets the "shingle_color" field.
func (m *JobMutation) SetShingleColor(s string) {
	m.shingle_color = &s
}

// ShingleColor returns the value of the "shingle_color" field in the mutation.
func (m *JobMutation) ShingleColor() (r string, exists bool) {
	v := m.shingle_color
	if v == nil {
		return
	}
	return *v, true
}

// OldShingleColor returns the old "shingle_color" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldShingleColor(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShingleColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShingleColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShingleColor: %w", err)
	}
	return oldValue.ShingleColor, nil
}

// ClearShingleColor clears the value of the "shingle_color" field.
func (m *JobMutation) ClearShingleColor() {
	m.shingle_color = nil
	m.clearedFields[job.FieldShingleColor] = struct{}{}
}

// ShingleColorCleared returns if the "shingle_color" field was cleared in this mutation.
func (m *JobMutation) ShingleColorCleared() bool {
	_, ok := m.clearedFields[job.FieldShingleColor]
	return ok
}

// ResetShingleColor resets all changes to the "shingle_color" field.
func (m *JobMutation) ResetShingleColor() {
	m.shingle_color = nil
	delete(m.clearedFields, job.FieldShingleColor)
}

// SetPermitRequired sets the "permit_required" field.
func (m *JobMutation) SetPermitRequired(b bool) {
	m.permit_required = &b
}

// PermitRequired returns the value of the "permit_required" field in the mutation.
func (m *JobMutation) PermitRequired() (r bool, exists bool) {
	v := m.permit_required
	if v == nil {
		return
	}
	return *v, true
}

// OldPermitRequired returns the old "permit_required" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldPermitRequired(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermitRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermitRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermitRequired: %w", err)
	}
	return oldValue.PermitRequired, nil
}

// ClearPermitRequired clears the value of the "permit_required" field.
func (m *JobMutation) ClearPermitRequired() {
	m.permit_required = nil
	m.clearedFields[job.FieldPermitRequired] = struct{}{}
}

// PermitRequiredCleared returns if the "permit_required" field was cleared in this mutation.
func (m *JobMutation) PermitRequiredCleared() bool {
	_, ok := m.clearedFields[job.FieldPermitRequired]
	return ok
}

// ResetPermitRequired resets all changes to the "permit_required" field.
func (m *JobMutation) ResetPermitRequired() {
	m.permit_required = nil
	delete(m.clearedFields, job.FieldPermitRequired)
}

// SetInspectionRequired sets the "inspection_required" field.
func (m *JobMutation) SetInspectionRequired(b bool) {
	m.inspection_required = &b
}

// InspectionRequired returns the value of the "inspection_required" field in the mutation.
func (m *JobMutation) InspectionRequired() (r bool, exists bool) {
	v := m.inspection_required
	if v == nil {
		return
	}
	return *v, true
}

// OldInspectionRequired returns the old "inspection_required" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldInspectionRequired(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInspectionRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInspectionRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInspectionRequired: %w", err)
	}
	return oldValue.InspectionRequired, nil
}

// ClearInspectionRequired clears the value of the "inspection_required" field.
func (m *JobMutation) ClearInspectionRequired() {
	m.inspection_required = nil
	m.clearedFields[job.FieldInspectionRequired] = struct{}{}
}

// InspectionRequiredCleared returns if the "inspection_required" field was cleared in this mutation.
func (m *JobMutation) InspectionRequiredCleared() bool {
	_, ok := m.clearedFields[job.FieldInspectionRequired]
	return ok
}

// ResetInspectionRequired resets all changes to the "inspection_required" field.
func (m *JobMutation) ResetInspectionRequired() {
	m.inspection_required = nil
	delete(m.clearedFields, job.FieldInspectionRequired)
}

// SetInspectionDate sets the "inspection_date" field.
func (m *JobMutation) SetInspectionDate(t time.Time) {
	m.inspection_date = &t
}

// InspectionDate returns the value of the "inspection_date" field in the mutation.
func (m *JobMutation) InspectionDate() (r time.Time, exists bool) {
	v := m.inspection_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInspectionDate returns the old "inspection_date" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldInspectionDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInspectionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInspectionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInspectionDate: %w", err)
	}
	return oldValue.InspectionDate, nil
}

// ClearInspectionDate clears the value of the "inspection_date" field.
func (m *JobMutation) ClearInspectionDate() {
	m.inspection_date = nil
	m.clearedFields[job.FieldInspectionDate] = struct{}{}
}

// InspectionDateCleared returns if the "inspection_date" field was cleared in this mutation.
func (m *JobMutation) InspectionDateCleared() bool {
	_, ok := m.clearedFields[job.FieldInspectionDate]
	return ok
}

// ResetInspectionDate resets all changes to the "inspection_date" field.
func (m *JobMutation) ResetInspectionDate() {
	m.inspection_date = nil
	delete(m.clearedFields, job.FieldInspectionDate)
}

// SetProgressInspectionDate sets the "progress_inspection_date" field.
func (m *JobMutation) SetProgressInspectionDate(t time.Time) {
	m.progress_inspection_date = &t
}

// ProgressInspectionDate returns the value of the "progress_inspection_date" field in the mutation.
func (m *JobMutation) ProgressInspectionDate() (r time.Time, exists bool) {
	v := m.progress_inspection_date
	if v == nil {
		return
	}
	return *v, true
}

// OldProgressInspectionDate returns the old "progress_inspection_date" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldProgressInspectionDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgressInspectionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgressInspectionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgressInspectionDate: %w", err)
	}
	return oldValue.ProgressInspectionDate, nil
}

// ClearProgressInspectionDate clears the value of the "progress_inspection_date" field.
func (m *JobMutation) ClearProgressInspectionDate() {
	m.progress_inspection_date = nil
	m.clearedFields[job.FieldProgressInspectionDate] = struct{}{}
}

// ProgressInspectionDateCleared returns if the "progress_inspection_date" field was cleared in this mutation.
func (m *JobMutation) ProgressInspectionDateCleared() bool {
	_, ok := m.clearedFields[job.FieldProgressInspectionDate]
	return ok
}

// ResetProgressInspectionDate resets all changes to the "progress_inspection_date" field.
func (m *JobMutation) ResetProgressInspectionDate() {
	m.progress_inspection_date = nil
	delete(m.clearedFields, job.FieldProgressInspectionDate)
}

// SetInstallDate sets the "install_date" field.
func (m *JobMutation) SetInstallDate(t time.Time) {
	m.install_date = &t
}

// InstallDate returns the value of the "install_date" field in the mutation.
func (m *JobMutation) InstallDate() (r time.Time, exists bool) {
	v := m.install_date
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallDate returns the old "install_date" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldInstallDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallDate: %w", err)
	}
	return oldValue.InstallDate, nil
}

// ClearInstallDate clears the value of the "install_date" field.
func (m *JobMutation) ClearInstallDate() {
	m.install_date = nil
	m.clearedFields[job.FieldInstallDate] = struct{}{}
}

// InstallDateCleared returns if the "install_date" field was cleared in this mutation.
func (m *JobMutation) InstallDateCleared() bool {
	_, ok := m.clearedFields[job.FieldInstallDate]
	return ok
}

// ResetInstallDate resets all changes to the "install_date" field.
func (m *JobMutation) ResetInstallDate() {
	m.install_date = nil
	delete(m.clearedFields, job.FieldInstallDate)
}

// SetCompletionDate sets the "completion_date" field.
func (m *JobMutation) SetCompletionDate(t time.Time) {
	m.completion_date = &t
}

// CompletionDate returns the value of the "completion_date" field in the mutation.
func (m *JobMutation) CompletionDate() (r time.Time, exists bool) {
	v := m.completion_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCompletionDate returns the old "completion_date" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldCompletionDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompletionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompletionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompletionDate: %w", err)
	}
	return oldValue.CompletionDate, nil
}

// ClearCompletionDate clears the value of the "completion_date" field.
func (m *JobMutation) ClearCompletionDate() {
	m.completion_date = nil
	m.clearedFields[job.FieldCompletionDate] = struct{}{}
}

// CompletionDateCleared returns if the "completion_date" field was cleared in this mutation.
func (m *JobMutation) CompletionDateCleared() bool {
	_, ok := m.clearedFields[job.FieldCompletionDate]
	return ok
}

// ResetCompletionDate resets all changes to the "completion_date" field.
func (m *JobMutation) ResetCompletionDate() {
	m.completion_date = nil
	delete(m.clearedFields, job.FieldCompletionDate)
}

// SetMaterialDeliveryDate sets the "material_delivery_date" field.
func (m *JobMutation) SetMaterialDeliveryDate(t time.Time) {
	m.material_delivery_date = &t
}

// MaterialDeliveryDate returns the value of the "material_delivery_date" field in the mutation.
func (m *JobMutation) MaterialDeliveryDate() (r time.Time, exists bool) {
	v := m.material_delivery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldMaterialDeliveryDate returns the old "material_delivery_date" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldMaterialDeliveryDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaterialDeliveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaterialDeliveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaterialDeliveryDate: %w", err)
	}
	return oldValue.MaterialDeliveryDate, nil
}

// ClearMaterialDeliveryDate clears the value of the "material_delivery_date" field.
func (m *JobMutation) ClearMaterialDeliveryDate() {
	m.material_delivery_date = nil
	m.clearedFields[job.FieldMaterialDeliveryDate] = struct{}{}
}

// MaterialDeliveryDateCleared returns if the "material_delivery_date" field was cleared in this mutation.
func (m *JobMutation) MaterialDeliveryDateCleared() bool {
	_, ok := m.clearedFields[job.FieldMaterialDeliveryDate]
	return ok
}

// ResetMaterialDeliveryDate resets all changes to the "material_delivery_date" field.
func (m *JobMutation) ResetMaterialDeliveryDate() {
	m.material_delivery_date = nil
	delete(m.clearedFields, job.FieldMaterialDeliveryDate)
}

// SetAgree sets the "agree" field.
func (m *JobMutation) SetAgree(b bool) {
	m.agree = &b
}

// Agree returns the value of the "agree" field in the mutation.
func (m *JobMutation) Agree() (r bool, exists bool) {
	v := m.agree
	if v == nil {
		return
	}
	return *v, true
}

// OldAgree returns the old "agree" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldAgree(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgree is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgree requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgree: %w", err)
	}
	return oldValue.Agree, nil
}

// ClearAgree clears the value of the "agree" field.
func (m *JobMutation) ClearAgree() {
	m.agree = nil
	m.clearedFields[job.FieldAgree] = struct{}{}
}

// AgreeCleared returns if the "agree" field was cleared in this mutation.
func (m *JobMutation) AgreeCleared() bool {
	_, ok := m.clearedFields[job.FieldAgree]
	return ok
}

// ResetAgree resets all changes to the "agree" field.
func (m *JobMutation) ResetAgree() {
	m.agree = nil
	delete(m.clearedFields, job.FieldAgree)
}

// SetAgreeAt sets the "agree_at" field.
func (m *JobMutation) SetAgreeAt(t time.Time) {
	m.agree_at = &t
}

// AgreeAt returns the value of the "agree_at" field in the mutation.
func (m *JobMutation) AgreeAt() (r time.Time, exists bool) {
	v := m.agree_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreeAt returns the old "agree_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldAgreeAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgreeAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgreeAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreeAt: %w", err)
	}
	return oldValue.AgreeAt, nil
}

// ClearAgreeAt clears the value of the "agree_at" field.
func (m *JobMutation) ClearAgreeAt() {
	m.agree_at = nil
	m.clearedFields[job.FieldAgreeAt] = struct{}{}
}

// AgreeAtCleared returns if the "agree_at" field was cleared in this mutation.
func (m *JobMutation) AgreeAtCleared() bool {
	_, ok := m.clearedFields[job.FieldAgreeAt]
	return ok
}

// ResetAgreeAt resets all changes to the "agree_at" field.
func (m *JobMutation) ResetAgreeAt() {
	m.agree_at = nil
	delete(m.clearedFields, job.FieldAgreeAt)
}

// SetPoNumber sets the "po_number" field.
func (m *JobMutation) SetPoNumber(s string) {
	m.po_number = &s
}

// PoNumber returns the value of the "po_number" field in the mutation.
func (m *JobMutation) PoNumber() (r string, exists bool) {
	v := m.po_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPoNumber returns the old "po_number" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldPoNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPoNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPoNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoNumber: %w", err)
	}
	return oldValue.PoNumber, nil
}

// ClearPoNumber clears the value of the "po_number" field.
func (m *JobMutation) ClearPoNumber() {
	m.po_number = nil
	m.clearedFields[job.FieldPoNumber] = struct{}{}
}

// PoNumberCleared returns if the "po_number" field was cleared in this mutation.
func (m *JobMutation) PoNumberCleared() bool {
	_, ok := m.clearedFields[job.FieldPoNumber]
	return ok
}

// ResetPoNumber resets all changes to the "po_number" field.
func (m *JobMutation) ResetPoNumber() {
	m.po_number = nil
	delete(m.clearedFields, job.FieldPoNumber)
}

// SetRoofingPartnerAssignedAt sets the "roofing_partner_assigned_at" field.
func (m *JobMutation) SetRoofingPartnerAssignedAt(t time.Time) {
	m.roofing_partner_assigned_at = &t
}

// RoofingPartnerAssignedAt returns the value of the "roofing_partner_assigned_at" field in the mutation.
func (m *JobMutation) RoofingPartnerAssignedAt() (r time.Time, exists bool) {
	v := m.roofing_partner_assigned_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRoofingPartnerAssignedAt returns the old "roofing_partner_assigned_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldRoofingPartnerAssignedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoofingPartnerAssignedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoofingPartnerAssignedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoofingPartnerAssignedAt: %w", err)
	}
	return oldValue.RoofingPartnerAssignedAt, nil
}

// ClearRoofingPartnerAssignedAt clears the value of the "roofing_partner_assigned_at" field.
func (m *JobMutation) ClearRoofingPartnerAssignedAt() {
	m.roofing_partner_assigned_at = nil
	m.clearedFields[job.FieldRoofingPartnerAssignedAt] = struct{}{}
}

// RoofingPartnerAssignedAtCleared returns if the "roofing_partner_assigned_at" field was cleared in this mutation.
func (m *JobMutation) RoofingPartnerAssignedAtCleared() bool {
	_, ok := m.clearedFields[job.FieldRoofingPartnerAssignedAt]
	return ok
}

// ResetRoofingPartnerAssignedAt resets all changes to the "roofing_partner_assigned_at" field.
func (m *JobMutation) ResetRoofingPartnerAssignedAt() {
	m.roofing_partner_assigned_at = nil
	delete(m.clearedFields, job.FieldRoofingPartnerAssignedAt)
}

// SetRoofingPartnerFlagAt sets the "roofing_partner_flag_at" field.
func (m *JobMutation) SetRoofingPartnerFlagAt(t time.Time) {
	m.roofing_partner_flag_at = &t
}

// RoofingPartnerFlagAt returns the value of the "roofing_partner_flag_at" field in the mutation.
func (m *JobMutation) RoofingPartnerFlagAt() (r time.Time, exists bool) {
	v := m.roofing_partner_flag_at
	if v == nil {
		return
	}
	return *v, true
}

// OldRoofingPartnerFlagAt returns the old "roofing_partner_flag_at" field's value of the Job entity.
// If the Job object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobMutation) OldRoofingPartnerFlagAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoofingPartnerFlagAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoofingPartnerFlagAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoofingPartnerFlagAt: %w", err)
	}
	return oldValue.RoofingPartnerFlagAt, nil
}

// ClearRoofingPartnerFlagAt clears the value of the "roofing_partner_flag_at" field.
func (m *JobMutation) ClearRoofingPartnerFlagAt() {
	m.roofing_partner_flag_at = nil
	m.clearedFields[job.FieldRoofingPartnerFlagAt] = struct{}{}
}

// RoofingPartnerFlagAtCleared returns if the "roofing_partner_flag_at" field was cleared in this mutation.
func (m *JobMutation) RoofingPartnerFlagAtCleared() bool {
	_, ok := m.clearedFields[job.FieldRoofingPartnerFlagAt]
	return ok
}

// ResetRoofingPartnerFlagAt resets all changes to the "roofing_partner_flag_at" field.
func (m *JobMutation) ResetRoofingPartnerFlagAt() {
	m.roofing_partner_flag_at = nil
	delete(m.clearedFields, job.FieldRoofingPartnerFlagAt)
}

// AddPaymentIDs adds the "payments" edge to the Payment entity by ids.
func (m *JobMutation) AddPaymentIDs(ids ...string) {
	if m.payments == nil {
		m.payments = make(map[string]struct{})
	}
	for i := range ids {
		m.payments[ids[i]] = struct{}{}
	}
}

// ClearPayments clears the "payments" edge to the Payment entity.
func (m *JobMutation) ClearPayments() {
	m.clearedpayments = true
}

// PaymentsCleared reports if the "payments" edge to the Payment entity was cleared.
func (m *JobMutation) PaymentsCleared() bool {
	return m.clearedpayments
}

// RemovePaymentIDs removes the "payments" edge to the Payment entity by IDs.
func (m *JobMutation) RemovePaymentIDs(ids ...string) {
	if m.removedpayments == nil {
		m.removedpayments = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.payments, ids[i])
		m.removedpayments[ids[i]] = struct{}{}
	}
}

// RemovedPayments returns the removed IDs of the "payments" edge to the Payment entity.
func (m *JobMutation) RemovedPaymentsIDs() (ids []string) {
	for id := range m.removedpayments {
		ids = append(ids, id)
	}
	return
}

// PaymentsIDs returns the "payments" edge IDs in the mutation.
func (m *JobMutation) PaymentsIDs() (ids []string) {
	for id := range m.payments {
		ids = append(ids, id)
	}
	return
}

// ResetPayments resets all changes to the "payments" edge.
func (m *JobMutation) ResetPayments() {
	m.payments = nil
	m.clearedpayments = false
	m.removedpayments = nil
}

// AddActivityIDs adds the "activities" edge to the JobActivity entity by ids.
func (m *JobMutation) AddActivityIDs(ids ...string) {
	if m.activities == nil {
		m.activities = make(map[string]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the JobActivity entity.
func (m *JobMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the JobActivity entity was cleared.
func (m *JobMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the JobActivity entity by IDs.
func (m *JobMutation) RemoveActivityIDs(ids ...string) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the JobActivity entity.
func (m *JobMutation) RemovedActivitiesIDs() (ids []string) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *JobMutation) ActivitiesIDs() (ids []string) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *JobMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// AddAssignmentHistoryIDs adds the "assignment_history" edge to the JobAssignmentHistory entity by ids.
func (m *JobMutation) AddAssignmentHistoryIDs(ids ...string) {
	if m.assignment_history == nil {
		m.assignment_history = make(map[string]struct{})
	}
	for i := range ids {
		m.assignment_history[ids[i]] = struct{}{}
	}
}

// ClearAssignmentHistory clears the "assignment_history" edge to the JobAssignmentHistory entity.
func (m *JobMutation) ClearAssignmentHistory() {
	m.clearedassignment_history = true
}

// AssignmentHistoryCleared reports if the "assignment_history" edge to the JobAssignmentHistory entity was cleared.
func (m *JobMutation) AssignmentHistoryCleared() bool {
	return m.clearedassignment_history
}

// RemoveAssignmentHistoryIDs removes the "assignment_history" edge to the JobAssignmentHistory entity by IDs.
func (m *JobMutation) RemoveAssignmentHistoryIDs(ids ...string) {
	if m.removedassignment_history == nil {
		m.removedassignment_history = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.assignment_history, ids[i])
		m.removedassignment_history[ids[i]] = struct{}{}
	}
}

// RemovedAssignmentHistory returns the removed IDs of the "assignment_history" edge to the JobAssignmentHistory entity.
func (m *JobMutation) RemovedAssignmentHistoryIDs() (ids []string) {
	for id := range m.removedassignment_history {
		ids = append(ids, id)
	}
	return
}

// AssignmentHistoryIDs returns the "assignment_history" edge IDs in the mutation.
func (m *JobMutation) AssignmentHistoryIDs() (ids []string) {
	for id := range m.assignment_history {
		ids = append(ids, id)
	}
	return
}

// ResetAssignmentHistory resets all changes to the "assignment_history" edge.
func (m *JobMutation) ResetAssignmentHistory() {
	m.assignment_history = nil
	m.clearedassignment_history = false
	m.removedassignment_history = nil
}

// AddProgressHistoryIDs adds the "progress_history" edge to the JobProgressHistory entity by ids.
func (m *JobMutation) AddProgressHistoryIDs(ids ...string) {
	if m.progress_history == nil {
		m.progress_history = make(map[string]struct{})
	}
	for i := range ids {
		m.progress_history[ids[i]] = struct{}{}
	}
}

// ClearProgressHistory clears the "progress_history" edge to the JobProgressHistory entity.
func (m *JobMutation) ClearProgressHistory() {
	m.clearedprogress_history = true
}

// ProgressHistoryCleared reports if the "progress_history" edge to the JobProgressHistory entity was cleared.
func (m *JobMutation) ProgressHistoryCleared() bool {
	return m.clearedprogress_history
}

// RemoveProgressHistoryIDs removes the "progress_history" edge to the JobProgressHistory entity by IDs.
func (m *JobMutation) RemoveProgressHistoryIDs(ids ...string) {
	if m.removedprogress_history == nil {
		m.removedprogress_history = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.progress_history, ids[i])
		m.removedprogress_history[ids[i]] = struct{}{}
	}
}

// RemovedProgressHistory returns the removed IDs of the "progress_history" edge to the JobProgressHistory entity.
func (m *JobMutation) RemovedProgressHistoryIDs() (ids []string) {
	for id := range m.removedprogress_history {
		ids = append(ids, id)
	}
	return
}

// ProgressHistoryIDs returns the "progress_history" edge IDs in the mutation.
func (m *JobMutation) ProgressHistoryIDs() (ids []string) {
	for id := range m.progress_history {
		ids = append(ids, id)
	}
	return
}

// ResetProgressHistory resets all changes to the "progress_history" edge.
func (m *JobMutation) ResetProgressHistory() {
	m.progress_history = nil
	m.clearedprogress_history = false
	m.removedprogress_history = nil
}

// AddNoteIDs adds the "notes" edge to the JobNote entity by ids.
func (m *JobMutation) AddNoteIDs(ids ...string) {
	if m.notes == nil {
		m.notes = make(map[string]struct{})
	}
	for i := range ids {
		m.notes[ids[i]] = struct{}{}
	}
}

// ClearNotes clears the "notes" edge to the JobNote entity.
func (m *JobMutation) ClearNotes() {
	m.clearednotes = true
}

// NotesCleared reports if the "notes" edge to the JobNote entity was cleared.
func (m *JobMutation) NotesCleared() bool {
	return m.clearednotes
}

// RemoveNoteIDs removes the "notes" edge to the JobNote entity by IDs.
func (m *JobMutation) RemoveNoteIDs(ids ...string) {
	if m.removednotes == nil {
		m.removednotes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notes, ids[i])
		m.removednotes[ids[i]] = struct{}{}
	}
}

// RemovedNotes returns the removed IDs of the "notes" edge to the JobNote entity.
func (m *JobMutation) RemovedNotesIDs() (ids []string) {
	for id := range m.removednotes {
		ids = append(ids, id)
	}
	return
}

// NotesIDs returns the "notes" edge IDs in the mutation.
func (m *JobMutation) NotesIDs() (ids []string) {
	for id := range m.notes {
		ids = append(ids, id)
	}
	return
}

// ResetNotes resets all changes to the "notes" edge.
func (m *JobMutation) ResetNotes() {
	m.notes = nil
	m.clearednotes = false
	m.removednotes = nil
}

// AddDocURLIDs adds the "doc_urls" edge to the JobDocURL entity by ids.
func (m *JobMutation) AddDocURLIDs(ids ...string) {
	if m.doc_urls == nil {
		m.doc_urls = make(map[string]struct{})
	}
	for i := range ids {
		m.doc_urls[ids[i]] = struct{}{}
	}
}

// ClearDocUrls clears the "doc_urls" edge to the JobDocURL entity.
func (m *JobMutation) ClearDocUrls() {
	m.cleareddoc_urls = true
}

// DocUrlsCleared reports if the "doc_urls" edge to the JobDocURL entity was cleared.
func (m *JobMutation) DocUrlsCleared() bool {
	return m.cleareddoc_urls
}

// RemoveDocURLIDs removes the "doc_urls" edge to the JobDocURL entity by IDs.
func (m *JobMutation) RemoveDocURLIDs(ids ...string) {
	if m.removeddoc_urls == nil {
		m.removeddoc_urls = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.doc_urls, ids[i])
		m.removeddoc_urls[ids[i]] = struct{}{}
	}
}

// RemovedDocUrls returns the removed IDs of the "doc_urls" edge to the JobDocURL entity.
func (m *JobMutation) RemovedDocUrlsIDs() (ids []string) {
	for id := range m.removeddoc_urls {
		ids = append(ids, id)
	}
	return
}

// DocUrlsIDs returns the "doc_urls" edge IDs in the mutation.
func (m *JobMutation) DocUrlsIDs() (ids []string) {
	for id := range m.doc_urls {
		ids = append(ids, id)
	}
	return
}

// ResetDocUrls resets all changes to the "doc_urls" edge.
func (m *JobMutation) ResetDocUrls() {
	m.doc_urls = nil
	m.cleareddoc_urls = false
	m.removeddoc_urls = nil
}

// SetEstimateID sets the "estimate" edge to the Estimate entity by id.
func (m *JobMutation) SetEstimateID(id string) {
	m.estimate = &id
}

// ClearEstimate clears the "estimate" edge to the Estimate entity.
func (m *JobMutation) ClearEstimate() {
	m.clearedestimate = true
}

// EstimateCleared reports if the "estimate" edge to the Estimate entity was cleared.
func (m *JobMutation) EstimateCleared() bool {
	return m.clearedestimate
}

// EstimateID returns the "estimate" edge ID in the mutation.
func (m *JobMutation) EstimateID() (id string, exists bool) {
	if m.estimate != nil {
		return *m.estimate, true
	}
	return
}

// EstimateIDs returns the "estimate" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EstimateID instead. It exists only for internal usage by the builders.
func (m *JobMutation) EstimateIDs() (ids []string) {
	if id := m.estimate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEstimate resets all changes to the "estimate" edge.
func (m *JobMutation) ResetEstimate() {
	m.estimate = nil
	m.clearedestimate = false
}

// SetCreatorAPIID sets the "creator_api" edge to the ApiUser entity by id.
func (m *JobMutation) SetCreatorAPIID(id string) {
	m.creator_api = &id
}

// ClearCreatorAPI clears the "creator_api" edge to the ApiUser entity.
func (m *JobMutation) ClearCreatorAPI() {
	m.clearedcreator_api = true
}

// CreatorAPICleared reports if the "creator_api" edge to the ApiUser entity was cleared.
func (m *JobMutation) CreatorAPICleared() bool {
	return m.clearedcreator_api
}

// CreatorAPIID returns the "creator_api" edge ID in the mutation.
func (m *JobMutation) CreatorAPIID() (id string, exists bool) {
	if m.creator_api != nil {
		return *m.creator_api, true
	}
	return
}

// CreatorAPIIDs returns the "creator_api" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorAPIID instead. It exists only for internal usage by the builders.
func (m *JobMutation) CreatorAPIIDs() (ids []string) {
	if id := m.creator_api; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatorAPI resets all changes to the "creator_api" edge.
func (m *JobMutation) ResetCreatorAPI() {
	m.creator_api = nil
	m.clearedcreator_api = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *JobMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *JobMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *JobMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *JobMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *JobMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *JobMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetHomeOwnerID sets the "home_owner" edge to the HomeOwner entity by id.
func (m *JobMutation) SetHomeOwnerID(id string) {
	m.home_owner = &id
}

// ClearHomeOwner clears the "home_owner" edge to the HomeOwner entity.
func (m *JobMutation) ClearHomeOwner() {
	m.clearedhome_owner = true
}

// HomeOwnerCleared reports if the "home_owner" edge to the HomeOwner entity was cleared.
func (m *JobMutation) HomeOwnerCleared() bool {
	return m.clearedhome_owner
}

// HomeOwnerID returns the "home_owner" edge ID in the mutation.
func (m *JobMutation) HomeOwnerID() (id string, exists bool) {
	if m.home_owner != nil {
		return *m.home_owner, true
	}
	return
}

// HomeOwnerIDs returns the "home_owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HomeOwnerID instead. It exists only for internal usage by the builders.
func (m *JobMutation) HomeOwnerIDs() (ids []string) {
	if id := m.home_owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHomeOwner resets all changes to the "home_owner" edge.
func (m *JobMutation) ResetHomeOwner() {
	m.home_owner = nil
	m.clearedhome_owner = false
}

// SetSalesRepID sets the "sales_rep" edge to the User entity by id.
func (m *JobMutation) SetSalesRepID(id string) {
	m.sales_rep = &id
}

// ClearSalesRep clears the "sales_rep" edge to the User entity.
func (m *JobMutation) ClearSalesRep() {
	m.clearedsales_rep = true
}

// SalesRepCleared reports if the "sales_rep" edge to the User entity was cleared.
func (m *JobMutation) SalesRepCleared() bool {
	return m.clearedsales_rep
}

// SalesRepID returns the "sales_rep" edge ID in the mutation.
func (m *JobMutation) SalesRepID() (id string, exists bool) {
	if m.sales_rep != nil {
		return *m.sales_rep, true
	}
	return
}

// SalesRepIDs returns the "sales_rep" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SalesRepID instead. It exists only for internal usage by the builders.
func (m *JobMutation) SalesRepIDs() (ids []string) {
	if id := m.sales_rep; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSalesRep resets all changes to the "sales_rep" edge.
func (m *JobMutation) ResetSalesRep() {
	m.sales_rep = nil
	m.clearedsales_rep = false
}

// SetRequesterID sets the "requester" edge to the Partner entity by id.
func (m *JobMutation) SetRequesterID(id string) {
	m.requester = &id
}

// ClearRequester clears the "requester" edge to the Partner entity.
func (m *JobMutation) ClearRequester() {
	m.clearedrequester = true
}

// RequesterCleared reports if the "requester" edge to the Partner entity was cleared.
func (m *JobMutation) RequesterCleared() bool {
	return m.clearedrequester
}

// RequesterID returns the "requester" edge ID in the mutation.
func (m *JobMutation) RequesterID() (id string, exists bool) {
	if m.requester != nil {
		return *m.requester, true
	}
	return
}

// RequesterIDs returns the "requester" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequesterID instead. It exists only for internal usage by the builders.
func (m *JobMutation) RequesterIDs() (ids []string) {
	if id := m.requester; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequester resets all changes to the "requester" edge.
func (m *JobMutation) ResetRequester() {
	m.requester = nil
	m.clearedrequester = false
}

// SetRoofingPartnerID sets the "roofing_partner" edge to the Partner entity by id.
func (m *JobMutation) SetRoofingPartnerID(id string) {
	m.roofing_partner = &id
}

// ClearRoofingPartner clears the "roofing_partner" edge to the Partner entity.
func (m *JobMutation) ClearRoofingPartner() {
	m.clearedroofing_partner = true
}

// RoofingPartnerCleared reports if the "roofing_partner" edge to the Partner entity was cleared.
func (m *JobMutation) RoofingPartnerCleared() bool {
	return m.clearedroofing_partner
}

// RoofingPartnerID returns the "roofing_partner" edge ID in the mutation.
func (m *JobMutation) RoofingPartnerID() (id string, exists bool) {
	if m.roofing_partner != nil {
		return *m.roofing_partner, true
	}
	return
}

// RoofingPartnerIDs returns the "roofing_partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RoofingPartnerID instead. It exists only for internal usage by the builders.
func (m *JobMutation) RoofingPartnerIDs() (ids []string) {
	if id := m.roofing_partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoofingPartner resets all changes to the "roofing_partner" edge.
func (m *JobMutation) ResetRoofingPartner() {
	m.roofing_partner = nil
	m.clearedroofing_partner = false
}

// SetIntegrationPartnerID sets the "integration_partner" edge to the Partner entity by id.
func (m *JobMutation) SetIntegrationPartnerID(id string) {
	m.integration_partner = &id
}

// ClearIntegrationPartner clears the "integration_partner" edge to the Partner entity.
func (m *JobMutation) ClearIntegrationPartner() {
	m.clearedintegration_partner = true
}

// IntegrationPartnerCleared reports if the "integration_partner" edge to the Partner entity was cleared.
func (m *JobMutation) IntegrationPartnerCleared() bool {
	return m.clearedintegration_partner
}

// IntegrationPartnerID returns the "integration_partner" edge ID in the mutation.
func (m *JobMutation) IntegrationPartnerID() (id string, exists bool) {
	if m.integration_partner != nil {
		return *m.integration_partner, true
	}
	return
}

// IntegrationPartnerIDs returns the "integration_partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// IntegrationPartnerID instead. It exists only for internal usage by the builders.
func (m *JobMutation) IntegrationPartnerIDs() (ids []string) {
	if id := m.integration_partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetIntegrationPartner resets all changes to the "integration_partner" edge.
func (m *JobMutation) ResetIntegrationPartner() {
	m.integration_partner = nil
	m.clearedintegration_partner = false
}

// SetEpcPartnerID sets the "epc_partner" edge to the Partner entity by id.
func (m *JobMutation) SetEpcPartnerID(id string) {
	m.epc_partner = &id
}

// ClearEpcPartner clears the "epc_partner" edge to the Partner entity.
func (m *JobMutation) ClearEpcPartner() {
	m.clearedepc_partner = true
}

// EpcPartnerCleared reports if the "epc_partner" edge to the Partner entity was cleared.
func (m *JobMutation) EpcPartnerCleared() bool {
	return m.clearedepc_partner
}

// EpcPartnerID returns the "epc_partner" edge ID in the mutation.
func (m *JobMutation) EpcPartnerID() (id string, exists bool) {
	if m.epc_partner != nil {
		return *m.epc_partner, true
	}
	return
}

// EpcPartnerIDs returns the "epc_partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EpcPartnerID instead. It exists only for internal usage by the builders.
func (m *JobMutation) EpcPartnerIDs() (ids []string) {
	if id := m.epc_partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEpcPartner resets all changes to the "epc_partner" edge.
func (m *JobMutation) ResetEpcPartner() {
	m.epc_partner = nil
	m.clearedepc_partner = false
}

// SetEpcID sets the "epc" edge to the OptionList entity by id.
func (m *JobMutation) SetEpcID(id string) {
	m.epc = &id
}

// ClearEpc clears the "epc" edge to the OptionList entity.
func (m *JobMutation) ClearEpc() {
	m.clearedepc = true
}

// EpcCleared reports if the "epc" edge to the OptionList entity was cleared.
func (m *JobMutation) EpcCleared() bool {
	return m.clearedepc
}

// EpcID returns the "epc" edge ID in the mutation.
func (m *JobMutation) EpcID() (id string, exists bool) {
	if m.epc != nil {
		return *m.epc, true
	}
	return
}

// EpcIDs returns the "epc" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EpcID instead. It exists only for internal usage by the builders.
func (m *JobMutation) EpcIDs() (ids []string) {
	if id := m.epc; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEpc resets all changes to the "epc" edge.
func (m *JobMutation) ResetEpc() {
	m.epc = nil
	m.clearedepc = false
}

// SetEstimatePdfID sets the "estimate_pdf" edge to the Document entity by id.
func (m *JobMutation) SetEstimatePdfID(id string) {
	m.estimate_pdf = &id
}

// ClearEstimatePdf clears the "estimate_pdf" edge to the Document entity.
func (m *JobMutation) ClearEstimatePdf() {
	m.clearedestimate_pdf = true
}

// EstimatePdfCleared reports if the "estimate_pdf" edge to the Document entity was cleared.
func (m *JobMutation) EstimatePdfCleared() bool {
	return m.clearedestimate_pdf
}

// EstimatePdfID returns the "estimate_pdf" edge ID in the mutation.
func (m *JobMutation) EstimatePdfID() (id string, exists bool) {
	if m.estimate_pdf != nil {
		return *m.estimate_pdf, true
	}
	return
}

// EstimatePdfIDs returns the "estimate_pdf" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EstimatePdfID instead. It exists only for internal usage by the builders.
func (m *JobMutation) EstimatePdfIDs() (ids []string) {
	if id := m.estimate_pdf; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEstimatePdf resets all changes to the "estimate_pdf" edge.
func (m *JobMutation) ResetEstimatePdf() {
	m.estimate_pdf = nil
	m.clearedestimate_pdf = false
}

// Where appends a list predicates to the JobMutation builder.
func (m *JobMutation) Where(ps ...predicate.Job) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Job, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Job).
func (m *JobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, job.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, job.FieldUpdatedAt)
	}
	if m.progress != nil {
		fields = append(fields, job.FieldProgress)
	}
	if m.progress_at != nil {
		fields = append(fields, job.FieldProgressAt)
	}
	if m.progress_flag_at != nil {
		fields = append(fields, job.FieldProgressFlagAt)
	}
	if m.region_id != nil {
		fields = append(fields, job.FieldRegionID)
	}
	if m.company_ref_id != nil {
		fields = append(fields, job.FieldCompanyRefID)
	}
	if m.company_name != nil {
		fields = append(fields, job.FieldCompanyName)
	}
	if m.price != nil {
		fields = append(fields, job.FieldPrice)
	}
	if m.work_order_price != nil {
		fields = append(fields, job.FieldWorkOrderPrice)
	}
	if m.contract_price != nil {
		fields = append(fields, job.FieldContractPrice)
	}
	if m.change_order_price != nil {
		fields = append(fields, job.FieldChangeOrderPrice)
	}
	if m.note != nil {
		fields = append(fields, job.FieldNote)
	}
	if m.shingle_color != nil {
		fields = append(fields, job.FieldShingleColor)
	}
	if m.permit_required != nil {
		fields = append(fields, job.FieldPermitRequired)
	}
	if m.inspection_required != nil {
		fields = append(fields, job.FieldInspectionRequired)
	}
	if m.inspection_date != nil {
		fields = append(fields, job.FieldInspectionDate)
	}
	if m.progress_inspection_date != nil {
		fields = append(fields, job.FieldProgressInspectionDate)
	}
	if m.install_date != nil {
		fields = append(fields, job.FieldInstallDate)
	}
	if m.completion_date != nil {
		fields = append(fields, job.FieldCompletionDate)
	}
	if m.material_delivery_date != nil {
		fields = append(fields, job.FieldMaterialDeliveryDate)
	}
	if m.agree != nil {
		fields = append(fields, job.FieldAgree)
	}
	if m.agree_at != nil {
		fields = append(fields, job.FieldAgreeAt)
	}
	if m.po_number != nil {
		fields = append(fields, job.FieldPoNumber)
	}
	if m.roofing_partner_assigned_at != nil {
		fields = append(fields, job.FieldRoofingPartnerAssignedAt)
	}
	if m.roofing_partner_flag_at != nil {
		fields = append(fields, job.FieldRoofingPartnerFlagAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case job.FieldCreatedAt:
		return m.CreatedAt()
	case job.FieldUpdatedAt:
		return m.UpdatedAt()
	case job.FieldProgress:
		return m.Progress()
	case job.FieldProgressAt:
		return m.ProgressAt()
	case job.FieldProgressFlagAt:
		return m.ProgressFlagAt()
	case job.FieldRegionID:
		return m.RegionID()
	case job.FieldCompanyRefID:
		return m.CompanyRefID()
	case job.FieldCompanyName:
		return m.CompanyName()
	case job.FieldPrice:
		return m.Price()
	case job.FieldWorkOrderPrice:
		return m.WorkOrderPrice()
	case job.FieldContractPrice:
		return m.ContractPrice()
	case job.FieldChangeOrderPrice:
		return m.ChangeOrderPrice()
	case job.FieldNote:
		return m.Note()
	case job.FieldShingleColor:
		return m.ShingleColor()
	case job.FieldPermitRequired:
		return m.PermitRequired()
	case job.FieldInspectionRequired:
		return m.InspectionRequired()
	case job.FieldInspectionDate:
		return m.InspectionDate()
	case job.FieldProgressInspectionDate:
		return m.ProgressInspectionDate()
	case job.FieldInstallDate:
		return m.InstallDate()
	case job.FieldCompletionDate:
		return m.CompletionDate()
	case job.FieldMaterialDeliveryDate:
		return m.MaterialDeliveryDate()
	case job.FieldAgree:
		return m.Agree()
	case job.FieldAgreeAt:
		return m.AgreeAt()
	case job.FieldPoNumber:
		return m.PoNumber()
	case job.FieldRoofingPartnerAssignedAt:
		return m.RoofingPartnerAssignedAt()
	case job.FieldRoofingPartnerFlagAt:
		return m.RoofingPartnerFlagAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case job.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case job.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case job.FieldProgress:
		return m.OldProgress(ctx)
	case job.FieldProgressAt:
		return m.OldProgressAt(ctx)
	case job.FieldProgressFlagAt:
		return m.OldProgressFlagAt(ctx)
	case job.FieldRegionID:
		return m.OldRegionID(ctx)
	case job.FieldCompanyRefID:
		return m.OldCompanyRefID(ctx)
	case job.FieldCompanyName:
		return m.OldCompanyName(ctx)
	case job.FieldPrice:
		return m.OldPrice(ctx)
	case job.FieldWorkOrderPrice:
		return m.OldWorkOrderPrice(ctx)
	case job.FieldContractPrice:
		return m.OldContractPrice(ctx)
	case job.FieldChangeOrderPrice:
		return m.OldChangeOrderPrice(ctx)
	case job.FieldNote:
		return m.OldNote(ctx)
	case job.FieldShingleColor:
		return m.OldShingleColor(ctx)
	case job.FieldPermitRequired:
		return m.OldPermitRequired(ctx)
	case job.FieldInspectionRequired:
		return m.OldInspectionRequired(ctx)
	case job.FieldInspectionDate:
		return m.OldInspectionDate(ctx)
	case job.FieldProgressInspectionDate:
		return m.OldProgressInspectionDate(ctx)
	case job.FieldInstallDate:
		return m.OldInstallDate(ctx)
	case job.FieldCompletionDate:
		return m.OldCompletionDate(ctx)
	case job.FieldMaterialDeliveryDate:
		return m.OldMaterialDeliveryDate(ctx)
	case job.FieldAgree:
		return m.OldAgree(ctx)
	case job.FieldAgreeAt:
		return m.OldAgreeAt(ctx)
	case job.FieldPoNumber:
		return m.OldPoNumber(ctx)
	case job.FieldRoofingPartnerAssignedAt:
		return m.OldRoofingPartnerAssignedAt(ctx)
	case job.FieldRoofingPartnerFlagAt:
		return m.OldRoofingPartnerFlagAt(ctx)
	}
	return nil, fmt.Errorf("unknown Job field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case job.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case job.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case job.FieldProgress:
		v, ok := value.(enum.JobProgress)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case job.FieldProgressAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgressAt(v)
		return nil
	case job.FieldProgressFlagAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgressFlagAt(v)
		return nil
	case job.FieldRegionID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionID(v)
		return nil
	case job.FieldCompanyRefID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyRefID(v)
		return nil
	case job.FieldCompanyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompanyName(v)
		return nil
	case job.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case job.FieldWorkOrderPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkOrderPrice(v)
		return nil
	case job.FieldContractPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContractPrice(v)
		return nil
	case job.FieldChangeOrderPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChangeOrderPrice(v)
		return nil
	case job.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case job.FieldShingleColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShingleColor(v)
		return nil
	case job.FieldPermitRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermitRequired(v)
		return nil
	case job.FieldInspectionRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInspectionRequired(v)
		return nil
	case job.FieldInspectionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInspectionDate(v)
		return nil
	case job.FieldProgressInspectionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgressInspectionDate(v)
		return nil
	case job.FieldInstallDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallDate(v)
		return nil
	case job.FieldCompletionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompletionDate(v)
		return nil
	case job.FieldMaterialDeliveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaterialDeliveryDate(v)
		return nil
	case job.FieldAgree:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgree(v)
		return nil
	case job.FieldAgreeAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreeAt(v)
		return nil
	case job.FieldPoNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoNumber(v)
		return nil
	case job.FieldRoofingPartnerAssignedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoofingPartnerAssignedAt(v)
		return nil
	case job.FieldRoofingPartnerFlagAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoofingPartnerFlagAt(v)
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobMutation) AddedFields() []string {
	var fields []string
	if m.addregion_id != nil {
		fields = append(fields, job.FieldRegionID)
	}
	if m.addprice != nil {
		fields = append(fields, job.FieldPrice)
	}
	if m.addwork_order_price != nil {
		fields = append(fields, job.FieldWorkOrderPrice)
	}
	if m.addcontract_price != nil {
		fields = append(fields, job.FieldContractPrice)
	}
	if m.addchange_order_price != nil {
		fields = append(fields, job.FieldChangeOrderPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case job.FieldRegionID:
		return m.AddedRegionID()
	case job.FieldPrice:
		return m.AddedPrice()
	case job.FieldWorkOrderPrice:
		return m.AddedWorkOrderPrice()
	case job.FieldContractPrice:
		return m.AddedContractPrice()
	case job.FieldChangeOrderPrice:
		return m.AddedChangeOrderPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobMutation) AddField(name string, value ent.Value) error {
	switch name {
	case job.FieldRegionID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionID(v)
		return nil
	case job.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case job.FieldWorkOrderPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWorkOrderPrice(v)
		return nil
	case job.FieldContractPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddContractPrice(v)
		return nil
	case job.FieldChangeOrderPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChangeOrderPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Job numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(job.FieldProgress) {
		fields = append(fields, job.FieldProgress)
	}
	if m.FieldCleared(job.FieldProgressAt) {
		fields = append(fields, job.FieldProgressAt)
	}
	if m.FieldCleared(job.FieldProgressFlagAt) {
		fields = append(fields, job.FieldProgressFlagAt)
	}
	if m.FieldCleared(job.FieldRegionID) {
		fields = append(fields, job.FieldRegionID)
	}
	if m.FieldCleared(job.FieldCompanyRefID) {
		fields = append(fields, job.FieldCompanyRefID)
	}
	if m.FieldCleared(job.FieldCompanyName) {
		fields = append(fields, job.FieldCompanyName)
	}
	if m.FieldCleared(job.FieldContractPrice) {
		fields = append(fields, job.FieldContractPrice)
	}
	if m.FieldCleared(job.FieldChangeOrderPrice) {
		fields = append(fields, job.FieldChangeOrderPrice)
	}
	if m.FieldCleared(job.FieldNote) {
		fields = append(fields, job.FieldNote)
	}
	if m.FieldCleared(job.FieldShingleColor) {
		fields = append(fields, job.FieldShingleColor)
	}
	if m.FieldCleared(job.FieldPermitRequired) {
		fields = append(fields, job.FieldPermitRequired)
	}
	if m.FieldCleared(job.FieldInspectionRequired) {
		fields = append(fields, job.FieldInspectionRequired)
	}
	if m.FieldCleared(job.FieldInspectionDate) {
		fields = append(fields, job.FieldInspectionDate)
	}
	if m.FieldCleared(job.FieldProgressInspectionDate) {
		fields = append(fields, job.FieldProgressInspectionDate)
	}
	if m.FieldCleared(job.FieldInstallDate) {
		fields = append(fields, job.FieldInstallDate)
	}
	if m.FieldCleared(job.FieldCompletionDate) {
		fields = append(fields, job.FieldCompletionDate)
	}
	if m.FieldCleared(job.FieldMaterialDeliveryDate) {
		fields = append(fields, job.FieldMaterialDeliveryDate)
	}
	if m.FieldCleared(job.FieldAgree) {
		fields = append(fields, job.FieldAgree)
	}
	if m.FieldCleared(job.FieldAgreeAt) {
		fields = append(fields, job.FieldAgreeAt)
	}
	if m.FieldCleared(job.FieldPoNumber) {
		fields = append(fields, job.FieldPoNumber)
	}
	if m.FieldCleared(job.FieldRoofingPartnerAssignedAt) {
		fields = append(fields, job.FieldRoofingPartnerAssignedAt)
	}
	if m.FieldCleared(job.FieldRoofingPartnerFlagAt) {
		fields = append(fields, job.FieldRoofingPartnerFlagAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobMutation) ClearField(name string) error {
	switch name {
	case job.FieldProgress:
		m.ClearProgress()
		return nil
	case job.FieldProgressAt:
		m.ClearProgressAt()
		return nil
	case job.FieldProgressFlagAt:
		m.ClearProgressFlagAt()
		return nil
	case job.FieldRegionID:
		m.ClearRegionID()
		return nil
	case job.FieldCompanyRefID:
		m.ClearCompanyRefID()
		return nil
	case job.FieldCompanyName:
		m.ClearCompanyName()
		return nil
	case job.FieldContractPrice:
		m.ClearContractPrice()
		return nil
	case job.FieldChangeOrderPrice:
		m.ClearChangeOrderPrice()
		return nil
	case job.FieldNote:
		m.ClearNote()
		return nil
	case job.FieldShingleColor:
		m.ClearShingleColor()
		return nil
	case job.FieldPermitRequired:
		m.ClearPermitRequired()
		return nil
	case job.FieldInspectionRequired:
		m.ClearInspectionRequired()
		return nil
	case job.FieldInspectionDate:
		m.ClearInspectionDate()
		return nil
	case job.FieldProgressInspectionDate:
		m.ClearProgressInspectionDate()
		return nil
	case job.FieldInstallDate:
		m.ClearInstallDate()
		return nil
	case job.FieldCompletionDate:
		m.ClearCompletionDate()
		return nil
	case job.FieldMaterialDeliveryDate:
		m.ClearMaterialDeliveryDate()
		return nil
	case job.FieldAgree:
		m.ClearAgree()
		return nil
	case job.FieldAgreeAt:
		m.ClearAgreeAt()
		return nil
	case job.FieldPoNumber:
		m.ClearPoNumber()
		return nil
	case job.FieldRoofingPartnerAssignedAt:
		m.ClearRoofingPartnerAssignedAt()
		return nil
	case job.FieldRoofingPartnerFlagAt:
		m.ClearRoofingPartnerFlagAt()
		return nil
	}
	return fmt.Errorf("unknown Job nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobMutation) ResetField(name string) error {
	switch name {
	case job.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case job.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case job.FieldProgress:
		m.ResetProgress()
		return nil
	case job.FieldProgressAt:
		m.ResetProgressAt()
		return nil
	case job.FieldProgressFlagAt:
		m.ResetProgressFlagAt()
		return nil
	case job.FieldRegionID:
		m.ResetRegionID()
		return nil
	case job.FieldCompanyRefID:
		m.ResetCompanyRefID()
		return nil
	case job.FieldCompanyName:
		m.ResetCompanyName()
		return nil
	case job.FieldPrice:
		m.ResetPrice()
		return nil
	case job.FieldWorkOrderPrice:
		m.ResetWorkOrderPrice()
		return nil
	case job.FieldContractPrice:
		m.ResetContractPrice()
		return nil
	case job.FieldChangeOrderPrice:
		m.ResetChangeOrderPrice()
		return nil
	case job.FieldNote:
		m.ResetNote()
		return nil
	case job.FieldShingleColor:
		m.ResetShingleColor()
		return nil
	case job.FieldPermitRequired:
		m.ResetPermitRequired()
		return nil
	case job.FieldInspectionRequired:
		m.ResetInspectionRequired()
		return nil
	case job.FieldInspectionDate:
		m.ResetInspectionDate()
		return nil
	case job.FieldProgressInspectionDate:
		m.ResetProgressInspectionDate()
		return nil
	case job.FieldInstallDate:
		m.ResetInstallDate()
		return nil
	case job.FieldCompletionDate:
		m.ResetCompletionDate()
		return nil
	case job.FieldMaterialDeliveryDate:
		m.ResetMaterialDeliveryDate()
		return nil
	case job.FieldAgree:
		m.ResetAgree()
		return nil
	case job.FieldAgreeAt:
		m.ResetAgreeAt()
		return nil
	case job.FieldPoNumber:
		m.ResetPoNumber()
		return nil
	case job.FieldRoofingPartnerAssignedAt:
		m.ResetRoofingPartnerAssignedAt()
		return nil
	case job.FieldRoofingPartnerFlagAt:
		m.ResetRoofingPartnerFlagAt()
		return nil
	}
	return fmt.Errorf("unknown Job field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobMutation) AddedEdges() []string {
	edges := make([]string, 0, 17)
	if m.payments != nil {
		edges = append(edges, job.EdgePayments)
	}
	if m.activities != nil {
		edges = append(edges, job.EdgeActivities)
	}
	if m.assignment_history != nil {
		edges = append(edges, job.EdgeAssignmentHistory)
	}
	if m.progress_history != nil {
		edges = append(edges, job.EdgeProgressHistory)
	}
	if m.notes != nil {
		edges = append(edges, job.EdgeNotes)
	}
	if m.doc_urls != nil {
		edges = append(edges, job.EdgeDocUrls)
	}
	if m.estimate != nil {
		edges = append(edges, job.EdgeEstimate)
	}
	if m.creator_api != nil {
		edges = append(edges, job.EdgeCreatorAPI)
	}
	if m.creator != nil {
		edges = append(edges, job.EdgeCreator)
	}
	if m.home_owner != nil {
		edges = append(edges, job.EdgeHomeOwner)
	}
	if m.sales_rep != nil {
		edges = append(edges, job.EdgeSalesRep)
	}
	if m.requester != nil {
		edges = append(edges, job.EdgeRequester)
	}
	if m.roofing_partner != nil {
		edges = append(edges, job.EdgeRoofingPartner)
	}
	if m.integration_partner != nil {
		edges = append(edges, job.EdgeIntegrationPartner)
	}
	if m.epc_partner != nil {
		edges = append(edges, job.EdgeEpcPartner)
	}
	if m.epc != nil {
		edges = append(edges, job.EdgeEpc)
	}
	if m.estimate_pdf != nil {
		edges = append(edges, job.EdgeEstimatePdf)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case job.EdgePayments:
		ids := make([]ent.Value, 0, len(m.payments))
		for id := range m.payments {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeAssignmentHistory:
		ids := make([]ent.Value, 0, len(m.assignment_history))
		for id := range m.assignment_history {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeProgressHistory:
		ids := make([]ent.Value, 0, len(m.progress_history))
		for id := range m.progress_history {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.notes))
		for id := range m.notes {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeDocUrls:
		ids := make([]ent.Value, 0, len(m.doc_urls))
		for id := range m.doc_urls {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeEstimate:
		if id := m.estimate; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeCreatorAPI:
		if id := m.creator_api; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeHomeOwner:
		if id := m.home_owner; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeSalesRep:
		if id := m.sales_rep; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeRequester:
		if id := m.requester; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeRoofingPartner:
		if id := m.roofing_partner; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeIntegrationPartner:
		if id := m.integration_partner; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeEpcPartner:
		if id := m.epc_partner; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeEpc:
		if id := m.epc; id != nil {
			return []ent.Value{*id}
		}
	case job.EdgeEstimatePdf:
		if id := m.estimate_pdf; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 17)
	if m.removedpayments != nil {
		edges = append(edges, job.EdgePayments)
	}
	if m.removedactivities != nil {
		edges = append(edges, job.EdgeActivities)
	}
	if m.removedassignment_history != nil {
		edges = append(edges, job.EdgeAssignmentHistory)
	}
	if m.removedprogress_history != nil {
		edges = append(edges, job.EdgeProgressHistory)
	}
	if m.removednotes != nil {
		edges = append(edges, job.EdgeNotes)
	}
	if m.removeddoc_urls != nil {
		edges = append(edges, job.EdgeDocUrls)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case job.EdgePayments:
		ids := make([]ent.Value, 0, len(m.removedpayments))
		for id := range m.removedpayments {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeAssignmentHistory:
		ids := make([]ent.Value, 0, len(m.removedassignment_history))
		for id := range m.removedassignment_history {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeProgressHistory:
		ids := make([]ent.Value, 0, len(m.removedprogress_history))
		for id := range m.removedprogress_history {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeNotes:
		ids := make([]ent.Value, 0, len(m.removednotes))
		for id := range m.removednotes {
			ids = append(ids, id)
		}
		return ids
	case job.EdgeDocUrls:
		ids := make([]ent.Value, 0, len(m.removeddoc_urls))
		for id := range m.removeddoc_urls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 17)
	if m.clearedpayments {
		edges = append(edges, job.EdgePayments)
	}
	if m.clearedactivities {
		edges = append(edges, job.EdgeActivities)
	}
	if m.clearedassignment_history {
		edges = append(edges, job.EdgeAssignmentHistory)
	}
	if m.clearedprogress_history {
		edges = append(edges, job.EdgeProgressHistory)
	}
	if m.clearednotes {
		edges = append(edges, job.EdgeNotes)
	}
	if m.cleareddoc_urls {
		edges = append(edges, job.EdgeDocUrls)
	}
	if m.clearedestimate {
		edges = append(edges, job.EdgeEstimate)
	}
	if m.clearedcreator_api {
		edges = append(edges, job.EdgeCreatorAPI)
	}
	if m.clearedcreator {
		edges = append(edges, job.EdgeCreator)
	}
	if m.clearedhome_owner {
		edges = append(edges, job.EdgeHomeOwner)
	}
	if m.clearedsales_rep {
		edges = append(edges, job.EdgeSalesRep)
	}
	if m.clearedrequester {
		edges = append(edges, job.EdgeRequester)
	}
	if m.clearedroofing_partner {
		edges = append(edges, job.EdgeRoofingPartner)
	}
	if m.clearedintegration_partner {
		edges = append(edges, job.EdgeIntegrationPartner)
	}
	if m.clearedepc_partner {
		edges = append(edges, job.EdgeEpcPartner)
	}
	if m.clearedepc {
		edges = append(edges, job.EdgeEpc)
	}
	if m.clearedestimate_pdf {
		edges = append(edges, job.EdgeEstimatePdf)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobMutation) EdgeCleared(name string) bool {
	switch name {
	case job.EdgePayments:
		return m.clearedpayments
	case job.EdgeActivities:
		return m.clearedactivities
	case job.EdgeAssignmentHistory:
		return m.clearedassignment_history
	case job.EdgeProgressHistory:
		return m.clearedprogress_history
	case job.EdgeNotes:
		return m.clearednotes
	case job.EdgeDocUrls:
		return m.cleareddoc_urls
	case job.EdgeEstimate:
		return m.clearedestimate
	case job.EdgeCreatorAPI:
		return m.clearedcreator_api
	case job.EdgeCreator:
		return m.clearedcreator
	case job.EdgeHomeOwner:
		return m.clearedhome_owner
	case job.EdgeSalesRep:
		return m.clearedsales_rep
	case job.EdgeRequester:
		return m.clearedrequester
	case job.EdgeRoofingPartner:
		return m.clearedroofing_partner
	case job.EdgeIntegrationPartner:
		return m.clearedintegration_partner
	case job.EdgeEpcPartner:
		return m.clearedepc_partner
	case job.EdgeEpc:
		return m.clearedepc
	case job.EdgeEstimatePdf:
		return m.clearedestimate_pdf
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobMutation) ClearEdge(name string) error {
	switch name {
	case job.EdgeEstimate:
		m.ClearEstimate()
		return nil
	case job.EdgeCreatorAPI:
		m.ClearCreatorAPI()
		return nil
	case job.EdgeCreator:
		m.ClearCreator()
		return nil
	case job.EdgeHomeOwner:
		m.ClearHomeOwner()
		return nil
	case job.EdgeSalesRep:
		m.ClearSalesRep()
		return nil
	case job.EdgeRequester:
		m.ClearRequester()
		return nil
	case job.EdgeRoofingPartner:
		m.ClearRoofingPartner()
		return nil
	case job.EdgeIntegrationPartner:
		m.ClearIntegrationPartner()
		return nil
	case job.EdgeEpcPartner:
		m.ClearEpcPartner()
		return nil
	case job.EdgeEpc:
		m.ClearEpc()
		return nil
	case job.EdgeEstimatePdf:
		m.ClearEstimatePdf()
		return nil
	}
	return fmt.Errorf("unknown Job unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobMutation) ResetEdge(name string) error {
	switch name {
	case job.EdgePayments:
		m.ResetPayments()
		return nil
	case job.EdgeActivities:
		m.ResetActivities()
		return nil
	case job.EdgeAssignmentHistory:
		m.ResetAssignmentHistory()
		return nil
	case job.EdgeProgressHistory:
		m.ResetProgressHistory()
		return nil
	case job.EdgeNotes:
		m.ResetNotes()
		return nil
	case job.EdgeDocUrls:
		m.ResetDocUrls()
		return nil
	case job.EdgeEstimate:
		m.ResetEstimate()
		return nil
	case job.EdgeCreatorAPI:
		m.ResetCreatorAPI()
		return nil
	case job.EdgeCreator:
		m.ResetCreator()
		return nil
	case job.EdgeHomeOwner:
		m.ResetHomeOwner()
		return nil
	case job.EdgeSalesRep:
		m.ResetSalesRep()
		return nil
	case job.EdgeRequester:
		m.ResetRequester()
		return nil
	case job.EdgeRoofingPartner:
		m.ResetRoofingPartner()
		return nil
	case job.EdgeIntegrationPartner:
		m.ResetIntegrationPartner()
		return nil
	case job.EdgeEpcPartner:
		m.ResetEpcPartner()
		return nil
	case job.EdgeEpc:
		m.ResetEpc()
		return nil
	case job.EdgeEstimatePdf:
		m.ResetEstimatePdf()
		return nil
	}
	return fmt.Errorf("unknown Job edge %s", name)
}

// JobActivityMutation represents an operation that mutates the JobActivity nodes in the graph.
type JobActivityMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	description        *string
	raw                *map[string]interface{}
	clearedFields      map[string]struct{}
	job                *string
	clearedjob         bool
	creator            *string
	clearedcreator     bool
	creator_api        *string
	clearedcreator_api bool
	done               bool
	oldValue           func(context.Context) (*JobActivity, error)
	predicates         []predicate.JobActivity
}

var _ ent.Mutation = (*JobActivityMutation)(nil)

// jobactivityOption allows management of the mutation configuration using functional options.
type jobactivityOption func(*JobActivityMutation)

// newJobActivityMutation creates new mutation for the JobActivity entity.
func newJobActivityMutation(c config, op Op, opts ...jobactivityOption) *JobActivityMutation {
	m := &JobActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeJobActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobActivityID sets the ID field of the mutation.
func withJobActivityID(id string) jobactivityOption {
	return func(m *JobActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *JobActivity
		)
		m.oldValue = func(ctx context.Context) (*JobActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobActivity sets the old JobActivity of the mutation.
func withJobActivity(node *JobActivity) jobactivityOption {
	return func(m *JobActivityMutation) {
		m.oldValue = func(context.Context) (*JobActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobActivity entities.
func (m *JobActivityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobActivityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobActivityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JobActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobActivity entity.
// If the JobActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDescription sets the "description" field.
func (m *JobActivityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *JobActivityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the JobActivity entity.
// If the JobActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobActivityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *JobActivityMutation) ResetDescription() {
	m.description = nil
}

// SetRaw sets the "raw" field.
func (m *JobActivityMutation) SetRaw(value map[string]interface{}) {
	m.raw = &value
}

// Raw returns the value of the "raw" field in the mutation.
func (m *JobActivityMutation) Raw() (r map[string]interface{}, exists bool) {
	v := m.raw
	if v == nil {
		return
	}
	return *v, true
}

// OldRaw returns the old "raw" field's value of the JobActivity entity.
// If the JobActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobActivityMutation) OldRaw(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRaw: %w", err)
	}
	return oldValue.Raw, nil
}

// ClearRaw clears the value of the "raw" field.
func (m *JobActivityMutation) ClearRaw() {
	m.raw = nil
	m.clearedFields[jobactivity.FieldRaw] = struct{}{}
}

// RawCleared returns if the "raw" field was cleared in this mutation.
func (m *JobActivityMutation) RawCleared() bool {
	_, ok := m.clearedFields[jobactivity.FieldRaw]
	return ok
}

// ResetRaw resets all changes to the "raw" field.
func (m *JobActivityMutation) ResetRaw() {
	m.raw = nil
	delete(m.clearedFields, jobactivity.FieldRaw)
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *JobActivityMutation) SetJobID(id string) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *JobActivityMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *JobActivityMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *JobActivityMutation) JobID() (id string, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobActivityMutation) JobIDs() (ids []string) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobActivityMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *JobActivityMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *JobActivityMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *JobActivityMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *JobActivityMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *JobActivityMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *JobActivityMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetCreatorAPIID sets the "creator_api" edge to the ApiUser entity by id.
func (m *JobActivityMutation) SetCreatorAPIID(id string) {
	m.creator_api = &id
}

// ClearCreatorAPI clears the "creator_api" edge to the ApiUser entity.
func (m *JobActivityMutation) ClearCreatorAPI() {
	m.clearedcreator_api = true
}

// CreatorAPICleared reports if the "creator_api" edge to the ApiUser entity was cleared.
func (m *JobActivityMutation) CreatorAPICleared() bool {
	return m.clearedcreator_api
}

// CreatorAPIID returns the "creator_api" edge ID in the mutation.
func (m *JobActivityMutation) CreatorAPIID() (id string, exists bool) {
	if m.creator_api != nil {
		return *m.creator_api, true
	}
	return
}

// CreatorAPIIDs returns the "creator_api" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorAPIID instead. It exists only for internal usage by the builders.
func (m *JobActivityMutation) CreatorAPIIDs() (ids []string) {
	if id := m.creator_api; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatorAPI resets all changes to the "creator_api" edge.
func (m *JobActivityMutation) ResetCreatorAPI() {
	m.creator_api = nil
	m.clearedcreator_api = false
}

// Where appends a list predicates to the JobActivityMutation builder.
func (m *JobActivityMutation) Where(ps ...predicate.JobActivity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobActivity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobActivity).
func (m *JobActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobActivityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, jobactivity.FieldCreatedAt)
	}
	if m.description != nil {
		fields = append(fields, jobactivity.FieldDescription)
	}
	if m.raw != nil {
		fields = append(fields, jobactivity.FieldRaw)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobactivity.FieldCreatedAt:
		return m.CreatedAt()
	case jobactivity.FieldDescription:
		return m.Description()
	case jobactivity.FieldRaw:
		return m.Raw()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobactivity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobactivity.FieldDescription:
		return m.OldDescription(ctx)
	case jobactivity.FieldRaw:
		return m.OldRaw(ctx)
	}
	return nil, fmt.Errorf("unknown JobActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobactivity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobactivity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case jobactivity.FieldRaw:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRaw(v)
		return nil
	}
	return fmt.Errorf("unknown JobActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobactivity.FieldRaw) {
		fields = append(fields, jobactivity.FieldRaw)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobActivityMutation) ClearField(name string) error {
	switch name {
	case jobactivity.FieldRaw:
		m.ClearRaw()
		return nil
	}
	return fmt.Errorf("unknown JobActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobActivityMutation) ResetField(name string) error {
	switch name {
	case jobactivity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobactivity.FieldDescription:
		m.ResetDescription()
		return nil
	case jobactivity.FieldRaw:
		m.ResetRaw()
		return nil
	}
	return fmt.Errorf("unknown JobActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.job != nil {
		edges = append(edges, jobactivity.EdgeJob)
	}
	if m.creator != nil {
		edges = append(edges, jobactivity.EdgeCreator)
	}
	if m.creator_api != nil {
		edges = append(edges, jobactivity.EdgeCreatorAPI)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobactivity.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case jobactivity.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case jobactivity.EdgeCreatorAPI:
		if id := m.creator_api; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedjob {
		edges = append(edges, jobactivity.EdgeJob)
	}
	if m.clearedcreator {
		edges = append(edges, jobactivity.EdgeCreator)
	}
	if m.clearedcreator_api {
		edges = append(edges, jobactivity.EdgeCreatorAPI)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case jobactivity.EdgeJob:
		return m.clearedjob
	case jobactivity.EdgeCreator:
		return m.clearedcreator
	case jobactivity.EdgeCreatorAPI:
		return m.clearedcreator_api
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobActivityMutation) ClearEdge(name string) error {
	switch name {
	case jobactivity.EdgeJob:
		m.ClearJob()
		return nil
	case jobactivity.EdgeCreator:
		m.ClearCreator()
		return nil
	case jobactivity.EdgeCreatorAPI:
		m.ClearCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown JobActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobActivityMutation) ResetEdge(name string) error {
	switch name {
	case jobactivity.EdgeJob:
		m.ResetJob()
		return nil
	case jobactivity.EdgeCreator:
		m.ResetCreator()
		return nil
	case jobactivity.EdgeCreatorAPI:
		m.ResetCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown JobActivity edge %s", name)
}

// JobAssignmentHistoryMutation represents an operation that mutates the JobAssignmentHistory nodes in the graph.
type JobAssignmentHistoryMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	status         *enum.JobAssignmentStatus
	_Note          *string
	clearedFields  map[string]struct{}
	job            *string
	clearedjob     bool
	partner        *string
	clearedpartner bool
	done           bool
	oldValue       func(context.Context) (*JobAssignmentHistory, error)
	predicates     []predicate.JobAssignmentHistory
}

var _ ent.Mutation = (*JobAssignmentHistoryMutation)(nil)

// jobassignmenthistoryOption allows management of the mutation configuration using functional options.
type jobassignmenthistoryOption func(*JobAssignmentHistoryMutation)

// newJobAssignmentHistoryMutation creates new mutation for the JobAssignmentHistory entity.
func newJobAssignmentHistoryMutation(c config, op Op, opts ...jobassignmenthistoryOption) *JobAssignmentHistoryMutation {
	m := &JobAssignmentHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeJobAssignmentHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobAssignmentHistoryID sets the ID field of the mutation.
func withJobAssignmentHistoryID(id string) jobassignmenthistoryOption {
	return func(m *JobAssignmentHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *JobAssignmentHistory
		)
		m.oldValue = func(ctx context.Context) (*JobAssignmentHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobAssignmentHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobAssignmentHistory sets the old JobAssignmentHistory of the mutation.
func withJobAssignmentHistory(node *JobAssignmentHistory) jobassignmenthistoryOption {
	return func(m *JobAssignmentHistoryMutation) {
		m.oldValue = func(context.Context) (*JobAssignmentHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobAssignmentHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobAssignmentHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobAssignmentHistory entities.
func (m *JobAssignmentHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobAssignmentHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobAssignmentHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobAssignmentHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JobAssignmentHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobAssignmentHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobAssignmentHistory entity.
// If the JobAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAssignmentHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobAssignmentHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStatus sets the "status" field.
func (m *JobAssignmentHistoryMutation) SetStatus(eas enum.JobAssignmentStatus) {
	m.status = &eas
}

// Status returns the value of the "status" field in the mutation.
func (m *JobAssignmentHistoryMutation) Status() (r enum.JobAssignmentStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the JobAssignmentHistory entity.
// If the JobAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAssignmentHistoryMutation) OldStatus(ctx context.Context) (v enum.JobAssignmentStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JobAssignmentHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetNote sets the "Note" field.
func (m *JobAssignmentHistoryMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *JobAssignmentHistoryMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the JobAssignmentHistory entity.
// If the JobAssignmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobAssignmentHistoryMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *JobAssignmentHistoryMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[jobassignmenthistory.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *JobAssignmentHistoryMutation) NoteCleared() bool {
	_, ok := m.clearedFields[jobassignmenthistory.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *JobAssignmentHistoryMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, jobassignmenthistory.FieldNote)
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *JobAssignmentHistoryMutation) SetJobID(id string) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *JobAssignmentHistoryMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *JobAssignmentHistoryMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *JobAssignmentHistoryMutation) JobID() (id string, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobAssignmentHistoryMutation) JobIDs() (ids []string) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobAssignmentHistoryMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *JobAssignmentHistoryMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *JobAssignmentHistoryMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *JobAssignmentHistoryMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *JobAssignmentHistoryMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *JobAssignmentHistoryMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *JobAssignmentHistoryMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// Where appends a list predicates to the JobAssignmentHistoryMutation builder.
func (m *JobAssignmentHistoryMutation) Where(ps ...predicate.JobAssignmentHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobAssignmentHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobAssignmentHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobAssignmentHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobAssignmentHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobAssignmentHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobAssignmentHistory).
func (m *JobAssignmentHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobAssignmentHistoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, jobassignmenthistory.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, jobassignmenthistory.FieldStatus)
	}
	if m._Note != nil {
		fields = append(fields, jobassignmenthistory.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobAssignmentHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobassignmenthistory.FieldCreatedAt:
		return m.CreatedAt()
	case jobassignmenthistory.FieldStatus:
		return m.Status()
	case jobassignmenthistory.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobAssignmentHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobassignmenthistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobassignmenthistory.FieldStatus:
		return m.OldStatus(ctx)
	case jobassignmenthistory.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown JobAssignmentHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobAssignmentHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobassignmenthistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobassignmenthistory.FieldStatus:
		v, ok := value.(enum.JobAssignmentStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case jobassignmenthistory.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown JobAssignmentHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobAssignmentHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobAssignmentHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobAssignmentHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobAssignmentHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobAssignmentHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobassignmenthistory.FieldNote) {
		fields = append(fields, jobassignmenthistory.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobAssignmentHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobAssignmentHistoryMutation) ClearField(name string) error {
	switch name {
	case jobassignmenthistory.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown JobAssignmentHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobAssignmentHistoryMutation) ResetField(name string) error {
	switch name {
	case jobassignmenthistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobassignmenthistory.FieldStatus:
		m.ResetStatus()
		return nil
	case jobassignmenthistory.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown JobAssignmentHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobAssignmentHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.job != nil {
		edges = append(edges, jobassignmenthistory.EdgeJob)
	}
	if m.partner != nil {
		edges = append(edges, jobassignmenthistory.EdgePartner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobAssignmentHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobassignmenthistory.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case jobassignmenthistory.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobAssignmentHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobAssignmentHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobAssignmentHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjob {
		edges = append(edges, jobassignmenthistory.EdgeJob)
	}
	if m.clearedpartner {
		edges = append(edges, jobassignmenthistory.EdgePartner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobAssignmentHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case jobassignmenthistory.EdgeJob:
		return m.clearedjob
	case jobassignmenthistory.EdgePartner:
		return m.clearedpartner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobAssignmentHistoryMutation) ClearEdge(name string) error {
	switch name {
	case jobassignmenthistory.EdgeJob:
		m.ClearJob()
		return nil
	case jobassignmenthistory.EdgePartner:
		m.ClearPartner()
		return nil
	}
	return fmt.Errorf("unknown JobAssignmentHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobAssignmentHistoryMutation) ResetEdge(name string) error {
	switch name {
	case jobassignmenthistory.EdgeJob:
		m.ResetJob()
		return nil
	case jobassignmenthistory.EdgePartner:
		m.ResetPartner()
		return nil
	}
	return fmt.Errorf("unknown JobAssignmentHistory edge %s", name)
}

// JobDocURLMutation represents an operation that mutates the JobDocURL nodes in the graph.
type JobDocURLMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	_type          *enum.JobDocUrlType
	url            *string
	clearedFields  map[string]struct{}
	job            *string
	clearedjob     bool
	creator        *string
	clearedcreator bool
	done           bool
	oldValue       func(context.Context) (*JobDocURL, error)
	predicates     []predicate.JobDocURL
}

var _ ent.Mutation = (*JobDocURLMutation)(nil)

// jobdocurlOption allows management of the mutation configuration using functional options.
type jobdocurlOption func(*JobDocURLMutation)

// newJobDocURLMutation creates new mutation for the JobDocURL entity.
func newJobDocURLMutation(c config, op Op, opts ...jobdocurlOption) *JobDocURLMutation {
	m := &JobDocURLMutation{
		config:        c,
		op:            op,
		typ:           TypeJobDocURL,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobDocURLID sets the ID field of the mutation.
func withJobDocURLID(id string) jobdocurlOption {
	return func(m *JobDocURLMutation) {
		var (
			err   error
			once  sync.Once
			value *JobDocURL
		)
		m.oldValue = func(ctx context.Context) (*JobDocURL, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobDocURL.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobDocURL sets the old JobDocURL of the mutation.
func withJobDocURL(node *JobDocURL) jobdocurlOption {
	return func(m *JobDocURLMutation) {
		m.oldValue = func(context.Context) (*JobDocURL, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobDocURLMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobDocURLMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobDocURL entities.
func (m *JobDocURLMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobDocURLMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobDocURLMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobDocURL.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JobDocURLMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobDocURLMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobDocURL entity.
// If the JobDocURL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDocURLMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobDocURLMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobDocURLMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobDocURLMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobDocURL entity.
// If the JobDocURL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDocURLMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobDocURLMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *JobDocURLMutation) SetType(edut enum.JobDocUrlType) {
	m._type = &edut
}

// GetType returns the value of the "type" field in the mutation.
func (m *JobDocURLMutation) GetType() (r enum.JobDocUrlType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the JobDocURL entity.
// If the JobDocURL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDocURLMutation) OldType(ctx context.Context) (v enum.JobDocUrlType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *JobDocURLMutation) ResetType() {
	m._type = nil
}

// SetURL sets the "url" field.
func (m *JobDocURLMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *JobDocURLMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the JobDocURL entity.
// If the JobDocURL object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobDocURLMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *JobDocURLMutation) ResetURL() {
	m.url = nil
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *JobDocURLMutation) SetJobID(id string) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *JobDocURLMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *JobDocURLMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *JobDocURLMutation) JobID() (id string, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobDocURLMutation) JobIDs() (ids []string) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobDocURLMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *JobDocURLMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *JobDocURLMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *JobDocURLMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *JobDocURLMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *JobDocURLMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *JobDocURLMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the JobDocURLMutation builder.
func (m *JobDocURLMutation) Where(ps ...predicate.JobDocURL) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobDocURLMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobDocURLMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobDocURL, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobDocURLMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobDocURLMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobDocURL).
func (m *JobDocURLMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobDocURLMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, jobdocurl.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobdocurl.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, jobdocurl.FieldType)
	}
	if m.url != nil {
		fields = append(fields, jobdocurl.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobDocURLMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobdocurl.FieldCreatedAt:
		return m.CreatedAt()
	case jobdocurl.FieldUpdatedAt:
		return m.UpdatedAt()
	case jobdocurl.FieldType:
		return m.GetType()
	case jobdocurl.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobDocURLMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobdocurl.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobdocurl.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case jobdocurl.FieldType:
		return m.OldType(ctx)
	case jobdocurl.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown JobDocURL field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobDocURLMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobdocurl.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobdocurl.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case jobdocurl.FieldType:
		v, ok := value.(enum.JobDocUrlType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case jobdocurl.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown JobDocURL field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobDocURLMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobDocURLMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobDocURLMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobDocURL numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobDocURLMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobDocURLMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobDocURLMutation) ClearField(name string) error {
	return fmt.Errorf("unknown JobDocURL nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobDocURLMutation) ResetField(name string) error {
	switch name {
	case jobdocurl.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobdocurl.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case jobdocurl.FieldType:
		m.ResetType()
		return nil
	case jobdocurl.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown JobDocURL field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobDocURLMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.job != nil {
		edges = append(edges, jobdocurl.EdgeJob)
	}
	if m.creator != nil {
		edges = append(edges, jobdocurl.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobDocURLMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobdocurl.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case jobdocurl.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobDocURLMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobDocURLMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobDocURLMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedjob {
		edges = append(edges, jobdocurl.EdgeJob)
	}
	if m.clearedcreator {
		edges = append(edges, jobdocurl.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobDocURLMutation) EdgeCleared(name string) bool {
	switch name {
	case jobdocurl.EdgeJob:
		return m.clearedjob
	case jobdocurl.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobDocURLMutation) ClearEdge(name string) error {
	switch name {
	case jobdocurl.EdgeJob:
		m.ClearJob()
		return nil
	case jobdocurl.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown JobDocURL unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobDocURLMutation) ResetEdge(name string) error {
	switch name {
	case jobdocurl.EdgeJob:
		m.ResetJob()
		return nil
	case jobdocurl.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown JobDocURL edge %s", name)
}

// JobNoteMutation represents an operation that mutates the JobNote nodes in the graph.
type JobNoteMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	note           *string
	clearedFields  map[string]struct{}
	job            *string
	clearedjob     bool
	user           *string
	cleareduser    bool
	partner        *string
	clearedpartner bool
	done           bool
	oldValue       func(context.Context) (*JobNote, error)
	predicates     []predicate.JobNote
}

var _ ent.Mutation = (*JobNoteMutation)(nil)

// jobnoteOption allows management of the mutation configuration using functional options.
type jobnoteOption func(*JobNoteMutation)

// newJobNoteMutation creates new mutation for the JobNote entity.
func newJobNoteMutation(c config, op Op, opts ...jobnoteOption) *JobNoteMutation {
	m := &JobNoteMutation{
		config:        c,
		op:            op,
		typ:           TypeJobNote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobNoteID sets the ID field of the mutation.
func withJobNoteID(id string) jobnoteOption {
	return func(m *JobNoteMutation) {
		var (
			err   error
			once  sync.Once
			value *JobNote
		)
		m.oldValue = func(ctx context.Context) (*JobNote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobNote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobNote sets the old JobNote of the mutation.
func withJobNote(node *JobNote) jobnoteOption {
	return func(m *JobNoteMutation) {
		m.oldValue = func(context.Context) (*JobNote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobNoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobNoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobNote entities.
func (m *JobNoteMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobNoteMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobNoteMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobNote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JobNoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobNoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobNote entity.
// If the JobNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobNoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobNoteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *JobNoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *JobNoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the JobNote entity.
// If the JobNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobNoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *JobNoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetNote sets the "note" field.
func (m *JobNoteMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *JobNoteMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the JobNote entity.
// If the JobNote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobNoteMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ResetNote resets all changes to the "note" field.
func (m *JobNoteMutation) ResetNote() {
	m.note = nil
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *JobNoteMutation) SetJobID(id string) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *JobNoteMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *JobNoteMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *JobNoteMutation) JobID() (id string, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobNoteMutation) JobIDs() (ids []string) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobNoteMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *JobNoteMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *JobNoteMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *JobNoteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *JobNoteMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *JobNoteMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *JobNoteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *JobNoteMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *JobNoteMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *JobNoteMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *JobNoteMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *JobNoteMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *JobNoteMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// Where appends a list predicates to the JobNoteMutation builder.
func (m *JobNoteMutation) Where(ps ...predicate.JobNote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobNoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobNoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobNote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobNoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobNoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobNote).
func (m *JobNoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobNoteMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, jobnote.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, jobnote.FieldUpdatedAt)
	}
	if m.note != nil {
		fields = append(fields, jobnote.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobNoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobnote.FieldCreatedAt:
		return m.CreatedAt()
	case jobnote.FieldUpdatedAt:
		return m.UpdatedAt()
	case jobnote.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobNoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobnote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobnote.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case jobnote.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown JobNote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobNoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobnote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobnote.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case jobnote.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown JobNote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobNoteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobNoteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobNoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobNote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobNoteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobNoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobNoteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown JobNote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobNoteMutation) ResetField(name string) error {
	switch name {
	case jobnote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobnote.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case jobnote.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown JobNote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobNoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.job != nil {
		edges = append(edges, jobnote.EdgeJob)
	}
	if m.user != nil {
		edges = append(edges, jobnote.EdgeUser)
	}
	if m.partner != nil {
		edges = append(edges, jobnote.EdgePartner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobNoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobnote.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case jobnote.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case jobnote.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobNoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobNoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobNoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedjob {
		edges = append(edges, jobnote.EdgeJob)
	}
	if m.cleareduser {
		edges = append(edges, jobnote.EdgeUser)
	}
	if m.clearedpartner {
		edges = append(edges, jobnote.EdgePartner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobNoteMutation) EdgeCleared(name string) bool {
	switch name {
	case jobnote.EdgeJob:
		return m.clearedjob
	case jobnote.EdgeUser:
		return m.cleareduser
	case jobnote.EdgePartner:
		return m.clearedpartner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobNoteMutation) ClearEdge(name string) error {
	switch name {
	case jobnote.EdgeJob:
		m.ClearJob()
		return nil
	case jobnote.EdgeUser:
		m.ClearUser()
		return nil
	case jobnote.EdgePartner:
		m.ClearPartner()
		return nil
	}
	return fmt.Errorf("unknown JobNote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobNoteMutation) ResetEdge(name string) error {
	switch name {
	case jobnote.EdgeJob:
		m.ResetJob()
		return nil
	case jobnote.EdgeUser:
		m.ResetUser()
		return nil
	case jobnote.EdgePartner:
		m.ResetPartner()
		return nil
	}
	return fmt.Errorf("unknown JobNote edge %s", name)
}

// JobProgressHistoryMutation represents an operation that mutates the JobProgressHistory nodes in the graph.
type JobProgressHistoryMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	created_at              *time.Time
	status                  *enum.JobProgress
	complete                *bool
	note                    *string
	clearedFields           map[string]struct{}
	job                     *string
	clearedjob              bool
	creator                 *string
	clearedcreator          bool
	creator_api_user        *string
	clearedcreator_api_user bool
	done                    bool
	oldValue                func(context.Context) (*JobProgressHistory, error)
	predicates              []predicate.JobProgressHistory
}

var _ ent.Mutation = (*JobProgressHistoryMutation)(nil)

// jobprogresshistoryOption allows management of the mutation configuration using functional options.
type jobprogresshistoryOption func(*JobProgressHistoryMutation)

// newJobProgressHistoryMutation creates new mutation for the JobProgressHistory entity.
func newJobProgressHistoryMutation(c config, op Op, opts ...jobprogresshistoryOption) *JobProgressHistoryMutation {
	m := &JobProgressHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeJobProgressHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withJobProgressHistoryID sets the ID field of the mutation.
func withJobProgressHistoryID(id string) jobprogresshistoryOption {
	return func(m *JobProgressHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *JobProgressHistory
		)
		m.oldValue = func(ctx context.Context) (*JobProgressHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().JobProgressHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withJobProgressHistory sets the old JobProgressHistory of the mutation.
func withJobProgressHistory(node *JobProgressHistory) jobprogresshistoryOption {
	return func(m *JobProgressHistoryMutation) {
		m.oldValue = func(context.Context) (*JobProgressHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m JobProgressHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m JobProgressHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of JobProgressHistory entities.
func (m *JobProgressHistoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *JobProgressHistoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *JobProgressHistoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().JobProgressHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *JobProgressHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *JobProgressHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the JobProgressHistory entity.
// If the JobProgressHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *JobProgressHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStatus sets the "status" field.
func (m *JobProgressHistoryMutation) SetStatus(ep enum.JobProgress) {
	m.status = &ep
}

// Status returns the value of the "status" field in the mutation.
func (m *JobProgressHistoryMutation) Status() (r enum.JobProgress, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the JobProgressHistory entity.
// If the JobProgressHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressHistoryMutation) OldStatus(ctx context.Context) (v enum.JobProgress, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *JobProgressHistoryMutation) ResetStatus() {
	m.status = nil
}

// SetComplete sets the "complete" field.
func (m *JobProgressHistoryMutation) SetComplete(b bool) {
	m.complete = &b
}

// Complete returns the value of the "complete" field in the mutation.
func (m *JobProgressHistoryMutation) Complete() (r bool, exists bool) {
	v := m.complete
	if v == nil {
		return
	}
	return *v, true
}

// OldComplete returns the old "complete" field's value of the JobProgressHistory entity.
// If the JobProgressHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressHistoryMutation) OldComplete(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComplete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComplete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComplete: %w", err)
	}
	return oldValue.Complete, nil
}

// ClearComplete clears the value of the "complete" field.
func (m *JobProgressHistoryMutation) ClearComplete() {
	m.complete = nil
	m.clearedFields[jobprogresshistory.FieldComplete] = struct{}{}
}

// CompleteCleared returns if the "complete" field was cleared in this mutation.
func (m *JobProgressHistoryMutation) CompleteCleared() bool {
	_, ok := m.clearedFields[jobprogresshistory.FieldComplete]
	return ok
}

// ResetComplete resets all changes to the "complete" field.
func (m *JobProgressHistoryMutation) ResetComplete() {
	m.complete = nil
	delete(m.clearedFields, jobprogresshistory.FieldComplete)
}

// SetNote sets the "note" field.
func (m *JobProgressHistoryMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *JobProgressHistoryMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the JobProgressHistory entity.
// If the JobProgressHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *JobProgressHistoryMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *JobProgressHistoryMutation) ClearNote() {
	m.note = nil
	m.clearedFields[jobprogresshistory.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *JobProgressHistoryMutation) NoteCleared() bool {
	_, ok := m.clearedFields[jobprogresshistory.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *JobProgressHistoryMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, jobprogresshistory.FieldNote)
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *JobProgressHistoryMutation) SetJobID(id string) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *JobProgressHistoryMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *JobProgressHistoryMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *JobProgressHistoryMutation) JobID() (id string, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *JobProgressHistoryMutation) JobIDs() (ids []string) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *JobProgressHistoryMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *JobProgressHistoryMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *JobProgressHistoryMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *JobProgressHistoryMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *JobProgressHistoryMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *JobProgressHistoryMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *JobProgressHistoryMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetCreatorAPIUserID sets the "creator_api_user" edge to the ApiUser entity by id.
func (m *JobProgressHistoryMutation) SetCreatorAPIUserID(id string) {
	m.creator_api_user = &id
}

// ClearCreatorAPIUser clears the "creator_api_user" edge to the ApiUser entity.
func (m *JobProgressHistoryMutation) ClearCreatorAPIUser() {
	m.clearedcreator_api_user = true
}

// CreatorAPIUserCleared reports if the "creator_api_user" edge to the ApiUser entity was cleared.
func (m *JobProgressHistoryMutation) CreatorAPIUserCleared() bool {
	return m.clearedcreator_api_user
}

// CreatorAPIUserID returns the "creator_api_user" edge ID in the mutation.
func (m *JobProgressHistoryMutation) CreatorAPIUserID() (id string, exists bool) {
	if m.creator_api_user != nil {
		return *m.creator_api_user, true
	}
	return
}

// CreatorAPIUserIDs returns the "creator_api_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorAPIUserID instead. It exists only for internal usage by the builders.
func (m *JobProgressHistoryMutation) CreatorAPIUserIDs() (ids []string) {
	if id := m.creator_api_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatorAPIUser resets all changes to the "creator_api_user" edge.
func (m *JobProgressHistoryMutation) ResetCreatorAPIUser() {
	m.creator_api_user = nil
	m.clearedcreator_api_user = false
}

// Where appends a list predicates to the JobProgressHistoryMutation builder.
func (m *JobProgressHistoryMutation) Where(ps ...predicate.JobProgressHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the JobProgressHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *JobProgressHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.JobProgressHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *JobProgressHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *JobProgressHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (JobProgressHistory).
func (m *JobProgressHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *JobProgressHistoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, jobprogresshistory.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, jobprogresshistory.FieldStatus)
	}
	if m.complete != nil {
		fields = append(fields, jobprogresshistory.FieldComplete)
	}
	if m.note != nil {
		fields = append(fields, jobprogresshistory.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *JobProgressHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case jobprogresshistory.FieldCreatedAt:
		return m.CreatedAt()
	case jobprogresshistory.FieldStatus:
		return m.Status()
	case jobprogresshistory.FieldComplete:
		return m.Complete()
	case jobprogresshistory.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *JobProgressHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case jobprogresshistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case jobprogresshistory.FieldStatus:
		return m.OldStatus(ctx)
	case jobprogresshistory.FieldComplete:
		return m.OldComplete(ctx)
	case jobprogresshistory.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown JobProgressHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobProgressHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case jobprogresshistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case jobprogresshistory.FieldStatus:
		v, ok := value.(enum.JobProgress)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case jobprogresshistory.FieldComplete:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComplete(v)
		return nil
	case jobprogresshistory.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown JobProgressHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *JobProgressHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *JobProgressHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *JobProgressHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown JobProgressHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *JobProgressHistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(jobprogresshistory.FieldComplete) {
		fields = append(fields, jobprogresshistory.FieldComplete)
	}
	if m.FieldCleared(jobprogresshistory.FieldNote) {
		fields = append(fields, jobprogresshistory.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *JobProgressHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *JobProgressHistoryMutation) ClearField(name string) error {
	switch name {
	case jobprogresshistory.FieldComplete:
		m.ClearComplete()
		return nil
	case jobprogresshistory.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown JobProgressHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *JobProgressHistoryMutation) ResetField(name string) error {
	switch name {
	case jobprogresshistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case jobprogresshistory.FieldStatus:
		m.ResetStatus()
		return nil
	case jobprogresshistory.FieldComplete:
		m.ResetComplete()
		return nil
	case jobprogresshistory.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown JobProgressHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *JobProgressHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.job != nil {
		edges = append(edges, jobprogresshistory.EdgeJob)
	}
	if m.creator != nil {
		edges = append(edges, jobprogresshistory.EdgeCreator)
	}
	if m.creator_api_user != nil {
		edges = append(edges, jobprogresshistory.EdgeCreatorAPIUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *JobProgressHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case jobprogresshistory.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	case jobprogresshistory.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case jobprogresshistory.EdgeCreatorAPIUser:
		if id := m.creator_api_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *JobProgressHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *JobProgressHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *JobProgressHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedjob {
		edges = append(edges, jobprogresshistory.EdgeJob)
	}
	if m.clearedcreator {
		edges = append(edges, jobprogresshistory.EdgeCreator)
	}
	if m.clearedcreator_api_user {
		edges = append(edges, jobprogresshistory.EdgeCreatorAPIUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *JobProgressHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case jobprogresshistory.EdgeJob:
		return m.clearedjob
	case jobprogresshistory.EdgeCreator:
		return m.clearedcreator
	case jobprogresshistory.EdgeCreatorAPIUser:
		return m.clearedcreator_api_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *JobProgressHistoryMutation) ClearEdge(name string) error {
	switch name {
	case jobprogresshistory.EdgeJob:
		m.ClearJob()
		return nil
	case jobprogresshistory.EdgeCreator:
		m.ClearCreator()
		return nil
	case jobprogresshistory.EdgeCreatorAPIUser:
		m.ClearCreatorAPIUser()
		return nil
	}
	return fmt.Errorf("unknown JobProgressHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *JobProgressHistoryMutation) ResetEdge(name string) error {
	switch name {
	case jobprogresshistory.EdgeJob:
		m.ResetJob()
		return nil
	case jobprogresshistory.EdgeCreator:
		m.ResetCreator()
		return nil
	case jobprogresshistory.EdgeCreatorAPIUser:
		m.ResetCreatorAPIUser()
		return nil
	}
	return fmt.Errorf("unknown JobProgressHistory edge %s", name)
}

// NotifySettingMutation represents an operation that mutates the NotifySetting nodes in the graph.
type NotifySettingMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	topic_id      *string
	receive_email *bool
	receive_sms   *bool
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*NotifySetting, error)
	predicates    []predicate.NotifySetting
}

var _ ent.Mutation = (*NotifySettingMutation)(nil)

// notifysettingOption allows management of the mutation configuration using functional options.
type notifysettingOption func(*NotifySettingMutation)

// newNotifySettingMutation creates new mutation for the NotifySetting entity.
func newNotifySettingMutation(c config, op Op, opts ...notifysettingOption) *NotifySettingMutation {
	m := &NotifySettingMutation{
		config:        c,
		op:            op,
		typ:           TypeNotifySetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotifySettingID sets the ID field of the mutation.
func withNotifySettingID(id string) notifysettingOption {
	return func(m *NotifySettingMutation) {
		var (
			err   error
			once  sync.Once
			value *NotifySetting
		)
		m.oldValue = func(ctx context.Context) (*NotifySetting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotifySetting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotifySetting sets the old NotifySetting of the mutation.
func withNotifySetting(node *NotifySetting) notifysettingOption {
	return func(m *NotifySettingMutation) {
		m.oldValue = func(context.Context) (*NotifySetting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotifySettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotifySettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of NotifySetting entities.
func (m *NotifySettingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotifySettingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotifySettingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotifySetting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NotifySettingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NotifySettingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the NotifySetting entity.
// If the NotifySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySettingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NotifySettingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetTopicID sets the "topic_id" field.
func (m *NotifySettingMutation) SetTopicID(s string) {
	m.topic_id = &s
}

// TopicID returns the value of the "topic_id" field in the mutation.
func (m *NotifySettingMutation) TopicID() (r string, exists bool) {
	v := m.topic_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTopicID returns the old "topic_id" field's value of the NotifySetting entity.
// If the NotifySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySettingMutation) OldTopicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTopicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTopicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTopicID: %w", err)
	}
	return oldValue.TopicID, nil
}

// ResetTopicID resets all changes to the "topic_id" field.
func (m *NotifySettingMutation) ResetTopicID() {
	m.topic_id = nil
}

// SetReceiveEmail sets the "receive_email" field.
func (m *NotifySettingMutation) SetReceiveEmail(b bool) {
	m.receive_email = &b
}

// ReceiveEmail returns the value of the "receive_email" field in the mutation.
func (m *NotifySettingMutation) ReceiveEmail() (r bool, exists bool) {
	v := m.receive_email
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiveEmail returns the old "receive_email" field's value of the NotifySetting entity.
// If the NotifySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySettingMutation) OldReceiveEmail(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiveEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiveEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiveEmail: %w", err)
	}
	return oldValue.ReceiveEmail, nil
}

// ClearReceiveEmail clears the value of the "receive_email" field.
func (m *NotifySettingMutation) ClearReceiveEmail() {
	m.receive_email = nil
	m.clearedFields[notifysetting.FieldReceiveEmail] = struct{}{}
}

// ReceiveEmailCleared returns if the "receive_email" field was cleared in this mutation.
func (m *NotifySettingMutation) ReceiveEmailCleared() bool {
	_, ok := m.clearedFields[notifysetting.FieldReceiveEmail]
	return ok
}

// ResetReceiveEmail resets all changes to the "receive_email" field.
func (m *NotifySettingMutation) ResetReceiveEmail() {
	m.receive_email = nil
	delete(m.clearedFields, notifysetting.FieldReceiveEmail)
}

// SetReceiveSms sets the "receive_sms" field.
func (m *NotifySettingMutation) SetReceiveSms(b bool) {
	m.receive_sms = &b
}

// ReceiveSms returns the value of the "receive_sms" field in the mutation.
func (m *NotifySettingMutation) ReceiveSms() (r bool, exists bool) {
	v := m.receive_sms
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiveSms returns the old "receive_sms" field's value of the NotifySetting entity.
// If the NotifySetting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotifySettingMutation) OldReceiveSms(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiveSms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiveSms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiveSms: %w", err)
	}
	return oldValue.ReceiveSms, nil
}

// ClearReceiveSms clears the value of the "receive_sms" field.
func (m *NotifySettingMutation) ClearReceiveSms() {
	m.receive_sms = nil
	m.clearedFields[notifysetting.FieldReceiveSms] = struct{}{}
}

// ReceiveSmsCleared returns if the "receive_sms" field was cleared in this mutation.
func (m *NotifySettingMutation) ReceiveSmsCleared() bool {
	_, ok := m.clearedFields[notifysetting.FieldReceiveSms]
	return ok
}

// ResetReceiveSms resets all changes to the "receive_sms" field.
func (m *NotifySettingMutation) ResetReceiveSms() {
	m.receive_sms = nil
	delete(m.clearedFields, notifysetting.FieldReceiveSms)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *NotifySettingMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *NotifySettingMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *NotifySettingMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *NotifySettingMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NotifySettingMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *NotifySettingMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the NotifySettingMutation builder.
func (m *NotifySettingMutation) Where(ps ...predicate.NotifySetting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotifySettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotifySettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotifySetting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotifySettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotifySettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotifySetting).
func (m *NotifySettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotifySettingMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, notifysetting.FieldCreatedAt)
	}
	if m.topic_id != nil {
		fields = append(fields, notifysetting.FieldTopicID)
	}
	if m.receive_email != nil {
		fields = append(fields, notifysetting.FieldReceiveEmail)
	}
	if m.receive_sms != nil {
		fields = append(fields, notifysetting.FieldReceiveSms)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotifySettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notifysetting.FieldCreatedAt:
		return m.CreatedAt()
	case notifysetting.FieldTopicID:
		return m.TopicID()
	case notifysetting.FieldReceiveEmail:
		return m.ReceiveEmail()
	case notifysetting.FieldReceiveSms:
		return m.ReceiveSms()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotifySettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notifysetting.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case notifysetting.FieldTopicID:
		return m.OldTopicID(ctx)
	case notifysetting.FieldReceiveEmail:
		return m.OldReceiveEmail(ctx)
	case notifysetting.FieldReceiveSms:
		return m.OldReceiveSms(ctx)
	}
	return nil, fmt.Errorf("unknown NotifySetting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifySettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notifysetting.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case notifysetting.FieldTopicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTopicID(v)
		return nil
	case notifysetting.FieldReceiveEmail:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiveEmail(v)
		return nil
	case notifysetting.FieldReceiveSms:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiveSms(v)
		return nil
	}
	return fmt.Errorf("unknown NotifySetting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotifySettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotifySettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotifySettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotifySetting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotifySettingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(notifysetting.FieldReceiveEmail) {
		fields = append(fields, notifysetting.FieldReceiveEmail)
	}
	if m.FieldCleared(notifysetting.FieldReceiveSms) {
		fields = append(fields, notifysetting.FieldReceiveSms)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotifySettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotifySettingMutation) ClearField(name string) error {
	switch name {
	case notifysetting.FieldReceiveEmail:
		m.ClearReceiveEmail()
		return nil
	case notifysetting.FieldReceiveSms:
		m.ClearReceiveSms()
		return nil
	}
	return fmt.Errorf("unknown NotifySetting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotifySettingMutation) ResetField(name string) error {
	switch name {
	case notifysetting.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case notifysetting.FieldTopicID:
		m.ResetTopicID()
		return nil
	case notifysetting.FieldReceiveEmail:
		m.ResetReceiveEmail()
		return nil
	case notifysetting.FieldReceiveSms:
		m.ResetReceiveSms()
		return nil
	}
	return fmt.Errorf("unknown NotifySetting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotifySettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, notifysetting.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotifySettingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notifysetting.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotifySettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotifySettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotifySettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, notifysetting.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotifySettingMutation) EdgeCleared(name string) bool {
	switch name {
	case notifysetting.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotifySettingMutation) ClearEdge(name string) error {
	switch name {
	case notifysetting.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown NotifySetting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotifySettingMutation) ResetEdge(name string) error {
	switch name {
	case notifysetting.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown NotifySetting edge %s", name)
}

// OptionListMutation represents an operation that mutates the OptionList nodes in the graph.
type OptionListMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	_type                  *enum.OptionList
	name                   *string
	display_name           *string
	active                 *bool
	_order                 *int
	add_order              *int
	clearedFields          map[string]struct{}
	finance_options        map[string]struct{}
	removedfinance_options map[string]struct{}
	clearedfinance_options bool
	epc_options            map[string]struct{}
	removedepc_options     map[string]struct{}
	clearedepc_options     bool
	epc                    map[string]struct{}
	removedepc             map[string]struct{}
	clearedepc             bool
	done                   bool
	oldValue               func(context.Context) (*OptionList, error)
	predicates             []predicate.OptionList
}

var _ ent.Mutation = (*OptionListMutation)(nil)

// optionlistOption allows management of the mutation configuration using functional options.
type optionlistOption func(*OptionListMutation)

// newOptionListMutation creates new mutation for the OptionList entity.
func newOptionListMutation(c config, op Op, opts ...optionlistOption) *OptionListMutation {
	m := &OptionListMutation{
		config:        c,
		op:            op,
		typ:           TypeOptionList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOptionListID sets the ID field of the mutation.
func withOptionListID(id string) optionlistOption {
	return func(m *OptionListMutation) {
		var (
			err   error
			once  sync.Once
			value *OptionList
		)
		m.oldValue = func(ctx context.Context) (*OptionList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OptionList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOptionList sets the old OptionList of the mutation.
func withOptionList(node *OptionList) optionlistOption {
	return func(m *OptionListMutation) {
		m.oldValue = func(context.Context) (*OptionList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OptionListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OptionListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OptionList entities.
func (m *OptionListMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OptionListMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OptionListMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OptionList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OptionListMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OptionListMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OptionList entity.
// If the OptionList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OptionListMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OptionListMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OptionListMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OptionListMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OptionList entity.
// If the OptionList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OptionListMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OptionListMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *OptionListMutation) SetType(el enum.OptionList) {
	m._type = &el
}

// GetType returns the value of the "type" field in the mutation.
func (m *OptionListMutation) GetType() (r enum.OptionList, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OptionList entity.
// If the OptionList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OptionListMutation) OldType(ctx context.Context) (v enum.OptionList, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OptionListMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *OptionListMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OptionListMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OptionList entity.
// If the OptionList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OptionListMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *OptionListMutation) ResetName() {
	m.name = nil
}

// SetDisplayName sets the "display_name" field.
func (m *OptionListMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *OptionListMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the OptionList entity.
// If the OptionList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OptionListMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *OptionListMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetActive sets the "active" field.
func (m *OptionListMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *OptionListMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the OptionList entity.
// If the OptionList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OptionListMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *OptionListMutation) ResetActive() {
	m.active = nil
}

// SetOrder sets the "order" field.
func (m *OptionListMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *OptionListMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the OptionList entity.
// If the OptionList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OptionListMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *OptionListMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *OptionListMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrder resets all changes to the "order" field.
func (m *OptionListMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
}

// AddFinanceOptionIDs adds the "finance_options" edge to the Partner entity by ids.
func (m *OptionListMutation) AddFinanceOptionIDs(ids ...string) {
	if m.finance_options == nil {
		m.finance_options = make(map[string]struct{})
	}
	for i := range ids {
		m.finance_options[ids[i]] = struct{}{}
	}
}

// ClearFinanceOptions clears the "finance_options" edge to the Partner entity.
func (m *OptionListMutation) ClearFinanceOptions() {
	m.clearedfinance_options = true
}

// FinanceOptionsCleared reports if the "finance_options" edge to the Partner entity was cleared.
func (m *OptionListMutation) FinanceOptionsCleared() bool {
	return m.clearedfinance_options
}

// RemoveFinanceOptionIDs removes the "finance_options" edge to the Partner entity by IDs.
func (m *OptionListMutation) RemoveFinanceOptionIDs(ids ...string) {
	if m.removedfinance_options == nil {
		m.removedfinance_options = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.finance_options, ids[i])
		m.removedfinance_options[ids[i]] = struct{}{}
	}
}

// RemovedFinanceOptions returns the removed IDs of the "finance_options" edge to the Partner entity.
func (m *OptionListMutation) RemovedFinanceOptionsIDs() (ids []string) {
	for id := range m.removedfinance_options {
		ids = append(ids, id)
	}
	return
}

// FinanceOptionsIDs returns the "finance_options" edge IDs in the mutation.
func (m *OptionListMutation) FinanceOptionsIDs() (ids []string) {
	for id := range m.finance_options {
		ids = append(ids, id)
	}
	return
}

// ResetFinanceOptions resets all changes to the "finance_options" edge.
func (m *OptionListMutation) ResetFinanceOptions() {
	m.finance_options = nil
	m.clearedfinance_options = false
	m.removedfinance_options = nil
}

// AddEpcOptionIDs adds the "epc_options" edge to the Partner entity by ids.
func (m *OptionListMutation) AddEpcOptionIDs(ids ...string) {
	if m.epc_options == nil {
		m.epc_options = make(map[string]struct{})
	}
	for i := range ids {
		m.epc_options[ids[i]] = struct{}{}
	}
}

// ClearEpcOptions clears the "epc_options" edge to the Partner entity.
func (m *OptionListMutation) ClearEpcOptions() {
	m.clearedepc_options = true
}

// EpcOptionsCleared reports if the "epc_options" edge to the Partner entity was cleared.
func (m *OptionListMutation) EpcOptionsCleared() bool {
	return m.clearedepc_options
}

// RemoveEpcOptionIDs removes the "epc_options" edge to the Partner entity by IDs.
func (m *OptionListMutation) RemoveEpcOptionIDs(ids ...string) {
	if m.removedepc_options == nil {
		m.removedepc_options = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.epc_options, ids[i])
		m.removedepc_options[ids[i]] = struct{}{}
	}
}

// RemovedEpcOptions returns the removed IDs of the "epc_options" edge to the Partner entity.
func (m *OptionListMutation) RemovedEpcOptionsIDs() (ids []string) {
	for id := range m.removedepc_options {
		ids = append(ids, id)
	}
	return
}

// EpcOptionsIDs returns the "epc_options" edge IDs in the mutation.
func (m *OptionListMutation) EpcOptionsIDs() (ids []string) {
	for id := range m.epc_options {
		ids = append(ids, id)
	}
	return
}

// ResetEpcOptions resets all changes to the "epc_options" edge.
func (m *OptionListMutation) ResetEpcOptions() {
	m.epc_options = nil
	m.clearedepc_options = false
	m.removedepc_options = nil
}

// AddEpcIDs adds the "epc" edge to the Job entity by ids.
func (m *OptionListMutation) AddEpcIDs(ids ...string) {
	if m.epc == nil {
		m.epc = make(map[string]struct{})
	}
	for i := range ids {
		m.epc[ids[i]] = struct{}{}
	}
}

// ClearEpc clears the "epc" edge to the Job entity.
func (m *OptionListMutation) ClearEpc() {
	m.clearedepc = true
}

// EpcCleared reports if the "epc" edge to the Job entity was cleared.
func (m *OptionListMutation) EpcCleared() bool {
	return m.clearedepc
}

// RemoveEpcIDs removes the "epc" edge to the Job entity by IDs.
func (m *OptionListMutation) RemoveEpcIDs(ids ...string) {
	if m.removedepc == nil {
		m.removedepc = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.epc, ids[i])
		m.removedepc[ids[i]] = struct{}{}
	}
}

// RemovedEpc returns the removed IDs of the "epc" edge to the Job entity.
func (m *OptionListMutation) RemovedEpcIDs() (ids []string) {
	for id := range m.removedepc {
		ids = append(ids, id)
	}
	return
}

// EpcIDs returns the "epc" edge IDs in the mutation.
func (m *OptionListMutation) EpcIDs() (ids []string) {
	for id := range m.epc {
		ids = append(ids, id)
	}
	return
}

// ResetEpc resets all changes to the "epc" edge.
func (m *OptionListMutation) ResetEpc() {
	m.epc = nil
	m.clearedepc = false
	m.removedepc = nil
}

// Where appends a list predicates to the OptionListMutation builder.
func (m *OptionListMutation) Where(ps ...predicate.OptionList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OptionListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OptionListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OptionList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OptionListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OptionListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OptionList).
func (m *OptionListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OptionListMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, optionlist.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, optionlist.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, optionlist.FieldType)
	}
	if m.name != nil {
		fields = append(fields, optionlist.FieldName)
	}
	if m.display_name != nil {
		fields = append(fields, optionlist.FieldDisplayName)
	}
	if m.active != nil {
		fields = append(fields, optionlist.FieldActive)
	}
	if m._order != nil {
		fields = append(fields, optionlist.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OptionListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case optionlist.FieldCreatedAt:
		return m.CreatedAt()
	case optionlist.FieldUpdatedAt:
		return m.UpdatedAt()
	case optionlist.FieldType:
		return m.GetType()
	case optionlist.FieldName:
		return m.Name()
	case optionlist.FieldDisplayName:
		return m.DisplayName()
	case optionlist.FieldActive:
		return m.Active()
	case optionlist.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OptionListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case optionlist.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case optionlist.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case optionlist.FieldType:
		return m.OldType(ctx)
	case optionlist.FieldName:
		return m.OldName(ctx)
	case optionlist.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case optionlist.FieldActive:
		return m.OldActive(ctx)
	case optionlist.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown OptionList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OptionListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case optionlist.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case optionlist.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case optionlist.FieldType:
		v, ok := value.(enum.OptionList)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case optionlist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case optionlist.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case optionlist.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case optionlist.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown OptionList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OptionListMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, optionlist.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OptionListMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case optionlist.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OptionListMutation) AddField(name string, value ent.Value) error {
	switch name {
	case optionlist.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown OptionList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OptionListMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OptionListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OptionListMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OptionList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OptionListMutation) ResetField(name string) error {
	switch name {
	case optionlist.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case optionlist.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case optionlist.FieldType:
		m.ResetType()
		return nil
	case optionlist.FieldName:
		m.ResetName()
		return nil
	case optionlist.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case optionlist.FieldActive:
		m.ResetActive()
		return nil
	case optionlist.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OptionList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OptionListMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.finance_options != nil {
		edges = append(edges, optionlist.EdgeFinanceOptions)
	}
	if m.epc_options != nil {
		edges = append(edges, optionlist.EdgeEpcOptions)
	}
	if m.epc != nil {
		edges = append(edges, optionlist.EdgeEpc)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OptionListMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case optionlist.EdgeFinanceOptions:
		ids := make([]ent.Value, 0, len(m.finance_options))
		for id := range m.finance_options {
			ids = append(ids, id)
		}
		return ids
	case optionlist.EdgeEpcOptions:
		ids := make([]ent.Value, 0, len(m.epc_options))
		for id := range m.epc_options {
			ids = append(ids, id)
		}
		return ids
	case optionlist.EdgeEpc:
		ids := make([]ent.Value, 0, len(m.epc))
		for id := range m.epc {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OptionListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfinance_options != nil {
		edges = append(edges, optionlist.EdgeFinanceOptions)
	}
	if m.removedepc_options != nil {
		edges = append(edges, optionlist.EdgeEpcOptions)
	}
	if m.removedepc != nil {
		edges = append(edges, optionlist.EdgeEpc)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OptionListMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case optionlist.EdgeFinanceOptions:
		ids := make([]ent.Value, 0, len(m.removedfinance_options))
		for id := range m.removedfinance_options {
			ids = append(ids, id)
		}
		return ids
	case optionlist.EdgeEpcOptions:
		ids := make([]ent.Value, 0, len(m.removedepc_options))
		for id := range m.removedepc_options {
			ids = append(ids, id)
		}
		return ids
	case optionlist.EdgeEpc:
		ids := make([]ent.Value, 0, len(m.removedepc))
		for id := range m.removedepc {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OptionListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedfinance_options {
		edges = append(edges, optionlist.EdgeFinanceOptions)
	}
	if m.clearedepc_options {
		edges = append(edges, optionlist.EdgeEpcOptions)
	}
	if m.clearedepc {
		edges = append(edges, optionlist.EdgeEpc)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OptionListMutation) EdgeCleared(name string) bool {
	switch name {
	case optionlist.EdgeFinanceOptions:
		return m.clearedfinance_options
	case optionlist.EdgeEpcOptions:
		return m.clearedepc_options
	case optionlist.EdgeEpc:
		return m.clearedepc
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OptionListMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown OptionList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OptionListMutation) ResetEdge(name string) error {
	switch name {
	case optionlist.EdgeFinanceOptions:
		m.ResetFinanceOptions()
		return nil
	case optionlist.EdgeEpcOptions:
		m.ResetEpcOptions()
		return nil
	case optionlist.EdgeEpc:
		m.ResetEpc()
		return nil
	}
	return fmt.Errorf("unknown OptionList edge %s", name)
}

// PartnerMutation represents an operation that mutates the Partner nodes in the graph.
type PartnerMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *string
	created_at                         *time.Time
	updated_at                         *time.Time
	external_id                        *string
	_type                              *enum.Partner
	name                               *string
	address                            *string
	website                            *string
	phone                              *string
	latitude                           *float64
	addlatitude                        *float64
	longitude                          *float64
	addlongitude                       *float64
	is_nation_wide                     *bool
	crew_count                         *uint16
	addcrew_count                      *int16
	years_in_business                  *int
	addyears_in_business               *int
	job_capacity                       *uint16
	addjob_capacity                    *int16
	asphalt_lead_t                     *string
	metal_lead_t                       *string
	tile_lead_t                        *string
	setup_steps_completed              *uint8
	addsetup_steps_completed           *int8
	sales_volume                       *int
	addsales_volume                    *int
	down_payment                       *int
	adddown_payment                    *int
	pif                                *int
	addpif                             *int
	install_in_house                   *bool
	status                             *enum.PartnerStatus
	epc_status                         *enum.EPCStatus
	mobile_app_settings                *model.MobileAppSettings
	clearedFields                      map[string]struct{}
	requested_estimates                map[string]struct{}
	removedrequested_estimates         map[string]struct{}
	clearedrequested_estimates         bool
	estimate_home_owners               map[string]struct{}
	removedestimate_home_owners        map[string]struct{}
	clearedestimate_home_owners        bool
	roofing_jobs                       map[string]struct{}
	removedroofing_jobs                map[string]struct{}
	clearedroofing_jobs                bool
	integration_jobs                   map[string]struct{}
	removedintegration_jobs            map[string]struct{}
	clearedintegration_jobs            bool
	epc_jobs                           map[string]struct{}
	removedepc_jobs                    map[string]struct{}
	clearedepc_jobs                    bool
	job_requests                       map[string]struct{}
	removedjob_requests                map[string]struct{}
	clearedjob_requests                bool
	activities                         map[string]struct{}
	removedactivities                  map[string]struct{}
	clearedactivities                  bool
	job_assignment_history             map[string]struct{}
	removedjob_assignment_history      map[string]struct{}
	clearedjob_assignment_history      bool
	requested_installation_jobs        map[string]struct{}
	removedrequested_installation_jobs map[string]struct{}
	clearedrequested_installation_jobs bool
	assigned_installation_jobs         map[string]struct{}
	removedassigned_installation_jobs  map[string]struct{}
	clearedassigned_installation_jobs  bool
	contacts                           map[string]struct{}
	removedcontacts                    map[string]struct{}
	clearedcontacts                    bool
	creator                            *string
	clearedcreator                     bool
	creator_api                        *string
	clearedcreator_api                 bool
	services                           map[string]struct{}
	removedservices                    map[string]struct{}
	clearedservices                    bool
	service_states                     map[string]struct{}
	removedservice_states              map[string]struct{}
	clearedservice_states              bool
	service_cities                     map[string]struct{}
	removedservice_cities              map[string]struct{}
	clearedservice_cities              bool
	training_videos                    map[string]struct{}
	removedtraining_videos             map[string]struct{}
	clearedtraining_videos             bool
	contact_us_requests                map[string]struct{}
	removedcontact_us_requests         map[string]struct{}
	clearedcontact_us_requests         bool
	surveys                            map[string]struct{}
	removedsurveys                     map[string]struct{}
	clearedsurveys                     bool
	sessions                           map[string]struct{}
	removedsessions                    map[string]struct{}
	clearedsessions                    bool
	job_notes                          map[string]struct{}
	removedjob_notes                   map[string]struct{}
	clearedjob_notes                   bool
	channels                           map[string]struct{}
	removedchannels                    map[string]struct{}
	clearedchannels                    bool
	finance_options                    map[string]struct{}
	removedfinance_options             map[string]struct{}
	clearedfinance_options             bool
	epc_options                        map[string]struct{}
	removedepc_options                 map[string]struct{}
	clearedepc_options                 bool
	partner_contacts                   map[string]struct{}
	removedpartner_contacts            map[string]struct{}
	clearedpartner_contacts            bool
	done                               bool
	oldValue                           func(context.Context) (*Partner, error)
	predicates                         []predicate.Partner
}

var _ ent.Mutation = (*PartnerMutation)(nil)

// partnerOption allows management of the mutation configuration using functional options.
type partnerOption func(*PartnerMutation)

// newPartnerMutation creates new mutation for the Partner entity.
func newPartnerMutation(c config, op Op, opts ...partnerOption) *PartnerMutation {
	m := &PartnerMutation{
		config:        c,
		op:            op,
		typ:           TypePartner,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnerID sets the ID field of the mutation.
func withPartnerID(id string) partnerOption {
	return func(m *PartnerMutation) {
		var (
			err   error
			once  sync.Once
			value *Partner
		)
		m.oldValue = func(ctx context.Context) (*Partner, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Partner.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartner sets the old Partner of the mutation.
func withPartner(node *Partner) partnerOption {
	return func(m *PartnerMutation) {
		m.oldValue = func(context.Context) (*Partner, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Partner entities.
func (m *PartnerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Partner.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnerMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartnerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartnerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartnerMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExternalID sets the "external_id" field.
func (m *PartnerMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *PartnerMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *PartnerMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[partner.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *PartnerMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[partner.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *PartnerMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, partner.FieldExternalID)
}

// SetCreatorID sets the "creator_id" field.
func (m *PartnerMutation) SetCreatorID(s string) {
	m.creator = &s
}

// CreatorID returns the value of the "creator_id" field in the mutation.
func (m *PartnerMutation) CreatorID() (r string, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatorID returns the old "creator_id" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldCreatorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatorID: %w", err)
	}
	return oldValue.CreatorID, nil
}

// ClearCreatorID clears the value of the "creator_id" field.
func (m *PartnerMutation) ClearCreatorID() {
	m.creator = nil
	m.clearedFields[partner.FieldCreatorID] = struct{}{}
}

// CreatorIDCleared returns if the "creator_id" field was cleared in this mutation.
func (m *PartnerMutation) CreatorIDCleared() bool {
	_, ok := m.clearedFields[partner.FieldCreatorID]
	return ok
}

// ResetCreatorID resets all changes to the "creator_id" field.
func (m *PartnerMutation) ResetCreatorID() {
	m.creator = nil
	delete(m.clearedFields, partner.FieldCreatorID)
}

// SetType sets the "type" field.
func (m *PartnerMutation) SetType(e enum.Partner) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *PartnerMutation) GetType() (r enum.Partner, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldType(ctx context.Context) (v enum.Partner, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PartnerMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *PartnerMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PartnerMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PartnerMutation) ResetName() {
	m.name = nil
}

// SetAddress sets the "address" field.
func (m *PartnerMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *PartnerMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *PartnerMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[partner.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *PartnerMutation) AddressCleared() bool {
	_, ok := m.clearedFields[partner.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *PartnerMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, partner.FieldAddress)
}

// SetWebsite sets the "website" field.
func (m *PartnerMutation) SetWebsite(s string) {
	m.website = &s
}

// Website returns the value of the "website" field in the mutation.
func (m *PartnerMutation) Website() (r string, exists bool) {
	v := m.website
	if v == nil {
		return
	}
	return *v, true
}

// OldWebsite returns the old "website" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldWebsite(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebsite is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebsite requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebsite: %w", err)
	}
	return oldValue.Website, nil
}

// ClearWebsite clears the value of the "website" field.
func (m *PartnerMutation) ClearWebsite() {
	m.website = nil
	m.clearedFields[partner.FieldWebsite] = struct{}{}
}

// WebsiteCleared returns if the "website" field was cleared in this mutation.
func (m *PartnerMutation) WebsiteCleared() bool {
	_, ok := m.clearedFields[partner.FieldWebsite]
	return ok
}

// ResetWebsite resets all changes to the "website" field.
func (m *PartnerMutation) ResetWebsite() {
	m.website = nil
	delete(m.clearedFields, partner.FieldWebsite)
}

// SetPhone sets the "phone" field.
func (m *PartnerMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *PartnerMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *PartnerMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[partner.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *PartnerMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[partner.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *PartnerMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, partner.FieldPhone)
}

// SetLatitude sets the "latitude" field.
func (m *PartnerMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *PartnerMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *PartnerMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *PartnerMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLatitude clears the value of the "latitude" field.
func (m *PartnerMutation) ClearLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	m.clearedFields[partner.FieldLatitude] = struct{}{}
}

// LatitudeCleared returns if the "latitude" field was cleared in this mutation.
func (m *PartnerMutation) LatitudeCleared() bool {
	_, ok := m.clearedFields[partner.FieldLatitude]
	return ok
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *PartnerMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
	delete(m.clearedFields, partner.FieldLatitude)
}

// SetLongitude sets the "longitude" field.
func (m *PartnerMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *PartnerMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *PartnerMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *PartnerMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ClearLongitude clears the value of the "longitude" field.
func (m *PartnerMutation) ClearLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	m.clearedFields[partner.FieldLongitude] = struct{}{}
}

// LongitudeCleared returns if the "longitude" field was cleared in this mutation.
func (m *PartnerMutation) LongitudeCleared() bool {
	_, ok := m.clearedFields[partner.FieldLongitude]
	return ok
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *PartnerMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
	delete(m.clearedFields, partner.FieldLongitude)
}

// SetIsNationWide sets the "is_nation_wide" field.
func (m *PartnerMutation) SetIsNationWide(b bool) {
	m.is_nation_wide = &b
}

// IsNationWide returns the value of the "is_nation_wide" field in the mutation.
func (m *PartnerMutation) IsNationWide() (r bool, exists bool) {
	v := m.is_nation_wide
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNationWide returns the old "is_nation_wide" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldIsNationWide(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNationWide is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNationWide requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNationWide: %w", err)
	}
	return oldValue.IsNationWide, nil
}

// ResetIsNationWide resets all changes to the "is_nation_wide" field.
func (m *PartnerMutation) ResetIsNationWide() {
	m.is_nation_wide = nil
}

// SetCrewCount sets the "crew_count" field.
func (m *PartnerMutation) SetCrewCount(u uint16) {
	m.crew_count = &u
	m.addcrew_count = nil
}

// CrewCount returns the value of the "crew_count" field in the mutation.
func (m *PartnerMutation) CrewCount() (r uint16, exists bool) {
	v := m.crew_count
	if v == nil {
		return
	}
	return *v, true
}

// OldCrewCount returns the old "crew_count" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldCrewCount(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrewCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrewCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrewCount: %w", err)
	}
	return oldValue.CrewCount, nil
}

// AddCrewCount adds u to the "crew_count" field.
func (m *PartnerMutation) AddCrewCount(u int16) {
	if m.addcrew_count != nil {
		*m.addcrew_count += u
	} else {
		m.addcrew_count = &u
	}
}

// AddedCrewCount returns the value that was added to the "crew_count" field in this mutation.
func (m *PartnerMutation) AddedCrewCount() (r int16, exists bool) {
	v := m.addcrew_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetCrewCount resets all changes to the "crew_count" field.
func (m *PartnerMutation) ResetCrewCount() {
	m.crew_count = nil
	m.addcrew_count = nil
}

// SetYearsInBusiness sets the "years_in_business" field.
func (m *PartnerMutation) SetYearsInBusiness(i int) {
	m.years_in_business = &i
	m.addyears_in_business = nil
}

// YearsInBusiness returns the value of the "years_in_business" field in the mutation.
func (m *PartnerMutation) YearsInBusiness() (r int, exists bool) {
	v := m.years_in_business
	if v == nil {
		return
	}
	return *v, true
}

// OldYearsInBusiness returns the old "years_in_business" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldYearsInBusiness(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYearsInBusiness is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYearsInBusiness requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYearsInBusiness: %w", err)
	}
	return oldValue.YearsInBusiness, nil
}

// AddYearsInBusiness adds i to the "years_in_business" field.
func (m *PartnerMutation) AddYearsInBusiness(i int) {
	if m.addyears_in_business != nil {
		*m.addyears_in_business += i
	} else {
		m.addyears_in_business = &i
	}
}

// AddedYearsInBusiness returns the value that was added to the "years_in_business" field in this mutation.
func (m *PartnerMutation) AddedYearsInBusiness() (r int, exists bool) {
	v := m.addyears_in_business
	if v == nil {
		return
	}
	return *v, true
}

// ClearYearsInBusiness clears the value of the "years_in_business" field.
func (m *PartnerMutation) ClearYearsInBusiness() {
	m.years_in_business = nil
	m.addyears_in_business = nil
	m.clearedFields[partner.FieldYearsInBusiness] = struct{}{}
}

// YearsInBusinessCleared returns if the "years_in_business" field was cleared in this mutation.
func (m *PartnerMutation) YearsInBusinessCleared() bool {
	_, ok := m.clearedFields[partner.FieldYearsInBusiness]
	return ok
}

// ResetYearsInBusiness resets all changes to the "years_in_business" field.
func (m *PartnerMutation) ResetYearsInBusiness() {
	m.years_in_business = nil
	m.addyears_in_business = nil
	delete(m.clearedFields, partner.FieldYearsInBusiness)
}

// SetJobCapacity sets the "job_capacity" field.
func (m *PartnerMutation) SetJobCapacity(u uint16) {
	m.job_capacity = &u
	m.addjob_capacity = nil
}

// JobCapacity returns the value of the "job_capacity" field in the mutation.
func (m *PartnerMutation) JobCapacity() (r uint16, exists bool) {
	v := m.job_capacity
	if v == nil {
		return
	}
	return *v, true
}

// OldJobCapacity returns the old "job_capacity" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldJobCapacity(ctx context.Context) (v uint16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJobCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJobCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJobCapacity: %w", err)
	}
	return oldValue.JobCapacity, nil
}

// AddJobCapacity adds u to the "job_capacity" field.
func (m *PartnerMutation) AddJobCapacity(u int16) {
	if m.addjob_capacity != nil {
		*m.addjob_capacity += u
	} else {
		m.addjob_capacity = &u
	}
}

// AddedJobCapacity returns the value that was added to the "job_capacity" field in this mutation.
func (m *PartnerMutation) AddedJobCapacity() (r int16, exists bool) {
	v := m.addjob_capacity
	if v == nil {
		return
	}
	return *v, true
}

// ResetJobCapacity resets all changes to the "job_capacity" field.
func (m *PartnerMutation) ResetJobCapacity() {
	m.job_capacity = nil
	m.addjob_capacity = nil
}

// SetAsphaltLeadT sets the "asphalt_lead_t" field.
func (m *PartnerMutation) SetAsphaltLeadT(s string) {
	m.asphalt_lead_t = &s
}

// AsphaltLeadT returns the value of the "asphalt_lead_t" field in the mutation.
func (m *PartnerMutation) AsphaltLeadT() (r string, exists bool) {
	v := m.asphalt_lead_t
	if v == nil {
		return
	}
	return *v, true
}

// OldAsphaltLeadT returns the old "asphalt_lead_t" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldAsphaltLeadT(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAsphaltLeadT is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAsphaltLeadT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAsphaltLeadT: %w", err)
	}
	return oldValue.AsphaltLeadT, nil
}

// ClearAsphaltLeadT clears the value of the "asphalt_lead_t" field.
func (m *PartnerMutation) ClearAsphaltLeadT() {
	m.asphalt_lead_t = nil
	m.clearedFields[partner.FieldAsphaltLeadT] = struct{}{}
}

// AsphaltLeadTCleared returns if the "asphalt_lead_t" field was cleared in this mutation.
func (m *PartnerMutation) AsphaltLeadTCleared() bool {
	_, ok := m.clearedFields[partner.FieldAsphaltLeadT]
	return ok
}

// ResetAsphaltLeadT resets all changes to the "asphalt_lead_t" field.
func (m *PartnerMutation) ResetAsphaltLeadT() {
	m.asphalt_lead_t = nil
	delete(m.clearedFields, partner.FieldAsphaltLeadT)
}

// SetMetalLeadT sets the "metal_lead_t" field.
func (m *PartnerMutation) SetMetalLeadT(s string) {
	m.metal_lead_t = &s
}

// MetalLeadT returns the value of the "metal_lead_t" field in the mutation.
func (m *PartnerMutation) MetalLeadT() (r string, exists bool) {
	v := m.metal_lead_t
	if v == nil {
		return
	}
	return *v, true
}

// OldMetalLeadT returns the old "metal_lead_t" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldMetalLeadT(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetalLeadT is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetalLeadT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetalLeadT: %w", err)
	}
	return oldValue.MetalLeadT, nil
}

// ClearMetalLeadT clears the value of the "metal_lead_t" field.
func (m *PartnerMutation) ClearMetalLeadT() {
	m.metal_lead_t = nil
	m.clearedFields[partner.FieldMetalLeadT] = struct{}{}
}

// MetalLeadTCleared returns if the "metal_lead_t" field was cleared in this mutation.
func (m *PartnerMutation) MetalLeadTCleared() bool {
	_, ok := m.clearedFields[partner.FieldMetalLeadT]
	return ok
}

// ResetMetalLeadT resets all changes to the "metal_lead_t" field.
func (m *PartnerMutation) ResetMetalLeadT() {
	m.metal_lead_t = nil
	delete(m.clearedFields, partner.FieldMetalLeadT)
}

// SetTileLeadT sets the "tile_lead_t" field.
func (m *PartnerMutation) SetTileLeadT(s string) {
	m.tile_lead_t = &s
}

// TileLeadT returns the value of the "tile_lead_t" field in the mutation.
func (m *PartnerMutation) TileLeadT() (r string, exists bool) {
	v := m.tile_lead_t
	if v == nil {
		return
	}
	return *v, true
}

// OldTileLeadT returns the old "tile_lead_t" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldTileLeadT(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTileLeadT is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTileLeadT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTileLeadT: %w", err)
	}
	return oldValue.TileLeadT, nil
}

// ClearTileLeadT clears the value of the "tile_lead_t" field.
func (m *PartnerMutation) ClearTileLeadT() {
	m.tile_lead_t = nil
	m.clearedFields[partner.FieldTileLeadT] = struct{}{}
}

// TileLeadTCleared returns if the "tile_lead_t" field was cleared in this mutation.
func (m *PartnerMutation) TileLeadTCleared() bool {
	_, ok := m.clearedFields[partner.FieldTileLeadT]
	return ok
}

// ResetTileLeadT resets all changes to the "tile_lead_t" field.
func (m *PartnerMutation) ResetTileLeadT() {
	m.tile_lead_t = nil
	delete(m.clearedFields, partner.FieldTileLeadT)
}

// SetSetupStepsCompleted sets the "setup_steps_completed" field.
func (m *PartnerMutation) SetSetupStepsCompleted(u uint8) {
	m.setup_steps_completed = &u
	m.addsetup_steps_completed = nil
}

// SetupStepsCompleted returns the value of the "setup_steps_completed" field in the mutation.
func (m *PartnerMutation) SetupStepsCompleted() (r uint8, exists bool) {
	v := m.setup_steps_completed
	if v == nil {
		return
	}
	return *v, true
}

// OldSetupStepsCompleted returns the old "setup_steps_completed" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldSetupStepsCompleted(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSetupStepsCompleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSetupStepsCompleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSetupStepsCompleted: %w", err)
	}
	return oldValue.SetupStepsCompleted, nil
}

// AddSetupStepsCompleted adds u to the "setup_steps_completed" field.
func (m *PartnerMutation) AddSetupStepsCompleted(u int8) {
	if m.addsetup_steps_completed != nil {
		*m.addsetup_steps_completed += u
	} else {
		m.addsetup_steps_completed = &u
	}
}

// AddedSetupStepsCompleted returns the value that was added to the "setup_steps_completed" field in this mutation.
func (m *PartnerMutation) AddedSetupStepsCompleted() (r int8, exists bool) {
	v := m.addsetup_steps_completed
	if v == nil {
		return
	}
	return *v, true
}

// ResetSetupStepsCompleted resets all changes to the "setup_steps_completed" field.
func (m *PartnerMutation) ResetSetupStepsCompleted() {
	m.setup_steps_completed = nil
	m.addsetup_steps_completed = nil
}

// SetSalesVolume sets the "sales_volume" field.
func (m *PartnerMutation) SetSalesVolume(i int) {
	m.sales_volume = &i
	m.addsales_volume = nil
}

// SalesVolume returns the value of the "sales_volume" field in the mutation.
func (m *PartnerMutation) SalesVolume() (r int, exists bool) {
	v := m.sales_volume
	if v == nil {
		return
	}
	return *v, true
}

// OldSalesVolume returns the old "sales_volume" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldSalesVolume(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalesVolume is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalesVolume requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalesVolume: %w", err)
	}
	return oldValue.SalesVolume, nil
}

// AddSalesVolume adds i to the "sales_volume" field.
func (m *PartnerMutation) AddSalesVolume(i int) {
	if m.addsales_volume != nil {
		*m.addsales_volume += i
	} else {
		m.addsales_volume = &i
	}
}

// AddedSalesVolume returns the value that was added to the "sales_volume" field in this mutation.
func (m *PartnerMutation) AddedSalesVolume() (r int, exists bool) {
	v := m.addsales_volume
	if v == nil {
		return
	}
	return *v, true
}

// ClearSalesVolume clears the value of the "sales_volume" field.
func (m *PartnerMutation) ClearSalesVolume() {
	m.sales_volume = nil
	m.addsales_volume = nil
	m.clearedFields[partner.FieldSalesVolume] = struct{}{}
}

// SalesVolumeCleared returns if the "sales_volume" field was cleared in this mutation.
func (m *PartnerMutation) SalesVolumeCleared() bool {
	_, ok := m.clearedFields[partner.FieldSalesVolume]
	return ok
}

// ResetSalesVolume resets all changes to the "sales_volume" field.
func (m *PartnerMutation) ResetSalesVolume() {
	m.sales_volume = nil
	m.addsales_volume = nil
	delete(m.clearedFields, partner.FieldSalesVolume)
}

// SetDownPayment sets the "down_payment" field.
func (m *PartnerMutation) SetDownPayment(i int) {
	m.down_payment = &i
	m.adddown_payment = nil
}

// DownPayment returns the value of the "down_payment" field in the mutation.
func (m *PartnerMutation) DownPayment() (r int, exists bool) {
	v := m.down_payment
	if v == nil {
		return
	}
	return *v, true
}

// OldDownPayment returns the old "down_payment" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldDownPayment(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownPayment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownPayment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownPayment: %w", err)
	}
	return oldValue.DownPayment, nil
}

// AddDownPayment adds i to the "down_payment" field.
func (m *PartnerMutation) AddDownPayment(i int) {
	if m.adddown_payment != nil {
		*m.adddown_payment += i
	} else {
		m.adddown_payment = &i
	}
}

// AddedDownPayment returns the value that was added to the "down_payment" field in this mutation.
func (m *PartnerMutation) AddedDownPayment() (r int, exists bool) {
	v := m.adddown_payment
	if v == nil {
		return
	}
	return *v, true
}

// ClearDownPayment clears the value of the "down_payment" field.
func (m *PartnerMutation) ClearDownPayment() {
	m.down_payment = nil
	m.adddown_payment = nil
	m.clearedFields[partner.FieldDownPayment] = struct{}{}
}

// DownPaymentCleared returns if the "down_payment" field was cleared in this mutation.
func (m *PartnerMutation) DownPaymentCleared() bool {
	_, ok := m.clearedFields[partner.FieldDownPayment]
	return ok
}

// ResetDownPayment resets all changes to the "down_payment" field.
func (m *PartnerMutation) ResetDownPayment() {
	m.down_payment = nil
	m.adddown_payment = nil
	delete(m.clearedFields, partner.FieldDownPayment)
}

// SetPif sets the "pif" field.
func (m *PartnerMutation) SetPif(i int) {
	m.pif = &i
	m.addpif = nil
}

// Pif returns the value of the "pif" field in the mutation.
func (m *PartnerMutation) Pif() (r int, exists bool) {
	v := m.pif
	if v == nil {
		return
	}
	return *v, true
}

// OldPif returns the old "pif" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldPif(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPif is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPif requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPif: %w", err)
	}
	return oldValue.Pif, nil
}

// AddPif adds i to the "pif" field.
func (m *PartnerMutation) AddPif(i int) {
	if m.addpif != nil {
		*m.addpif += i
	} else {
		m.addpif = &i
	}
}

// AddedPif returns the value that was added to the "pif" field in this mutation.
func (m *PartnerMutation) AddedPif() (r int, exists bool) {
	v := m.addpif
	if v == nil {
		return
	}
	return *v, true
}

// ClearPif clears the value of the "pif" field.
func (m *PartnerMutation) ClearPif() {
	m.pif = nil
	m.addpif = nil
	m.clearedFields[partner.FieldPif] = struct{}{}
}

// PifCleared returns if the "pif" field was cleared in this mutation.
func (m *PartnerMutation) PifCleared() bool {
	_, ok := m.clearedFields[partner.FieldPif]
	return ok
}

// ResetPif resets all changes to the "pif" field.
func (m *PartnerMutation) ResetPif() {
	m.pif = nil
	m.addpif = nil
	delete(m.clearedFields, partner.FieldPif)
}

// SetInstallInHouse sets the "install_in_house" field.
func (m *PartnerMutation) SetInstallInHouse(b bool) {
	m.install_in_house = &b
}

// InstallInHouse returns the value of the "install_in_house" field in the mutation.
func (m *PartnerMutation) InstallInHouse() (r bool, exists bool) {
	v := m.install_in_house
	if v == nil {
		return
	}
	return *v, true
}

// OldInstallInHouse returns the old "install_in_house" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldInstallInHouse(ctx context.Context) (v *bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstallInHouse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstallInHouse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstallInHouse: %w", err)
	}
	return oldValue.InstallInHouse, nil
}

// ClearInstallInHouse clears the value of the "install_in_house" field.
func (m *PartnerMutation) ClearInstallInHouse() {
	m.install_in_house = nil
	m.clearedFields[partner.FieldInstallInHouse] = struct{}{}
}

// InstallInHouseCleared returns if the "install_in_house" field was cleared in this mutation.
func (m *PartnerMutation) InstallInHouseCleared() bool {
	_, ok := m.clearedFields[partner.FieldInstallInHouse]
	return ok
}

// ResetInstallInHouse resets all changes to the "install_in_house" field.
func (m *PartnerMutation) ResetInstallInHouse() {
	m.install_in_house = nil
	delete(m.clearedFields, partner.FieldInstallInHouse)
}

// SetStatus sets the "status" field.
func (m *PartnerMutation) SetStatus(es enum.PartnerStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *PartnerMutation) Status() (r enum.PartnerStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldStatus(ctx context.Context) (v enum.PartnerStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PartnerMutation) ResetStatus() {
	m.status = nil
}

// SetEpcStatus sets the "epc_status" field.
func (m *PartnerMutation) SetEpcStatus(es enum.EPCStatus) {
	m.epc_status = &es
}

// EpcStatus returns the value of the "epc_status" field in the mutation.
func (m *PartnerMutation) EpcStatus() (r enum.EPCStatus, exists bool) {
	v := m.epc_status
	if v == nil {
		return
	}
	return *v, true
}

// OldEpcStatus returns the old "epc_status" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldEpcStatus(ctx context.Context) (v enum.EPCStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpcStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpcStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpcStatus: %w", err)
	}
	return oldValue.EpcStatus, nil
}

// ClearEpcStatus clears the value of the "epc_status" field.
func (m *PartnerMutation) ClearEpcStatus() {
	m.epc_status = nil
	m.clearedFields[partner.FieldEpcStatus] = struct{}{}
}

// EpcStatusCleared returns if the "epc_status" field was cleared in this mutation.
func (m *PartnerMutation) EpcStatusCleared() bool {
	_, ok := m.clearedFields[partner.FieldEpcStatus]
	return ok
}

// ResetEpcStatus resets all changes to the "epc_status" field.
func (m *PartnerMutation) ResetEpcStatus() {
	m.epc_status = nil
	delete(m.clearedFields, partner.FieldEpcStatus)
}

// SetMobileAppSettings sets the "mobile_app_settings" field.
func (m *PartnerMutation) SetMobileAppSettings(mas model.MobileAppSettings) {
	m.mobile_app_settings = &mas
}

// MobileAppSettings returns the value of the "mobile_app_settings" field in the mutation.
func (m *PartnerMutation) MobileAppSettings() (r model.MobileAppSettings, exists bool) {
	v := m.mobile_app_settings
	if v == nil {
		return
	}
	return *v, true
}

// OldMobileAppSettings returns the old "mobile_app_settings" field's value of the Partner entity.
// If the Partner object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerMutation) OldMobileAppSettings(ctx context.Context) (v model.MobileAppSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobileAppSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobileAppSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobileAppSettings: %w", err)
	}
	return oldValue.MobileAppSettings, nil
}

// ClearMobileAppSettings clears the value of the "mobile_app_settings" field.
func (m *PartnerMutation) ClearMobileAppSettings() {
	m.mobile_app_settings = nil
	m.clearedFields[partner.FieldMobileAppSettings] = struct{}{}
}

// MobileAppSettingsCleared returns if the "mobile_app_settings" field was cleared in this mutation.
func (m *PartnerMutation) MobileAppSettingsCleared() bool {
	_, ok := m.clearedFields[partner.FieldMobileAppSettings]
	return ok
}

// ResetMobileAppSettings resets all changes to the "mobile_app_settings" field.
func (m *PartnerMutation) ResetMobileAppSettings() {
	m.mobile_app_settings = nil
	delete(m.clearedFields, partner.FieldMobileAppSettings)
}

// AddRequestedEstimateIDs adds the "requested_estimates" edge to the Estimate entity by ids.
func (m *PartnerMutation) AddRequestedEstimateIDs(ids ...string) {
	if m.requested_estimates == nil {
		m.requested_estimates = make(map[string]struct{})
	}
	for i := range ids {
		m.requested_estimates[ids[i]] = struct{}{}
	}
}

// ClearRequestedEstimates clears the "requested_estimates" edge to the Estimate entity.
func (m *PartnerMutation) ClearRequestedEstimates() {
	m.clearedrequested_estimates = true
}

// RequestedEstimatesCleared reports if the "requested_estimates" edge to the Estimate entity was cleared.
func (m *PartnerMutation) RequestedEstimatesCleared() bool {
	return m.clearedrequested_estimates
}

// RemoveRequestedEstimateIDs removes the "requested_estimates" edge to the Estimate entity by IDs.
func (m *PartnerMutation) RemoveRequestedEstimateIDs(ids ...string) {
	if m.removedrequested_estimates == nil {
		m.removedrequested_estimates = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.requested_estimates, ids[i])
		m.removedrequested_estimates[ids[i]] = struct{}{}
	}
}

// RemovedRequestedEstimates returns the removed IDs of the "requested_estimates" edge to the Estimate entity.
func (m *PartnerMutation) RemovedRequestedEstimatesIDs() (ids []string) {
	for id := range m.removedrequested_estimates {
		ids = append(ids, id)
	}
	return
}

// RequestedEstimatesIDs returns the "requested_estimates" edge IDs in the mutation.
func (m *PartnerMutation) RequestedEstimatesIDs() (ids []string) {
	for id := range m.requested_estimates {
		ids = append(ids, id)
	}
	return
}

// ResetRequestedEstimates resets all changes to the "requested_estimates" edge.
func (m *PartnerMutation) ResetRequestedEstimates() {
	m.requested_estimates = nil
	m.clearedrequested_estimates = false
	m.removedrequested_estimates = nil
}

// AddEstimateHomeOwnerIDs adds the "estimate_home_owners" edge to the HomeOwner entity by ids.
func (m *PartnerMutation) AddEstimateHomeOwnerIDs(ids ...string) {
	if m.estimate_home_owners == nil {
		m.estimate_home_owners = make(map[string]struct{})
	}
	for i := range ids {
		m.estimate_home_owners[ids[i]] = struct{}{}
	}
}

// ClearEstimateHomeOwners clears the "estimate_home_owners" edge to the HomeOwner entity.
func (m *PartnerMutation) ClearEstimateHomeOwners() {
	m.clearedestimate_home_owners = true
}

// EstimateHomeOwnersCleared reports if the "estimate_home_owners" edge to the HomeOwner entity was cleared.
func (m *PartnerMutation) EstimateHomeOwnersCleared() bool {
	return m.clearedestimate_home_owners
}

// RemoveEstimateHomeOwnerIDs removes the "estimate_home_owners" edge to the HomeOwner entity by IDs.
func (m *PartnerMutation) RemoveEstimateHomeOwnerIDs(ids ...string) {
	if m.removedestimate_home_owners == nil {
		m.removedestimate_home_owners = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.estimate_home_owners, ids[i])
		m.removedestimate_home_owners[ids[i]] = struct{}{}
	}
}

// RemovedEstimateHomeOwners returns the removed IDs of the "estimate_home_owners" edge to the HomeOwner entity.
func (m *PartnerMutation) RemovedEstimateHomeOwnersIDs() (ids []string) {
	for id := range m.removedestimate_home_owners {
		ids = append(ids, id)
	}
	return
}

// EstimateHomeOwnersIDs returns the "estimate_home_owners" edge IDs in the mutation.
func (m *PartnerMutation) EstimateHomeOwnersIDs() (ids []string) {
	for id := range m.estimate_home_owners {
		ids = append(ids, id)
	}
	return
}

// ResetEstimateHomeOwners resets all changes to the "estimate_home_owners" edge.
func (m *PartnerMutation) ResetEstimateHomeOwners() {
	m.estimate_home_owners = nil
	m.clearedestimate_home_owners = false
	m.removedestimate_home_owners = nil
}

// AddRoofingJobIDs adds the "roofing_jobs" edge to the Job entity by ids.
func (m *PartnerMutation) AddRoofingJobIDs(ids ...string) {
	if m.roofing_jobs == nil {
		m.roofing_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.roofing_jobs[ids[i]] = struct{}{}
	}
}

// ClearRoofingJobs clears the "roofing_jobs" edge to the Job entity.
func (m *PartnerMutation) ClearRoofingJobs() {
	m.clearedroofing_jobs = true
}

// RoofingJobsCleared reports if the "roofing_jobs" edge to the Job entity was cleared.
func (m *PartnerMutation) RoofingJobsCleared() bool {
	return m.clearedroofing_jobs
}

// RemoveRoofingJobIDs removes the "roofing_jobs" edge to the Job entity by IDs.
func (m *PartnerMutation) RemoveRoofingJobIDs(ids ...string) {
	if m.removedroofing_jobs == nil {
		m.removedroofing_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.roofing_jobs, ids[i])
		m.removedroofing_jobs[ids[i]] = struct{}{}
	}
}

// RemovedRoofingJobs returns the removed IDs of the "roofing_jobs" edge to the Job entity.
func (m *PartnerMutation) RemovedRoofingJobsIDs() (ids []string) {
	for id := range m.removedroofing_jobs {
		ids = append(ids, id)
	}
	return
}

// RoofingJobsIDs returns the "roofing_jobs" edge IDs in the mutation.
func (m *PartnerMutation) RoofingJobsIDs() (ids []string) {
	for id := range m.roofing_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetRoofingJobs resets all changes to the "roofing_jobs" edge.
func (m *PartnerMutation) ResetRoofingJobs() {
	m.roofing_jobs = nil
	m.clearedroofing_jobs = false
	m.removedroofing_jobs = nil
}

// AddIntegrationJobIDs adds the "integration_jobs" edge to the Job entity by ids.
func (m *PartnerMutation) AddIntegrationJobIDs(ids ...string) {
	if m.integration_jobs == nil {
		m.integration_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.integration_jobs[ids[i]] = struct{}{}
	}
}

// ClearIntegrationJobs clears the "integration_jobs" edge to the Job entity.
func (m *PartnerMutation) ClearIntegrationJobs() {
	m.clearedintegration_jobs = true
}

// IntegrationJobsCleared reports if the "integration_jobs" edge to the Job entity was cleared.
func (m *PartnerMutation) IntegrationJobsCleared() bool {
	return m.clearedintegration_jobs
}

// RemoveIntegrationJobIDs removes the "integration_jobs" edge to the Job entity by IDs.
func (m *PartnerMutation) RemoveIntegrationJobIDs(ids ...string) {
	if m.removedintegration_jobs == nil {
		m.removedintegration_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.integration_jobs, ids[i])
		m.removedintegration_jobs[ids[i]] = struct{}{}
	}
}

// RemovedIntegrationJobs returns the removed IDs of the "integration_jobs" edge to the Job entity.
func (m *PartnerMutation) RemovedIntegrationJobsIDs() (ids []string) {
	for id := range m.removedintegration_jobs {
		ids = append(ids, id)
	}
	return
}

// IntegrationJobsIDs returns the "integration_jobs" edge IDs in the mutation.
func (m *PartnerMutation) IntegrationJobsIDs() (ids []string) {
	for id := range m.integration_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetIntegrationJobs resets all changes to the "integration_jobs" edge.
func (m *PartnerMutation) ResetIntegrationJobs() {
	m.integration_jobs = nil
	m.clearedintegration_jobs = false
	m.removedintegration_jobs = nil
}

// AddEpcJobIDs adds the "epc_jobs" edge to the Job entity by ids.
func (m *PartnerMutation) AddEpcJobIDs(ids ...string) {
	if m.epc_jobs == nil {
		m.epc_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.epc_jobs[ids[i]] = struct{}{}
	}
}

// ClearEpcJobs clears the "epc_jobs" edge to the Job entity.
func (m *PartnerMutation) ClearEpcJobs() {
	m.clearedepc_jobs = true
}

// EpcJobsCleared reports if the "epc_jobs" edge to the Job entity was cleared.
func (m *PartnerMutation) EpcJobsCleared() bool {
	return m.clearedepc_jobs
}

// RemoveEpcJobIDs removes the "epc_jobs" edge to the Job entity by IDs.
func (m *PartnerMutation) RemoveEpcJobIDs(ids ...string) {
	if m.removedepc_jobs == nil {
		m.removedepc_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.epc_jobs, ids[i])
		m.removedepc_jobs[ids[i]] = struct{}{}
	}
}

// RemovedEpcJobs returns the removed IDs of the "epc_jobs" edge to the Job entity.
func (m *PartnerMutation) RemovedEpcJobsIDs() (ids []string) {
	for id := range m.removedepc_jobs {
		ids = append(ids, id)
	}
	return
}

// EpcJobsIDs returns the "epc_jobs" edge IDs in the mutation.
func (m *PartnerMutation) EpcJobsIDs() (ids []string) {
	for id := range m.epc_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetEpcJobs resets all changes to the "epc_jobs" edge.
func (m *PartnerMutation) ResetEpcJobs() {
	m.epc_jobs = nil
	m.clearedepc_jobs = false
	m.removedepc_jobs = nil
}

// AddJobRequestIDs adds the "job_requests" edge to the Job entity by ids.
func (m *PartnerMutation) AddJobRequestIDs(ids ...string) {
	if m.job_requests == nil {
		m.job_requests = make(map[string]struct{})
	}
	for i := range ids {
		m.job_requests[ids[i]] = struct{}{}
	}
}

// ClearJobRequests clears the "job_requests" edge to the Job entity.
func (m *PartnerMutation) ClearJobRequests() {
	m.clearedjob_requests = true
}

// JobRequestsCleared reports if the "job_requests" edge to the Job entity was cleared.
func (m *PartnerMutation) JobRequestsCleared() bool {
	return m.clearedjob_requests
}

// RemoveJobRequestIDs removes the "job_requests" edge to the Job entity by IDs.
func (m *PartnerMutation) RemoveJobRequestIDs(ids ...string) {
	if m.removedjob_requests == nil {
		m.removedjob_requests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.job_requests, ids[i])
		m.removedjob_requests[ids[i]] = struct{}{}
	}
}

// RemovedJobRequests returns the removed IDs of the "job_requests" edge to the Job entity.
func (m *PartnerMutation) RemovedJobRequestsIDs() (ids []string) {
	for id := range m.removedjob_requests {
		ids = append(ids, id)
	}
	return
}

// JobRequestsIDs returns the "job_requests" edge IDs in the mutation.
func (m *PartnerMutation) JobRequestsIDs() (ids []string) {
	for id := range m.job_requests {
		ids = append(ids, id)
	}
	return
}

// ResetJobRequests resets all changes to the "job_requests" edge.
func (m *PartnerMutation) ResetJobRequests() {
	m.job_requests = nil
	m.clearedjob_requests = false
	m.removedjob_requests = nil
}

// AddActivityIDs adds the "activities" edge to the PartnerActivity entity by ids.
func (m *PartnerMutation) AddActivityIDs(ids ...string) {
	if m.activities == nil {
		m.activities = make(map[string]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the PartnerActivity entity.
func (m *PartnerMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the PartnerActivity entity was cleared.
func (m *PartnerMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the PartnerActivity entity by IDs.
func (m *PartnerMutation) RemoveActivityIDs(ids ...string) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the PartnerActivity entity.
func (m *PartnerMutation) RemovedActivitiesIDs() (ids []string) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *PartnerMutation) ActivitiesIDs() (ids []string) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *PartnerMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// AddJobAssignmentHistoryIDs adds the "job_assignment_history" edge to the JobAssignmentHistory entity by ids.
func (m *PartnerMutation) AddJobAssignmentHistoryIDs(ids ...string) {
	if m.job_assignment_history == nil {
		m.job_assignment_history = make(map[string]struct{})
	}
	for i := range ids {
		m.job_assignment_history[ids[i]] = struct{}{}
	}
}

// ClearJobAssignmentHistory clears the "job_assignment_history" edge to the JobAssignmentHistory entity.
func (m *PartnerMutation) ClearJobAssignmentHistory() {
	m.clearedjob_assignment_history = true
}

// JobAssignmentHistoryCleared reports if the "job_assignment_history" edge to the JobAssignmentHistory entity was cleared.
func (m *PartnerMutation) JobAssignmentHistoryCleared() bool {
	return m.clearedjob_assignment_history
}

// RemoveJobAssignmentHistoryIDs removes the "job_assignment_history" edge to the JobAssignmentHistory entity by IDs.
func (m *PartnerMutation) RemoveJobAssignmentHistoryIDs(ids ...string) {
	if m.removedjob_assignment_history == nil {
		m.removedjob_assignment_history = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.job_assignment_history, ids[i])
		m.removedjob_assignment_history[ids[i]] = struct{}{}
	}
}

// RemovedJobAssignmentHistory returns the removed IDs of the "job_assignment_history" edge to the JobAssignmentHistory entity.
func (m *PartnerMutation) RemovedJobAssignmentHistoryIDs() (ids []string) {
	for id := range m.removedjob_assignment_history {
		ids = append(ids, id)
	}
	return
}

// JobAssignmentHistoryIDs returns the "job_assignment_history" edge IDs in the mutation.
func (m *PartnerMutation) JobAssignmentHistoryIDs() (ids []string) {
	for id := range m.job_assignment_history {
		ids = append(ids, id)
	}
	return
}

// ResetJobAssignmentHistory resets all changes to the "job_assignment_history" edge.
func (m *PartnerMutation) ResetJobAssignmentHistory() {
	m.job_assignment_history = nil
	m.clearedjob_assignment_history = false
	m.removedjob_assignment_history = nil
}

// AddRequestedInstallationJobIDs adds the "requested_installation_jobs" edge to the InstallationJob entity by ids.
func (m *PartnerMutation) AddRequestedInstallationJobIDs(ids ...string) {
	if m.requested_installation_jobs == nil {
		m.requested_installation_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.requested_installation_jobs[ids[i]] = struct{}{}
	}
}

// ClearRequestedInstallationJobs clears the "requested_installation_jobs" edge to the InstallationJob entity.
func (m *PartnerMutation) ClearRequestedInstallationJobs() {
	m.clearedrequested_installation_jobs = true
}

// RequestedInstallationJobsCleared reports if the "requested_installation_jobs" edge to the InstallationJob entity was cleared.
func (m *PartnerMutation) RequestedInstallationJobsCleared() bool {
	return m.clearedrequested_installation_jobs
}

// RemoveRequestedInstallationJobIDs removes the "requested_installation_jobs" edge to the InstallationJob entity by IDs.
func (m *PartnerMutation) RemoveRequestedInstallationJobIDs(ids ...string) {
	if m.removedrequested_installation_jobs == nil {
		m.removedrequested_installation_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.requested_installation_jobs, ids[i])
		m.removedrequested_installation_jobs[ids[i]] = struct{}{}
	}
}

// RemovedRequestedInstallationJobs returns the removed IDs of the "requested_installation_jobs" edge to the InstallationJob entity.
func (m *PartnerMutation) RemovedRequestedInstallationJobsIDs() (ids []string) {
	for id := range m.removedrequested_installation_jobs {
		ids = append(ids, id)
	}
	return
}

// RequestedInstallationJobsIDs returns the "requested_installation_jobs" edge IDs in the mutation.
func (m *PartnerMutation) RequestedInstallationJobsIDs() (ids []string) {
	for id := range m.requested_installation_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetRequestedInstallationJobs resets all changes to the "requested_installation_jobs" edge.
func (m *PartnerMutation) ResetRequestedInstallationJobs() {
	m.requested_installation_jobs = nil
	m.clearedrequested_installation_jobs = false
	m.removedrequested_installation_jobs = nil
}

// AddAssignedInstallationJobIDs adds the "assigned_installation_jobs" edge to the InstallationJob entity by ids.
func (m *PartnerMutation) AddAssignedInstallationJobIDs(ids ...string) {
	if m.assigned_installation_jobs == nil {
		m.assigned_installation_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.assigned_installation_jobs[ids[i]] = struct{}{}
	}
}

// ClearAssignedInstallationJobs clears the "assigned_installation_jobs" edge to the InstallationJob entity.
func (m *PartnerMutation) ClearAssignedInstallationJobs() {
	m.clearedassigned_installation_jobs = true
}

// AssignedInstallationJobsCleared reports if the "assigned_installation_jobs" edge to the InstallationJob entity was cleared.
func (m *PartnerMutation) AssignedInstallationJobsCleared() bool {
	return m.clearedassigned_installation_jobs
}

// RemoveAssignedInstallationJobIDs removes the "assigned_installation_jobs" edge to the InstallationJob entity by IDs.
func (m *PartnerMutation) RemoveAssignedInstallationJobIDs(ids ...string) {
	if m.removedassigned_installation_jobs == nil {
		m.removedassigned_installation_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.assigned_installation_jobs, ids[i])
		m.removedassigned_installation_jobs[ids[i]] = struct{}{}
	}
}

// RemovedAssignedInstallationJobs returns the removed IDs of the "assigned_installation_jobs" edge to the InstallationJob entity.
func (m *PartnerMutation) RemovedAssignedInstallationJobsIDs() (ids []string) {
	for id := range m.removedassigned_installation_jobs {
		ids = append(ids, id)
	}
	return
}

// AssignedInstallationJobsIDs returns the "assigned_installation_jobs" edge IDs in the mutation.
func (m *PartnerMutation) AssignedInstallationJobsIDs() (ids []string) {
	for id := range m.assigned_installation_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedInstallationJobs resets all changes to the "assigned_installation_jobs" edge.
func (m *PartnerMutation) ResetAssignedInstallationJobs() {
	m.assigned_installation_jobs = nil
	m.clearedassigned_installation_jobs = false
	m.removedassigned_installation_jobs = nil
}

// AddContactIDs adds the "contacts" edge to the User entity by ids.
func (m *PartnerMutation) AddContactIDs(ids ...string) {
	if m.contacts == nil {
		m.contacts = make(map[string]struct{})
	}
	for i := range ids {
		m.contacts[ids[i]] = struct{}{}
	}
}

// ClearContacts clears the "contacts" edge to the User entity.
func (m *PartnerMutation) ClearContacts() {
	m.clearedcontacts = true
}

// ContactsCleared reports if the "contacts" edge to the User entity was cleared.
func (m *PartnerMutation) ContactsCleared() bool {
	return m.clearedcontacts
}

// RemoveContactIDs removes the "contacts" edge to the User entity by IDs.
func (m *PartnerMutation) RemoveContactIDs(ids ...string) {
	if m.removedcontacts == nil {
		m.removedcontacts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.contacts, ids[i])
		m.removedcontacts[ids[i]] = struct{}{}
	}
}

// RemovedContacts returns the removed IDs of the "contacts" edge to the User entity.
func (m *PartnerMutation) RemovedContactsIDs() (ids []string) {
	for id := range m.removedcontacts {
		ids = append(ids, id)
	}
	return
}

// ContactsIDs returns the "contacts" edge IDs in the mutation.
func (m *PartnerMutation) ContactsIDs() (ids []string) {
	for id := range m.contacts {
		ids = append(ids, id)
	}
	return
}

// ResetContacts resets all changes to the "contacts" edge.
func (m *PartnerMutation) ResetContacts() {
	m.contacts = nil
	m.clearedcontacts = false
	m.removedcontacts = nil
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *PartnerMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *PartnerMutation) CreatorCleared() bool {
	return m.CreatorIDCleared() || m.clearedcreator
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *PartnerMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *PartnerMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetCreatorAPIID sets the "creator_api" edge to the ApiUser entity by id.
func (m *PartnerMutation) SetCreatorAPIID(id string) {
	m.creator_api = &id
}

// ClearCreatorAPI clears the "creator_api" edge to the ApiUser entity.
func (m *PartnerMutation) ClearCreatorAPI() {
	m.clearedcreator_api = true
}

// CreatorAPICleared reports if the "creator_api" edge to the ApiUser entity was cleared.
func (m *PartnerMutation) CreatorAPICleared() bool {
	return m.clearedcreator_api
}

// CreatorAPIID returns the "creator_api" edge ID in the mutation.
func (m *PartnerMutation) CreatorAPIID() (id string, exists bool) {
	if m.creator_api != nil {
		return *m.creator_api, true
	}
	return
}

// CreatorAPIIDs returns the "creator_api" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorAPIID instead. It exists only for internal usage by the builders.
func (m *PartnerMutation) CreatorAPIIDs() (ids []string) {
	if id := m.creator_api; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatorAPI resets all changes to the "creator_api" edge.
func (m *PartnerMutation) ResetCreatorAPI() {
	m.creator_api = nil
	m.clearedcreator_api = false
}

// AddServiceIDs adds the "services" edge to the PartnerService entity by ids.
func (m *PartnerMutation) AddServiceIDs(ids ...string) {
	if m.services == nil {
		m.services = make(map[string]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the PartnerService entity.
func (m *PartnerMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the PartnerService entity was cleared.
func (m *PartnerMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the PartnerService entity by IDs.
func (m *PartnerMutation) RemoveServiceIDs(ids ...string) {
	if m.removedservices == nil {
		m.removedservices = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the PartnerService entity.
func (m *PartnerMutation) RemovedServicesIDs() (ids []string) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *PartnerMutation) ServicesIDs() (ids []string) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *PartnerMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// AddServiceStateIDs adds the "service_states" edge to the PartnerServiceState entity by ids.
func (m *PartnerMutation) AddServiceStateIDs(ids ...string) {
	if m.service_states == nil {
		m.service_states = make(map[string]struct{})
	}
	for i := range ids {
		m.service_states[ids[i]] = struct{}{}
	}
}

// ClearServiceStates clears the "service_states" edge to the PartnerServiceState entity.
func (m *PartnerMutation) ClearServiceStates() {
	m.clearedservice_states = true
}

// ServiceStatesCleared reports if the "service_states" edge to the PartnerServiceState entity was cleared.
func (m *PartnerMutation) ServiceStatesCleared() bool {
	return m.clearedservice_states
}

// RemoveServiceStateIDs removes the "service_states" edge to the PartnerServiceState entity by IDs.
func (m *PartnerMutation) RemoveServiceStateIDs(ids ...string) {
	if m.removedservice_states == nil {
		m.removedservice_states = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.service_states, ids[i])
		m.removedservice_states[ids[i]] = struct{}{}
	}
}

// RemovedServiceStates returns the removed IDs of the "service_states" edge to the PartnerServiceState entity.
func (m *PartnerMutation) RemovedServiceStatesIDs() (ids []string) {
	for id := range m.removedservice_states {
		ids = append(ids, id)
	}
	return
}

// ServiceStatesIDs returns the "service_states" edge IDs in the mutation.
func (m *PartnerMutation) ServiceStatesIDs() (ids []string) {
	for id := range m.service_states {
		ids = append(ids, id)
	}
	return
}

// ResetServiceStates resets all changes to the "service_states" edge.
func (m *PartnerMutation) ResetServiceStates() {
	m.service_states = nil
	m.clearedservice_states = false
	m.removedservice_states = nil
}

// AddServiceCityIDs adds the "service_cities" edge to the PartnerServiceCity entity by ids.
func (m *PartnerMutation) AddServiceCityIDs(ids ...string) {
	if m.service_cities == nil {
		m.service_cities = make(map[string]struct{})
	}
	for i := range ids {
		m.service_cities[ids[i]] = struct{}{}
	}
}

// ClearServiceCities clears the "service_cities" edge to the PartnerServiceCity entity.
func (m *PartnerMutation) ClearServiceCities() {
	m.clearedservice_cities = true
}

// ServiceCitiesCleared reports if the "service_cities" edge to the PartnerServiceCity entity was cleared.
func (m *PartnerMutation) ServiceCitiesCleared() bool {
	return m.clearedservice_cities
}

// RemoveServiceCityIDs removes the "service_cities" edge to the PartnerServiceCity entity by IDs.
func (m *PartnerMutation) RemoveServiceCityIDs(ids ...string) {
	if m.removedservice_cities == nil {
		m.removedservice_cities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.service_cities, ids[i])
		m.removedservice_cities[ids[i]] = struct{}{}
	}
}

// RemovedServiceCities returns the removed IDs of the "service_cities" edge to the PartnerServiceCity entity.
func (m *PartnerMutation) RemovedServiceCitiesIDs() (ids []string) {
	for id := range m.removedservice_cities {
		ids = append(ids, id)
	}
	return
}

// ServiceCitiesIDs returns the "service_cities" edge IDs in the mutation.
func (m *PartnerMutation) ServiceCitiesIDs() (ids []string) {
	for id := range m.service_cities {
		ids = append(ids, id)
	}
	return
}

// ResetServiceCities resets all changes to the "service_cities" edge.
func (m *PartnerMutation) ResetServiceCities() {
	m.service_cities = nil
	m.clearedservice_cities = false
	m.removedservice_cities = nil
}

// AddTrainingVideoIDs adds the "training_videos" edge to the PartnerTrainingVideo entity by ids.
func (m *PartnerMutation) AddTrainingVideoIDs(ids ...string) {
	if m.training_videos == nil {
		m.training_videos = make(map[string]struct{})
	}
	for i := range ids {
		m.training_videos[ids[i]] = struct{}{}
	}
}

// ClearTrainingVideos clears the "training_videos" edge to the PartnerTrainingVideo entity.
func (m *PartnerMutation) ClearTrainingVideos() {
	m.clearedtraining_videos = true
}

// TrainingVideosCleared reports if the "training_videos" edge to the PartnerTrainingVideo entity was cleared.
func (m *PartnerMutation) TrainingVideosCleared() bool {
	return m.clearedtraining_videos
}

// RemoveTrainingVideoIDs removes the "training_videos" edge to the PartnerTrainingVideo entity by IDs.
func (m *PartnerMutation) RemoveTrainingVideoIDs(ids ...string) {
	if m.removedtraining_videos == nil {
		m.removedtraining_videos = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.training_videos, ids[i])
		m.removedtraining_videos[ids[i]] = struct{}{}
	}
}

// RemovedTrainingVideos returns the removed IDs of the "training_videos" edge to the PartnerTrainingVideo entity.
func (m *PartnerMutation) RemovedTrainingVideosIDs() (ids []string) {
	for id := range m.removedtraining_videos {
		ids = append(ids, id)
	}
	return
}

// TrainingVideosIDs returns the "training_videos" edge IDs in the mutation.
func (m *PartnerMutation) TrainingVideosIDs() (ids []string) {
	for id := range m.training_videos {
		ids = append(ids, id)
	}
	return
}

// ResetTrainingVideos resets all changes to the "training_videos" edge.
func (m *PartnerMutation) ResetTrainingVideos() {
	m.training_videos = nil
	m.clearedtraining_videos = false
	m.removedtraining_videos = nil
}

// AddContactUsRequestIDs adds the "contact_us_requests" edge to the ContactUs entity by ids.
func (m *PartnerMutation) AddContactUsRequestIDs(ids ...string) {
	if m.contact_us_requests == nil {
		m.contact_us_requests = make(map[string]struct{})
	}
	for i := range ids {
		m.contact_us_requests[ids[i]] = struct{}{}
	}
}

// ClearContactUsRequests clears the "contact_us_requests" edge to the ContactUs entity.
func (m *PartnerMutation) ClearContactUsRequests() {
	m.clearedcontact_us_requests = true
}

// ContactUsRequestsCleared reports if the "contact_us_requests" edge to the ContactUs entity was cleared.
func (m *PartnerMutation) ContactUsRequestsCleared() bool {
	return m.clearedcontact_us_requests
}

// RemoveContactUsRequestIDs removes the "contact_us_requests" edge to the ContactUs entity by IDs.
func (m *PartnerMutation) RemoveContactUsRequestIDs(ids ...string) {
	if m.removedcontact_us_requests == nil {
		m.removedcontact_us_requests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.contact_us_requests, ids[i])
		m.removedcontact_us_requests[ids[i]] = struct{}{}
	}
}

// RemovedContactUsRequests returns the removed IDs of the "contact_us_requests" edge to the ContactUs entity.
func (m *PartnerMutation) RemovedContactUsRequestsIDs() (ids []string) {
	for id := range m.removedcontact_us_requests {
		ids = append(ids, id)
	}
	return
}

// ContactUsRequestsIDs returns the "contact_us_requests" edge IDs in the mutation.
func (m *PartnerMutation) ContactUsRequestsIDs() (ids []string) {
	for id := range m.contact_us_requests {
		ids = append(ids, id)
	}
	return
}

// ResetContactUsRequests resets all changes to the "contact_us_requests" edge.
func (m *PartnerMutation) ResetContactUsRequests() {
	m.contact_us_requests = nil
	m.clearedcontact_us_requests = false
	m.removedcontact_us_requests = nil
}

// AddSurveyIDs adds the "surveys" edge to the Survey entity by ids.
func (m *PartnerMutation) AddSurveyIDs(ids ...string) {
	if m.surveys == nil {
		m.surveys = make(map[string]struct{})
	}
	for i := range ids {
		m.surveys[ids[i]] = struct{}{}
	}
}

// ClearSurveys clears the "surveys" edge to the Survey entity.
func (m *PartnerMutation) ClearSurveys() {
	m.clearedsurveys = true
}

// SurveysCleared reports if the "surveys" edge to the Survey entity was cleared.
func (m *PartnerMutation) SurveysCleared() bool {
	return m.clearedsurveys
}

// RemoveSurveyIDs removes the "surveys" edge to the Survey entity by IDs.
func (m *PartnerMutation) RemoveSurveyIDs(ids ...string) {
	if m.removedsurveys == nil {
		m.removedsurveys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.surveys, ids[i])
		m.removedsurveys[ids[i]] = struct{}{}
	}
}

// RemovedSurveys returns the removed IDs of the "surveys" edge to the Survey entity.
func (m *PartnerMutation) RemovedSurveysIDs() (ids []string) {
	for id := range m.removedsurveys {
		ids = append(ids, id)
	}
	return
}

// SurveysIDs returns the "surveys" edge IDs in the mutation.
func (m *PartnerMutation) SurveysIDs() (ids []string) {
	for id := range m.surveys {
		ids = append(ids, id)
	}
	return
}

// ResetSurveys resets all changes to the "surveys" edge.
func (m *PartnerMutation) ResetSurveys() {
	m.surveys = nil
	m.clearedsurveys = false
	m.removedsurveys = nil
}

// AddSessionIDs adds the "sessions" edge to the UserSession entity by ids.
func (m *PartnerMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the UserSession entity.
func (m *PartnerMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the UserSession entity was cleared.
func (m *PartnerMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the UserSession entity by IDs.
func (m *PartnerMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the UserSession entity.
func (m *PartnerMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *PartnerMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *PartnerMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddJobNoteIDs adds the "job_notes" edge to the JobNote entity by ids.
func (m *PartnerMutation) AddJobNoteIDs(ids ...string) {
	if m.job_notes == nil {
		m.job_notes = make(map[string]struct{})
	}
	for i := range ids {
		m.job_notes[ids[i]] = struct{}{}
	}
}

// ClearJobNotes clears the "job_notes" edge to the JobNote entity.
func (m *PartnerMutation) ClearJobNotes() {
	m.clearedjob_notes = true
}

// JobNotesCleared reports if the "job_notes" edge to the JobNote entity was cleared.
func (m *PartnerMutation) JobNotesCleared() bool {
	return m.clearedjob_notes
}

// RemoveJobNoteIDs removes the "job_notes" edge to the JobNote entity by IDs.
func (m *PartnerMutation) RemoveJobNoteIDs(ids ...string) {
	if m.removedjob_notes == nil {
		m.removedjob_notes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.job_notes, ids[i])
		m.removedjob_notes[ids[i]] = struct{}{}
	}
}

// RemovedJobNotes returns the removed IDs of the "job_notes" edge to the JobNote entity.
func (m *PartnerMutation) RemovedJobNotesIDs() (ids []string) {
	for id := range m.removedjob_notes {
		ids = append(ids, id)
	}
	return
}

// JobNotesIDs returns the "job_notes" edge IDs in the mutation.
func (m *PartnerMutation) JobNotesIDs() (ids []string) {
	for id := range m.job_notes {
		ids = append(ids, id)
	}
	return
}

// ResetJobNotes resets all changes to the "job_notes" edge.
func (m *PartnerMutation) ResetJobNotes() {
	m.job_notes = nil
	m.clearedjob_notes = false
	m.removedjob_notes = nil
}

// AddChannelIDs adds the "channels" edge to the ChannelSub entity by ids.
func (m *PartnerMutation) AddChannelIDs(ids ...string) {
	if m.channels == nil {
		m.channels = make(map[string]struct{})
	}
	for i := range ids {
		m.channels[ids[i]] = struct{}{}
	}
}

// ClearChannels clears the "channels" edge to the ChannelSub entity.
func (m *PartnerMutation) ClearChannels() {
	m.clearedchannels = true
}

// ChannelsCleared reports if the "channels" edge to the ChannelSub entity was cleared.
func (m *PartnerMutation) ChannelsCleared() bool {
	return m.clearedchannels
}

// RemoveChannelIDs removes the "channels" edge to the ChannelSub entity by IDs.
func (m *PartnerMutation) RemoveChannelIDs(ids ...string) {
	if m.removedchannels == nil {
		m.removedchannels = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.channels, ids[i])
		m.removedchannels[ids[i]] = struct{}{}
	}
}

// RemovedChannels returns the removed IDs of the "channels" edge to the ChannelSub entity.
func (m *PartnerMutation) RemovedChannelsIDs() (ids []string) {
	for id := range m.removedchannels {
		ids = append(ids, id)
	}
	return
}

// ChannelsIDs returns the "channels" edge IDs in the mutation.
func (m *PartnerMutation) ChannelsIDs() (ids []string) {
	for id := range m.channels {
		ids = append(ids, id)
	}
	return
}

// ResetChannels resets all changes to the "channels" edge.
func (m *PartnerMutation) ResetChannels() {
	m.channels = nil
	m.clearedchannels = false
	m.removedchannels = nil
}

// AddFinanceOptionIDs adds the "finance_options" edge to the OptionList entity by ids.
func (m *PartnerMutation) AddFinanceOptionIDs(ids ...string) {
	if m.finance_options == nil {
		m.finance_options = make(map[string]struct{})
	}
	for i := range ids {
		m.finance_options[ids[i]] = struct{}{}
	}
}

// ClearFinanceOptions clears the "finance_options" edge to the OptionList entity.
func (m *PartnerMutation) ClearFinanceOptions() {
	m.clearedfinance_options = true
}

// FinanceOptionsCleared reports if the "finance_options" edge to the OptionList entity was cleared.
func (m *PartnerMutation) FinanceOptionsCleared() bool {
	return m.clearedfinance_options
}

// RemoveFinanceOptionIDs removes the "finance_options" edge to the OptionList entity by IDs.
func (m *PartnerMutation) RemoveFinanceOptionIDs(ids ...string) {
	if m.removedfinance_options == nil {
		m.removedfinance_options = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.finance_options, ids[i])
		m.removedfinance_options[ids[i]] = struct{}{}
	}
}

// RemovedFinanceOptions returns the removed IDs of the "finance_options" edge to the OptionList entity.
func (m *PartnerMutation) RemovedFinanceOptionsIDs() (ids []string) {
	for id := range m.removedfinance_options {
		ids = append(ids, id)
	}
	return
}

// FinanceOptionsIDs returns the "finance_options" edge IDs in the mutation.
func (m *PartnerMutation) FinanceOptionsIDs() (ids []string) {
	for id := range m.finance_options {
		ids = append(ids, id)
	}
	return
}

// ResetFinanceOptions resets all changes to the "finance_options" edge.
func (m *PartnerMutation) ResetFinanceOptions() {
	m.finance_options = nil
	m.clearedfinance_options = false
	m.removedfinance_options = nil
}

// AddEpcOptionIDs adds the "epc_options" edge to the OptionList entity by ids.
func (m *PartnerMutation) AddEpcOptionIDs(ids ...string) {
	if m.epc_options == nil {
		m.epc_options = make(map[string]struct{})
	}
	for i := range ids {
		m.epc_options[ids[i]] = struct{}{}
	}
}

// ClearEpcOptions clears the "epc_options" edge to the OptionList entity.
func (m *PartnerMutation) ClearEpcOptions() {
	m.clearedepc_options = true
}

// EpcOptionsCleared reports if the "epc_options" edge to the OptionList entity was cleared.
func (m *PartnerMutation) EpcOptionsCleared() bool {
	return m.clearedepc_options
}

// RemoveEpcOptionIDs removes the "epc_options" edge to the OptionList entity by IDs.
func (m *PartnerMutation) RemoveEpcOptionIDs(ids ...string) {
	if m.removedepc_options == nil {
		m.removedepc_options = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.epc_options, ids[i])
		m.removedepc_options[ids[i]] = struct{}{}
	}
}

// RemovedEpcOptions returns the removed IDs of the "epc_options" edge to the OptionList entity.
func (m *PartnerMutation) RemovedEpcOptionsIDs() (ids []string) {
	for id := range m.removedepc_options {
		ids = append(ids, id)
	}
	return
}

// EpcOptionsIDs returns the "epc_options" edge IDs in the mutation.
func (m *PartnerMutation) EpcOptionsIDs() (ids []string) {
	for id := range m.epc_options {
		ids = append(ids, id)
	}
	return
}

// ResetEpcOptions resets all changes to the "epc_options" edge.
func (m *PartnerMutation) ResetEpcOptions() {
	m.epc_options = nil
	m.clearedepc_options = false
	m.removedepc_options = nil
}

// AddPartnerContactIDs adds the "partner_contacts" edge to the PartnerContact entity by ids.
func (m *PartnerMutation) AddPartnerContactIDs(ids ...string) {
	if m.partner_contacts == nil {
		m.partner_contacts = make(map[string]struct{})
	}
	for i := range ids {
		m.partner_contacts[ids[i]] = struct{}{}
	}
}

// ClearPartnerContacts clears the "partner_contacts" edge to the PartnerContact entity.
func (m *PartnerMutation) ClearPartnerContacts() {
	m.clearedpartner_contacts = true
}

// PartnerContactsCleared reports if the "partner_contacts" edge to the PartnerContact entity was cleared.
func (m *PartnerMutation) PartnerContactsCleared() bool {
	return m.clearedpartner_contacts
}

// RemovePartnerContactIDs removes the "partner_contacts" edge to the PartnerContact entity by IDs.
func (m *PartnerMutation) RemovePartnerContactIDs(ids ...string) {
	if m.removedpartner_contacts == nil {
		m.removedpartner_contacts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.partner_contacts, ids[i])
		m.removedpartner_contacts[ids[i]] = struct{}{}
	}
}

// RemovedPartnerContacts returns the removed IDs of the "partner_contacts" edge to the PartnerContact entity.
func (m *PartnerMutation) RemovedPartnerContactsIDs() (ids []string) {
	for id := range m.removedpartner_contacts {
		ids = append(ids, id)
	}
	return
}

// PartnerContactsIDs returns the "partner_contacts" edge IDs in the mutation.
func (m *PartnerMutation) PartnerContactsIDs() (ids []string) {
	for id := range m.partner_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetPartnerContacts resets all changes to the "partner_contacts" edge.
func (m *PartnerMutation) ResetPartnerContacts() {
	m.partner_contacts = nil
	m.clearedpartner_contacts = false
	m.removedpartner_contacts = nil
}

// Where appends a list predicates to the PartnerMutation builder.
func (m *PartnerMutation) Where(ps ...predicate.Partner) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Partner, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Partner).
func (m *PartnerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnerMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, partner.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, partner.FieldUpdatedAt)
	}
	if m.external_id != nil {
		fields = append(fields, partner.FieldExternalID)
	}
	if m.creator != nil {
		fields = append(fields, partner.FieldCreatorID)
	}
	if m._type != nil {
		fields = append(fields, partner.FieldType)
	}
	if m.name != nil {
		fields = append(fields, partner.FieldName)
	}
	if m.address != nil {
		fields = append(fields, partner.FieldAddress)
	}
	if m.website != nil {
		fields = append(fields, partner.FieldWebsite)
	}
	if m.phone != nil {
		fields = append(fields, partner.FieldPhone)
	}
	if m.latitude != nil {
		fields = append(fields, partner.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, partner.FieldLongitude)
	}
	if m.is_nation_wide != nil {
		fields = append(fields, partner.FieldIsNationWide)
	}
	if m.crew_count != nil {
		fields = append(fields, partner.FieldCrewCount)
	}
	if m.years_in_business != nil {
		fields = append(fields, partner.FieldYearsInBusiness)
	}
	if m.job_capacity != nil {
		fields = append(fields, partner.FieldJobCapacity)
	}
	if m.asphalt_lead_t != nil {
		fields = append(fields, partner.FieldAsphaltLeadT)
	}
	if m.metal_lead_t != nil {
		fields = append(fields, partner.FieldMetalLeadT)
	}
	if m.tile_lead_t != nil {
		fields = append(fields, partner.FieldTileLeadT)
	}
	if m.setup_steps_completed != nil {
		fields = append(fields, partner.FieldSetupStepsCompleted)
	}
	if m.sales_volume != nil {
		fields = append(fields, partner.FieldSalesVolume)
	}
	if m.down_payment != nil {
		fields = append(fields, partner.FieldDownPayment)
	}
	if m.pif != nil {
		fields = append(fields, partner.FieldPif)
	}
	if m.install_in_house != nil {
		fields = append(fields, partner.FieldInstallInHouse)
	}
	if m.status != nil {
		fields = append(fields, partner.FieldStatus)
	}
	if m.epc_status != nil {
		fields = append(fields, partner.FieldEpcStatus)
	}
	if m.mobile_app_settings != nil {
		fields = append(fields, partner.FieldMobileAppSettings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partner.FieldCreatedAt:
		return m.CreatedAt()
	case partner.FieldUpdatedAt:
		return m.UpdatedAt()
	case partner.FieldExternalID:
		return m.ExternalID()
	case partner.FieldCreatorID:
		return m.CreatorID()
	case partner.FieldType:
		return m.GetType()
	case partner.FieldName:
		return m.Name()
	case partner.FieldAddress:
		return m.Address()
	case partner.FieldWebsite:
		return m.Website()
	case partner.FieldPhone:
		return m.Phone()
	case partner.FieldLatitude:
		return m.Latitude()
	case partner.FieldLongitude:
		return m.Longitude()
	case partner.FieldIsNationWide:
		return m.IsNationWide()
	case partner.FieldCrewCount:
		return m.CrewCount()
	case partner.FieldYearsInBusiness:
		return m.YearsInBusiness()
	case partner.FieldJobCapacity:
		return m.JobCapacity()
	case partner.FieldAsphaltLeadT:
		return m.AsphaltLeadT()
	case partner.FieldMetalLeadT:
		return m.MetalLeadT()
	case partner.FieldTileLeadT:
		return m.TileLeadT()
	case partner.FieldSetupStepsCompleted:
		return m.SetupStepsCompleted()
	case partner.FieldSalesVolume:
		return m.SalesVolume()
	case partner.FieldDownPayment:
		return m.DownPayment()
	case partner.FieldPif:
		return m.Pif()
	case partner.FieldInstallInHouse:
		return m.InstallInHouse()
	case partner.FieldStatus:
		return m.Status()
	case partner.FieldEpcStatus:
		return m.EpcStatus()
	case partner.FieldMobileAppSettings:
		return m.MobileAppSettings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partner.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partner.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case partner.FieldExternalID:
		return m.OldExternalID(ctx)
	case partner.FieldCreatorID:
		return m.OldCreatorID(ctx)
	case partner.FieldType:
		return m.OldType(ctx)
	case partner.FieldName:
		return m.OldName(ctx)
	case partner.FieldAddress:
		return m.OldAddress(ctx)
	case partner.FieldWebsite:
		return m.OldWebsite(ctx)
	case partner.FieldPhone:
		return m.OldPhone(ctx)
	case partner.FieldLatitude:
		return m.OldLatitude(ctx)
	case partner.FieldLongitude:
		return m.OldLongitude(ctx)
	case partner.FieldIsNationWide:
		return m.OldIsNationWide(ctx)
	case partner.FieldCrewCount:
		return m.OldCrewCount(ctx)
	case partner.FieldYearsInBusiness:
		return m.OldYearsInBusiness(ctx)
	case partner.FieldJobCapacity:
		return m.OldJobCapacity(ctx)
	case partner.FieldAsphaltLeadT:
		return m.OldAsphaltLeadT(ctx)
	case partner.FieldMetalLeadT:
		return m.OldMetalLeadT(ctx)
	case partner.FieldTileLeadT:
		return m.OldTileLeadT(ctx)
	case partner.FieldSetupStepsCompleted:
		return m.OldSetupStepsCompleted(ctx)
	case partner.FieldSalesVolume:
		return m.OldSalesVolume(ctx)
	case partner.FieldDownPayment:
		return m.OldDownPayment(ctx)
	case partner.FieldPif:
		return m.OldPif(ctx)
	case partner.FieldInstallInHouse:
		return m.OldInstallInHouse(ctx)
	case partner.FieldStatus:
		return m.OldStatus(ctx)
	case partner.FieldEpcStatus:
		return m.OldEpcStatus(ctx)
	case partner.FieldMobileAppSettings:
		return m.OldMobileAppSettings(ctx)
	}
	return nil, fmt.Errorf("unknown Partner field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partner.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partner.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case partner.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case partner.FieldCreatorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatorID(v)
		return nil
	case partner.FieldType:
		v, ok := value.(enum.Partner)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case partner.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case partner.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case partner.FieldWebsite:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebsite(v)
		return nil
	case partner.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case partner.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case partner.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case partner.FieldIsNationWide:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNationWide(v)
		return nil
	case partner.FieldCrewCount:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrewCount(v)
		return nil
	case partner.FieldYearsInBusiness:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYearsInBusiness(v)
		return nil
	case partner.FieldJobCapacity:
		v, ok := value.(uint16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJobCapacity(v)
		return nil
	case partner.FieldAsphaltLeadT:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAsphaltLeadT(v)
		return nil
	case partner.FieldMetalLeadT:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetalLeadT(v)
		return nil
	case partner.FieldTileLeadT:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTileLeadT(v)
		return nil
	case partner.FieldSetupStepsCompleted:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSetupStepsCompleted(v)
		return nil
	case partner.FieldSalesVolume:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalesVolume(v)
		return nil
	case partner.FieldDownPayment:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownPayment(v)
		return nil
	case partner.FieldPif:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPif(v)
		return nil
	case partner.FieldInstallInHouse:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstallInHouse(v)
		return nil
	case partner.FieldStatus:
		v, ok := value.(enum.PartnerStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case partner.FieldEpcStatus:
		v, ok := value.(enum.EPCStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpcStatus(v)
		return nil
	case partner.FieldMobileAppSettings:
		v, ok := value.(model.MobileAppSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobileAppSettings(v)
		return nil
	}
	return fmt.Errorf("unknown Partner field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnerMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, partner.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, partner.FieldLongitude)
	}
	if m.addcrew_count != nil {
		fields = append(fields, partner.FieldCrewCount)
	}
	if m.addyears_in_business != nil {
		fields = append(fields, partner.FieldYearsInBusiness)
	}
	if m.addjob_capacity != nil {
		fields = append(fields, partner.FieldJobCapacity)
	}
	if m.addsetup_steps_completed != nil {
		fields = append(fields, partner.FieldSetupStepsCompleted)
	}
	if m.addsales_volume != nil {
		fields = append(fields, partner.FieldSalesVolume)
	}
	if m.adddown_payment != nil {
		fields = append(fields, partner.FieldDownPayment)
	}
	if m.addpif != nil {
		fields = append(fields, partner.FieldPif)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case partner.FieldLatitude:
		return m.AddedLatitude()
	case partner.FieldLongitude:
		return m.AddedLongitude()
	case partner.FieldCrewCount:
		return m.AddedCrewCount()
	case partner.FieldYearsInBusiness:
		return m.AddedYearsInBusiness()
	case partner.FieldJobCapacity:
		return m.AddedJobCapacity()
	case partner.FieldSetupStepsCompleted:
		return m.AddedSetupStepsCompleted()
	case partner.FieldSalesVolume:
		return m.AddedSalesVolume()
	case partner.FieldDownPayment:
		return m.AddedDownPayment()
	case partner.FieldPif:
		return m.AddedPif()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case partner.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case partner.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case partner.FieldCrewCount:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCrewCount(v)
		return nil
	case partner.FieldYearsInBusiness:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYearsInBusiness(v)
		return nil
	case partner.FieldJobCapacity:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddJobCapacity(v)
		return nil
	case partner.FieldSetupStepsCompleted:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSetupStepsCompleted(v)
		return nil
	case partner.FieldSalesVolume:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalesVolume(v)
		return nil
	case partner.FieldDownPayment:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownPayment(v)
		return nil
	case partner.FieldPif:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPif(v)
		return nil
	}
	return fmt.Errorf("unknown Partner numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partner.FieldExternalID) {
		fields = append(fields, partner.FieldExternalID)
	}
	if m.FieldCleared(partner.FieldCreatorID) {
		fields = append(fields, partner.FieldCreatorID)
	}
	if m.FieldCleared(partner.FieldAddress) {
		fields = append(fields, partner.FieldAddress)
	}
	if m.FieldCleared(partner.FieldWebsite) {
		fields = append(fields, partner.FieldWebsite)
	}
	if m.FieldCleared(partner.FieldPhone) {
		fields = append(fields, partner.FieldPhone)
	}
	if m.FieldCleared(partner.FieldLatitude) {
		fields = append(fields, partner.FieldLatitude)
	}
	if m.FieldCleared(partner.FieldLongitude) {
		fields = append(fields, partner.FieldLongitude)
	}
	if m.FieldCleared(partner.FieldYearsInBusiness) {
		fields = append(fields, partner.FieldYearsInBusiness)
	}
	if m.FieldCleared(partner.FieldAsphaltLeadT) {
		fields = append(fields, partner.FieldAsphaltLeadT)
	}
	if m.FieldCleared(partner.FieldMetalLeadT) {
		fields = append(fields, partner.FieldMetalLeadT)
	}
	if m.FieldCleared(partner.FieldTileLeadT) {
		fields = append(fields, partner.FieldTileLeadT)
	}
	if m.FieldCleared(partner.FieldSalesVolume) {
		fields = append(fields, partner.FieldSalesVolume)
	}
	if m.FieldCleared(partner.FieldDownPayment) {
		fields = append(fields, partner.FieldDownPayment)
	}
	if m.FieldCleared(partner.FieldPif) {
		fields = append(fields, partner.FieldPif)
	}
	if m.FieldCleared(partner.FieldInstallInHouse) {
		fields = append(fields, partner.FieldInstallInHouse)
	}
	if m.FieldCleared(partner.FieldEpcStatus) {
		fields = append(fields, partner.FieldEpcStatus)
	}
	if m.FieldCleared(partner.FieldMobileAppSettings) {
		fields = append(fields, partner.FieldMobileAppSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnerMutation) ClearField(name string) error {
	switch name {
	case partner.FieldExternalID:
		m.ClearExternalID()
		return nil
	case partner.FieldCreatorID:
		m.ClearCreatorID()
		return nil
	case partner.FieldAddress:
		m.ClearAddress()
		return nil
	case partner.FieldWebsite:
		m.ClearWebsite()
		return nil
	case partner.FieldPhone:
		m.ClearPhone()
		return nil
	case partner.FieldLatitude:
		m.ClearLatitude()
		return nil
	case partner.FieldLongitude:
		m.ClearLongitude()
		return nil
	case partner.FieldYearsInBusiness:
		m.ClearYearsInBusiness()
		return nil
	case partner.FieldAsphaltLeadT:
		m.ClearAsphaltLeadT()
		return nil
	case partner.FieldMetalLeadT:
		m.ClearMetalLeadT()
		return nil
	case partner.FieldTileLeadT:
		m.ClearTileLeadT()
		return nil
	case partner.FieldSalesVolume:
		m.ClearSalesVolume()
		return nil
	case partner.FieldDownPayment:
		m.ClearDownPayment()
		return nil
	case partner.FieldPif:
		m.ClearPif()
		return nil
	case partner.FieldInstallInHouse:
		m.ClearInstallInHouse()
		return nil
	case partner.FieldEpcStatus:
		m.ClearEpcStatus()
		return nil
	case partner.FieldMobileAppSettings:
		m.ClearMobileAppSettings()
		return nil
	}
	return fmt.Errorf("unknown Partner nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnerMutation) ResetField(name string) error {
	switch name {
	case partner.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partner.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case partner.FieldExternalID:
		m.ResetExternalID()
		return nil
	case partner.FieldCreatorID:
		m.ResetCreatorID()
		return nil
	case partner.FieldType:
		m.ResetType()
		return nil
	case partner.FieldName:
		m.ResetName()
		return nil
	case partner.FieldAddress:
		m.ResetAddress()
		return nil
	case partner.FieldWebsite:
		m.ResetWebsite()
		return nil
	case partner.FieldPhone:
		m.ResetPhone()
		return nil
	case partner.FieldLatitude:
		m.ResetLatitude()
		return nil
	case partner.FieldLongitude:
		m.ResetLongitude()
		return nil
	case partner.FieldIsNationWide:
		m.ResetIsNationWide()
		return nil
	case partner.FieldCrewCount:
		m.ResetCrewCount()
		return nil
	case partner.FieldYearsInBusiness:
		m.ResetYearsInBusiness()
		return nil
	case partner.FieldJobCapacity:
		m.ResetJobCapacity()
		return nil
	case partner.FieldAsphaltLeadT:
		m.ResetAsphaltLeadT()
		return nil
	case partner.FieldMetalLeadT:
		m.ResetMetalLeadT()
		return nil
	case partner.FieldTileLeadT:
		m.ResetTileLeadT()
		return nil
	case partner.FieldSetupStepsCompleted:
		m.ResetSetupStepsCompleted()
		return nil
	case partner.FieldSalesVolume:
		m.ResetSalesVolume()
		return nil
	case partner.FieldDownPayment:
		m.ResetDownPayment()
		return nil
	case partner.FieldPif:
		m.ResetPif()
		return nil
	case partner.FieldInstallInHouse:
		m.ResetInstallInHouse()
		return nil
	case partner.FieldStatus:
		m.ResetStatus()
		return nil
	case partner.FieldEpcStatus:
		m.ResetEpcStatus()
		return nil
	case partner.FieldMobileAppSettings:
		m.ResetMobileAppSettings()
		return nil
	}
	return fmt.Errorf("unknown Partner field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnerMutation) AddedEdges() []string {
	edges := make([]string, 0, 25)
	if m.requested_estimates != nil {
		edges = append(edges, partner.EdgeRequestedEstimates)
	}
	if m.estimate_home_owners != nil {
		edges = append(edges, partner.EdgeEstimateHomeOwners)
	}
	if m.roofing_jobs != nil {
		edges = append(edges, partner.EdgeRoofingJobs)
	}
	if m.integration_jobs != nil {
		edges = append(edges, partner.EdgeIntegrationJobs)
	}
	if m.epc_jobs != nil {
		edges = append(edges, partner.EdgeEpcJobs)
	}
	if m.job_requests != nil {
		edges = append(edges, partner.EdgeJobRequests)
	}
	if m.activities != nil {
		edges = append(edges, partner.EdgeActivities)
	}
	if m.job_assignment_history != nil {
		edges = append(edges, partner.EdgeJobAssignmentHistory)
	}
	if m.requested_installation_jobs != nil {
		edges = append(edges, partner.EdgeRequestedInstallationJobs)
	}
	if m.assigned_installation_jobs != nil {
		edges = append(edges, partner.EdgeAssignedInstallationJobs)
	}
	if m.contacts != nil {
		edges = append(edges, partner.EdgeContacts)
	}
	if m.creator != nil {
		edges = append(edges, partner.EdgeCreator)
	}
	if m.creator_api != nil {
		edges = append(edges, partner.EdgeCreatorAPI)
	}
	if m.services != nil {
		edges = append(edges, partner.EdgeServices)
	}
	if m.service_states != nil {
		edges = append(edges, partner.EdgeServiceStates)
	}
	if m.service_cities != nil {
		edges = append(edges, partner.EdgeServiceCities)
	}
	if m.training_videos != nil {
		edges = append(edges, partner.EdgeTrainingVideos)
	}
	if m.contact_us_requests != nil {
		edges = append(edges, partner.EdgeContactUsRequests)
	}
	if m.surveys != nil {
		edges = append(edges, partner.EdgeSurveys)
	}
	if m.sessions != nil {
		edges = append(edges, partner.EdgeSessions)
	}
	if m.job_notes != nil {
		edges = append(edges, partner.EdgeJobNotes)
	}
	if m.channels != nil {
		edges = append(edges, partner.EdgeChannels)
	}
	if m.finance_options != nil {
		edges = append(edges, partner.EdgeFinanceOptions)
	}
	if m.epc_options != nil {
		edges = append(edges, partner.EdgeEpcOptions)
	}
	if m.partner_contacts != nil {
		edges = append(edges, partner.EdgePartnerContacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partner.EdgeRequestedEstimates:
		ids := make([]ent.Value, 0, len(m.requested_estimates))
		for id := range m.requested_estimates {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeEstimateHomeOwners:
		ids := make([]ent.Value, 0, len(m.estimate_home_owners))
		for id := range m.estimate_home_owners {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeRoofingJobs:
		ids := make([]ent.Value, 0, len(m.roofing_jobs))
		for id := range m.roofing_jobs {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeIntegrationJobs:
		ids := make([]ent.Value, 0, len(m.integration_jobs))
		for id := range m.integration_jobs {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeEpcJobs:
		ids := make([]ent.Value, 0, len(m.epc_jobs))
		for id := range m.epc_jobs {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeJobRequests:
		ids := make([]ent.Value, 0, len(m.job_requests))
		for id := range m.job_requests {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeJobAssignmentHistory:
		ids := make([]ent.Value, 0, len(m.job_assignment_history))
		for id := range m.job_assignment_history {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeRequestedInstallationJobs:
		ids := make([]ent.Value, 0, len(m.requested_installation_jobs))
		for id := range m.requested_installation_jobs {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeAssignedInstallationJobs:
		ids := make([]ent.Value, 0, len(m.assigned_installation_jobs))
		for id := range m.assigned_installation_jobs {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.contacts))
		for id := range m.contacts {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case partner.EdgeCreatorAPI:
		if id := m.creator_api; id != nil {
			return []ent.Value{*id}
		}
	case partner.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeServiceStates:
		ids := make([]ent.Value, 0, len(m.service_states))
		for id := range m.service_states {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeServiceCities:
		ids := make([]ent.Value, 0, len(m.service_cities))
		for id := range m.service_cities {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeTrainingVideos:
		ids := make([]ent.Value, 0, len(m.training_videos))
		for id := range m.training_videos {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeContactUsRequests:
		ids := make([]ent.Value, 0, len(m.contact_us_requests))
		for id := range m.contact_us_requests {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeSurveys:
		ids := make([]ent.Value, 0, len(m.surveys))
		for id := range m.surveys {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeJobNotes:
		ids := make([]ent.Value, 0, len(m.job_notes))
		for id := range m.job_notes {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.channels))
		for id := range m.channels {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeFinanceOptions:
		ids := make([]ent.Value, 0, len(m.finance_options))
		for id := range m.finance_options {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeEpcOptions:
		ids := make([]ent.Value, 0, len(m.epc_options))
		for id := range m.epc_options {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgePartnerContacts:
		ids := make([]ent.Value, 0, len(m.partner_contacts))
		for id := range m.partner_contacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 25)
	if m.removedrequested_estimates != nil {
		edges = append(edges, partner.EdgeRequestedEstimates)
	}
	if m.removedestimate_home_owners != nil {
		edges = append(edges, partner.EdgeEstimateHomeOwners)
	}
	if m.removedroofing_jobs != nil {
		edges = append(edges, partner.EdgeRoofingJobs)
	}
	if m.removedintegration_jobs != nil {
		edges = append(edges, partner.EdgeIntegrationJobs)
	}
	if m.removedepc_jobs != nil {
		edges = append(edges, partner.EdgeEpcJobs)
	}
	if m.removedjob_requests != nil {
		edges = append(edges, partner.EdgeJobRequests)
	}
	if m.removedactivities != nil {
		edges = append(edges, partner.EdgeActivities)
	}
	if m.removedjob_assignment_history != nil {
		edges = append(edges, partner.EdgeJobAssignmentHistory)
	}
	if m.removedrequested_installation_jobs != nil {
		edges = append(edges, partner.EdgeRequestedInstallationJobs)
	}
	if m.removedassigned_installation_jobs != nil {
		edges = append(edges, partner.EdgeAssignedInstallationJobs)
	}
	if m.removedcontacts != nil {
		edges = append(edges, partner.EdgeContacts)
	}
	if m.removedservices != nil {
		edges = append(edges, partner.EdgeServices)
	}
	if m.removedservice_states != nil {
		edges = append(edges, partner.EdgeServiceStates)
	}
	if m.removedservice_cities != nil {
		edges = append(edges, partner.EdgeServiceCities)
	}
	if m.removedtraining_videos != nil {
		edges = append(edges, partner.EdgeTrainingVideos)
	}
	if m.removedcontact_us_requests != nil {
		edges = append(edges, partner.EdgeContactUsRequests)
	}
	if m.removedsurveys != nil {
		edges = append(edges, partner.EdgeSurveys)
	}
	if m.removedsessions != nil {
		edges = append(edges, partner.EdgeSessions)
	}
	if m.removedjob_notes != nil {
		edges = append(edges, partner.EdgeJobNotes)
	}
	if m.removedchannels != nil {
		edges = append(edges, partner.EdgeChannels)
	}
	if m.removedfinance_options != nil {
		edges = append(edges, partner.EdgeFinanceOptions)
	}
	if m.removedepc_options != nil {
		edges = append(edges, partner.EdgeEpcOptions)
	}
	if m.removedpartner_contacts != nil {
		edges = append(edges, partner.EdgePartnerContacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnerMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case partner.EdgeRequestedEstimates:
		ids := make([]ent.Value, 0, len(m.removedrequested_estimates))
		for id := range m.removedrequested_estimates {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeEstimateHomeOwners:
		ids := make([]ent.Value, 0, len(m.removedestimate_home_owners))
		for id := range m.removedestimate_home_owners {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeRoofingJobs:
		ids := make([]ent.Value, 0, len(m.removedroofing_jobs))
		for id := range m.removedroofing_jobs {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeIntegrationJobs:
		ids := make([]ent.Value, 0, len(m.removedintegration_jobs))
		for id := range m.removedintegration_jobs {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeEpcJobs:
		ids := make([]ent.Value, 0, len(m.removedepc_jobs))
		for id := range m.removedepc_jobs {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeJobRequests:
		ids := make([]ent.Value, 0, len(m.removedjob_requests))
		for id := range m.removedjob_requests {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeJobAssignmentHistory:
		ids := make([]ent.Value, 0, len(m.removedjob_assignment_history))
		for id := range m.removedjob_assignment_history {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeRequestedInstallationJobs:
		ids := make([]ent.Value, 0, len(m.removedrequested_installation_jobs))
		for id := range m.removedrequested_installation_jobs {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeAssignedInstallationJobs:
		ids := make([]ent.Value, 0, len(m.removedassigned_installation_jobs))
		for id := range m.removedassigned_installation_jobs {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeContacts:
		ids := make([]ent.Value, 0, len(m.removedcontacts))
		for id := range m.removedcontacts {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeServiceStates:
		ids := make([]ent.Value, 0, len(m.removedservice_states))
		for id := range m.removedservice_states {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeServiceCities:
		ids := make([]ent.Value, 0, len(m.removedservice_cities))
		for id := range m.removedservice_cities {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeTrainingVideos:
		ids := make([]ent.Value, 0, len(m.removedtraining_videos))
		for id := range m.removedtraining_videos {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeContactUsRequests:
		ids := make([]ent.Value, 0, len(m.removedcontact_us_requests))
		for id := range m.removedcontact_us_requests {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeSurveys:
		ids := make([]ent.Value, 0, len(m.removedsurveys))
		for id := range m.removedsurveys {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeJobNotes:
		ids := make([]ent.Value, 0, len(m.removedjob_notes))
		for id := range m.removedjob_notes {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeChannels:
		ids := make([]ent.Value, 0, len(m.removedchannels))
		for id := range m.removedchannels {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeFinanceOptions:
		ids := make([]ent.Value, 0, len(m.removedfinance_options))
		for id := range m.removedfinance_options {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgeEpcOptions:
		ids := make([]ent.Value, 0, len(m.removedepc_options))
		for id := range m.removedepc_options {
			ids = append(ids, id)
		}
		return ids
	case partner.EdgePartnerContacts:
		ids := make([]ent.Value, 0, len(m.removedpartner_contacts))
		for id := range m.removedpartner_contacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 25)
	if m.clearedrequested_estimates {
		edges = append(edges, partner.EdgeRequestedEstimates)
	}
	if m.clearedestimate_home_owners {
		edges = append(edges, partner.EdgeEstimateHomeOwners)
	}
	if m.clearedroofing_jobs {
		edges = append(edges, partner.EdgeRoofingJobs)
	}
	if m.clearedintegration_jobs {
		edges = append(edges, partner.EdgeIntegrationJobs)
	}
	if m.clearedepc_jobs {
		edges = append(edges, partner.EdgeEpcJobs)
	}
	if m.clearedjob_requests {
		edges = append(edges, partner.EdgeJobRequests)
	}
	if m.clearedactivities {
		edges = append(edges, partner.EdgeActivities)
	}
	if m.clearedjob_assignment_history {
		edges = append(edges, partner.EdgeJobAssignmentHistory)
	}
	if m.clearedrequested_installation_jobs {
		edges = append(edges, partner.EdgeRequestedInstallationJobs)
	}
	if m.clearedassigned_installation_jobs {
		edges = append(edges, partner.EdgeAssignedInstallationJobs)
	}
	if m.clearedcontacts {
		edges = append(edges, partner.EdgeContacts)
	}
	if m.clearedcreator {
		edges = append(edges, partner.EdgeCreator)
	}
	if m.clearedcreator_api {
		edges = append(edges, partner.EdgeCreatorAPI)
	}
	if m.clearedservices {
		edges = append(edges, partner.EdgeServices)
	}
	if m.clearedservice_states {
		edges = append(edges, partner.EdgeServiceStates)
	}
	if m.clearedservice_cities {
		edges = append(edges, partner.EdgeServiceCities)
	}
	if m.clearedtraining_videos {
		edges = append(edges, partner.EdgeTrainingVideos)
	}
	if m.clearedcontact_us_requests {
		edges = append(edges, partner.EdgeContactUsRequests)
	}
	if m.clearedsurveys {
		edges = append(edges, partner.EdgeSurveys)
	}
	if m.clearedsessions {
		edges = append(edges, partner.EdgeSessions)
	}
	if m.clearedjob_notes {
		edges = append(edges, partner.EdgeJobNotes)
	}
	if m.clearedchannels {
		edges = append(edges, partner.EdgeChannels)
	}
	if m.clearedfinance_options {
		edges = append(edges, partner.EdgeFinanceOptions)
	}
	if m.clearedepc_options {
		edges = append(edges, partner.EdgeEpcOptions)
	}
	if m.clearedpartner_contacts {
		edges = append(edges, partner.EdgePartnerContacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnerMutation) EdgeCleared(name string) bool {
	switch name {
	case partner.EdgeRequestedEstimates:
		return m.clearedrequested_estimates
	case partner.EdgeEstimateHomeOwners:
		return m.clearedestimate_home_owners
	case partner.EdgeRoofingJobs:
		return m.clearedroofing_jobs
	case partner.EdgeIntegrationJobs:
		return m.clearedintegration_jobs
	case partner.EdgeEpcJobs:
		return m.clearedepc_jobs
	case partner.EdgeJobRequests:
		return m.clearedjob_requests
	case partner.EdgeActivities:
		return m.clearedactivities
	case partner.EdgeJobAssignmentHistory:
		return m.clearedjob_assignment_history
	case partner.EdgeRequestedInstallationJobs:
		return m.clearedrequested_installation_jobs
	case partner.EdgeAssignedInstallationJobs:
		return m.clearedassigned_installation_jobs
	case partner.EdgeContacts:
		return m.clearedcontacts
	case partner.EdgeCreator:
		return m.clearedcreator
	case partner.EdgeCreatorAPI:
		return m.clearedcreator_api
	case partner.EdgeServices:
		return m.clearedservices
	case partner.EdgeServiceStates:
		return m.clearedservice_states
	case partner.EdgeServiceCities:
		return m.clearedservice_cities
	case partner.EdgeTrainingVideos:
		return m.clearedtraining_videos
	case partner.EdgeContactUsRequests:
		return m.clearedcontact_us_requests
	case partner.EdgeSurveys:
		return m.clearedsurveys
	case partner.EdgeSessions:
		return m.clearedsessions
	case partner.EdgeJobNotes:
		return m.clearedjob_notes
	case partner.EdgeChannels:
		return m.clearedchannels
	case partner.EdgeFinanceOptions:
		return m.clearedfinance_options
	case partner.EdgeEpcOptions:
		return m.clearedepc_options
	case partner.EdgePartnerContacts:
		return m.clearedpartner_contacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnerMutation) ClearEdge(name string) error {
	switch name {
	case partner.EdgeCreator:
		m.ClearCreator()
		return nil
	case partner.EdgeCreatorAPI:
		m.ClearCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown Partner unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnerMutation) ResetEdge(name string) error {
	switch name {
	case partner.EdgeRequestedEstimates:
		m.ResetRequestedEstimates()
		return nil
	case partner.EdgeEstimateHomeOwners:
		m.ResetEstimateHomeOwners()
		return nil
	case partner.EdgeRoofingJobs:
		m.ResetRoofingJobs()
		return nil
	case partner.EdgeIntegrationJobs:
		m.ResetIntegrationJobs()
		return nil
	case partner.EdgeEpcJobs:
		m.ResetEpcJobs()
		return nil
	case partner.EdgeJobRequests:
		m.ResetJobRequests()
		return nil
	case partner.EdgeActivities:
		m.ResetActivities()
		return nil
	case partner.EdgeJobAssignmentHistory:
		m.ResetJobAssignmentHistory()
		return nil
	case partner.EdgeRequestedInstallationJobs:
		m.ResetRequestedInstallationJobs()
		return nil
	case partner.EdgeAssignedInstallationJobs:
		m.ResetAssignedInstallationJobs()
		return nil
	case partner.EdgeContacts:
		m.ResetContacts()
		return nil
	case partner.EdgeCreator:
		m.ResetCreator()
		return nil
	case partner.EdgeCreatorAPI:
		m.ResetCreatorAPI()
		return nil
	case partner.EdgeServices:
		m.ResetServices()
		return nil
	case partner.EdgeServiceStates:
		m.ResetServiceStates()
		return nil
	case partner.EdgeServiceCities:
		m.ResetServiceCities()
		return nil
	case partner.EdgeTrainingVideos:
		m.ResetTrainingVideos()
		return nil
	case partner.EdgeContactUsRequests:
		m.ResetContactUsRequests()
		return nil
	case partner.EdgeSurveys:
		m.ResetSurveys()
		return nil
	case partner.EdgeSessions:
		m.ResetSessions()
		return nil
	case partner.EdgeJobNotes:
		m.ResetJobNotes()
		return nil
	case partner.EdgeChannels:
		m.ResetChannels()
		return nil
	case partner.EdgeFinanceOptions:
		m.ResetFinanceOptions()
		return nil
	case partner.EdgeEpcOptions:
		m.ResetEpcOptions()
		return nil
	case partner.EdgePartnerContacts:
		m.ResetPartnerContacts()
		return nil
	}
	return fmt.Errorf("unknown Partner edge %s", name)
}

// PartnerActivityMutation represents an operation that mutates the PartnerActivity nodes in the graph.
type PartnerActivityMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	description        *string
	raw                *map[string]interface{}
	clearedFields      map[string]struct{}
	partner            *string
	clearedpartner     bool
	creator            *string
	clearedcreator     bool
	creator_api        *string
	clearedcreator_api bool
	done               bool
	oldValue           func(context.Context) (*PartnerActivity, error)
	predicates         []predicate.PartnerActivity
}

var _ ent.Mutation = (*PartnerActivityMutation)(nil)

// partneractivityOption allows management of the mutation configuration using functional options.
type partneractivityOption func(*PartnerActivityMutation)

// newPartnerActivityMutation creates new mutation for the PartnerActivity entity.
func newPartnerActivityMutation(c config, op Op, opts ...partneractivityOption) *PartnerActivityMutation {
	m := &PartnerActivityMutation{
		config:        c,
		op:            op,
		typ:           TypePartnerActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnerActivityID sets the ID field of the mutation.
func withPartnerActivityID(id string) partneractivityOption {
	return func(m *PartnerActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *PartnerActivity
		)
		m.oldValue = func(ctx context.Context) (*PartnerActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartnerActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnerActivity sets the old PartnerActivity of the mutation.
func withPartnerActivity(node *PartnerActivity) partneractivityOption {
	return func(m *PartnerActivityMutation) {
		m.oldValue = func(context.Context) (*PartnerActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnerActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnerActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PartnerActivity entities.
func (m *PartnerActivityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnerActivityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnerActivityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PartnerActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnerActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnerActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PartnerActivity entity.
// If the PartnerActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnerActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDescription sets the "description" field.
func (m *PartnerActivityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PartnerActivityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PartnerActivity entity.
// If the PartnerActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerActivityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PartnerActivityMutation) ResetDescription() {
	m.description = nil
}

// SetRaw sets the "raw" field.
func (m *PartnerActivityMutation) SetRaw(value map[string]interface{}) {
	m.raw = &value
}

// Raw returns the value of the "raw" field in the mutation.
func (m *PartnerActivityMutation) Raw() (r map[string]interface{}, exists bool) {
	v := m.raw
	if v == nil {
		return
	}
	return *v, true
}

// OldRaw returns the old "raw" field's value of the PartnerActivity entity.
// If the PartnerActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerActivityMutation) OldRaw(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRaw: %w", err)
	}
	return oldValue.Raw, nil
}

// ClearRaw clears the value of the "raw" field.
func (m *PartnerActivityMutation) ClearRaw() {
	m.raw = nil
	m.clearedFields[partneractivity.FieldRaw] = struct{}{}
}

// RawCleared returns if the "raw" field was cleared in this mutation.
func (m *PartnerActivityMutation) RawCleared() bool {
	_, ok := m.clearedFields[partneractivity.FieldRaw]
	return ok
}

// ResetRaw resets all changes to the "raw" field.
func (m *PartnerActivityMutation) ResetRaw() {
	m.raw = nil
	delete(m.clearedFields, partneractivity.FieldRaw)
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *PartnerActivityMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *PartnerActivityMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *PartnerActivityMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *PartnerActivityMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *PartnerActivityMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *PartnerActivityMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *PartnerActivityMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *PartnerActivityMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *PartnerActivityMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *PartnerActivityMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *PartnerActivityMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *PartnerActivityMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetCreatorAPIID sets the "creator_api" edge to the ApiUser entity by id.
func (m *PartnerActivityMutation) SetCreatorAPIID(id string) {
	m.creator_api = &id
}

// ClearCreatorAPI clears the "creator_api" edge to the ApiUser entity.
func (m *PartnerActivityMutation) ClearCreatorAPI() {
	m.clearedcreator_api = true
}

// CreatorAPICleared reports if the "creator_api" edge to the ApiUser entity was cleared.
func (m *PartnerActivityMutation) CreatorAPICleared() bool {
	return m.clearedcreator_api
}

// CreatorAPIID returns the "creator_api" edge ID in the mutation.
func (m *PartnerActivityMutation) CreatorAPIID() (id string, exists bool) {
	if m.creator_api != nil {
		return *m.creator_api, true
	}
	return
}

// CreatorAPIIDs returns the "creator_api" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorAPIID instead. It exists only for internal usage by the builders.
func (m *PartnerActivityMutation) CreatorAPIIDs() (ids []string) {
	if id := m.creator_api; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatorAPI resets all changes to the "creator_api" edge.
func (m *PartnerActivityMutation) ResetCreatorAPI() {
	m.creator_api = nil
	m.clearedcreator_api = false
}

// Where appends a list predicates to the PartnerActivityMutation builder.
func (m *PartnerActivityMutation) Where(ps ...predicate.PartnerActivity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnerActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnerActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PartnerActivity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnerActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnerActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PartnerActivity).
func (m *PartnerActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnerActivityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, partneractivity.FieldCreatedAt)
	}
	if m.description != nil {
		fields = append(fields, partneractivity.FieldDescription)
	}
	if m.raw != nil {
		fields = append(fields, partneractivity.FieldRaw)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnerActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partneractivity.FieldCreatedAt:
		return m.CreatedAt()
	case partneractivity.FieldDescription:
		return m.Description()
	case partneractivity.FieldRaw:
		return m.Raw()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnerActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partneractivity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partneractivity.FieldDescription:
		return m.OldDescription(ctx)
	case partneractivity.FieldRaw:
		return m.OldRaw(ctx)
	}
	return nil, fmt.Errorf("unknown PartnerActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partneractivity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partneractivity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case partneractivity.FieldRaw:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRaw(v)
		return nil
	}
	return fmt.Errorf("unknown PartnerActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnerActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnerActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PartnerActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnerActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partneractivity.FieldRaw) {
		fields = append(fields, partneractivity.FieldRaw)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnerActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnerActivityMutation) ClearField(name string) error {
	switch name {
	case partneractivity.FieldRaw:
		m.ClearRaw()
		return nil
	}
	return fmt.Errorf("unknown PartnerActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnerActivityMutation) ResetField(name string) error {
	switch name {
	case partneractivity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partneractivity.FieldDescription:
		m.ResetDescription()
		return nil
	case partneractivity.FieldRaw:
		m.ResetRaw()
		return nil
	}
	return fmt.Errorf("unknown PartnerActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnerActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.partner != nil {
		edges = append(edges, partneractivity.EdgePartner)
	}
	if m.creator != nil {
		edges = append(edges, partneractivity.EdgeCreator)
	}
	if m.creator_api != nil {
		edges = append(edges, partneractivity.EdgeCreatorAPI)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnerActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partneractivity.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	case partneractivity.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case partneractivity.EdgeCreatorAPI:
		if id := m.creator_api; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnerActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnerActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnerActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedpartner {
		edges = append(edges, partneractivity.EdgePartner)
	}
	if m.clearedcreator {
		edges = append(edges, partneractivity.EdgeCreator)
	}
	if m.clearedcreator_api {
		edges = append(edges, partneractivity.EdgeCreatorAPI)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnerActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case partneractivity.EdgePartner:
		return m.clearedpartner
	case partneractivity.EdgeCreator:
		return m.clearedcreator
	case partneractivity.EdgeCreatorAPI:
		return m.clearedcreator_api
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnerActivityMutation) ClearEdge(name string) error {
	switch name {
	case partneractivity.EdgePartner:
		m.ClearPartner()
		return nil
	case partneractivity.EdgeCreator:
		m.ClearCreator()
		return nil
	case partneractivity.EdgeCreatorAPI:
		m.ClearCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown PartnerActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnerActivityMutation) ResetEdge(name string) error {
	switch name {
	case partneractivity.EdgePartner:
		m.ResetPartner()
		return nil
	case partneractivity.EdgeCreator:
		m.ResetCreator()
		return nil
	case partneractivity.EdgeCreatorAPI:
		m.ResetCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown PartnerActivity edge %s", name)
}

// PartnerContactMutation represents an operation that mutates the PartnerContact nodes in the graph.
type PartnerContactMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	role            *enum.PartnerContactRole
	_type           *enum.PartnerContact
	title           *string
	description     *string
	invoicing_email *string
	clearedFields   map[string]struct{}
	user            *string
	cleareduser     bool
	partner         *string
	clearedpartner  bool
	sessions        map[string]struct{}
	removedsessions map[string]struct{}
	clearedsessions bool
	done            bool
	oldValue        func(context.Context) (*PartnerContact, error)
	predicates      []predicate.PartnerContact
}

var _ ent.Mutation = (*PartnerContactMutation)(nil)

// partnercontactOption allows management of the mutation configuration using functional options.
type partnercontactOption func(*PartnerContactMutation)

// newPartnerContactMutation creates new mutation for the PartnerContact entity.
func newPartnerContactMutation(c config, op Op, opts ...partnercontactOption) *PartnerContactMutation {
	m := &PartnerContactMutation{
		config:        c,
		op:            op,
		typ:           TypePartnerContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnerContactID sets the ID field of the mutation.
func withPartnerContactID(id string) partnercontactOption {
	return func(m *PartnerContactMutation) {
		var (
			err   error
			once  sync.Once
			value *PartnerContact
		)
		m.oldValue = func(ctx context.Context) (*PartnerContact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartnerContact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnerContact sets the old PartnerContact of the mutation.
func withPartnerContact(node *PartnerContact) partnercontactOption {
	return func(m *PartnerContactMutation) {
		m.oldValue = func(context.Context) (*PartnerContact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnerContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnerContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PartnerContact entities.
func (m *PartnerContactMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnerContactMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnerContactMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PartnerContact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnerContactMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnerContactMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PartnerContact entity.
// If the PartnerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerContactMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnerContactMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartnerContactMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartnerContactMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PartnerContact entity.
// If the PartnerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerContactMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartnerContactMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPartnerID sets the "partner_id" field.
func (m *PartnerContactMutation) SetPartnerID(s string) {
	m.partner = &s
}

// PartnerID returns the value of the "partner_id" field in the mutation.
func (m *PartnerContactMutation) PartnerID() (r string, exists bool) {
	v := m.partner
	if v == nil {
		return
	}
	return *v, true
}

// OldPartnerID returns the old "partner_id" field's value of the PartnerContact entity.
// If the PartnerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerContactMutation) OldPartnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartnerID: %w", err)
	}
	return oldValue.PartnerID, nil
}

// ResetPartnerID resets all changes to the "partner_id" field.
func (m *PartnerContactMutation) ResetPartnerID() {
	m.partner = nil
}

// SetUserID sets the "user_id" field.
func (m *PartnerContactMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *PartnerContactMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the PartnerContact entity.
// If the PartnerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerContactMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *PartnerContactMutation) ResetUserID() {
	m.user = nil
}

// SetRole sets the "role" field.
func (m *PartnerContactMutation) SetRole(ecr enum.PartnerContactRole) {
	m.role = &ecr
}

// Role returns the value of the "role" field in the mutation.
func (m *PartnerContactMutation) Role() (r enum.PartnerContactRole, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the PartnerContact entity.
// If the PartnerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerContactMutation) OldRole(ctx context.Context) (v enum.PartnerContactRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *PartnerContactMutation) ResetRole() {
	m.role = nil
}

// SetType sets the "type" field.
func (m *PartnerContactMutation) SetType(ec enum.PartnerContact) {
	m._type = &ec
}

// GetType returns the value of the "type" field in the mutation.
func (m *PartnerContactMutation) GetType() (r enum.PartnerContact, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the PartnerContact entity.
// If the PartnerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerContactMutation) OldType(ctx context.Context) (v enum.PartnerContact, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PartnerContactMutation) ResetType() {
	m._type = nil
}

// SetTitle sets the "title" field.
func (m *PartnerContactMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *PartnerContactMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the PartnerContact entity.
// If the PartnerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerContactMutation) OldTitle(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *PartnerContactMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[partnercontact.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *PartnerContactMutation) TitleCleared() bool {
	_, ok := m.clearedFields[partnercontact.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *PartnerContactMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, partnercontact.FieldTitle)
}

// SetDescription sets the "description" field.
func (m *PartnerContactMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PartnerContactMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the PartnerContact entity.
// If the PartnerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerContactMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PartnerContactMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[partnercontact.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PartnerContactMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[partnercontact.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PartnerContactMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, partnercontact.FieldDescription)
}

// SetInvoicingEmail sets the "invoicing_email" field.
func (m *PartnerContactMutation) SetInvoicingEmail(s string) {
	m.invoicing_email = &s
}

// InvoicingEmail returns the value of the "invoicing_email" field in the mutation.
func (m *PartnerContactMutation) InvoicingEmail() (r string, exists bool) {
	v := m.invoicing_email
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoicingEmail returns the old "invoicing_email" field's value of the PartnerContact entity.
// If the PartnerContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerContactMutation) OldInvoicingEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoicingEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoicingEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoicingEmail: %w", err)
	}
	return oldValue.InvoicingEmail, nil
}

// ClearInvoicingEmail clears the value of the "invoicing_email" field.
func (m *PartnerContactMutation) ClearInvoicingEmail() {
	m.invoicing_email = nil
	m.clearedFields[partnercontact.FieldInvoicingEmail] = struct{}{}
}

// InvoicingEmailCleared returns if the "invoicing_email" field was cleared in this mutation.
func (m *PartnerContactMutation) InvoicingEmailCleared() bool {
	_, ok := m.clearedFields[partnercontact.FieldInvoicingEmail]
	return ok
}

// ResetInvoicingEmail resets all changes to the "invoicing_email" field.
func (m *PartnerContactMutation) ResetInvoicingEmail() {
	m.invoicing_email = nil
	delete(m.clearedFields, partnercontact.FieldInvoicingEmail)
}

// ClearUser clears the "user" edge to the User entity.
func (m *PartnerContactMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *PartnerContactMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PartnerContactMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *PartnerContactMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *PartnerContactMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *PartnerContactMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *PartnerContactMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *PartnerContactMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// AddSessionIDs adds the "sessions" edge to the UserSession entity by ids.
func (m *PartnerContactMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the UserSession entity.
func (m *PartnerContactMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the UserSession entity was cleared.
func (m *PartnerContactMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the UserSession entity by IDs.
func (m *PartnerContactMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the UserSession entity.
func (m *PartnerContactMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *PartnerContactMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *PartnerContactMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// Where appends a list predicates to the PartnerContactMutation builder.
func (m *PartnerContactMutation) Where(ps ...predicate.PartnerContact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnerContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnerContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PartnerContact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnerContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnerContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PartnerContact).
func (m *PartnerContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnerContactMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, partnercontact.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, partnercontact.FieldUpdatedAt)
	}
	if m.partner != nil {
		fields = append(fields, partnercontact.FieldPartnerID)
	}
	if m.user != nil {
		fields = append(fields, partnercontact.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, partnercontact.FieldRole)
	}
	if m._type != nil {
		fields = append(fields, partnercontact.FieldType)
	}
	if m.title != nil {
		fields = append(fields, partnercontact.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, partnercontact.FieldDescription)
	}
	if m.invoicing_email != nil {
		fields = append(fields, partnercontact.FieldInvoicingEmail)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnerContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partnercontact.FieldCreatedAt:
		return m.CreatedAt()
	case partnercontact.FieldUpdatedAt:
		return m.UpdatedAt()
	case partnercontact.FieldPartnerID:
		return m.PartnerID()
	case partnercontact.FieldUserID:
		return m.UserID()
	case partnercontact.FieldRole:
		return m.Role()
	case partnercontact.FieldType:
		return m.GetType()
	case partnercontact.FieldTitle:
		return m.Title()
	case partnercontact.FieldDescription:
		return m.Description()
	case partnercontact.FieldInvoicingEmail:
		return m.InvoicingEmail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnerContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partnercontact.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partnercontact.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case partnercontact.FieldPartnerID:
		return m.OldPartnerID(ctx)
	case partnercontact.FieldUserID:
		return m.OldUserID(ctx)
	case partnercontact.FieldRole:
		return m.OldRole(ctx)
	case partnercontact.FieldType:
		return m.OldType(ctx)
	case partnercontact.FieldTitle:
		return m.OldTitle(ctx)
	case partnercontact.FieldDescription:
		return m.OldDescription(ctx)
	case partnercontact.FieldInvoicingEmail:
		return m.OldInvoicingEmail(ctx)
	}
	return nil, fmt.Errorf("unknown PartnerContact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partnercontact.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partnercontact.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case partnercontact.FieldPartnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartnerID(v)
		return nil
	case partnercontact.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case partnercontact.FieldRole:
		v, ok := value.(enum.PartnerContactRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case partnercontact.FieldType:
		v, ok := value.(enum.PartnerContact)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case partnercontact.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case partnercontact.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case partnercontact.FieldInvoicingEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoicingEmail(v)
		return nil
	}
	return fmt.Errorf("unknown PartnerContact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnerContactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnerContactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PartnerContact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnerContactMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partnercontact.FieldTitle) {
		fields = append(fields, partnercontact.FieldTitle)
	}
	if m.FieldCleared(partnercontact.FieldDescription) {
		fields = append(fields, partnercontact.FieldDescription)
	}
	if m.FieldCleared(partnercontact.FieldInvoicingEmail) {
		fields = append(fields, partnercontact.FieldInvoicingEmail)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnerContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnerContactMutation) ClearField(name string) error {
	switch name {
	case partnercontact.FieldTitle:
		m.ClearTitle()
		return nil
	case partnercontact.FieldDescription:
		m.ClearDescription()
		return nil
	case partnercontact.FieldInvoicingEmail:
		m.ClearInvoicingEmail()
		return nil
	}
	return fmt.Errorf("unknown PartnerContact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnerContactMutation) ResetField(name string) error {
	switch name {
	case partnercontact.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partnercontact.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case partnercontact.FieldPartnerID:
		m.ResetPartnerID()
		return nil
	case partnercontact.FieldUserID:
		m.ResetUserID()
		return nil
	case partnercontact.FieldRole:
		m.ResetRole()
		return nil
	case partnercontact.FieldType:
		m.ResetType()
		return nil
	case partnercontact.FieldTitle:
		m.ResetTitle()
		return nil
	case partnercontact.FieldDescription:
		m.ResetDescription()
		return nil
	case partnercontact.FieldInvoicingEmail:
		m.ResetInvoicingEmail()
		return nil
	}
	return fmt.Errorf("unknown PartnerContact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnerContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, partnercontact.EdgeUser)
	}
	if m.partner != nil {
		edges = append(edges, partnercontact.EdgePartner)
	}
	if m.sessions != nil {
		edges = append(edges, partnercontact.EdgeSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnerContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partnercontact.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case partnercontact.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	case partnercontact.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnerContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsessions != nil {
		edges = append(edges, partnercontact.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnerContactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case partnercontact.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnerContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, partnercontact.EdgeUser)
	}
	if m.clearedpartner {
		edges = append(edges, partnercontact.EdgePartner)
	}
	if m.clearedsessions {
		edges = append(edges, partnercontact.EdgeSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnerContactMutation) EdgeCleared(name string) bool {
	switch name {
	case partnercontact.EdgeUser:
		return m.cleareduser
	case partnercontact.EdgePartner:
		return m.clearedpartner
	case partnercontact.EdgeSessions:
		return m.clearedsessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnerContactMutation) ClearEdge(name string) error {
	switch name {
	case partnercontact.EdgeUser:
		m.ClearUser()
		return nil
	case partnercontact.EdgePartner:
		m.ClearPartner()
		return nil
	}
	return fmt.Errorf("unknown PartnerContact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnerContactMutation) ResetEdge(name string) error {
	switch name {
	case partnercontact.EdgeUser:
		m.ResetUser()
		return nil
	case partnercontact.EdgePartner:
		m.ResetPartner()
		return nil
	case partnercontact.EdgeSessions:
		m.ResetSessions()
		return nil
	}
	return fmt.Errorf("unknown PartnerContact edge %s", name)
}

// PartnerServiceMutation represents an operation that mutates the PartnerService nodes in the graph.
type PartnerServiceMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	service_id     *uint8
	addservice_id  *int8
	active         *bool
	clearedFields  map[string]struct{}
	partner        *string
	clearedpartner bool
	done           bool
	oldValue       func(context.Context) (*PartnerService, error)
	predicates     []predicate.PartnerService
}

var _ ent.Mutation = (*PartnerServiceMutation)(nil)

// partnerserviceOption allows management of the mutation configuration using functional options.
type partnerserviceOption func(*PartnerServiceMutation)

// newPartnerServiceMutation creates new mutation for the PartnerService entity.
func newPartnerServiceMutation(c config, op Op, opts ...partnerserviceOption) *PartnerServiceMutation {
	m := &PartnerServiceMutation{
		config:        c,
		op:            op,
		typ:           TypePartnerService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnerServiceID sets the ID field of the mutation.
func withPartnerServiceID(id string) partnerserviceOption {
	return func(m *PartnerServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *PartnerService
		)
		m.oldValue = func(ctx context.Context) (*PartnerService, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartnerService.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnerService sets the old PartnerService of the mutation.
func withPartnerService(node *PartnerService) partnerserviceOption {
	return func(m *PartnerServiceMutation) {
		m.oldValue = func(context.Context) (*PartnerService, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnerServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnerServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PartnerService entities.
func (m *PartnerServiceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnerServiceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnerServiceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PartnerService.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnerServiceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnerServiceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PartnerService entity.
// If the PartnerService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnerServiceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartnerServiceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartnerServiceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PartnerService entity.
// If the PartnerService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartnerServiceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetServiceID sets the "service_id" field.
func (m *PartnerServiceMutation) SetServiceID(u uint8) {
	m.service_id = &u
	m.addservice_id = nil
}

// ServiceID returns the value of the "service_id" field in the mutation.
func (m *PartnerServiceMutation) ServiceID() (r uint8, exists bool) {
	v := m.service_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceID returns the old "service_id" field's value of the PartnerService entity.
// If the PartnerService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceMutation) OldServiceID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceID: %w", err)
	}
	return oldValue.ServiceID, nil
}

// AddServiceID adds u to the "service_id" field.
func (m *PartnerServiceMutation) AddServiceID(u int8) {
	if m.addservice_id != nil {
		*m.addservice_id += u
	} else {
		m.addservice_id = &u
	}
}

// AddedServiceID returns the value that was added to the "service_id" field in this mutation.
func (m *PartnerServiceMutation) AddedServiceID() (r int8, exists bool) {
	v := m.addservice_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetServiceID resets all changes to the "service_id" field.
func (m *PartnerServiceMutation) ResetServiceID() {
	m.service_id = nil
	m.addservice_id = nil
}

// SetActive sets the "active" field.
func (m *PartnerServiceMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *PartnerServiceMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the PartnerService entity.
// If the PartnerService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *PartnerServiceMutation) ResetActive() {
	m.active = nil
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *PartnerServiceMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *PartnerServiceMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *PartnerServiceMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *PartnerServiceMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *PartnerServiceMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *PartnerServiceMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// Where appends a list predicates to the PartnerServiceMutation builder.
func (m *PartnerServiceMutation) Where(ps ...predicate.PartnerService) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnerServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnerServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PartnerService, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnerServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnerServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PartnerService).
func (m *PartnerServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnerServiceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, partnerservice.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, partnerservice.FieldUpdatedAt)
	}
	if m.service_id != nil {
		fields = append(fields, partnerservice.FieldServiceID)
	}
	if m.active != nil {
		fields = append(fields, partnerservice.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnerServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partnerservice.FieldCreatedAt:
		return m.CreatedAt()
	case partnerservice.FieldUpdatedAt:
		return m.UpdatedAt()
	case partnerservice.FieldServiceID:
		return m.ServiceID()
	case partnerservice.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnerServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partnerservice.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partnerservice.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case partnerservice.FieldServiceID:
		return m.OldServiceID(ctx)
	case partnerservice.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown PartnerService field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partnerservice.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partnerservice.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case partnerservice.FieldServiceID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceID(v)
		return nil
	case partnerservice.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown PartnerService field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnerServiceMutation) AddedFields() []string {
	var fields []string
	if m.addservice_id != nil {
		fields = append(fields, partnerservice.FieldServiceID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnerServiceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case partnerservice.FieldServiceID:
		return m.AddedServiceID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case partnerservice.FieldServiceID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddServiceID(v)
		return nil
	}
	return fmt.Errorf("unknown PartnerService numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnerServiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnerServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnerServiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PartnerService nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnerServiceMutation) ResetField(name string) error {
	switch name {
	case partnerservice.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partnerservice.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case partnerservice.FieldServiceID:
		m.ResetServiceID()
		return nil
	case partnerservice.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown PartnerService field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnerServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.partner != nil {
		edges = append(edges, partnerservice.EdgePartner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnerServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partnerservice.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnerServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnerServiceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnerServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpartner {
		edges = append(edges, partnerservice.EdgePartner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnerServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case partnerservice.EdgePartner:
		return m.clearedpartner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnerServiceMutation) ClearEdge(name string) error {
	switch name {
	case partnerservice.EdgePartner:
		m.ClearPartner()
		return nil
	}
	return fmt.Errorf("unknown PartnerService unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnerServiceMutation) ResetEdge(name string) error {
	switch name {
	case partnerservice.EdgePartner:
		m.ResetPartner()
		return nil
	}
	return fmt.Errorf("unknown PartnerService edge %s", name)
}

// PartnerServiceCityMutation represents an operation that mutates the PartnerServiceCity nodes in the graph.
type PartnerServiceCityMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	postal_id      *string
	active         *bool
	name           *string
	naics_code     *uint
	addnaics_code  *int
	license_no     *string
	proof_doc_id   *string
	clearedFields  map[string]struct{}
	partner        *string
	clearedpartner bool
	done           bool
	oldValue       func(context.Context) (*PartnerServiceCity, error)
	predicates     []predicate.PartnerServiceCity
}

var _ ent.Mutation = (*PartnerServiceCityMutation)(nil)

// partnerservicecityOption allows management of the mutation configuration using functional options.
type partnerservicecityOption func(*PartnerServiceCityMutation)

// newPartnerServiceCityMutation creates new mutation for the PartnerServiceCity entity.
func newPartnerServiceCityMutation(c config, op Op, opts ...partnerservicecityOption) *PartnerServiceCityMutation {
	m := &PartnerServiceCityMutation{
		config:        c,
		op:            op,
		typ:           TypePartnerServiceCity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnerServiceCityID sets the ID field of the mutation.
func withPartnerServiceCityID(id string) partnerservicecityOption {
	return func(m *PartnerServiceCityMutation) {
		var (
			err   error
			once  sync.Once
			value *PartnerServiceCity
		)
		m.oldValue = func(ctx context.Context) (*PartnerServiceCity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartnerServiceCity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnerServiceCity sets the old PartnerServiceCity of the mutation.
func withPartnerServiceCity(node *PartnerServiceCity) partnerservicecityOption {
	return func(m *PartnerServiceCityMutation) {
		m.oldValue = func(context.Context) (*PartnerServiceCity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnerServiceCityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnerServiceCityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PartnerServiceCity entities.
func (m *PartnerServiceCityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnerServiceCityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnerServiceCityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PartnerServiceCity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnerServiceCityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnerServiceCityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PartnerServiceCity entity.
// If the PartnerServiceCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceCityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnerServiceCityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartnerServiceCityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartnerServiceCityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PartnerServiceCity entity.
// If the PartnerServiceCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceCityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartnerServiceCityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPostalID sets the "postal_id" field.
func (m *PartnerServiceCityMutation) SetPostalID(s string) {
	m.postal_id = &s
}

// PostalID returns the value of the "postal_id" field in the mutation.
func (m *PartnerServiceCityMutation) PostalID() (r string, exists bool) {
	v := m.postal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalID returns the old "postal_id" field's value of the PartnerServiceCity entity.
// If the PartnerServiceCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceCityMutation) OldPostalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalID: %w", err)
	}
	return oldValue.PostalID, nil
}

// ResetPostalID resets all changes to the "postal_id" field.
func (m *PartnerServiceCityMutation) ResetPostalID() {
	m.postal_id = nil
}

// SetActive sets the "active" field.
func (m *PartnerServiceCityMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *PartnerServiceCityMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the PartnerServiceCity entity.
// If the PartnerServiceCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceCityMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *PartnerServiceCityMutation) ResetActive() {
	m.active = nil
}

// SetName sets the "name" field.
func (m *PartnerServiceCityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PartnerServiceCityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PartnerServiceCity entity.
// If the PartnerServiceCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceCityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PartnerServiceCityMutation) ResetName() {
	m.name = nil
}

// SetNaicsCode sets the "naics_code" field.
func (m *PartnerServiceCityMutation) SetNaicsCode(u uint) {
	m.naics_code = &u
	m.addnaics_code = nil
}

// NaicsCode returns the value of the "naics_code" field in the mutation.
func (m *PartnerServiceCityMutation) NaicsCode() (r uint, exists bool) {
	v := m.naics_code
	if v == nil {
		return
	}
	return *v, true
}

// OldNaicsCode returns the old "naics_code" field's value of the PartnerServiceCity entity.
// If the PartnerServiceCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceCityMutation) OldNaicsCode(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNaicsCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNaicsCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNaicsCode: %w", err)
	}
	return oldValue.NaicsCode, nil
}

// AddNaicsCode adds u to the "naics_code" field.
func (m *PartnerServiceCityMutation) AddNaicsCode(u int) {
	if m.addnaics_code != nil {
		*m.addnaics_code += u
	} else {
		m.addnaics_code = &u
	}
}

// AddedNaicsCode returns the value that was added to the "naics_code" field in this mutation.
func (m *PartnerServiceCityMutation) AddedNaicsCode() (r int, exists bool) {
	v := m.addnaics_code
	if v == nil {
		return
	}
	return *v, true
}

// ResetNaicsCode resets all changes to the "naics_code" field.
func (m *PartnerServiceCityMutation) ResetNaicsCode() {
	m.naics_code = nil
	m.addnaics_code = nil
}

// SetLicenseNo sets the "license_no" field.
func (m *PartnerServiceCityMutation) SetLicenseNo(s string) {
	m.license_no = &s
}

// LicenseNo returns the value of the "license_no" field in the mutation.
func (m *PartnerServiceCityMutation) LicenseNo() (r string, exists bool) {
	v := m.license_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseNo returns the old "license_no" field's value of the PartnerServiceCity entity.
// If the PartnerServiceCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceCityMutation) OldLicenseNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseNo: %w", err)
	}
	return oldValue.LicenseNo, nil
}

// ClearLicenseNo clears the value of the "license_no" field.
func (m *PartnerServiceCityMutation) ClearLicenseNo() {
	m.license_no = nil
	m.clearedFields[partnerservicecity.FieldLicenseNo] = struct{}{}
}

// LicenseNoCleared returns if the "license_no" field was cleared in this mutation.
func (m *PartnerServiceCityMutation) LicenseNoCleared() bool {
	_, ok := m.clearedFields[partnerservicecity.FieldLicenseNo]
	return ok
}

// ResetLicenseNo resets all changes to the "license_no" field.
func (m *PartnerServiceCityMutation) ResetLicenseNo() {
	m.license_no = nil
	delete(m.clearedFields, partnerservicecity.FieldLicenseNo)
}

// SetProofDocID sets the "proof_doc_id" field.
func (m *PartnerServiceCityMutation) SetProofDocID(s string) {
	m.proof_doc_id = &s
}

// ProofDocID returns the value of the "proof_doc_id" field in the mutation.
func (m *PartnerServiceCityMutation) ProofDocID() (r string, exists bool) {
	v := m.proof_doc_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProofDocID returns the old "proof_doc_id" field's value of the PartnerServiceCity entity.
// If the PartnerServiceCity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceCityMutation) OldProofDocID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProofDocID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProofDocID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProofDocID: %w", err)
	}
	return oldValue.ProofDocID, nil
}

// ClearProofDocID clears the value of the "proof_doc_id" field.
func (m *PartnerServiceCityMutation) ClearProofDocID() {
	m.proof_doc_id = nil
	m.clearedFields[partnerservicecity.FieldProofDocID] = struct{}{}
}

// ProofDocIDCleared returns if the "proof_doc_id" field was cleared in this mutation.
func (m *PartnerServiceCityMutation) ProofDocIDCleared() bool {
	_, ok := m.clearedFields[partnerservicecity.FieldProofDocID]
	return ok
}

// ResetProofDocID resets all changes to the "proof_doc_id" field.
func (m *PartnerServiceCityMutation) ResetProofDocID() {
	m.proof_doc_id = nil
	delete(m.clearedFields, partnerservicecity.FieldProofDocID)
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *PartnerServiceCityMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *PartnerServiceCityMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *PartnerServiceCityMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *PartnerServiceCityMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *PartnerServiceCityMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *PartnerServiceCityMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// Where appends a list predicates to the PartnerServiceCityMutation builder.
func (m *PartnerServiceCityMutation) Where(ps ...predicate.PartnerServiceCity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnerServiceCityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnerServiceCityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PartnerServiceCity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnerServiceCityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnerServiceCityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PartnerServiceCity).
func (m *PartnerServiceCityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnerServiceCityMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, partnerservicecity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, partnerservicecity.FieldUpdatedAt)
	}
	if m.postal_id != nil {
		fields = append(fields, partnerservicecity.FieldPostalID)
	}
	if m.active != nil {
		fields = append(fields, partnerservicecity.FieldActive)
	}
	if m.name != nil {
		fields = append(fields, partnerservicecity.FieldName)
	}
	if m.naics_code != nil {
		fields = append(fields, partnerservicecity.FieldNaicsCode)
	}
	if m.license_no != nil {
		fields = append(fields, partnerservicecity.FieldLicenseNo)
	}
	if m.proof_doc_id != nil {
		fields = append(fields, partnerservicecity.FieldProofDocID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnerServiceCityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partnerservicecity.FieldCreatedAt:
		return m.CreatedAt()
	case partnerservicecity.FieldUpdatedAt:
		return m.UpdatedAt()
	case partnerservicecity.FieldPostalID:
		return m.PostalID()
	case partnerservicecity.FieldActive:
		return m.Active()
	case partnerservicecity.FieldName:
		return m.Name()
	case partnerservicecity.FieldNaicsCode:
		return m.NaicsCode()
	case partnerservicecity.FieldLicenseNo:
		return m.LicenseNo()
	case partnerservicecity.FieldProofDocID:
		return m.ProofDocID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnerServiceCityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partnerservicecity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partnerservicecity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case partnerservicecity.FieldPostalID:
		return m.OldPostalID(ctx)
	case partnerservicecity.FieldActive:
		return m.OldActive(ctx)
	case partnerservicecity.FieldName:
		return m.OldName(ctx)
	case partnerservicecity.FieldNaicsCode:
		return m.OldNaicsCode(ctx)
	case partnerservicecity.FieldLicenseNo:
		return m.OldLicenseNo(ctx)
	case partnerservicecity.FieldProofDocID:
		return m.OldProofDocID(ctx)
	}
	return nil, fmt.Errorf("unknown PartnerServiceCity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerServiceCityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partnerservicecity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partnerservicecity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case partnerservicecity.FieldPostalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalID(v)
		return nil
	case partnerservicecity.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case partnerservicecity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case partnerservicecity.FieldNaicsCode:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNaicsCode(v)
		return nil
	case partnerservicecity.FieldLicenseNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseNo(v)
		return nil
	case partnerservicecity.FieldProofDocID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProofDocID(v)
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceCity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnerServiceCityMutation) AddedFields() []string {
	var fields []string
	if m.addnaics_code != nil {
		fields = append(fields, partnerservicecity.FieldNaicsCode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnerServiceCityMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case partnerservicecity.FieldNaicsCode:
		return m.AddedNaicsCode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerServiceCityMutation) AddField(name string, value ent.Value) error {
	switch name {
	case partnerservicecity.FieldNaicsCode:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNaicsCode(v)
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceCity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnerServiceCityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partnerservicecity.FieldLicenseNo) {
		fields = append(fields, partnerservicecity.FieldLicenseNo)
	}
	if m.FieldCleared(partnerservicecity.FieldProofDocID) {
		fields = append(fields, partnerservicecity.FieldProofDocID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnerServiceCityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnerServiceCityMutation) ClearField(name string) error {
	switch name {
	case partnerservicecity.FieldLicenseNo:
		m.ClearLicenseNo()
		return nil
	case partnerservicecity.FieldProofDocID:
		m.ClearProofDocID()
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceCity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnerServiceCityMutation) ResetField(name string) error {
	switch name {
	case partnerservicecity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partnerservicecity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case partnerservicecity.FieldPostalID:
		m.ResetPostalID()
		return nil
	case partnerservicecity.FieldActive:
		m.ResetActive()
		return nil
	case partnerservicecity.FieldName:
		m.ResetName()
		return nil
	case partnerservicecity.FieldNaicsCode:
		m.ResetNaicsCode()
		return nil
	case partnerservicecity.FieldLicenseNo:
		m.ResetLicenseNo()
		return nil
	case partnerservicecity.FieldProofDocID:
		m.ResetProofDocID()
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceCity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnerServiceCityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.partner != nil {
		edges = append(edges, partnerservicecity.EdgePartner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnerServiceCityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partnerservicecity.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnerServiceCityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnerServiceCityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnerServiceCityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpartner {
		edges = append(edges, partnerservicecity.EdgePartner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnerServiceCityMutation) EdgeCleared(name string) bool {
	switch name {
	case partnerservicecity.EdgePartner:
		return m.clearedpartner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnerServiceCityMutation) ClearEdge(name string) error {
	switch name {
	case partnerservicecity.EdgePartner:
		m.ClearPartner()
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceCity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnerServiceCityMutation) ResetEdge(name string) error {
	switch name {
	case partnerservicecity.EdgePartner:
		m.ResetPartner()
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceCity edge %s", name)
}

// PartnerServiceStateMutation represents an operation that mutates the PartnerServiceState nodes in the graph.
type PartnerServiceStateMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	country          *string
	state            *string
	license_no       *string
	license_exp_date *time.Time
	proof_doc_id     *string
	clearedFields    map[string]struct{}
	partner          *string
	clearedpartner   bool
	done             bool
	oldValue         func(context.Context) (*PartnerServiceState, error)
	predicates       []predicate.PartnerServiceState
}

var _ ent.Mutation = (*PartnerServiceStateMutation)(nil)

// partnerservicestateOption allows management of the mutation configuration using functional options.
type partnerservicestateOption func(*PartnerServiceStateMutation)

// newPartnerServiceStateMutation creates new mutation for the PartnerServiceState entity.
func newPartnerServiceStateMutation(c config, op Op, opts ...partnerservicestateOption) *PartnerServiceStateMutation {
	m := &PartnerServiceStateMutation{
		config:        c,
		op:            op,
		typ:           TypePartnerServiceState,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnerServiceStateID sets the ID field of the mutation.
func withPartnerServiceStateID(id string) partnerservicestateOption {
	return func(m *PartnerServiceStateMutation) {
		var (
			err   error
			once  sync.Once
			value *PartnerServiceState
		)
		m.oldValue = func(ctx context.Context) (*PartnerServiceState, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartnerServiceState.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnerServiceState sets the old PartnerServiceState of the mutation.
func withPartnerServiceState(node *PartnerServiceState) partnerservicestateOption {
	return func(m *PartnerServiceStateMutation) {
		m.oldValue = func(context.Context) (*PartnerServiceState, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnerServiceStateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnerServiceStateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PartnerServiceState entities.
func (m *PartnerServiceStateMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnerServiceStateMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnerServiceStateMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PartnerServiceState.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnerServiceStateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnerServiceStateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PartnerServiceState entity.
// If the PartnerServiceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceStateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnerServiceStateMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartnerServiceStateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartnerServiceStateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PartnerServiceState entity.
// If the PartnerServiceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceStateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartnerServiceStateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCountry sets the "country" field.
func (m *PartnerServiceStateMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *PartnerServiceStateMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the PartnerServiceState entity.
// If the PartnerServiceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceStateMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *PartnerServiceStateMutation) ResetCountry() {
	m.country = nil
}

// SetState sets the "state" field.
func (m *PartnerServiceStateMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *PartnerServiceStateMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the PartnerServiceState entity.
// If the PartnerServiceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceStateMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *PartnerServiceStateMutation) ResetState() {
	m.state = nil
}

// SetLicenseNo sets the "license_no" field.
func (m *PartnerServiceStateMutation) SetLicenseNo(s string) {
	m.license_no = &s
}

// LicenseNo returns the value of the "license_no" field in the mutation.
func (m *PartnerServiceStateMutation) LicenseNo() (r string, exists bool) {
	v := m.license_no
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseNo returns the old "license_no" field's value of the PartnerServiceState entity.
// If the PartnerServiceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceStateMutation) OldLicenseNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseNo: %w", err)
	}
	return oldValue.LicenseNo, nil
}

// ClearLicenseNo clears the value of the "license_no" field.
func (m *PartnerServiceStateMutation) ClearLicenseNo() {
	m.license_no = nil
	m.clearedFields[partnerservicestate.FieldLicenseNo] = struct{}{}
}

// LicenseNoCleared returns if the "license_no" field was cleared in this mutation.
func (m *PartnerServiceStateMutation) LicenseNoCleared() bool {
	_, ok := m.clearedFields[partnerservicestate.FieldLicenseNo]
	return ok
}

// ResetLicenseNo resets all changes to the "license_no" field.
func (m *PartnerServiceStateMutation) ResetLicenseNo() {
	m.license_no = nil
	delete(m.clearedFields, partnerservicestate.FieldLicenseNo)
}

// SetLicenseExpDate sets the "license_exp_date" field.
func (m *PartnerServiceStateMutation) SetLicenseExpDate(t time.Time) {
	m.license_exp_date = &t
}

// LicenseExpDate returns the value of the "license_exp_date" field in the mutation.
func (m *PartnerServiceStateMutation) LicenseExpDate() (r time.Time, exists bool) {
	v := m.license_exp_date
	if v == nil {
		return
	}
	return *v, true
}

// OldLicenseExpDate returns the old "license_exp_date" field's value of the PartnerServiceState entity.
// If the PartnerServiceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceStateMutation) OldLicenseExpDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLicenseExpDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLicenseExpDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLicenseExpDate: %w", err)
	}
	return oldValue.LicenseExpDate, nil
}

// ClearLicenseExpDate clears the value of the "license_exp_date" field.
func (m *PartnerServiceStateMutation) ClearLicenseExpDate() {
	m.license_exp_date = nil
	m.clearedFields[partnerservicestate.FieldLicenseExpDate] = struct{}{}
}

// LicenseExpDateCleared returns if the "license_exp_date" field was cleared in this mutation.
func (m *PartnerServiceStateMutation) LicenseExpDateCleared() bool {
	_, ok := m.clearedFields[partnerservicestate.FieldLicenseExpDate]
	return ok
}

// ResetLicenseExpDate resets all changes to the "license_exp_date" field.
func (m *PartnerServiceStateMutation) ResetLicenseExpDate() {
	m.license_exp_date = nil
	delete(m.clearedFields, partnerservicestate.FieldLicenseExpDate)
}

// SetProofDocID sets the "proof_doc_id" field.
func (m *PartnerServiceStateMutation) SetProofDocID(s string) {
	m.proof_doc_id = &s
}

// ProofDocID returns the value of the "proof_doc_id" field in the mutation.
func (m *PartnerServiceStateMutation) ProofDocID() (r string, exists bool) {
	v := m.proof_doc_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProofDocID returns the old "proof_doc_id" field's value of the PartnerServiceState entity.
// If the PartnerServiceState object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerServiceStateMutation) OldProofDocID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProofDocID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProofDocID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProofDocID: %w", err)
	}
	return oldValue.ProofDocID, nil
}

// ClearProofDocID clears the value of the "proof_doc_id" field.
func (m *PartnerServiceStateMutation) ClearProofDocID() {
	m.proof_doc_id = nil
	m.clearedFields[partnerservicestate.FieldProofDocID] = struct{}{}
}

// ProofDocIDCleared returns if the "proof_doc_id" field was cleared in this mutation.
func (m *PartnerServiceStateMutation) ProofDocIDCleared() bool {
	_, ok := m.clearedFields[partnerservicestate.FieldProofDocID]
	return ok
}

// ResetProofDocID resets all changes to the "proof_doc_id" field.
func (m *PartnerServiceStateMutation) ResetProofDocID() {
	m.proof_doc_id = nil
	delete(m.clearedFields, partnerservicestate.FieldProofDocID)
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *PartnerServiceStateMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *PartnerServiceStateMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *PartnerServiceStateMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *PartnerServiceStateMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *PartnerServiceStateMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *PartnerServiceStateMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// Where appends a list predicates to the PartnerServiceStateMutation builder.
func (m *PartnerServiceStateMutation) Where(ps ...predicate.PartnerServiceState) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnerServiceStateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnerServiceStateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PartnerServiceState, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnerServiceStateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnerServiceStateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PartnerServiceState).
func (m *PartnerServiceStateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnerServiceStateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, partnerservicestate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, partnerservicestate.FieldUpdatedAt)
	}
	if m.country != nil {
		fields = append(fields, partnerservicestate.FieldCountry)
	}
	if m.state != nil {
		fields = append(fields, partnerservicestate.FieldState)
	}
	if m.license_no != nil {
		fields = append(fields, partnerservicestate.FieldLicenseNo)
	}
	if m.license_exp_date != nil {
		fields = append(fields, partnerservicestate.FieldLicenseExpDate)
	}
	if m.proof_doc_id != nil {
		fields = append(fields, partnerservicestate.FieldProofDocID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnerServiceStateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partnerservicestate.FieldCreatedAt:
		return m.CreatedAt()
	case partnerservicestate.FieldUpdatedAt:
		return m.UpdatedAt()
	case partnerservicestate.FieldCountry:
		return m.Country()
	case partnerservicestate.FieldState:
		return m.State()
	case partnerservicestate.FieldLicenseNo:
		return m.LicenseNo()
	case partnerservicestate.FieldLicenseExpDate:
		return m.LicenseExpDate()
	case partnerservicestate.FieldProofDocID:
		return m.ProofDocID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnerServiceStateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partnerservicestate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partnerservicestate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case partnerservicestate.FieldCountry:
		return m.OldCountry(ctx)
	case partnerservicestate.FieldState:
		return m.OldState(ctx)
	case partnerservicestate.FieldLicenseNo:
		return m.OldLicenseNo(ctx)
	case partnerservicestate.FieldLicenseExpDate:
		return m.OldLicenseExpDate(ctx)
	case partnerservicestate.FieldProofDocID:
		return m.OldProofDocID(ctx)
	}
	return nil, fmt.Errorf("unknown PartnerServiceState field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerServiceStateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partnerservicestate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partnerservicestate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case partnerservicestate.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case partnerservicestate.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case partnerservicestate.FieldLicenseNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseNo(v)
		return nil
	case partnerservicestate.FieldLicenseExpDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLicenseExpDate(v)
		return nil
	case partnerservicestate.FieldProofDocID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProofDocID(v)
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceState field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnerServiceStateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnerServiceStateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerServiceStateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PartnerServiceState numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnerServiceStateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(partnerservicestate.FieldLicenseNo) {
		fields = append(fields, partnerservicestate.FieldLicenseNo)
	}
	if m.FieldCleared(partnerservicestate.FieldLicenseExpDate) {
		fields = append(fields, partnerservicestate.FieldLicenseExpDate)
	}
	if m.FieldCleared(partnerservicestate.FieldProofDocID) {
		fields = append(fields, partnerservicestate.FieldProofDocID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnerServiceStateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnerServiceStateMutation) ClearField(name string) error {
	switch name {
	case partnerservicestate.FieldLicenseNo:
		m.ClearLicenseNo()
		return nil
	case partnerservicestate.FieldLicenseExpDate:
		m.ClearLicenseExpDate()
		return nil
	case partnerservicestate.FieldProofDocID:
		m.ClearProofDocID()
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceState nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnerServiceStateMutation) ResetField(name string) error {
	switch name {
	case partnerservicestate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partnerservicestate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case partnerservicestate.FieldCountry:
		m.ResetCountry()
		return nil
	case partnerservicestate.FieldState:
		m.ResetState()
		return nil
	case partnerservicestate.FieldLicenseNo:
		m.ResetLicenseNo()
		return nil
	case partnerservicestate.FieldLicenseExpDate:
		m.ResetLicenseExpDate()
		return nil
	case partnerservicestate.FieldProofDocID:
		m.ResetProofDocID()
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceState field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnerServiceStateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.partner != nil {
		edges = append(edges, partnerservicestate.EdgePartner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnerServiceStateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partnerservicestate.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnerServiceStateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnerServiceStateMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnerServiceStateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpartner {
		edges = append(edges, partnerservicestate.EdgePartner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnerServiceStateMutation) EdgeCleared(name string) bool {
	switch name {
	case partnerservicestate.EdgePartner:
		return m.clearedpartner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnerServiceStateMutation) ClearEdge(name string) error {
	switch name {
	case partnerservicestate.EdgePartner:
		m.ClearPartner()
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceState unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnerServiceStateMutation) ResetEdge(name string) error {
	switch name {
	case partnerservicestate.EdgePartner:
		m.ResetPartner()
		return nil
	}
	return fmt.Errorf("unknown PartnerServiceState edge %s", name)
}

// PartnerTrainingVideoMutation represents an operation that mutates the PartnerTrainingVideo nodes in the graph.
type PartnerTrainingVideoMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	enabled        *bool
	clearedFields  map[string]struct{}
	video          *string
	clearedvideo   bool
	partner        *string
	clearedpartner bool
	done           bool
	oldValue       func(context.Context) (*PartnerTrainingVideo, error)
	predicates     []predicate.PartnerTrainingVideo
}

var _ ent.Mutation = (*PartnerTrainingVideoMutation)(nil)

// partnertrainingvideoOption allows management of the mutation configuration using functional options.
type partnertrainingvideoOption func(*PartnerTrainingVideoMutation)

// newPartnerTrainingVideoMutation creates new mutation for the PartnerTrainingVideo entity.
func newPartnerTrainingVideoMutation(c config, op Op, opts ...partnertrainingvideoOption) *PartnerTrainingVideoMutation {
	m := &PartnerTrainingVideoMutation{
		config:        c,
		op:            op,
		typ:           TypePartnerTrainingVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPartnerTrainingVideoID sets the ID field of the mutation.
func withPartnerTrainingVideoID(id string) partnertrainingvideoOption {
	return func(m *PartnerTrainingVideoMutation) {
		var (
			err   error
			once  sync.Once
			value *PartnerTrainingVideo
		)
		m.oldValue = func(ctx context.Context) (*PartnerTrainingVideo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PartnerTrainingVideo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPartnerTrainingVideo sets the old PartnerTrainingVideo of the mutation.
func withPartnerTrainingVideo(node *PartnerTrainingVideo) partnertrainingvideoOption {
	return func(m *PartnerTrainingVideoMutation) {
		m.oldValue = func(context.Context) (*PartnerTrainingVideo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PartnerTrainingVideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PartnerTrainingVideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PartnerTrainingVideo entities.
func (m *PartnerTrainingVideoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PartnerTrainingVideoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PartnerTrainingVideoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PartnerTrainingVideo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PartnerTrainingVideoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PartnerTrainingVideoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PartnerTrainingVideo entity.
// If the PartnerTrainingVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerTrainingVideoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PartnerTrainingVideoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PartnerTrainingVideoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PartnerTrainingVideoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PartnerTrainingVideo entity.
// If the PartnerTrainingVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerTrainingVideoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PartnerTrainingVideoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEnabled sets the "enabled" field.
func (m *PartnerTrainingVideoMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *PartnerTrainingVideoMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the PartnerTrainingVideo entity.
// If the PartnerTrainingVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PartnerTrainingVideoMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *PartnerTrainingVideoMutation) ResetEnabled() {
	m.enabled = nil
}

// SetVideoID sets the "video" edge to the TrainingVideo entity by id.
func (m *PartnerTrainingVideoMutation) SetVideoID(id string) {
	m.video = &id
}

// ClearVideo clears the "video" edge to the TrainingVideo entity.
func (m *PartnerTrainingVideoMutation) ClearVideo() {
	m.clearedvideo = true
}

// VideoCleared reports if the "video" edge to the TrainingVideo entity was cleared.
func (m *PartnerTrainingVideoMutation) VideoCleared() bool {
	return m.clearedvideo
}

// VideoID returns the "video" edge ID in the mutation.
func (m *PartnerTrainingVideoMutation) VideoID() (id string, exists bool) {
	if m.video != nil {
		return *m.video, true
	}
	return
}

// VideoIDs returns the "video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VideoID instead. It exists only for internal usage by the builders.
func (m *PartnerTrainingVideoMutation) VideoIDs() (ids []string) {
	if id := m.video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVideo resets all changes to the "video" edge.
func (m *PartnerTrainingVideoMutation) ResetVideo() {
	m.video = nil
	m.clearedvideo = false
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *PartnerTrainingVideoMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *PartnerTrainingVideoMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *PartnerTrainingVideoMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *PartnerTrainingVideoMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *PartnerTrainingVideoMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *PartnerTrainingVideoMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// Where appends a list predicates to the PartnerTrainingVideoMutation builder.
func (m *PartnerTrainingVideoMutation) Where(ps ...predicate.PartnerTrainingVideo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PartnerTrainingVideoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PartnerTrainingVideoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PartnerTrainingVideo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PartnerTrainingVideoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PartnerTrainingVideoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PartnerTrainingVideo).
func (m *PartnerTrainingVideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PartnerTrainingVideoMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, partnertrainingvideo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, partnertrainingvideo.FieldUpdatedAt)
	}
	if m.enabled != nil {
		fields = append(fields, partnertrainingvideo.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PartnerTrainingVideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case partnertrainingvideo.FieldCreatedAt:
		return m.CreatedAt()
	case partnertrainingvideo.FieldUpdatedAt:
		return m.UpdatedAt()
	case partnertrainingvideo.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PartnerTrainingVideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case partnertrainingvideo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case partnertrainingvideo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case partnertrainingvideo.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown PartnerTrainingVideo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerTrainingVideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case partnertrainingvideo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case partnertrainingvideo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case partnertrainingvideo.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown PartnerTrainingVideo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PartnerTrainingVideoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PartnerTrainingVideoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PartnerTrainingVideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PartnerTrainingVideo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PartnerTrainingVideoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PartnerTrainingVideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PartnerTrainingVideoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PartnerTrainingVideo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PartnerTrainingVideoMutation) ResetField(name string) error {
	switch name {
	case partnertrainingvideo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case partnertrainingvideo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case partnertrainingvideo.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown PartnerTrainingVideo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PartnerTrainingVideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.video != nil {
		edges = append(edges, partnertrainingvideo.EdgeVideo)
	}
	if m.partner != nil {
		edges = append(edges, partnertrainingvideo.EdgePartner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PartnerTrainingVideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case partnertrainingvideo.EdgeVideo:
		if id := m.video; id != nil {
			return []ent.Value{*id}
		}
	case partnertrainingvideo.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PartnerTrainingVideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PartnerTrainingVideoMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PartnerTrainingVideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvideo {
		edges = append(edges, partnertrainingvideo.EdgeVideo)
	}
	if m.clearedpartner {
		edges = append(edges, partnertrainingvideo.EdgePartner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PartnerTrainingVideoMutation) EdgeCleared(name string) bool {
	switch name {
	case partnertrainingvideo.EdgeVideo:
		return m.clearedvideo
	case partnertrainingvideo.EdgePartner:
		return m.clearedpartner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PartnerTrainingVideoMutation) ClearEdge(name string) error {
	switch name {
	case partnertrainingvideo.EdgeVideo:
		m.ClearVideo()
		return nil
	case partnertrainingvideo.EdgePartner:
		m.ClearPartner()
		return nil
	}
	return fmt.Errorf("unknown PartnerTrainingVideo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PartnerTrainingVideoMutation) ResetEdge(name string) error {
	switch name {
	case partnertrainingvideo.EdgeVideo:
		m.ResetVideo()
		return nil
	case partnertrainingvideo.EdgePartner:
		m.ResetPartner()
		return nil
	}
	return fmt.Errorf("unknown PartnerTrainingVideo edge %s", name)
}

// PaymentMutation represents an operation that mutates the Payment nodes in the graph.
type PaymentMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	amount        *float64
	addamount     *float64
	status_id     *uint8
	addstatus_id  *int8
	clearedFields map[string]struct{}
	job           *string
	clearedjob    bool
	done          bool
	oldValue      func(context.Context) (*Payment, error)
	predicates    []predicate.Payment
}

var _ ent.Mutation = (*PaymentMutation)(nil)

// paymentOption allows management of the mutation configuration using functional options.
type paymentOption func(*PaymentMutation)

// newPaymentMutation creates new mutation for the Payment entity.
func newPaymentMutation(c config, op Op, opts ...paymentOption) *PaymentMutation {
	m := &PaymentMutation{
		config:        c,
		op:            op,
		typ:           TypePayment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPaymentID sets the ID field of the mutation.
func withPaymentID(id string) paymentOption {
	return func(m *PaymentMutation) {
		var (
			err   error
			once  sync.Once
			value *Payment
		)
		m.oldValue = func(ctx context.Context) (*Payment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Payment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPayment sets the old Payment of the mutation.
func withPayment(node *Payment) paymentOption {
	return func(m *PaymentMutation) {
		m.oldValue = func(context.Context) (*Payment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PaymentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PaymentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Payment entities.
func (m *PaymentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PaymentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PaymentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Payment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PaymentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PaymentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PaymentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PaymentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PaymentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PaymentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetAmount sets the "amount" field.
func (m *PaymentMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *PaymentMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *PaymentMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *PaymentMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ResetAmount resets all changes to the "amount" field.
func (m *PaymentMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
}

// SetStatusID sets the "status_id" field.
func (m *PaymentMutation) SetStatusID(u uint8) {
	m.status_id = &u
	m.addstatus_id = nil
}

// StatusID returns the value of the "status_id" field in the mutation.
func (m *PaymentMutation) StatusID() (r uint8, exists bool) {
	v := m.status_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusID returns the old "status_id" field's value of the Payment entity.
// If the Payment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PaymentMutation) OldStatusID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusID: %w", err)
	}
	return oldValue.StatusID, nil
}

// AddStatusID adds u to the "status_id" field.
func (m *PaymentMutation) AddStatusID(u int8) {
	if m.addstatus_id != nil {
		*m.addstatus_id += u
	} else {
		m.addstatus_id = &u
	}
}

// AddedStatusID returns the value that was added to the "status_id" field in this mutation.
func (m *PaymentMutation) AddedStatusID() (r int8, exists bool) {
	v := m.addstatus_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatusID resets all changes to the "status_id" field.
func (m *PaymentMutation) ResetStatusID() {
	m.status_id = nil
	m.addstatus_id = nil
}

// SetJobID sets the "job" edge to the Job entity by id.
func (m *PaymentMutation) SetJobID(id string) {
	m.job = &id
}

// ClearJob clears the "job" edge to the Job entity.
func (m *PaymentMutation) ClearJob() {
	m.clearedjob = true
}

// JobCleared reports if the "job" edge to the Job entity was cleared.
func (m *PaymentMutation) JobCleared() bool {
	return m.clearedjob
}

// JobID returns the "job" edge ID in the mutation.
func (m *PaymentMutation) JobID() (id string, exists bool) {
	if m.job != nil {
		return *m.job, true
	}
	return
}

// JobIDs returns the "job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// JobID instead. It exists only for internal usage by the builders.
func (m *PaymentMutation) JobIDs() (ids []string) {
	if id := m.job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetJob resets all changes to the "job" edge.
func (m *PaymentMutation) ResetJob() {
	m.job = nil
	m.clearedjob = false
}

// Where appends a list predicates to the PaymentMutation builder.
func (m *PaymentMutation) Where(ps ...predicate.Payment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PaymentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PaymentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Payment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PaymentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PaymentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Payment).
func (m *PaymentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PaymentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, payment.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, payment.FieldUpdatedAt)
	}
	if m.amount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.status_id != nil {
		fields = append(fields, payment.FieldStatusID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PaymentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldCreatedAt:
		return m.CreatedAt()
	case payment.FieldUpdatedAt:
		return m.UpdatedAt()
	case payment.FieldAmount:
		return m.Amount()
	case payment.FieldStatusID:
		return m.StatusID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PaymentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case payment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case payment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case payment.FieldAmount:
		return m.OldAmount(ctx)
	case payment.FieldStatusID:
		return m.OldStatusID(ctx)
	}
	return nil, fmt.Errorf("unknown Payment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case payment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case payment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case payment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case payment.FieldStatusID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusID(v)
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PaymentMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, payment.FieldAmount)
	}
	if m.addstatus_id != nil {
		fields = append(fields, payment.FieldStatusID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PaymentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case payment.FieldAmount:
		return m.AddedAmount()
	case payment.FieldStatusID:
		return m.AddedStatusID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PaymentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case payment.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case payment.FieldStatusID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusID(v)
		return nil
	}
	return fmt.Errorf("unknown Payment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PaymentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PaymentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PaymentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Payment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PaymentMutation) ResetField(name string) error {
	switch name {
	case payment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case payment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case payment.FieldAmount:
		m.ResetAmount()
		return nil
	case payment.FieldStatusID:
		m.ResetStatusID()
		return nil
	}
	return fmt.Errorf("unknown Payment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PaymentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.job != nil {
		edges = append(edges, payment.EdgeJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PaymentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case payment.EdgeJob:
		if id := m.job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PaymentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PaymentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PaymentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedjob {
		edges = append(edges, payment.EdgeJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PaymentMutation) EdgeCleared(name string) bool {
	switch name {
	case payment.EdgeJob:
		return m.clearedjob
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PaymentMutation) ClearEdge(name string) error {
	switch name {
	case payment.EdgeJob:
		m.ClearJob()
		return nil
	}
	return fmt.Errorf("unknown Payment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PaymentMutation) ResetEdge(name string) error {
	switch name {
	case payment.EdgeJob:
		m.ResetJob()
		return nil
	}
	return fmt.Errorf("unknown Payment edge %s", name)
}

// PostalCodeMutation represents an operation that mutates the PostalCode nodes in the graph.
type PostalCodeMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	country        *string
	code           *string
	city           *string
	state          *string
	state_abr      *string
	region_id      *uint8
	addregion_id   *int8
	latitude       *float64
	addlatitude    *float64
	longitude      *float64
	addlongitude   *float64
	accuracy       *uint8
	addaccuracy    *int8
	service_area   *bool
	clearedFields  map[string]struct{}
	pricing        map[string]struct{}
	removedpricing map[string]struct{}
	clearedpricing bool
	done           bool
	oldValue       func(context.Context) (*PostalCode, error)
	predicates     []predicate.PostalCode
}

var _ ent.Mutation = (*PostalCodeMutation)(nil)

// postalcodeOption allows management of the mutation configuration using functional options.
type postalcodeOption func(*PostalCodeMutation)

// newPostalCodeMutation creates new mutation for the PostalCode entity.
func newPostalCodeMutation(c config, op Op, opts ...postalcodeOption) *PostalCodeMutation {
	m := &PostalCodeMutation{
		config:        c,
		op:            op,
		typ:           TypePostalCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostalCodeID sets the ID field of the mutation.
func withPostalCodeID(id string) postalcodeOption {
	return func(m *PostalCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *PostalCode
		)
		m.oldValue = func(ctx context.Context) (*PostalCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostalCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostalCode sets the old PostalCode of the mutation.
func withPostalCode(node *PostalCode) postalcodeOption {
	return func(m *PostalCodeMutation) {
		m.oldValue = func(context.Context) (*PostalCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostalCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostalCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostalCode entities.
func (m *PostalCodeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostalCodeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostalCodeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostalCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostalCodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostalCodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostalCodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostalCodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostalCodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostalCodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCountry sets the "country" field.
func (m *PostalCodeMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *PostalCodeMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *PostalCodeMutation) ResetCountry() {
	m.country = nil
}

// SetCode sets the "code" field.
func (m *PostalCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PostalCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PostalCodeMutation) ResetCode() {
	m.code = nil
}

// SetCity sets the "city" field.
func (m *PostalCodeMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *PostalCodeMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *PostalCodeMutation) ResetCity() {
	m.city = nil
}

// SetState sets the "state" field.
func (m *PostalCodeMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *PostalCodeMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ResetState resets all changes to the "state" field.
func (m *PostalCodeMutation) ResetState() {
	m.state = nil
}

// SetStateAbr sets the "state_abr" field.
func (m *PostalCodeMutation) SetStateAbr(s string) {
	m.state_abr = &s
}

// StateAbr returns the value of the "state_abr" field in the mutation.
func (m *PostalCodeMutation) StateAbr() (r string, exists bool) {
	v := m.state_abr
	if v == nil {
		return
	}
	return *v, true
}

// OldStateAbr returns the old "state_abr" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldStateAbr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateAbr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateAbr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateAbr: %w", err)
	}
	return oldValue.StateAbr, nil
}

// ResetStateAbr resets all changes to the "state_abr" field.
func (m *PostalCodeMutation) ResetStateAbr() {
	m.state_abr = nil
}

// SetRegionID sets the "region_id" field.
func (m *PostalCodeMutation) SetRegionID(u uint8) {
	m.region_id = &u
	m.addregion_id = nil
}

// RegionID returns the value of the "region_id" field in the mutation.
func (m *PostalCodeMutation) RegionID() (r uint8, exists bool) {
	v := m.region_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRegionID returns the old "region_id" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldRegionID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegionID: %w", err)
	}
	return oldValue.RegionID, nil
}

// AddRegionID adds u to the "region_id" field.
func (m *PostalCodeMutation) AddRegionID(u int8) {
	if m.addregion_id != nil {
		*m.addregion_id += u
	} else {
		m.addregion_id = &u
	}
}

// AddedRegionID returns the value that was added to the "region_id" field in this mutation.
func (m *PostalCodeMutation) AddedRegionID() (r int8, exists bool) {
	v := m.addregion_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegionID resets all changes to the "region_id" field.
func (m *PostalCodeMutation) ResetRegionID() {
	m.region_id = nil
	m.addregion_id = nil
}

// SetLatitude sets the "latitude" field.
func (m *PostalCodeMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *PostalCodeMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *PostalCodeMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *PostalCodeMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *PostalCodeMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *PostalCodeMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *PostalCodeMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *PostalCodeMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *PostalCodeMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *PostalCodeMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetAccuracy sets the "accuracy" field.
func (m *PostalCodeMutation) SetAccuracy(u uint8) {
	m.accuracy = &u
	m.addaccuracy = nil
}

// Accuracy returns the value of the "accuracy" field in the mutation.
func (m *PostalCodeMutation) Accuracy() (r uint8, exists bool) {
	v := m.accuracy
	if v == nil {
		return
	}
	return *v, true
}

// OldAccuracy returns the old "accuracy" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldAccuracy(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccuracy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccuracy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccuracy: %w", err)
	}
	return oldValue.Accuracy, nil
}

// AddAccuracy adds u to the "accuracy" field.
func (m *PostalCodeMutation) AddAccuracy(u int8) {
	if m.addaccuracy != nil {
		*m.addaccuracy += u
	} else {
		m.addaccuracy = &u
	}
}

// AddedAccuracy returns the value that was added to the "accuracy" field in this mutation.
func (m *PostalCodeMutation) AddedAccuracy() (r int8, exists bool) {
	v := m.addaccuracy
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccuracy resets all changes to the "accuracy" field.
func (m *PostalCodeMutation) ResetAccuracy() {
	m.accuracy = nil
	m.addaccuracy = nil
}

// SetServiceArea sets the "service_area" field.
func (m *PostalCodeMutation) SetServiceArea(b bool) {
	m.service_area = &b
}

// ServiceArea returns the value of the "service_area" field in the mutation.
func (m *PostalCodeMutation) ServiceArea() (r bool, exists bool) {
	v := m.service_area
	if v == nil {
		return
	}
	return *v, true
}

// OldServiceArea returns the old "service_area" field's value of the PostalCode entity.
// If the PostalCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostalCodeMutation) OldServiceArea(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServiceArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServiceArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServiceArea: %w", err)
	}
	return oldValue.ServiceArea, nil
}

// ResetServiceArea resets all changes to the "service_area" field.
func (m *PostalCodeMutation) ResetServiceArea() {
	m.service_area = nil
}

// AddPricingIDs adds the "pricing" edge to the Pricing entity by ids.
func (m *PostalCodeMutation) AddPricingIDs(ids ...string) {
	if m.pricing == nil {
		m.pricing = make(map[string]struct{})
	}
	for i := range ids {
		m.pricing[ids[i]] = struct{}{}
	}
}

// ClearPricing clears the "pricing" edge to the Pricing entity.
func (m *PostalCodeMutation) ClearPricing() {
	m.clearedpricing = true
}

// PricingCleared reports if the "pricing" edge to the Pricing entity was cleared.
func (m *PostalCodeMutation) PricingCleared() bool {
	return m.clearedpricing
}

// RemovePricingIDs removes the "pricing" edge to the Pricing entity by IDs.
func (m *PostalCodeMutation) RemovePricingIDs(ids ...string) {
	if m.removedpricing == nil {
		m.removedpricing = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.pricing, ids[i])
		m.removedpricing[ids[i]] = struct{}{}
	}
}

// RemovedPricing returns the removed IDs of the "pricing" edge to the Pricing entity.
func (m *PostalCodeMutation) RemovedPricingIDs() (ids []string) {
	for id := range m.removedpricing {
		ids = append(ids, id)
	}
	return
}

// PricingIDs returns the "pricing" edge IDs in the mutation.
func (m *PostalCodeMutation) PricingIDs() (ids []string) {
	for id := range m.pricing {
		ids = append(ids, id)
	}
	return
}

// ResetPricing resets all changes to the "pricing" edge.
func (m *PostalCodeMutation) ResetPricing() {
	m.pricing = nil
	m.clearedpricing = false
	m.removedpricing = nil
}

// Where appends a list predicates to the PostalCodeMutation builder.
func (m *PostalCodeMutation) Where(ps ...predicate.PostalCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostalCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostalCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostalCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostalCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostalCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostalCode).
func (m *PostalCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostalCodeMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, postalcode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, postalcode.FieldUpdatedAt)
	}
	if m.country != nil {
		fields = append(fields, postalcode.FieldCountry)
	}
	if m.code != nil {
		fields = append(fields, postalcode.FieldCode)
	}
	if m.city != nil {
		fields = append(fields, postalcode.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, postalcode.FieldState)
	}
	if m.state_abr != nil {
		fields = append(fields, postalcode.FieldStateAbr)
	}
	if m.region_id != nil {
		fields = append(fields, postalcode.FieldRegionID)
	}
	if m.latitude != nil {
		fields = append(fields, postalcode.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, postalcode.FieldLongitude)
	}
	if m.accuracy != nil {
		fields = append(fields, postalcode.FieldAccuracy)
	}
	if m.service_area != nil {
		fields = append(fields, postalcode.FieldServiceArea)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostalCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postalcode.FieldCreatedAt:
		return m.CreatedAt()
	case postalcode.FieldUpdatedAt:
		return m.UpdatedAt()
	case postalcode.FieldCountry:
		return m.Country()
	case postalcode.FieldCode:
		return m.Code()
	case postalcode.FieldCity:
		return m.City()
	case postalcode.FieldState:
		return m.State()
	case postalcode.FieldStateAbr:
		return m.StateAbr()
	case postalcode.FieldRegionID:
		return m.RegionID()
	case postalcode.FieldLatitude:
		return m.Latitude()
	case postalcode.FieldLongitude:
		return m.Longitude()
	case postalcode.FieldAccuracy:
		return m.Accuracy()
	case postalcode.FieldServiceArea:
		return m.ServiceArea()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostalCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postalcode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case postalcode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case postalcode.FieldCountry:
		return m.OldCountry(ctx)
	case postalcode.FieldCode:
		return m.OldCode(ctx)
	case postalcode.FieldCity:
		return m.OldCity(ctx)
	case postalcode.FieldState:
		return m.OldState(ctx)
	case postalcode.FieldStateAbr:
		return m.OldStateAbr(ctx)
	case postalcode.FieldRegionID:
		return m.OldRegionID(ctx)
	case postalcode.FieldLatitude:
		return m.OldLatitude(ctx)
	case postalcode.FieldLongitude:
		return m.OldLongitude(ctx)
	case postalcode.FieldAccuracy:
		return m.OldAccuracy(ctx)
	case postalcode.FieldServiceArea:
		return m.OldServiceArea(ctx)
	}
	return nil, fmt.Errorf("unknown PostalCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostalCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postalcode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case postalcode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case postalcode.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case postalcode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case postalcode.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case postalcode.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case postalcode.FieldStateAbr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateAbr(v)
		return nil
	case postalcode.FieldRegionID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegionID(v)
		return nil
	case postalcode.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case postalcode.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	case postalcode.FieldAccuracy:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccuracy(v)
		return nil
	case postalcode.FieldServiceArea:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServiceArea(v)
		return nil
	}
	return fmt.Errorf("unknown PostalCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostalCodeMutation) AddedFields() []string {
	var fields []string
	if m.addregion_id != nil {
		fields = append(fields, postalcode.FieldRegionID)
	}
	if m.addlatitude != nil {
		fields = append(fields, postalcode.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, postalcode.FieldLongitude)
	}
	if m.addaccuracy != nil {
		fields = append(fields, postalcode.FieldAccuracy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostalCodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case postalcode.FieldRegionID:
		return m.AddedRegionID()
	case postalcode.FieldLatitude:
		return m.AddedLatitude()
	case postalcode.FieldLongitude:
		return m.AddedLongitude()
	case postalcode.FieldAccuracy:
		return m.AddedAccuracy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostalCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case postalcode.FieldRegionID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegionID(v)
		return nil
	case postalcode.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case postalcode.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	case postalcode.FieldAccuracy:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccuracy(v)
		return nil
	}
	return fmt.Errorf("unknown PostalCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostalCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostalCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostalCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PostalCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostalCodeMutation) ResetField(name string) error {
	switch name {
	case postalcode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case postalcode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case postalcode.FieldCountry:
		m.ResetCountry()
		return nil
	case postalcode.FieldCode:
		m.ResetCode()
		return nil
	case postalcode.FieldCity:
		m.ResetCity()
		return nil
	case postalcode.FieldState:
		m.ResetState()
		return nil
	case postalcode.FieldStateAbr:
		m.ResetStateAbr()
		return nil
	case postalcode.FieldRegionID:
		m.ResetRegionID()
		return nil
	case postalcode.FieldLatitude:
		m.ResetLatitude()
		return nil
	case postalcode.FieldLongitude:
		m.ResetLongitude()
		return nil
	case postalcode.FieldAccuracy:
		m.ResetAccuracy()
		return nil
	case postalcode.FieldServiceArea:
		m.ResetServiceArea()
		return nil
	}
	return fmt.Errorf("unknown PostalCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostalCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.pricing != nil {
		edges = append(edges, postalcode.EdgePricing)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostalCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postalcode.EdgePricing:
		ids := make([]ent.Value, 0, len(m.pricing))
		for id := range m.pricing {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostalCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpricing != nil {
		edges = append(edges, postalcode.EdgePricing)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostalCodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case postalcode.EdgePricing:
		ids := make([]ent.Value, 0, len(m.removedpricing))
		for id := range m.removedpricing {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostalCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpricing {
		edges = append(edges, postalcode.EdgePricing)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostalCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case postalcode.EdgePricing:
		return m.clearedpricing
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostalCodeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PostalCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostalCodeMutation) ResetEdge(name string) error {
	switch name {
	case postalcode.EdgePricing:
		m.ResetPricing()
		return nil
	}
	return fmt.Errorf("unknown PostalCode edge %s", name)
}

// PricingMutation represents an operation that mutates the Pricing nodes in the graph.
type PricingMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	postal_country *string
	postal_code    *string
	product_id     *uint8
	addproduct_id  *int8
	description    *string
	price          *float64
	addprice       *float64
	price_per      *string
	clearedFields  map[string]struct{}
	postal         *string
	clearedpostal  bool
	done           bool
	oldValue       func(context.Context) (*Pricing, error)
	predicates     []predicate.Pricing
}

var _ ent.Mutation = (*PricingMutation)(nil)

// pricingOption allows management of the mutation configuration using functional options.
type pricingOption func(*PricingMutation)

// newPricingMutation creates new mutation for the Pricing entity.
func newPricingMutation(c config, op Op, opts ...pricingOption) *PricingMutation {
	m := &PricingMutation{
		config:        c,
		op:            op,
		typ:           TypePricing,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPricingID sets the ID field of the mutation.
func withPricingID(id string) pricingOption {
	return func(m *PricingMutation) {
		var (
			err   error
			once  sync.Once
			value *Pricing
		)
		m.oldValue = func(ctx context.Context) (*Pricing, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pricing.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPricing sets the old Pricing of the mutation.
func withPricing(node *Pricing) pricingOption {
	return func(m *PricingMutation) {
		m.oldValue = func(context.Context) (*Pricing, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PricingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PricingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pricing entities.
func (m *PricingMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PricingMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PricingMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pricing.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PricingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PricingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Pricing entity.
// If the Pricing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PricingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PricingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PricingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PricingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Pricing entity.
// If the Pricing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PricingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PricingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPostalCountry sets the "postal_country" field.
func (m *PricingMutation) SetPostalCountry(s string) {
	m.postal_country = &s
}

// PostalCountry returns the value of the "postal_country" field in the mutation.
func (m *PricingMutation) PostalCountry() (r string, exists bool) {
	v := m.postal_country
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCountry returns the old "postal_country" field's value of the Pricing entity.
// If the Pricing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PricingMutation) OldPostalCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCountry: %w", err)
	}
	return oldValue.PostalCountry, nil
}

// ResetPostalCountry resets all changes to the "postal_country" field.
func (m *PricingMutation) ResetPostalCountry() {
	m.postal_country = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *PricingMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *PricingMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Pricing entity.
// If the Pricing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PricingMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *PricingMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetProductID sets the "product_id" field.
func (m *PricingMutation) SetProductID(u uint8) {
	m.product_id = &u
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *PricingMutation) ProductID() (r uint8, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the Pricing entity.
// If the Pricing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PricingMutation) OldProductID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds u to the "product_id" field.
func (m *PricingMutation) AddProductID(u int8) {
	if m.addproduct_id != nil {
		*m.addproduct_id += u
	} else {
		m.addproduct_id = &u
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *PricingMutation) AddedProductID() (r int8, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *PricingMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetDescription sets the "description" field.
func (m *PricingMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PricingMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Pricing entity.
// If the Pricing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PricingMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PricingMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[pricing.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PricingMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[pricing.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PricingMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, pricing.FieldDescription)
}

// SetPrice sets the "price" field.
func (m *PricingMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *PricingMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Pricing entity.
// If the Pricing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PricingMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *PricingMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *PricingMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *PricingMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetPricePer sets the "price_per" field.
func (m *PricingMutation) SetPricePer(s string) {
	m.price_per = &s
}

// PricePer returns the value of the "price_per" field in the mutation.
func (m *PricingMutation) PricePer() (r string, exists bool) {
	v := m.price_per
	if v == nil {
		return
	}
	return *v, true
}

// OldPricePer returns the old "price_per" field's value of the Pricing entity.
// If the Pricing object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PricingMutation) OldPricePer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPricePer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPricePer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPricePer: %w", err)
	}
	return oldValue.PricePer, nil
}

// ResetPricePer resets all changes to the "price_per" field.
func (m *PricingMutation) ResetPricePer() {
	m.price_per = nil
}

// SetPostalID sets the "postal" edge to the PostalCode entity by id.
func (m *PricingMutation) SetPostalID(id string) {
	m.postal = &id
}

// ClearPostal clears the "postal" edge to the PostalCode entity.
func (m *PricingMutation) ClearPostal() {
	m.clearedpostal = true
}

// PostalCleared reports if the "postal" edge to the PostalCode entity was cleared.
func (m *PricingMutation) PostalCleared() bool {
	return m.clearedpostal
}

// PostalID returns the "postal" edge ID in the mutation.
func (m *PricingMutation) PostalID() (id string, exists bool) {
	if m.postal != nil {
		return *m.postal, true
	}
	return
}

// PostalIDs returns the "postal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostalID instead. It exists only for internal usage by the builders.
func (m *PricingMutation) PostalIDs() (ids []string) {
	if id := m.postal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPostal resets all changes to the "postal" edge.
func (m *PricingMutation) ResetPostal() {
	m.postal = nil
	m.clearedpostal = false
}

// Where appends a list predicates to the PricingMutation builder.
func (m *PricingMutation) Where(ps ...predicate.Pricing) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PricingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PricingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pricing, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PricingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PricingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pricing).
func (m *PricingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PricingMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, pricing.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, pricing.FieldUpdatedAt)
	}
	if m.postal_country != nil {
		fields = append(fields, pricing.FieldPostalCountry)
	}
	if m.postal_code != nil {
		fields = append(fields, pricing.FieldPostalCode)
	}
	if m.product_id != nil {
		fields = append(fields, pricing.FieldProductID)
	}
	if m.description != nil {
		fields = append(fields, pricing.FieldDescription)
	}
	if m.price != nil {
		fields = append(fields, pricing.FieldPrice)
	}
	if m.price_per != nil {
		fields = append(fields, pricing.FieldPricePer)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PricingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pricing.FieldCreatedAt:
		return m.CreatedAt()
	case pricing.FieldUpdatedAt:
		return m.UpdatedAt()
	case pricing.FieldPostalCountry:
		return m.PostalCountry()
	case pricing.FieldPostalCode:
		return m.PostalCode()
	case pricing.FieldProductID:
		return m.ProductID()
	case pricing.FieldDescription:
		return m.Description()
	case pricing.FieldPrice:
		return m.Price()
	case pricing.FieldPricePer:
		return m.PricePer()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PricingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pricing.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case pricing.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case pricing.FieldPostalCountry:
		return m.OldPostalCountry(ctx)
	case pricing.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case pricing.FieldProductID:
		return m.OldProductID(ctx)
	case pricing.FieldDescription:
		return m.OldDescription(ctx)
	case pricing.FieldPrice:
		return m.OldPrice(ctx)
	case pricing.FieldPricePer:
		return m.OldPricePer(ctx)
	}
	return nil, fmt.Errorf("unknown Pricing field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PricingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pricing.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case pricing.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case pricing.FieldPostalCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCountry(v)
		return nil
	case pricing.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case pricing.FieldProductID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case pricing.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case pricing.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case pricing.FieldPricePer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPricePer(v)
		return nil
	}
	return fmt.Errorf("unknown Pricing field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PricingMutation) AddedFields() []string {
	var fields []string
	if m.addproduct_id != nil {
		fields = append(fields, pricing.FieldProductID)
	}
	if m.addprice != nil {
		fields = append(fields, pricing.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PricingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pricing.FieldProductID:
		return m.AddedProductID()
	case pricing.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PricingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pricing.FieldProductID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case pricing.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown Pricing numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PricingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pricing.FieldDescription) {
		fields = append(fields, pricing.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PricingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PricingMutation) ClearField(name string) error {
	switch name {
	case pricing.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Pricing nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PricingMutation) ResetField(name string) error {
	switch name {
	case pricing.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case pricing.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case pricing.FieldPostalCountry:
		m.ResetPostalCountry()
		return nil
	case pricing.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case pricing.FieldProductID:
		m.ResetProductID()
		return nil
	case pricing.FieldDescription:
		m.ResetDescription()
		return nil
	case pricing.FieldPrice:
		m.ResetPrice()
		return nil
	case pricing.FieldPricePer:
		m.ResetPricePer()
		return nil
	}
	return fmt.Errorf("unknown Pricing field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PricingMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.postal != nil {
		edges = append(edges, pricing.EdgePostal)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PricingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pricing.EdgePostal:
		if id := m.postal; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PricingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PricingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PricingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpostal {
		edges = append(edges, pricing.EdgePostal)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PricingMutation) EdgeCleared(name string) bool {
	switch name {
	case pricing.EdgePostal:
		return m.clearedpostal
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PricingMutation) ClearEdge(name string) error {
	switch name {
	case pricing.EdgePostal:
		m.ClearPostal()
		return nil
	}
	return fmt.Errorf("unknown Pricing unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PricingMutation) ResetEdge(name string) error {
	switch name {
	case pricing.EdgePostal:
		m.ResetPostal()
		return nil
	}
	return fmt.Errorf("unknown Pricing edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	_type             *enum.Product
	name              *string
	description       *string
	features          *[]string
	appendfeatures    []string
	special_note      *string
	unit_price        *float64
	addunit_price     *float64
	units_in_stock    *int
	addunits_in_stock *int
	units_on_order    *int
	addunits_on_order *int
	discontinued      *bool
	clearedFields     map[string]struct{}
	_package          map[string]struct{}
	removed_package   map[string]struct{}
	cleared_package   bool
	creator           *string
	clearedcreator    bool
	image             *string
	clearedimage      bool
	done              bool
	oldValue          func(context.Context) (*Product, error)
	predicates        []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id string) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *ProductMutation) SetType(e enum.Product) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductMutation) GetType() (r enum.Product, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldType(ctx context.Context) (v enum.Product, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProductMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *ProductMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductMutation) ResetDescription() {
	m.description = nil
}

// SetFeatures sets the "features" field.
func (m *ProductMutation) SetFeatures(s []string) {
	m.features = &s
	m.appendfeatures = nil
}

// Features returns the value of the "features" field in the mutation.
func (m *ProductMutation) Features() (r []string, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatures returns the old "features" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldFeatures(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatures: %w", err)
	}
	return oldValue.Features, nil
}

// AppendFeatures adds s to the "features" field.
func (m *ProductMutation) AppendFeatures(s []string) {
	m.appendfeatures = append(m.appendfeatures, s...)
}

// AppendedFeatures returns the list of values that were appended to the "features" field in this mutation.
func (m *ProductMutation) AppendedFeatures() ([]string, bool) {
	if len(m.appendfeatures) == 0 {
		return nil, false
	}
	return m.appendfeatures, true
}

// ResetFeatures resets all changes to the "features" field.
func (m *ProductMutation) ResetFeatures() {
	m.features = nil
	m.appendfeatures = nil
}

// SetSpecialNote sets the "special_note" field.
func (m *ProductMutation) SetSpecialNote(s string) {
	m.special_note = &s
}

// SpecialNote returns the value of the "special_note" field in the mutation.
func (m *ProductMutation) SpecialNote() (r string, exists bool) {
	v := m.special_note
	if v == nil {
		return
	}
	return *v, true
}

// OldSpecialNote returns the old "special_note" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldSpecialNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpecialNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpecialNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpecialNote: %w", err)
	}
	return oldValue.SpecialNote, nil
}

// ClearSpecialNote clears the value of the "special_note" field.
func (m *ProductMutation) ClearSpecialNote() {
	m.special_note = nil
	m.clearedFields[product.FieldSpecialNote] = struct{}{}
}

// SpecialNoteCleared returns if the "special_note" field was cleared in this mutation.
func (m *ProductMutation) SpecialNoteCleared() bool {
	_, ok := m.clearedFields[product.FieldSpecialNote]
	return ok
}

// ResetSpecialNote resets all changes to the "special_note" field.
func (m *ProductMutation) ResetSpecialNote() {
	m.special_note = nil
	delete(m.clearedFields, product.FieldSpecialNote)
}

// SetUnitPrice sets the "unit_price" field.
func (m *ProductMutation) SetUnitPrice(f float64) {
	m.unit_price = &f
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *ProductMutation) UnitPrice() (r float64, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "unit_price" field.
func (m *ProductMutation) AddUnitPrice(f float64) {
	if m.addunit_price != nil {
		*m.addunit_price += f
	} else {
		m.addunit_price = &f
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *ProductMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *ProductMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
}

// SetUnitsInStock sets the "units_in_stock" field.
func (m *ProductMutation) SetUnitsInStock(i int) {
	m.units_in_stock = &i
	m.addunits_in_stock = nil
}

// UnitsInStock returns the value of the "units_in_stock" field in the mutation.
func (m *ProductMutation) UnitsInStock() (r int, exists bool) {
	v := m.units_in_stock
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitsInStock returns the old "units_in_stock" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitsInStock(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitsInStock is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitsInStock requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitsInStock: %w", err)
	}
	return oldValue.UnitsInStock, nil
}

// AddUnitsInStock adds i to the "units_in_stock" field.
func (m *ProductMutation) AddUnitsInStock(i int) {
	if m.addunits_in_stock != nil {
		*m.addunits_in_stock += i
	} else {
		m.addunits_in_stock = &i
	}
}

// AddedUnitsInStock returns the value that was added to the "units_in_stock" field in this mutation.
func (m *ProductMutation) AddedUnitsInStock() (r int, exists bool) {
	v := m.addunits_in_stock
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitsInStock clears the value of the "units_in_stock" field.
func (m *ProductMutation) ClearUnitsInStock() {
	m.units_in_stock = nil
	m.addunits_in_stock = nil
	m.clearedFields[product.FieldUnitsInStock] = struct{}{}
}

// UnitsInStockCleared returns if the "units_in_stock" field was cleared in this mutation.
func (m *ProductMutation) UnitsInStockCleared() bool {
	_, ok := m.clearedFields[product.FieldUnitsInStock]
	return ok
}

// ResetUnitsInStock resets all changes to the "units_in_stock" field.
func (m *ProductMutation) ResetUnitsInStock() {
	m.units_in_stock = nil
	m.addunits_in_stock = nil
	delete(m.clearedFields, product.FieldUnitsInStock)
}

// SetUnitsOnOrder sets the "units_on_order" field.
func (m *ProductMutation) SetUnitsOnOrder(i int) {
	m.units_on_order = &i
	m.addunits_on_order = nil
}

// UnitsOnOrder returns the value of the "units_on_order" field in the mutation.
func (m *ProductMutation) UnitsOnOrder() (r int, exists bool) {
	v := m.units_on_order
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitsOnOrder returns the old "units_on_order" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUnitsOnOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitsOnOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitsOnOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitsOnOrder: %w", err)
	}
	return oldValue.UnitsOnOrder, nil
}

// AddUnitsOnOrder adds i to the "units_on_order" field.
func (m *ProductMutation) AddUnitsOnOrder(i int) {
	if m.addunits_on_order != nil {
		*m.addunits_on_order += i
	} else {
		m.addunits_on_order = &i
	}
}

// AddedUnitsOnOrder returns the value that was added to the "units_on_order" field in this mutation.
func (m *ProductMutation) AddedUnitsOnOrder() (r int, exists bool) {
	v := m.addunits_on_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearUnitsOnOrder clears the value of the "units_on_order" field.
func (m *ProductMutation) ClearUnitsOnOrder() {
	m.units_on_order = nil
	m.addunits_on_order = nil
	m.clearedFields[product.FieldUnitsOnOrder] = struct{}{}
}

// UnitsOnOrderCleared returns if the "units_on_order" field was cleared in this mutation.
func (m *ProductMutation) UnitsOnOrderCleared() bool {
	_, ok := m.clearedFields[product.FieldUnitsOnOrder]
	return ok
}

// ResetUnitsOnOrder resets all changes to the "units_on_order" field.
func (m *ProductMutation) ResetUnitsOnOrder() {
	m.units_on_order = nil
	m.addunits_on_order = nil
	delete(m.clearedFields, product.FieldUnitsOnOrder)
}

// SetDiscontinued sets the "discontinued" field.
func (m *ProductMutation) SetDiscontinued(b bool) {
	m.discontinued = &b
}

// Discontinued returns the value of the "discontinued" field in the mutation.
func (m *ProductMutation) Discontinued() (r bool, exists bool) {
	v := m.discontinued
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscontinued returns the old "discontinued" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldDiscontinued(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscontinued is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscontinued requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscontinued: %w", err)
	}
	return oldValue.Discontinued, nil
}

// ClearDiscontinued clears the value of the "discontinued" field.
func (m *ProductMutation) ClearDiscontinued() {
	m.discontinued = nil
	m.clearedFields[product.FieldDiscontinued] = struct{}{}
}

// DiscontinuedCleared returns if the "discontinued" field was cleared in this mutation.
func (m *ProductMutation) DiscontinuedCleared() bool {
	_, ok := m.clearedFields[product.FieldDiscontinued]
	return ok
}

// ResetDiscontinued resets all changes to the "discontinued" field.
func (m *ProductMutation) ResetDiscontinued() {
	m.discontinued = nil
	delete(m.clearedFields, product.FieldDiscontinued)
}

// AddPackageIDs adds the "package" edge to the ProductPackage entity by ids.
func (m *ProductMutation) AddPackageIDs(ids ...string) {
	if m._package == nil {
		m._package = make(map[string]struct{})
	}
	for i := range ids {
		m._package[ids[i]] = struct{}{}
	}
}

// ClearPackage clears the "package" edge to the ProductPackage entity.
func (m *ProductMutation) ClearPackage() {
	m.cleared_package = true
}

// PackageCleared reports if the "package" edge to the ProductPackage entity was cleared.
func (m *ProductMutation) PackageCleared() bool {
	return m.cleared_package
}

// RemovePackageIDs removes the "package" edge to the ProductPackage entity by IDs.
func (m *ProductMutation) RemovePackageIDs(ids ...string) {
	if m.removed_package == nil {
		m.removed_package = make(map[string]struct{})
	}
	for i := range ids {
		delete(m._package, ids[i])
		m.removed_package[ids[i]] = struct{}{}
	}
}

// RemovedPackage returns the removed IDs of the "package" edge to the ProductPackage entity.
func (m *ProductMutation) RemovedPackageIDs() (ids []string) {
	for id := range m.removed_package {
		ids = append(ids, id)
	}
	return
}

// PackageIDs returns the "package" edge IDs in the mutation.
func (m *ProductMutation) PackageIDs() (ids []string) {
	for id := range m._package {
		ids = append(ids, id)
	}
	return
}

// ResetPackage resets all changes to the "package" edge.
func (m *ProductMutation) ResetPackage() {
	m._package = nil
	m.cleared_package = false
	m.removed_package = nil
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *ProductMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *ProductMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *ProductMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *ProductMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *ProductMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetImageID sets the "image" edge to the Document entity by id.
func (m *ProductMutation) SetImageID(id string) {
	m.image = &id
}

// ClearImage clears the "image" edge to the Document entity.
func (m *ProductMutation) ClearImage() {
	m.clearedimage = true
}

// ImageCleared reports if the "image" edge to the Document entity was cleared.
func (m *ProductMutation) ImageCleared() bool {
	return m.clearedimage
}

// ImageID returns the "image" edge ID in the mutation.
func (m *ProductMutation) ImageID() (id string, exists bool) {
	if m.image != nil {
		return *m.image, true
	}
	return
}

// ImageIDs returns the "image" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ImageID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) ImageIDs() (ids []string) {
	if id := m.image; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetImage resets all changes to the "image" edge.
func (m *ProductMutation) ResetImage() {
	m.image = nil
	m.clearedimage = false
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, product.FieldType)
	}
	if m.name != nil {
		fields = append(fields, product.FieldName)
	}
	if m.description != nil {
		fields = append(fields, product.FieldDescription)
	}
	if m.features != nil {
		fields = append(fields, product.FieldFeatures)
	}
	if m.special_note != nil {
		fields = append(fields, product.FieldSpecialNote)
	}
	if m.unit_price != nil {
		fields = append(fields, product.FieldUnitPrice)
	}
	if m.units_in_stock != nil {
		fields = append(fields, product.FieldUnitsInStock)
	}
	if m.units_on_order != nil {
		fields = append(fields, product.FieldUnitsOnOrder)
	}
	if m.discontinued != nil {
		fields = append(fields, product.FieldDiscontinued)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	case product.FieldType:
		return m.GetType()
	case product.FieldName:
		return m.Name()
	case product.FieldDescription:
		return m.Description()
	case product.FieldFeatures:
		return m.Features()
	case product.FieldSpecialNote:
		return m.SpecialNote()
	case product.FieldUnitPrice:
		return m.UnitPrice()
	case product.FieldUnitsInStock:
		return m.UnitsInStock()
	case product.FieldUnitsOnOrder:
		return m.UnitsOnOrder()
	case product.FieldDiscontinued:
		return m.Discontinued()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case product.FieldType:
		return m.OldType(ctx)
	case product.FieldName:
		return m.OldName(ctx)
	case product.FieldDescription:
		return m.OldDescription(ctx)
	case product.FieldFeatures:
		return m.OldFeatures(ctx)
	case product.FieldSpecialNote:
		return m.OldSpecialNote(ctx)
	case product.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case product.FieldUnitsInStock:
		return m.OldUnitsInStock(ctx)
	case product.FieldUnitsOnOrder:
		return m.OldUnitsOnOrder(ctx)
	case product.FieldDiscontinued:
		return m.OldDiscontinued(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case product.FieldType:
		v, ok := value.(enum.Product)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case product.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case product.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case product.FieldFeatures:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatures(v)
		return nil
	case product.FieldSpecialNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpecialNote(v)
		return nil
	case product.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case product.FieldUnitsInStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitsInStock(v)
		return nil
	case product.FieldUnitsOnOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitsOnOrder(v)
		return nil
	case product.FieldDiscontinued:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscontinued(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	var fields []string
	if m.addunit_price != nil {
		fields = append(fields, product.FieldUnitPrice)
	}
	if m.addunits_in_stock != nil {
		fields = append(fields, product.FieldUnitsInStock)
	}
	if m.addunits_on_order != nil {
		fields = append(fields, product.FieldUnitsOnOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case product.FieldUnitPrice:
		return m.AddedUnitPrice()
	case product.FieldUnitsInStock:
		return m.AddedUnitsInStock()
	case product.FieldUnitsOnOrder:
		return m.AddedUnitsOnOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	case product.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case product.FieldUnitsInStock:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitsInStock(v)
		return nil
	case product.FieldUnitsOnOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitsOnOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldSpecialNote) {
		fields = append(fields, product.FieldSpecialNote)
	}
	if m.FieldCleared(product.FieldUnitsInStock) {
		fields = append(fields, product.FieldUnitsInStock)
	}
	if m.FieldCleared(product.FieldUnitsOnOrder) {
		fields = append(fields, product.FieldUnitsOnOrder)
	}
	if m.FieldCleared(product.FieldDiscontinued) {
		fields = append(fields, product.FieldDiscontinued)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldSpecialNote:
		m.ClearSpecialNote()
		return nil
	case product.FieldUnitsInStock:
		m.ClearUnitsInStock()
		return nil
	case product.FieldUnitsOnOrder:
		m.ClearUnitsOnOrder()
		return nil
	case product.FieldDiscontinued:
		m.ClearDiscontinued()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case product.FieldType:
		m.ResetType()
		return nil
	case product.FieldName:
		m.ResetName()
		return nil
	case product.FieldDescription:
		m.ResetDescription()
		return nil
	case product.FieldFeatures:
		m.ResetFeatures()
		return nil
	case product.FieldSpecialNote:
		m.ResetSpecialNote()
		return nil
	case product.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case product.FieldUnitsInStock:
		m.ResetUnitsInStock()
		return nil
	case product.FieldUnitsOnOrder:
		m.ResetUnitsOnOrder()
		return nil
	case product.FieldDiscontinued:
		m.ResetDiscontinued()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m._package != nil {
		edges = append(edges, product.EdgePackage)
	}
	if m.creator != nil {
		edges = append(edges, product.EdgeCreator)
	}
	if m.image != nil {
		edges = append(edges, product.EdgeImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgePackage:
		ids := make([]ent.Value, 0, len(m._package))
		for id := range m._package {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeImage:
		if id := m.image; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removed_package != nil {
		edges = append(edges, product.EdgePackage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgePackage:
		ids := make([]ent.Value, 0, len(m.removed_package))
		for id := range m.removed_package {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleared_package {
		edges = append(edges, product.EdgePackage)
	}
	if m.clearedcreator {
		edges = append(edges, product.EdgeCreator)
	}
	if m.clearedimage {
		edges = append(edges, product.EdgeImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgePackage:
		return m.cleared_package
	case product.EdgeCreator:
		return m.clearedcreator
	case product.EdgeImage:
		return m.clearedimage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeCreator:
		m.ClearCreator()
		return nil
	case product.EdgeImage:
		m.ClearImage()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgePackage:
		m.ResetPackage()
		return nil
	case product.EdgeCreator:
		m.ResetCreator()
		return nil
	case product.EdgeImage:
		m.ResetImage()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductPackageMutation represents an operation that mutates the ProductPackage nodes in the graph.
type ProductPackageMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	_type          *enum.Product
	sold_as        *enum.SoldAs
	name           *string
	description    *string
	features       *[]string
	appendfeatures []string
	price          *float64
	addprice       *float64
	discontinued   *bool
	clearedFields  map[string]struct{}
	items          map[string]struct{}
	removeditems   map[string]struct{}
	cleareditems   bool
	creator        *string
	clearedcreator bool
	done           bool
	oldValue       func(context.Context) (*ProductPackage, error)
	predicates     []predicate.ProductPackage
}

var _ ent.Mutation = (*ProductPackageMutation)(nil)

// productpackageOption allows management of the mutation configuration using functional options.
type productpackageOption func(*ProductPackageMutation)

// newProductPackageMutation creates new mutation for the ProductPackage entity.
func newProductPackageMutation(c config, op Op, opts ...productpackageOption) *ProductPackageMutation {
	m := &ProductPackageMutation{
		config:        c,
		op:            op,
		typ:           TypeProductPackage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductPackageID sets the ID field of the mutation.
func withProductPackageID(id string) productpackageOption {
	return func(m *ProductPackageMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductPackage
		)
		m.oldValue = func(ctx context.Context) (*ProductPackage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductPackage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductPackage sets the old ProductPackage of the mutation.
func withProductPackage(node *ProductPackage) productpackageOption {
	return func(m *ProductPackageMutation) {
		m.oldValue = func(context.Context) (*ProductPackage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductPackageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductPackageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductPackage entities.
func (m *ProductPackageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductPackageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductPackageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductPackage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductPackageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductPackageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductPackage entity.
// If the ProductPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPackageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductPackageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductPackageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductPackageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductPackage entity.
// If the ProductPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPackageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductPackageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *ProductPackageMutation) SetType(e enum.Product) {
	m._type = &e
}

// GetType returns the value of the "type" field in the mutation.
func (m *ProductPackageMutation) GetType() (r enum.Product, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ProductPackage entity.
// If the ProductPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPackageMutation) OldType(ctx context.Context) (v enum.Product, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ProductPackageMutation) ResetType() {
	m._type = nil
}

// SetSoldAs sets the "sold_as" field.
func (m *ProductPackageMutation) SetSoldAs(ea enum.SoldAs) {
	m.sold_as = &ea
}

// SoldAs returns the value of the "sold_as" field in the mutation.
func (m *ProductPackageMutation) SoldAs() (r enum.SoldAs, exists bool) {
	v := m.sold_as
	if v == nil {
		return
	}
	return *v, true
}

// OldSoldAs returns the old "sold_as" field's value of the ProductPackage entity.
// If the ProductPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPackageMutation) OldSoldAs(ctx context.Context) (v enum.SoldAs, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSoldAs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSoldAs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSoldAs: %w", err)
	}
	return oldValue.SoldAs, nil
}

// ResetSoldAs resets all changes to the "sold_as" field.
func (m *ProductPackageMutation) ResetSoldAs() {
	m.sold_as = nil
}

// SetName sets the "name" field.
func (m *ProductPackageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductPackageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductPackage entity.
// If the ProductPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPackageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductPackageMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ProductPackageMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductPackageMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductPackage entity.
// If the ProductPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPackageMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductPackageMutation) ResetDescription() {
	m.description = nil
}

// SetFeatures sets the "features" field.
func (m *ProductPackageMutation) SetFeatures(s []string) {
	m.features = &s
	m.appendfeatures = nil
}

// Features returns the value of the "features" field in the mutation.
func (m *ProductPackageMutation) Features() (r []string, exists bool) {
	v := m.features
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatures returns the old "features" field's value of the ProductPackage entity.
// If the ProductPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPackageMutation) OldFeatures(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatures is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatures requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatures: %w", err)
	}
	return oldValue.Features, nil
}

// AppendFeatures adds s to the "features" field.
func (m *ProductPackageMutation) AppendFeatures(s []string) {
	m.appendfeatures = append(m.appendfeatures, s...)
}

// AppendedFeatures returns the list of values that were appended to the "features" field in this mutation.
func (m *ProductPackageMutation) AppendedFeatures() ([]string, bool) {
	if len(m.appendfeatures) == 0 {
		return nil, false
	}
	return m.appendfeatures, true
}

// ResetFeatures resets all changes to the "features" field.
func (m *ProductPackageMutation) ResetFeatures() {
	m.features = nil
	m.appendfeatures = nil
}

// SetPrice sets the "price" field.
func (m *ProductPackageMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *ProductPackageMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the ProductPackage entity.
// If the ProductPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPackageMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *ProductPackageMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *ProductPackageMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *ProductPackageMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetDiscontinued sets the "discontinued" field.
func (m *ProductPackageMutation) SetDiscontinued(b bool) {
	m.discontinued = &b
}

// Discontinued returns the value of the "discontinued" field in the mutation.
func (m *ProductPackageMutation) Discontinued() (r bool, exists bool) {
	v := m.discontinued
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscontinued returns the old "discontinued" field's value of the ProductPackage entity.
// If the ProductPackage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductPackageMutation) OldDiscontinued(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscontinued is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscontinued requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscontinued: %w", err)
	}
	return oldValue.Discontinued, nil
}

// ClearDiscontinued clears the value of the "discontinued" field.
func (m *ProductPackageMutation) ClearDiscontinued() {
	m.discontinued = nil
	m.clearedFields[productpackage.FieldDiscontinued] = struct{}{}
}

// DiscontinuedCleared returns if the "discontinued" field was cleared in this mutation.
func (m *ProductPackageMutation) DiscontinuedCleared() bool {
	_, ok := m.clearedFields[productpackage.FieldDiscontinued]
	return ok
}

// ResetDiscontinued resets all changes to the "discontinued" field.
func (m *ProductPackageMutation) ResetDiscontinued() {
	m.discontinued = nil
	delete(m.clearedFields, productpackage.FieldDiscontinued)
}

// AddItemIDs adds the "items" edge to the Product entity by ids.
func (m *ProductPackageMutation) AddItemIDs(ids ...string) {
	if m.items == nil {
		m.items = make(map[string]struct{})
	}
	for i := range ids {
		m.items[ids[i]] = struct{}{}
	}
}

// ClearItems clears the "items" edge to the Product entity.
func (m *ProductPackageMutation) ClearItems() {
	m.cleareditems = true
}

// ItemsCleared reports if the "items" edge to the Product entity was cleared.
func (m *ProductPackageMutation) ItemsCleared() bool {
	return m.cleareditems
}

// RemoveItemIDs removes the "items" edge to the Product entity by IDs.
func (m *ProductPackageMutation) RemoveItemIDs(ids ...string) {
	if m.removeditems == nil {
		m.removeditems = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.items, ids[i])
		m.removeditems[ids[i]] = struct{}{}
	}
}

// RemovedItems returns the removed IDs of the "items" edge to the Product entity.
func (m *ProductPackageMutation) RemovedItemsIDs() (ids []string) {
	for id := range m.removeditems {
		ids = append(ids, id)
	}
	return
}

// ItemsIDs returns the "items" edge IDs in the mutation.
func (m *ProductPackageMutation) ItemsIDs() (ids []string) {
	for id := range m.items {
		ids = append(ids, id)
	}
	return
}

// ResetItems resets all changes to the "items" edge.
func (m *ProductPackageMutation) ResetItems() {
	m.items = nil
	m.cleareditems = false
	m.removeditems = nil
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *ProductPackageMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *ProductPackageMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *ProductPackageMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *ProductPackageMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *ProductPackageMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *ProductPackageMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the ProductPackageMutation builder.
func (m *ProductPackageMutation) Where(ps ...predicate.ProductPackage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductPackageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductPackageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductPackage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductPackageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductPackageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductPackage).
func (m *ProductPackageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductPackageMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, productpackage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productpackage.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, productpackage.FieldType)
	}
	if m.sold_as != nil {
		fields = append(fields, productpackage.FieldSoldAs)
	}
	if m.name != nil {
		fields = append(fields, productpackage.FieldName)
	}
	if m.description != nil {
		fields = append(fields, productpackage.FieldDescription)
	}
	if m.features != nil {
		fields = append(fields, productpackage.FieldFeatures)
	}
	if m.price != nil {
		fields = append(fields, productpackage.FieldPrice)
	}
	if m.discontinued != nil {
		fields = append(fields, productpackage.FieldDiscontinued)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductPackageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productpackage.FieldCreatedAt:
		return m.CreatedAt()
	case productpackage.FieldUpdatedAt:
		return m.UpdatedAt()
	case productpackage.FieldType:
		return m.GetType()
	case productpackage.FieldSoldAs:
		return m.SoldAs()
	case productpackage.FieldName:
		return m.Name()
	case productpackage.FieldDescription:
		return m.Description()
	case productpackage.FieldFeatures:
		return m.Features()
	case productpackage.FieldPrice:
		return m.Price()
	case productpackage.FieldDiscontinued:
		return m.Discontinued()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductPackageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productpackage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productpackage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case productpackage.FieldType:
		return m.OldType(ctx)
	case productpackage.FieldSoldAs:
		return m.OldSoldAs(ctx)
	case productpackage.FieldName:
		return m.OldName(ctx)
	case productpackage.FieldDescription:
		return m.OldDescription(ctx)
	case productpackage.FieldFeatures:
		return m.OldFeatures(ctx)
	case productpackage.FieldPrice:
		return m.OldPrice(ctx)
	case productpackage.FieldDiscontinued:
		return m.OldDiscontinued(ctx)
	}
	return nil, fmt.Errorf("unknown ProductPackage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPackageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productpackage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productpackage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case productpackage.FieldType:
		v, ok := value.(enum.Product)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case productpackage.FieldSoldAs:
		v, ok := value.(enum.SoldAs)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSoldAs(v)
		return nil
	case productpackage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case productpackage.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case productpackage.FieldFeatures:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatures(v)
		return nil
	case productpackage.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case productpackage.FieldDiscontinued:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscontinued(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPackage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductPackageMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, productpackage.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductPackageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productpackage.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductPackageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productpackage.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown ProductPackage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductPackageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productpackage.FieldDiscontinued) {
		fields = append(fields, productpackage.FieldDiscontinued)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductPackageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductPackageMutation) ClearField(name string) error {
	switch name {
	case productpackage.FieldDiscontinued:
		m.ClearDiscontinued()
		return nil
	}
	return fmt.Errorf("unknown ProductPackage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductPackageMutation) ResetField(name string) error {
	switch name {
	case productpackage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productpackage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case productpackage.FieldType:
		m.ResetType()
		return nil
	case productpackage.FieldSoldAs:
		m.ResetSoldAs()
		return nil
	case productpackage.FieldName:
		m.ResetName()
		return nil
	case productpackage.FieldDescription:
		m.ResetDescription()
		return nil
	case productpackage.FieldFeatures:
		m.ResetFeatures()
		return nil
	case productpackage.FieldPrice:
		m.ResetPrice()
		return nil
	case productpackage.FieldDiscontinued:
		m.ResetDiscontinued()
		return nil
	}
	return fmt.Errorf("unknown ProductPackage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductPackageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.items != nil {
		edges = append(edges, productpackage.EdgeItems)
	}
	if m.creator != nil {
		edges = append(edges, productpackage.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductPackageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productpackage.EdgeItems:
		ids := make([]ent.Value, 0, len(m.items))
		for id := range m.items {
			ids = append(ids, id)
		}
		return ids
	case productpackage.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductPackageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeditems != nil {
		edges = append(edges, productpackage.EdgeItems)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductPackageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productpackage.EdgeItems:
		ids := make([]ent.Value, 0, len(m.removeditems))
		for id := range m.removeditems {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductPackageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareditems {
		edges = append(edges, productpackage.EdgeItems)
	}
	if m.clearedcreator {
		edges = append(edges, productpackage.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductPackageMutation) EdgeCleared(name string) bool {
	switch name {
	case productpackage.EdgeItems:
		return m.cleareditems
	case productpackage.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductPackageMutation) ClearEdge(name string) error {
	switch name {
	case productpackage.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown ProductPackage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductPackageMutation) ResetEdge(name string) error {
	switch name {
	case productpackage.EdgeItems:
		m.ResetItems()
		return nil
	case productpackage.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown ProductPackage edge %s", name)
}

// SurveyMutation represents an operation that mutates the Survey nodes in the graph.
type SurveyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	created_at              *time.Time
	updated_at              *time.Time
	date                    *string
	slot                    *string
	slot_id                 *string
	from                    *time.Time
	to                      *time.Time
	until                   *time.Time
	name                    *string
	address                 *string
	phone                   *string
	notes                   *string
	status                  *enum.SurveyStatus
	progress                *enum.SurveyProgress
	progress_at             *time.Time
	progress_flag_at        *time.Time
	clearedFields           map[string]struct{}
	progress_history        map[string]struct{}
	removedprogress_history map[string]struct{}
	clearedprogress_history bool
	created_by              *string
	clearedcreated_by       bool
	partner                 *string
	clearedpartner          bool
	done                    bool
	oldValue                func(context.Context) (*Survey, error)
	predicates              []predicate.Survey
}

var _ ent.Mutation = (*SurveyMutation)(nil)

// surveyOption allows management of the mutation configuration using functional options.
type surveyOption func(*SurveyMutation)

// newSurveyMutation creates new mutation for the Survey entity.
func newSurveyMutation(c config, op Op, opts ...surveyOption) *SurveyMutation {
	m := &SurveyMutation{
		config:        c,
		op:            op,
		typ:           TypeSurvey,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyID sets the ID field of the mutation.
func withSurveyID(id string) surveyOption {
	return func(m *SurveyMutation) {
		var (
			err   error
			once  sync.Once
			value *Survey
		)
		m.oldValue = func(ctx context.Context) (*Survey, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Survey.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurvey sets the old Survey of the mutation.
func withSurvey(node *Survey) surveyOption {
	return func(m *SurveyMutation) {
		m.oldValue = func(context.Context) (*Survey, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Survey entities.
func (m *SurveyMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Survey.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SurveyMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SurveyMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SurveyMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetDate sets the "date" field.
func (m *SurveyMutation) SetDate(s string) {
	m.date = &s
}

// Date returns the value of the "date" field in the mutation.
func (m *SurveyMutation) Date() (r string, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *SurveyMutation) ResetDate() {
	m.date = nil
}

// SetSlot sets the "slot" field.
func (m *SurveyMutation) SetSlot(s string) {
	m.slot = &s
}

// Slot returns the value of the "slot" field in the mutation.
func (m *SurveyMutation) Slot() (r string, exists bool) {
	v := m.slot
	if v == nil {
		return
	}
	return *v, true
}

// OldSlot returns the old "slot" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldSlot(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlot is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlot requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlot: %w", err)
	}
	return oldValue.Slot, nil
}

// ResetSlot resets all changes to the "slot" field.
func (m *SurveyMutation) ResetSlot() {
	m.slot = nil
}

// SetSlotID sets the "slot_id" field.
func (m *SurveyMutation) SetSlotID(s string) {
	m.slot_id = &s
}

// SlotID returns the value of the "slot_id" field in the mutation.
func (m *SurveyMutation) SlotID() (r string, exists bool) {
	v := m.slot_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSlotID returns the old "slot_id" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldSlotID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlotID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlotID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlotID: %w", err)
	}
	return oldValue.SlotID, nil
}

// ResetSlotID resets all changes to the "slot_id" field.
func (m *SurveyMutation) ResetSlotID() {
	m.slot_id = nil
}

// SetFrom sets the "from" field.
func (m *SurveyMutation) SetFrom(t time.Time) {
	m.from = &t
}

// From returns the value of the "from" field in the mutation.
func (m *SurveyMutation) From() (r time.Time, exists bool) {
	v := m.from
	if v == nil {
		return
	}
	return *v, true
}

// OldFrom returns the old "from" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrom: %w", err)
	}
	return oldValue.From, nil
}

// ResetFrom resets all changes to the "from" field.
func (m *SurveyMutation) ResetFrom() {
	m.from = nil
}

// SetTo sets the "to" field.
func (m *SurveyMutation) SetTo(t time.Time) {
	m.to = &t
}

// To returns the value of the "to" field in the mutation.
func (m *SurveyMutation) To() (r time.Time, exists bool) {
	v := m.to
	if v == nil {
		return
	}
	return *v, true
}

// OldTo returns the old "to" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldTo(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTo: %w", err)
	}
	return oldValue.To, nil
}

// ResetTo resets all changes to the "to" field.
func (m *SurveyMutation) ResetTo() {
	m.to = nil
}

// SetUntil sets the "until" field.
func (m *SurveyMutation) SetUntil(t time.Time) {
	m.until = &t
}

// Until returns the value of the "until" field in the mutation.
func (m *SurveyMutation) Until() (r time.Time, exists bool) {
	v := m.until
	if v == nil {
		return
	}
	return *v, true
}

// OldUntil returns the old "until" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUntil: %w", err)
	}
	return oldValue.Until, nil
}

// ClearUntil clears the value of the "until" field.
func (m *SurveyMutation) ClearUntil() {
	m.until = nil
	m.clearedFields[survey.FieldUntil] = struct{}{}
}

// UntilCleared returns if the "until" field was cleared in this mutation.
func (m *SurveyMutation) UntilCleared() bool {
	_, ok := m.clearedFields[survey.FieldUntil]
	return ok
}

// ResetUntil resets all changes to the "until" field.
func (m *SurveyMutation) ResetUntil() {
	m.until = nil
	delete(m.clearedFields, survey.FieldUntil)
}

// SetName sets the "name" field.
func (m *SurveyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SurveyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *SurveyMutation) ClearName() {
	m.name = nil
	m.clearedFields[survey.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *SurveyMutation) NameCleared() bool {
	_, ok := m.clearedFields[survey.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *SurveyMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, survey.FieldName)
}

// SetAddress sets the "address" field.
func (m *SurveyMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *SurveyMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *SurveyMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[survey.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *SurveyMutation) AddressCleared() bool {
	_, ok := m.clearedFields[survey.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *SurveyMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, survey.FieldAddress)
}

// SetPhone sets the "phone" field.
func (m *SurveyMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *SurveyMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldPhone(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *SurveyMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[survey.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *SurveyMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[survey.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *SurveyMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, survey.FieldPhone)
}

// SetNotes sets the "notes" field.
func (m *SurveyMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *SurveyMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldNotes(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *SurveyMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[survey.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *SurveyMutation) NotesCleared() bool {
	_, ok := m.clearedFields[survey.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *SurveyMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, survey.FieldNotes)
}

// SetStatus sets the "status" field.
func (m *SurveyMutation) SetStatus(es enum.SurveyStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *SurveyMutation) Status() (r enum.SurveyStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldStatus(ctx context.Context) (v enum.SurveyStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SurveyMutation) ResetStatus() {
	m.status = nil
}

// SetProgress sets the "progress" field.
func (m *SurveyMutation) SetProgress(ep enum.SurveyProgress) {
	m.progress = &ep
}

// Progress returns the value of the "progress" field in the mutation.
func (m *SurveyMutation) Progress() (r enum.SurveyProgress, exists bool) {
	v := m.progress
	if v == nil {
		return
	}
	return *v, true
}

// OldProgress returns the old "progress" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldProgress(ctx context.Context) (v *enum.SurveyProgress, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgress: %w", err)
	}
	return oldValue.Progress, nil
}

// ClearProgress clears the value of the "progress" field.
func (m *SurveyMutation) ClearProgress() {
	m.progress = nil
	m.clearedFields[survey.FieldProgress] = struct{}{}
}

// ProgressCleared returns if the "progress" field was cleared in this mutation.
func (m *SurveyMutation) ProgressCleared() bool {
	_, ok := m.clearedFields[survey.FieldProgress]
	return ok
}

// ResetProgress resets all changes to the "progress" field.
func (m *SurveyMutation) ResetProgress() {
	m.progress = nil
	delete(m.clearedFields, survey.FieldProgress)
}

// SetProgressAt sets the "progress_at" field.
func (m *SurveyMutation) SetProgressAt(t time.Time) {
	m.progress_at = &t
}

// ProgressAt returns the value of the "progress_at" field in the mutation.
func (m *SurveyMutation) ProgressAt() (r time.Time, exists bool) {
	v := m.progress_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProgressAt returns the old "progress_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldProgressAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgressAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgressAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgressAt: %w", err)
	}
	return oldValue.ProgressAt, nil
}

// ClearProgressAt clears the value of the "progress_at" field.
func (m *SurveyMutation) ClearProgressAt() {
	m.progress_at = nil
	m.clearedFields[survey.FieldProgressAt] = struct{}{}
}

// ProgressAtCleared returns if the "progress_at" field was cleared in this mutation.
func (m *SurveyMutation) ProgressAtCleared() bool {
	_, ok := m.clearedFields[survey.FieldProgressAt]
	return ok
}

// ResetProgressAt resets all changes to the "progress_at" field.
func (m *SurveyMutation) ResetProgressAt() {
	m.progress_at = nil
	delete(m.clearedFields, survey.FieldProgressAt)
}

// SetProgressFlagAt sets the "progress_flag_at" field.
func (m *SurveyMutation) SetProgressFlagAt(t time.Time) {
	m.progress_flag_at = &t
}

// ProgressFlagAt returns the value of the "progress_flag_at" field in the mutation.
func (m *SurveyMutation) ProgressFlagAt() (r time.Time, exists bool) {
	v := m.progress_flag_at
	if v == nil {
		return
	}
	return *v, true
}

// OldProgressFlagAt returns the old "progress_flag_at" field's value of the Survey entity.
// If the Survey object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyMutation) OldProgressFlagAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProgressFlagAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProgressFlagAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProgressFlagAt: %w", err)
	}
	return oldValue.ProgressFlagAt, nil
}

// ClearProgressFlagAt clears the value of the "progress_flag_at" field.
func (m *SurveyMutation) ClearProgressFlagAt() {
	m.progress_flag_at = nil
	m.clearedFields[survey.FieldProgressFlagAt] = struct{}{}
}

// ProgressFlagAtCleared returns if the "progress_flag_at" field was cleared in this mutation.
func (m *SurveyMutation) ProgressFlagAtCleared() bool {
	_, ok := m.clearedFields[survey.FieldProgressFlagAt]
	return ok
}

// ResetProgressFlagAt resets all changes to the "progress_flag_at" field.
func (m *SurveyMutation) ResetProgressFlagAt() {
	m.progress_flag_at = nil
	delete(m.clearedFields, survey.FieldProgressFlagAt)
}

// AddProgressHistoryIDs adds the "progress_history" edge to the SurveyProgress entity by ids.
func (m *SurveyMutation) AddProgressHistoryIDs(ids ...string) {
	if m.progress_history == nil {
		m.progress_history = make(map[string]struct{})
	}
	for i := range ids {
		m.progress_history[ids[i]] = struct{}{}
	}
}

// ClearProgressHistory clears the "progress_history" edge to the SurveyProgress entity.
func (m *SurveyMutation) ClearProgressHistory() {
	m.clearedprogress_history = true
}

// ProgressHistoryCleared reports if the "progress_history" edge to the SurveyProgress entity was cleared.
func (m *SurveyMutation) ProgressHistoryCleared() bool {
	return m.clearedprogress_history
}

// RemoveProgressHistoryIDs removes the "progress_history" edge to the SurveyProgress entity by IDs.
func (m *SurveyMutation) RemoveProgressHistoryIDs(ids ...string) {
	if m.removedprogress_history == nil {
		m.removedprogress_history = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.progress_history, ids[i])
		m.removedprogress_history[ids[i]] = struct{}{}
	}
}

// RemovedProgressHistory returns the removed IDs of the "progress_history" edge to the SurveyProgress entity.
func (m *SurveyMutation) RemovedProgressHistoryIDs() (ids []string) {
	for id := range m.removedprogress_history {
		ids = append(ids, id)
	}
	return
}

// ProgressHistoryIDs returns the "progress_history" edge IDs in the mutation.
func (m *SurveyMutation) ProgressHistoryIDs() (ids []string) {
	for id := range m.progress_history {
		ids = append(ids, id)
	}
	return
}

// ResetProgressHistory resets all changes to the "progress_history" edge.
func (m *SurveyMutation) ResetProgressHistory() {
	m.progress_history = nil
	m.clearedprogress_history = false
	m.removedprogress_history = nil
}

// SetCreatedByID sets the "created_by" edge to the User entity by id.
func (m *SurveyMutation) SetCreatedByID(id string) {
	m.created_by = &id
}

// ClearCreatedBy clears the "created_by" edge to the User entity.
func (m *SurveyMutation) ClearCreatedBy() {
	m.clearedcreated_by = true
}

// CreatedByCleared reports if the "created_by" edge to the User entity was cleared.
func (m *SurveyMutation) CreatedByCleared() bool {
	return m.clearedcreated_by
}

// CreatedByID returns the "created_by" edge ID in the mutation.
func (m *SurveyMutation) CreatedByID() (id string, exists bool) {
	if m.created_by != nil {
		return *m.created_by, true
	}
	return
}

// CreatedByIDs returns the "created_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatedByID instead. It exists only for internal usage by the builders.
func (m *SurveyMutation) CreatedByIDs() (ids []string) {
	if id := m.created_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatedBy resets all changes to the "created_by" edge.
func (m *SurveyMutation) ResetCreatedBy() {
	m.created_by = nil
	m.clearedcreated_by = false
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *SurveyMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *SurveyMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *SurveyMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *SurveyMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *SurveyMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *SurveyMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// Where appends a list predicates to the SurveyMutation builder.
func (m *SurveyMutation) Where(ps ...predicate.Survey) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Survey, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Survey).
func (m *SurveyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, survey.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, survey.FieldUpdatedAt)
	}
	if m.date != nil {
		fields = append(fields, survey.FieldDate)
	}
	if m.slot != nil {
		fields = append(fields, survey.FieldSlot)
	}
	if m.slot_id != nil {
		fields = append(fields, survey.FieldSlotID)
	}
	if m.from != nil {
		fields = append(fields, survey.FieldFrom)
	}
	if m.to != nil {
		fields = append(fields, survey.FieldTo)
	}
	if m.until != nil {
		fields = append(fields, survey.FieldUntil)
	}
	if m.name != nil {
		fields = append(fields, survey.FieldName)
	}
	if m.address != nil {
		fields = append(fields, survey.FieldAddress)
	}
	if m.phone != nil {
		fields = append(fields, survey.FieldPhone)
	}
	if m.notes != nil {
		fields = append(fields, survey.FieldNotes)
	}
	if m.status != nil {
		fields = append(fields, survey.FieldStatus)
	}
	if m.progress != nil {
		fields = append(fields, survey.FieldProgress)
	}
	if m.progress_at != nil {
		fields = append(fields, survey.FieldProgressAt)
	}
	if m.progress_flag_at != nil {
		fields = append(fields, survey.FieldProgressFlagAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case survey.FieldCreatedAt:
		return m.CreatedAt()
	case survey.FieldUpdatedAt:
		return m.UpdatedAt()
	case survey.FieldDate:
		return m.Date()
	case survey.FieldSlot:
		return m.Slot()
	case survey.FieldSlotID:
		return m.SlotID()
	case survey.FieldFrom:
		return m.From()
	case survey.FieldTo:
		return m.To()
	case survey.FieldUntil:
		return m.Until()
	case survey.FieldName:
		return m.Name()
	case survey.FieldAddress:
		return m.Address()
	case survey.FieldPhone:
		return m.Phone()
	case survey.FieldNotes:
		return m.Notes()
	case survey.FieldStatus:
		return m.Status()
	case survey.FieldProgress:
		return m.Progress()
	case survey.FieldProgressAt:
		return m.ProgressAt()
	case survey.FieldProgressFlagAt:
		return m.ProgressFlagAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case survey.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case survey.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case survey.FieldDate:
		return m.OldDate(ctx)
	case survey.FieldSlot:
		return m.OldSlot(ctx)
	case survey.FieldSlotID:
		return m.OldSlotID(ctx)
	case survey.FieldFrom:
		return m.OldFrom(ctx)
	case survey.FieldTo:
		return m.OldTo(ctx)
	case survey.FieldUntil:
		return m.OldUntil(ctx)
	case survey.FieldName:
		return m.OldName(ctx)
	case survey.FieldAddress:
		return m.OldAddress(ctx)
	case survey.FieldPhone:
		return m.OldPhone(ctx)
	case survey.FieldNotes:
		return m.OldNotes(ctx)
	case survey.FieldStatus:
		return m.OldStatus(ctx)
	case survey.FieldProgress:
		return m.OldProgress(ctx)
	case survey.FieldProgressAt:
		return m.OldProgressAt(ctx)
	case survey.FieldProgressFlagAt:
		return m.OldProgressFlagAt(ctx)
	}
	return nil, fmt.Errorf("unknown Survey field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case survey.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case survey.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case survey.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case survey.FieldSlot:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlot(v)
		return nil
	case survey.FieldSlotID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlotID(v)
		return nil
	case survey.FieldFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrom(v)
		return nil
	case survey.FieldTo:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTo(v)
		return nil
	case survey.FieldUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUntil(v)
		return nil
	case survey.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case survey.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case survey.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case survey.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case survey.FieldStatus:
		v, ok := value.(enum.SurveyStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case survey.FieldProgress:
		v, ok := value.(enum.SurveyProgress)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgress(v)
		return nil
	case survey.FieldProgressAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgressAt(v)
		return nil
	case survey.FieldProgressFlagAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProgressFlagAt(v)
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Survey numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(survey.FieldUntil) {
		fields = append(fields, survey.FieldUntil)
	}
	if m.FieldCleared(survey.FieldName) {
		fields = append(fields, survey.FieldName)
	}
	if m.FieldCleared(survey.FieldAddress) {
		fields = append(fields, survey.FieldAddress)
	}
	if m.FieldCleared(survey.FieldPhone) {
		fields = append(fields, survey.FieldPhone)
	}
	if m.FieldCleared(survey.FieldNotes) {
		fields = append(fields, survey.FieldNotes)
	}
	if m.FieldCleared(survey.FieldProgress) {
		fields = append(fields, survey.FieldProgress)
	}
	if m.FieldCleared(survey.FieldProgressAt) {
		fields = append(fields, survey.FieldProgressAt)
	}
	if m.FieldCleared(survey.FieldProgressFlagAt) {
		fields = append(fields, survey.FieldProgressFlagAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyMutation) ClearField(name string) error {
	switch name {
	case survey.FieldUntil:
		m.ClearUntil()
		return nil
	case survey.FieldName:
		m.ClearName()
		return nil
	case survey.FieldAddress:
		m.ClearAddress()
		return nil
	case survey.FieldPhone:
		m.ClearPhone()
		return nil
	case survey.FieldNotes:
		m.ClearNotes()
		return nil
	case survey.FieldProgress:
		m.ClearProgress()
		return nil
	case survey.FieldProgressAt:
		m.ClearProgressAt()
		return nil
	case survey.FieldProgressFlagAt:
		m.ClearProgressFlagAt()
		return nil
	}
	return fmt.Errorf("unknown Survey nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyMutation) ResetField(name string) error {
	switch name {
	case survey.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case survey.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case survey.FieldDate:
		m.ResetDate()
		return nil
	case survey.FieldSlot:
		m.ResetSlot()
		return nil
	case survey.FieldSlotID:
		m.ResetSlotID()
		return nil
	case survey.FieldFrom:
		m.ResetFrom()
		return nil
	case survey.FieldTo:
		m.ResetTo()
		return nil
	case survey.FieldUntil:
		m.ResetUntil()
		return nil
	case survey.FieldName:
		m.ResetName()
		return nil
	case survey.FieldAddress:
		m.ResetAddress()
		return nil
	case survey.FieldPhone:
		m.ResetPhone()
		return nil
	case survey.FieldNotes:
		m.ResetNotes()
		return nil
	case survey.FieldStatus:
		m.ResetStatus()
		return nil
	case survey.FieldProgress:
		m.ResetProgress()
		return nil
	case survey.FieldProgressAt:
		m.ResetProgressAt()
		return nil
	case survey.FieldProgressFlagAt:
		m.ResetProgressFlagAt()
		return nil
	}
	return fmt.Errorf("unknown Survey field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.progress_history != nil {
		edges = append(edges, survey.EdgeProgressHistory)
	}
	if m.created_by != nil {
		edges = append(edges, survey.EdgeCreatedBy)
	}
	if m.partner != nil {
		edges = append(edges, survey.EdgePartner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgeProgressHistory:
		ids := make([]ent.Value, 0, len(m.progress_history))
		for id := range m.progress_history {
			ids = append(ids, id)
		}
		return ids
	case survey.EdgeCreatedBy:
		if id := m.created_by; id != nil {
			return []ent.Value{*id}
		}
	case survey.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedprogress_history != nil {
		edges = append(edges, survey.EdgeProgressHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case survey.EdgeProgressHistory:
		ids := make([]ent.Value, 0, len(m.removedprogress_history))
		for id := range m.removedprogress_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedprogress_history {
		edges = append(edges, survey.EdgeProgressHistory)
	}
	if m.clearedcreated_by {
		edges = append(edges, survey.EdgeCreatedBy)
	}
	if m.clearedpartner {
		edges = append(edges, survey.EdgePartner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyMutation) EdgeCleared(name string) bool {
	switch name {
	case survey.EdgeProgressHistory:
		return m.clearedprogress_history
	case survey.EdgeCreatedBy:
		return m.clearedcreated_by
	case survey.EdgePartner:
		return m.clearedpartner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyMutation) ClearEdge(name string) error {
	switch name {
	case survey.EdgeCreatedBy:
		m.ClearCreatedBy()
		return nil
	case survey.EdgePartner:
		m.ClearPartner()
		return nil
	}
	return fmt.Errorf("unknown Survey unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyMutation) ResetEdge(name string) error {
	switch name {
	case survey.EdgeProgressHistory:
		m.ResetProgressHistory()
		return nil
	case survey.EdgeCreatedBy:
		m.ResetCreatedBy()
		return nil
	case survey.EdgePartner:
		m.ResetPartner()
		return nil
	}
	return fmt.Errorf("unknown Survey edge %s", name)
}

// SurveyProgressMutation represents an operation that mutates the SurveyProgress nodes in the graph.
type SurveyProgressMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	status             *enum.SurveyProgress
	complete           *bool
	note               *string
	clearedFields      map[string]struct{}
	survey             *string
	clearedsurvey      bool
	creator            *string
	clearedcreator     bool
	creator_api        *string
	clearedcreator_api bool
	done               bool
	oldValue           func(context.Context) (*SurveyProgress, error)
	predicates         []predicate.SurveyProgress
}

var _ ent.Mutation = (*SurveyProgressMutation)(nil)

// surveyprogressOption allows management of the mutation configuration using functional options.
type surveyprogressOption func(*SurveyProgressMutation)

// newSurveyProgressMutation creates new mutation for the SurveyProgress entity.
func newSurveyProgressMutation(c config, op Op, opts ...surveyprogressOption) *SurveyProgressMutation {
	m := &SurveyProgressMutation{
		config:        c,
		op:            op,
		typ:           TypeSurveyProgress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSurveyProgressID sets the ID field of the mutation.
func withSurveyProgressID(id string) surveyprogressOption {
	return func(m *SurveyProgressMutation) {
		var (
			err   error
			once  sync.Once
			value *SurveyProgress
		)
		m.oldValue = func(ctx context.Context) (*SurveyProgress, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SurveyProgress.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSurveyProgress sets the old SurveyProgress of the mutation.
func withSurveyProgress(node *SurveyProgress) surveyprogressOption {
	return func(m *SurveyProgressMutation) {
		m.oldValue = func(context.Context) (*SurveyProgress, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SurveyProgressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SurveyProgressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SurveyProgress entities.
func (m *SurveyProgressMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SurveyProgressMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SurveyProgressMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SurveyProgress.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SurveyProgressMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SurveyProgressMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SurveyProgress entity.
// If the SurveyProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyProgressMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SurveyProgressMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStatus sets the "status" field.
func (m *SurveyProgressMutation) SetStatus(ep enum.SurveyProgress) {
	m.status = &ep
}

// Status returns the value of the "status" field in the mutation.
func (m *SurveyProgressMutation) Status() (r enum.SurveyProgress, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SurveyProgress entity.
// If the SurveyProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyProgressMutation) OldStatus(ctx context.Context) (v enum.SurveyProgress, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SurveyProgressMutation) ResetStatus() {
	m.status = nil
}

// SetComplete sets the "complete" field.
func (m *SurveyProgressMutation) SetComplete(b bool) {
	m.complete = &b
}

// Complete returns the value of the "complete" field in the mutation.
func (m *SurveyProgressMutation) Complete() (r bool, exists bool) {
	v := m.complete
	if v == nil {
		return
	}
	return *v, true
}

// OldComplete returns the old "complete" field's value of the SurveyProgress entity.
// If the SurveyProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyProgressMutation) OldComplete(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComplete is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComplete requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComplete: %w", err)
	}
	return oldValue.Complete, nil
}

// ClearComplete clears the value of the "complete" field.
func (m *SurveyProgressMutation) ClearComplete() {
	m.complete = nil
	m.clearedFields[surveyprogress.FieldComplete] = struct{}{}
}

// CompleteCleared returns if the "complete" field was cleared in this mutation.
func (m *SurveyProgressMutation) CompleteCleared() bool {
	_, ok := m.clearedFields[surveyprogress.FieldComplete]
	return ok
}

// ResetComplete resets all changes to the "complete" field.
func (m *SurveyProgressMutation) ResetComplete() {
	m.complete = nil
	delete(m.clearedFields, surveyprogress.FieldComplete)
}

// SetNote sets the "note" field.
func (m *SurveyProgressMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *SurveyProgressMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the SurveyProgress entity.
// If the SurveyProgress object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SurveyProgressMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *SurveyProgressMutation) ClearNote() {
	m.note = nil
	m.clearedFields[surveyprogress.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *SurveyProgressMutation) NoteCleared() bool {
	_, ok := m.clearedFields[surveyprogress.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *SurveyProgressMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, surveyprogress.FieldNote)
}

// SetSurveyID sets the "survey" edge to the Survey entity by id.
func (m *SurveyProgressMutation) SetSurveyID(id string) {
	m.survey = &id
}

// ClearSurvey clears the "survey" edge to the Survey entity.
func (m *SurveyProgressMutation) ClearSurvey() {
	m.clearedsurvey = true
}

// SurveyCleared reports if the "survey" edge to the Survey entity was cleared.
func (m *SurveyProgressMutation) SurveyCleared() bool {
	return m.clearedsurvey
}

// SurveyID returns the "survey" edge ID in the mutation.
func (m *SurveyProgressMutation) SurveyID() (id string, exists bool) {
	if m.survey != nil {
		return *m.survey, true
	}
	return
}

// SurveyIDs returns the "survey" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SurveyID instead. It exists only for internal usage by the builders.
func (m *SurveyProgressMutation) SurveyIDs() (ids []string) {
	if id := m.survey; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSurvey resets all changes to the "survey" edge.
func (m *SurveyProgressMutation) ResetSurvey() {
	m.survey = nil
	m.clearedsurvey = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *SurveyProgressMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *SurveyProgressMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *SurveyProgressMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *SurveyProgressMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *SurveyProgressMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *SurveyProgressMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetCreatorAPIID sets the "creator_api" edge to the ApiUser entity by id.
func (m *SurveyProgressMutation) SetCreatorAPIID(id string) {
	m.creator_api = &id
}

// ClearCreatorAPI clears the "creator_api" edge to the ApiUser entity.
func (m *SurveyProgressMutation) ClearCreatorAPI() {
	m.clearedcreator_api = true
}

// CreatorAPICleared reports if the "creator_api" edge to the ApiUser entity was cleared.
func (m *SurveyProgressMutation) CreatorAPICleared() bool {
	return m.clearedcreator_api
}

// CreatorAPIID returns the "creator_api" edge ID in the mutation.
func (m *SurveyProgressMutation) CreatorAPIID() (id string, exists bool) {
	if m.creator_api != nil {
		return *m.creator_api, true
	}
	return
}

// CreatorAPIIDs returns the "creator_api" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorAPIID instead. It exists only for internal usage by the builders.
func (m *SurveyProgressMutation) CreatorAPIIDs() (ids []string) {
	if id := m.creator_api; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatorAPI resets all changes to the "creator_api" edge.
func (m *SurveyProgressMutation) ResetCreatorAPI() {
	m.creator_api = nil
	m.clearedcreator_api = false
}

// Where appends a list predicates to the SurveyProgressMutation builder.
func (m *SurveyProgressMutation) Where(ps ...predicate.SurveyProgress) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SurveyProgressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SurveyProgressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SurveyProgress, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SurveyProgressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SurveyProgressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SurveyProgress).
func (m *SurveyProgressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SurveyProgressMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, surveyprogress.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, surveyprogress.FieldStatus)
	}
	if m.complete != nil {
		fields = append(fields, surveyprogress.FieldComplete)
	}
	if m.note != nil {
		fields = append(fields, surveyprogress.FieldNote)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SurveyProgressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case surveyprogress.FieldCreatedAt:
		return m.CreatedAt()
	case surveyprogress.FieldStatus:
		return m.Status()
	case surveyprogress.FieldComplete:
		return m.Complete()
	case surveyprogress.FieldNote:
		return m.Note()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SurveyProgressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case surveyprogress.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case surveyprogress.FieldStatus:
		return m.OldStatus(ctx)
	case surveyprogress.FieldComplete:
		return m.OldComplete(ctx)
	case surveyprogress.FieldNote:
		return m.OldNote(ctx)
	}
	return nil, fmt.Errorf("unknown SurveyProgress field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyProgressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case surveyprogress.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case surveyprogress.FieldStatus:
		v, ok := value.(enum.SurveyProgress)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case surveyprogress.FieldComplete:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComplete(v)
		return nil
	case surveyprogress.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	}
	return fmt.Errorf("unknown SurveyProgress field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SurveyProgressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SurveyProgressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SurveyProgressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SurveyProgress numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SurveyProgressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(surveyprogress.FieldComplete) {
		fields = append(fields, surveyprogress.FieldComplete)
	}
	if m.FieldCleared(surveyprogress.FieldNote) {
		fields = append(fields, surveyprogress.FieldNote)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SurveyProgressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SurveyProgressMutation) ClearField(name string) error {
	switch name {
	case surveyprogress.FieldComplete:
		m.ClearComplete()
		return nil
	case surveyprogress.FieldNote:
		m.ClearNote()
		return nil
	}
	return fmt.Errorf("unknown SurveyProgress nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SurveyProgressMutation) ResetField(name string) error {
	switch name {
	case surveyprogress.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case surveyprogress.FieldStatus:
		m.ResetStatus()
		return nil
	case surveyprogress.FieldComplete:
		m.ResetComplete()
		return nil
	case surveyprogress.FieldNote:
		m.ResetNote()
		return nil
	}
	return fmt.Errorf("unknown SurveyProgress field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SurveyProgressMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.survey != nil {
		edges = append(edges, surveyprogress.EdgeSurvey)
	}
	if m.creator != nil {
		edges = append(edges, surveyprogress.EdgeCreator)
	}
	if m.creator_api != nil {
		edges = append(edges, surveyprogress.EdgeCreatorAPI)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SurveyProgressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case surveyprogress.EdgeSurvey:
		if id := m.survey; id != nil {
			return []ent.Value{*id}
		}
	case surveyprogress.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case surveyprogress.EdgeCreatorAPI:
		if id := m.creator_api; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SurveyProgressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SurveyProgressMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SurveyProgressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsurvey {
		edges = append(edges, surveyprogress.EdgeSurvey)
	}
	if m.clearedcreator {
		edges = append(edges, surveyprogress.EdgeCreator)
	}
	if m.clearedcreator_api {
		edges = append(edges, surveyprogress.EdgeCreatorAPI)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SurveyProgressMutation) EdgeCleared(name string) bool {
	switch name {
	case surveyprogress.EdgeSurvey:
		return m.clearedsurvey
	case surveyprogress.EdgeCreator:
		return m.clearedcreator
	case surveyprogress.EdgeCreatorAPI:
		return m.clearedcreator_api
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SurveyProgressMutation) ClearEdge(name string) error {
	switch name {
	case surveyprogress.EdgeSurvey:
		m.ClearSurvey()
		return nil
	case surveyprogress.EdgeCreator:
		m.ClearCreator()
		return nil
	case surveyprogress.EdgeCreatorAPI:
		m.ClearCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown SurveyProgress unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SurveyProgressMutation) ResetEdge(name string) error {
	switch name {
	case surveyprogress.EdgeSurvey:
		m.ResetSurvey()
		return nil
	case surveyprogress.EdgeCreator:
		m.ResetCreator()
		return nil
	case surveyprogress.EdgeCreatorAPI:
		m.ResetCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown SurveyProgress edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	confirmed_at  *time.Time
	action        *string
	data          *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id string) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetConfirmedAt sets the "confirmed_at" field.
func (m *TokenMutation) SetConfirmedAt(t time.Time) {
	m.confirmed_at = &t
}

// ConfirmedAt returns the value of the "confirmed_at" field in the mutation.
func (m *TokenMutation) ConfirmedAt() (r time.Time, exists bool) {
	v := m.confirmed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldConfirmedAt returns the old "confirmed_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldConfirmedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfirmedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfirmedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfirmedAt: %w", err)
	}
	return oldValue.ConfirmedAt, nil
}

// ClearConfirmedAt clears the value of the "confirmed_at" field.
func (m *TokenMutation) ClearConfirmedAt() {
	m.confirmed_at = nil
	m.clearedFields[token.FieldConfirmedAt] = struct{}{}
}

// ConfirmedAtCleared returns if the "confirmed_at" field was cleared in this mutation.
func (m *TokenMutation) ConfirmedAtCleared() bool {
	_, ok := m.clearedFields[token.FieldConfirmedAt]
	return ok
}

// ResetConfirmedAt resets all changes to the "confirmed_at" field.
func (m *TokenMutation) ResetConfirmedAt() {
	m.confirmed_at = nil
	delete(m.clearedFields, token.FieldConfirmedAt)
}

// SetAction sets the "action" field.
func (m *TokenMutation) SetAction(s string) {
	m.action = &s
}

// Action returns the value of the "action" field in the mutation.
func (m *TokenMutation) Action() (r string, exists bool) {
	v := m.action
	if v == nil {
		return
	}
	return *v, true
}

// OldAction returns the old "action" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldAction(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAction: %w", err)
	}
	return oldValue.Action, nil
}

// ResetAction resets all changes to the "action" field.
func (m *TokenMutation) ResetAction() {
	m.action = nil
}

// SetData sets the "data" field.
func (m *TokenMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *TokenMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *TokenMutation) ClearData() {
	m.data = nil
	m.clearedFields[token.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *TokenMutation) DataCleared() bool {
	_, ok := m.clearedFields[token.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *TokenMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, token.FieldData)
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.confirmed_at != nil {
		fields = append(fields, token.FieldConfirmedAt)
	}
	if m.action != nil {
		fields = append(fields, token.FieldAction)
	}
	if m.data != nil {
		fields = append(fields, token.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldConfirmedAt:
		return m.ConfirmedAt()
	case token.FieldAction:
		return m.Action()
	case token.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldConfirmedAt:
		return m.OldConfirmedAt(ctx)
	case token.FieldAction:
		return m.OldAction(ctx)
	case token.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldConfirmedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfirmedAt(v)
		return nil
	case token.FieldAction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAction(v)
		return nil
	case token.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(token.FieldConfirmedAt) {
		fields = append(fields, token.FieldConfirmedAt)
	}
	if m.FieldCleared(token.FieldData) {
		fields = append(fields, token.FieldData)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	switch name {
	case token.FieldConfirmedAt:
		m.ClearConfirmedAt()
		return nil
	case token.FieldData:
		m.ClearData()
		return nil
	}
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldConfirmedAt:
		m.ResetConfirmedAt()
		return nil
	case token.FieldAction:
		m.ResetAction()
		return nil
	case token.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Token edge %s", name)
}

// TrainingCourseMutation represents an operation that mutates the TrainingCourse nodes in the graph.
type TrainingCourseMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	name                   *string
	clearedFields          map[string]struct{}
	training_videos        map[string]struct{}
	removedtraining_videos map[string]struct{}
	clearedtraining_videos bool
	creator                *string
	clearedcreator         bool
	done                   bool
	oldValue               func(context.Context) (*TrainingCourse, error)
	predicates             []predicate.TrainingCourse
}

var _ ent.Mutation = (*TrainingCourseMutation)(nil)

// trainingcourseOption allows management of the mutation configuration using functional options.
type trainingcourseOption func(*TrainingCourseMutation)

// newTrainingCourseMutation creates new mutation for the TrainingCourse entity.
func newTrainingCourseMutation(c config, op Op, opts ...trainingcourseOption) *TrainingCourseMutation {
	m := &TrainingCourseMutation{
		config:        c,
		op:            op,
		typ:           TypeTrainingCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrainingCourseID sets the ID field of the mutation.
func withTrainingCourseID(id string) trainingcourseOption {
	return func(m *TrainingCourseMutation) {
		var (
			err   error
			once  sync.Once
			value *TrainingCourse
		)
		m.oldValue = func(ctx context.Context) (*TrainingCourse, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrainingCourse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrainingCourse sets the old TrainingCourse of the mutation.
func withTrainingCourse(node *TrainingCourse) trainingcourseOption {
	return func(m *TrainingCourseMutation) {
		m.oldValue = func(context.Context) (*TrainingCourse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrainingCourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrainingCourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrainingCourse entities.
func (m *TrainingCourseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrainingCourseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrainingCourseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrainingCourse.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TrainingCourseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrainingCourseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrainingCourse entity.
// If the TrainingCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainingCourseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrainingCourseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrainingCourseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrainingCourseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrainingCourse entity.
// If the TrainingCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainingCourseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrainingCourseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *TrainingCourseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TrainingCourseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the TrainingCourse entity.
// If the TrainingCourse object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainingCourseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TrainingCourseMutation) ResetName() {
	m.name = nil
}

// AddTrainingVideoIDs adds the "training_videos" edge to the TrainingVideo entity by ids.
func (m *TrainingCourseMutation) AddTrainingVideoIDs(ids ...string) {
	if m.training_videos == nil {
		m.training_videos = make(map[string]struct{})
	}
	for i := range ids {
		m.training_videos[ids[i]] = struct{}{}
	}
}

// ClearTrainingVideos clears the "training_videos" edge to the TrainingVideo entity.
func (m *TrainingCourseMutation) ClearTrainingVideos() {
	m.clearedtraining_videos = true
}

// TrainingVideosCleared reports if the "training_videos" edge to the TrainingVideo entity was cleared.
func (m *TrainingCourseMutation) TrainingVideosCleared() bool {
	return m.clearedtraining_videos
}

// RemoveTrainingVideoIDs removes the "training_videos" edge to the TrainingVideo entity by IDs.
func (m *TrainingCourseMutation) RemoveTrainingVideoIDs(ids ...string) {
	if m.removedtraining_videos == nil {
		m.removedtraining_videos = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.training_videos, ids[i])
		m.removedtraining_videos[ids[i]] = struct{}{}
	}
}

// RemovedTrainingVideos returns the removed IDs of the "training_videos" edge to the TrainingVideo entity.
func (m *TrainingCourseMutation) RemovedTrainingVideosIDs() (ids []string) {
	for id := range m.removedtraining_videos {
		ids = append(ids, id)
	}
	return
}

// TrainingVideosIDs returns the "training_videos" edge IDs in the mutation.
func (m *TrainingCourseMutation) TrainingVideosIDs() (ids []string) {
	for id := range m.training_videos {
		ids = append(ids, id)
	}
	return
}

// ResetTrainingVideos resets all changes to the "training_videos" edge.
func (m *TrainingCourseMutation) ResetTrainingVideos() {
	m.training_videos = nil
	m.clearedtraining_videos = false
	m.removedtraining_videos = nil
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *TrainingCourseMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *TrainingCourseMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *TrainingCourseMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *TrainingCourseMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TrainingCourseMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *TrainingCourseMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the TrainingCourseMutation builder.
func (m *TrainingCourseMutation) Where(ps ...predicate.TrainingCourse) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrainingCourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrainingCourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrainingCourse, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrainingCourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrainingCourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrainingCourse).
func (m *TrainingCourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrainingCourseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, trainingcourse.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trainingcourse.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, trainingcourse.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrainingCourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trainingcourse.FieldCreatedAt:
		return m.CreatedAt()
	case trainingcourse.FieldUpdatedAt:
		return m.UpdatedAt()
	case trainingcourse.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrainingCourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trainingcourse.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trainingcourse.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trainingcourse.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown TrainingCourse field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrainingCourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trainingcourse.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trainingcourse.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trainingcourse.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown TrainingCourse field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrainingCourseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrainingCourseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrainingCourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TrainingCourse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrainingCourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrainingCourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrainingCourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TrainingCourse nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrainingCourseMutation) ResetField(name string) error {
	switch name {
	case trainingcourse.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trainingcourse.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trainingcourse.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown TrainingCourse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrainingCourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.training_videos != nil {
		edges = append(edges, trainingcourse.EdgeTrainingVideos)
	}
	if m.creator != nil {
		edges = append(edges, trainingcourse.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrainingCourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trainingcourse.EdgeTrainingVideos:
		ids := make([]ent.Value, 0, len(m.training_videos))
		for id := range m.training_videos {
			ids = append(ids, id)
		}
		return ids
	case trainingcourse.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrainingCourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtraining_videos != nil {
		edges = append(edges, trainingcourse.EdgeTrainingVideos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrainingCourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case trainingcourse.EdgeTrainingVideos:
		ids := make([]ent.Value, 0, len(m.removedtraining_videos))
		for id := range m.removedtraining_videos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrainingCourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtraining_videos {
		edges = append(edges, trainingcourse.EdgeTrainingVideos)
	}
	if m.clearedcreator {
		edges = append(edges, trainingcourse.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrainingCourseMutation) EdgeCleared(name string) bool {
	switch name {
	case trainingcourse.EdgeTrainingVideos:
		return m.clearedtraining_videos
	case trainingcourse.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrainingCourseMutation) ClearEdge(name string) error {
	switch name {
	case trainingcourse.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown TrainingCourse unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrainingCourseMutation) ResetEdge(name string) error {
	switch name {
	case trainingcourse.EdgeTrainingVideos:
		m.ResetTrainingVideos()
		return nil
	case trainingcourse.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown TrainingCourse edge %s", name)
}

// TrainingVideoMutation represents an operation that mutates the TrainingVideo nodes in the graph.
type TrainingVideoMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	kind                   *enum.TrainingType
	title                  *string
	description            *string
	clearedFields          map[string]struct{}
	training_videos        map[string]struct{}
	removedtraining_videos map[string]struct{}
	clearedtraining_videos bool
	creator                *string
	clearedcreator         bool
	course                 *string
	clearedcourse          bool
	poster                 *string
	clearedposter          bool
	video                  *string
	clearedvideo           bool
	done                   bool
	oldValue               func(context.Context) (*TrainingVideo, error)
	predicates             []predicate.TrainingVideo
}

var _ ent.Mutation = (*TrainingVideoMutation)(nil)

// trainingvideoOption allows management of the mutation configuration using functional options.
type trainingvideoOption func(*TrainingVideoMutation)

// newTrainingVideoMutation creates new mutation for the TrainingVideo entity.
func newTrainingVideoMutation(c config, op Op, opts ...trainingvideoOption) *TrainingVideoMutation {
	m := &TrainingVideoMutation{
		config:        c,
		op:            op,
		typ:           TypeTrainingVideo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTrainingVideoID sets the ID field of the mutation.
func withTrainingVideoID(id string) trainingvideoOption {
	return func(m *TrainingVideoMutation) {
		var (
			err   error
			once  sync.Once
			value *TrainingVideo
		)
		m.oldValue = func(ctx context.Context) (*TrainingVideo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TrainingVideo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTrainingVideo sets the old TrainingVideo of the mutation.
func withTrainingVideo(node *TrainingVideo) trainingvideoOption {
	return func(m *TrainingVideoMutation) {
		m.oldValue = func(context.Context) (*TrainingVideo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TrainingVideoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TrainingVideoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TrainingVideo entities.
func (m *TrainingVideoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TrainingVideoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TrainingVideoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TrainingVideo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TrainingVideoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TrainingVideoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TrainingVideo entity.
// If the TrainingVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainingVideoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TrainingVideoMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TrainingVideoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TrainingVideoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TrainingVideo entity.
// If the TrainingVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainingVideoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TrainingVideoMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKind sets the "kind" field.
func (m *TrainingVideoMutation) SetKind(et enum.TrainingType) {
	m.kind = &et
}

// Kind returns the value of the "kind" field in the mutation.
func (m *TrainingVideoMutation) Kind() (r enum.TrainingType, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the TrainingVideo entity.
// If the TrainingVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainingVideoMutation) OldKind(ctx context.Context) (v enum.TrainingType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *TrainingVideoMutation) ResetKind() {
	m.kind = nil
}

// SetTitle sets the "title" field.
func (m *TrainingVideoMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TrainingVideoMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the TrainingVideo entity.
// If the TrainingVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainingVideoMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TrainingVideoMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *TrainingVideoMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TrainingVideoMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the TrainingVideo entity.
// If the TrainingVideo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TrainingVideoMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TrainingVideoMutation) ResetDescription() {
	m.description = nil
}

// AddTrainingVideoIDs adds the "training_videos" edge to the PartnerTrainingVideo entity by ids.
func (m *TrainingVideoMutation) AddTrainingVideoIDs(ids ...string) {
	if m.training_videos == nil {
		m.training_videos = make(map[string]struct{})
	}
	for i := range ids {
		m.training_videos[ids[i]] = struct{}{}
	}
}

// ClearTrainingVideos clears the "training_videos" edge to the PartnerTrainingVideo entity.
func (m *TrainingVideoMutation) ClearTrainingVideos() {
	m.clearedtraining_videos = true
}

// TrainingVideosCleared reports if the "training_videos" edge to the PartnerTrainingVideo entity was cleared.
func (m *TrainingVideoMutation) TrainingVideosCleared() bool {
	return m.clearedtraining_videos
}

// RemoveTrainingVideoIDs removes the "training_videos" edge to the PartnerTrainingVideo entity by IDs.
func (m *TrainingVideoMutation) RemoveTrainingVideoIDs(ids ...string) {
	if m.removedtraining_videos == nil {
		m.removedtraining_videos = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.training_videos, ids[i])
		m.removedtraining_videos[ids[i]] = struct{}{}
	}
}

// RemovedTrainingVideos returns the removed IDs of the "training_videos" edge to the PartnerTrainingVideo entity.
func (m *TrainingVideoMutation) RemovedTrainingVideosIDs() (ids []string) {
	for id := range m.removedtraining_videos {
		ids = append(ids, id)
	}
	return
}

// TrainingVideosIDs returns the "training_videos" edge IDs in the mutation.
func (m *TrainingVideoMutation) TrainingVideosIDs() (ids []string) {
	for id := range m.training_videos {
		ids = append(ids, id)
	}
	return
}

// ResetTrainingVideos resets all changes to the "training_videos" edge.
func (m *TrainingVideoMutation) ResetTrainingVideos() {
	m.training_videos = nil
	m.clearedtraining_videos = false
	m.removedtraining_videos = nil
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *TrainingVideoMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *TrainingVideoMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *TrainingVideoMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *TrainingVideoMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TrainingVideoMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *TrainingVideoMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetCourseID sets the "course" edge to the TrainingCourse entity by id.
func (m *TrainingVideoMutation) SetCourseID(id string) {
	m.course = &id
}

// ClearCourse clears the "course" edge to the TrainingCourse entity.
func (m *TrainingVideoMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the TrainingCourse entity was cleared.
func (m *TrainingVideoMutation) CourseCleared() bool {
	return m.clearedcourse
}

// CourseID returns the "course" edge ID in the mutation.
func (m *TrainingVideoMutation) CourseID() (id string, exists bool) {
	if m.course != nil {
		return *m.course, true
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *TrainingVideoMutation) CourseIDs() (ids []string) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *TrainingVideoMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// SetPosterID sets the "poster" edge to the Document entity by id.
func (m *TrainingVideoMutation) SetPosterID(id string) {
	m.poster = &id
}

// ClearPoster clears the "poster" edge to the Document entity.
func (m *TrainingVideoMutation) ClearPoster() {
	m.clearedposter = true
}

// PosterCleared reports if the "poster" edge to the Document entity was cleared.
func (m *TrainingVideoMutation) PosterCleared() bool {
	return m.clearedposter
}

// PosterID returns the "poster" edge ID in the mutation.
func (m *TrainingVideoMutation) PosterID() (id string, exists bool) {
	if m.poster != nil {
		return *m.poster, true
	}
	return
}

// PosterIDs returns the "poster" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PosterID instead. It exists only for internal usage by the builders.
func (m *TrainingVideoMutation) PosterIDs() (ids []string) {
	if id := m.poster; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPoster resets all changes to the "poster" edge.
func (m *TrainingVideoMutation) ResetPoster() {
	m.poster = nil
	m.clearedposter = false
}

// SetVideoID sets the "video" edge to the Document entity by id.
func (m *TrainingVideoMutation) SetVideoID(id string) {
	m.video = &id
}

// ClearVideo clears the "video" edge to the Document entity.
func (m *TrainingVideoMutation) ClearVideo() {
	m.clearedvideo = true
}

// VideoCleared reports if the "video" edge to the Document entity was cleared.
func (m *TrainingVideoMutation) VideoCleared() bool {
	return m.clearedvideo
}

// VideoID returns the "video" edge ID in the mutation.
func (m *TrainingVideoMutation) VideoID() (id string, exists bool) {
	if m.video != nil {
		return *m.video, true
	}
	return
}

// VideoIDs returns the "video" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VideoID instead. It exists only for internal usage by the builders.
func (m *TrainingVideoMutation) VideoIDs() (ids []string) {
	if id := m.video; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVideo resets all changes to the "video" edge.
func (m *TrainingVideoMutation) ResetVideo() {
	m.video = nil
	m.clearedvideo = false
}

// Where appends a list predicates to the TrainingVideoMutation builder.
func (m *TrainingVideoMutation) Where(ps ...predicate.TrainingVideo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TrainingVideoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TrainingVideoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TrainingVideo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TrainingVideoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TrainingVideoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TrainingVideo).
func (m *TrainingVideoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TrainingVideoMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, trainingvideo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, trainingvideo.FieldUpdatedAt)
	}
	if m.kind != nil {
		fields = append(fields, trainingvideo.FieldKind)
	}
	if m.title != nil {
		fields = append(fields, trainingvideo.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, trainingvideo.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TrainingVideoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case trainingvideo.FieldCreatedAt:
		return m.CreatedAt()
	case trainingvideo.FieldUpdatedAt:
		return m.UpdatedAt()
	case trainingvideo.FieldKind:
		return m.Kind()
	case trainingvideo.FieldTitle:
		return m.Title()
	case trainingvideo.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TrainingVideoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case trainingvideo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case trainingvideo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case trainingvideo.FieldKind:
		return m.OldKind(ctx)
	case trainingvideo.FieldTitle:
		return m.OldTitle(ctx)
	case trainingvideo.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown TrainingVideo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrainingVideoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case trainingvideo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case trainingvideo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case trainingvideo.FieldKind:
		v, ok := value.(enum.TrainingType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case trainingvideo.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case trainingvideo.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown TrainingVideo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TrainingVideoMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TrainingVideoMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TrainingVideoMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TrainingVideo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TrainingVideoMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TrainingVideoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TrainingVideoMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TrainingVideo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TrainingVideoMutation) ResetField(name string) error {
	switch name {
	case trainingvideo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case trainingvideo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case trainingvideo.FieldKind:
		m.ResetKind()
		return nil
	case trainingvideo.FieldTitle:
		m.ResetTitle()
		return nil
	case trainingvideo.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown TrainingVideo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TrainingVideoMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.training_videos != nil {
		edges = append(edges, trainingvideo.EdgeTrainingVideos)
	}
	if m.creator != nil {
		edges = append(edges, trainingvideo.EdgeCreator)
	}
	if m.course != nil {
		edges = append(edges, trainingvideo.EdgeCourse)
	}
	if m.poster != nil {
		edges = append(edges, trainingvideo.EdgePoster)
	}
	if m.video != nil {
		edges = append(edges, trainingvideo.EdgeVideo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TrainingVideoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case trainingvideo.EdgeTrainingVideos:
		ids := make([]ent.Value, 0, len(m.training_videos))
		for id := range m.training_videos {
			ids = append(ids, id)
		}
		return ids
	case trainingvideo.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case trainingvideo.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	case trainingvideo.EdgePoster:
		if id := m.poster; id != nil {
			return []ent.Value{*id}
		}
	case trainingvideo.EdgeVideo:
		if id := m.video; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TrainingVideoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedtraining_videos != nil {
		edges = append(edges, trainingvideo.EdgeTrainingVideos)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TrainingVideoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case trainingvideo.EdgeTrainingVideos:
		ids := make([]ent.Value, 0, len(m.removedtraining_videos))
		for id := range m.removedtraining_videos {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TrainingVideoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtraining_videos {
		edges = append(edges, trainingvideo.EdgeTrainingVideos)
	}
	if m.clearedcreator {
		edges = append(edges, trainingvideo.EdgeCreator)
	}
	if m.clearedcourse {
		edges = append(edges, trainingvideo.EdgeCourse)
	}
	if m.clearedposter {
		edges = append(edges, trainingvideo.EdgePoster)
	}
	if m.clearedvideo {
		edges = append(edges, trainingvideo.EdgeVideo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TrainingVideoMutation) EdgeCleared(name string) bool {
	switch name {
	case trainingvideo.EdgeTrainingVideos:
		return m.clearedtraining_videos
	case trainingvideo.EdgeCreator:
		return m.clearedcreator
	case trainingvideo.EdgeCourse:
		return m.clearedcourse
	case trainingvideo.EdgePoster:
		return m.clearedposter
	case trainingvideo.EdgeVideo:
		return m.clearedvideo
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TrainingVideoMutation) ClearEdge(name string) error {
	switch name {
	case trainingvideo.EdgeCreator:
		m.ClearCreator()
		return nil
	case trainingvideo.EdgeCourse:
		m.ClearCourse()
		return nil
	case trainingvideo.EdgePoster:
		m.ClearPoster()
		return nil
	case trainingvideo.EdgeVideo:
		m.ClearVideo()
		return nil
	}
	return fmt.Errorf("unknown TrainingVideo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TrainingVideoMutation) ResetEdge(name string) error {
	switch name {
	case trainingvideo.EdgeTrainingVideos:
		m.ResetTrainingVideos()
		return nil
	case trainingvideo.EdgeCreator:
		m.ResetCreator()
		return nil
	case trainingvideo.EdgeCourse:
		m.ResetCourse()
		return nil
	case trainingvideo.EdgePoster:
		m.ResetPoster()
		return nil
	case trainingvideo.EdgeVideo:
		m.ResetVideo()
		return nil
	}
	return fmt.Errorf("unknown TrainingVideo edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *string
	created_at                             *time.Time
	deleted_at                             *time.Time
	updated_at                             *time.Time
	external_id                            *string
	email                                  *string
	phone                                  *string
	pwd                                    *string
	first_name                             *string
	last_name                              *string
	email_verified                         *bool
	phone_verified                         *bool
	picture                                *string
	status                                 *enum.AccountStatus
	role                                   *enum.Role
	note                                   *string
	wrong_attempts                         *uint8
	addwrong_attempts                      *int8
	wrong_attempt_at                       *time.Time
	locked_until                           *time.Time
	location                               *string
	accepted_general_terms                 *bool
	accepted_terms_n_privacy               *bool
	clearedFields                          map[string]struct{}
	auths                                  *string
	clearedauths                           bool
	sessions                               map[string]struct{}
	removedsessions                        map[string]struct{}
	clearedsessions                        bool
	audit_logs                             map[string]struct{}
	removedaudit_logs                      map[string]struct{}
	clearedaudit_logs                      bool
	notify                                 map[string]struct{}
	removednotify                          map[string]struct{}
	clearednotify                          bool
	created_jobs                           map[string]struct{}
	removedcreated_jobs                    map[string]struct{}
	clearedcreated_jobs                    bool
	created_estimates                      map[string]struct{}
	removedcreated_estimates               map[string]struct{}
	clearedcreated_estimates               bool
	sales_rep_estimates                    map[string]struct{}
	removedsales_rep_estimates             map[string]struct{}
	clearedsales_rep_estimates             bool
	sales                                  map[string]struct{}
	removedsales                           map[string]struct{}
	clearedsales                           bool
	created_installation_jobs              map[string]struct{}
	removedcreated_installation_jobs       map[string]struct{}
	clearedcreated_installation_jobs       bool
	installation_leads                     map[string]struct{}
	removedinstallation_leads              map[string]struct{}
	clearedinstallation_leads              bool
	estimate_activities                    map[string]struct{}
	removedestimate_activities             map[string]struct{}
	clearedestimate_activities             bool
	job_activities                         map[string]struct{}
	removedjob_activities                  map[string]struct{}
	clearedjob_activities                  bool
	partner_activities                     map[string]struct{}
	removedpartner_activities              map[string]struct{}
	clearedpartner_activities              bool
	user_activities                        map[string]struct{}
	removeduser_activities                 map[string]struct{}
	cleareduser_activities                 bool
	activities                             map[string]struct{}
	removedactivities                      map[string]struct{}
	clearedactivities                      bool
	job_progress_history                   map[string]struct{}
	removedjob_progress_history            map[string]struct{}
	clearedjob_progress_history            bool
	installation_job_status_changer        map[string]struct{}
	removedinstallation_job_status_changer map[string]struct{}
	clearedinstallation_job_status_changer bool
	contact_us_requests                    map[string]struct{}
	removedcontact_us_requests             map[string]struct{}
	clearedcontact_us_requests             bool
	partner                                map[string]struct{}
	removedpartner                         map[string]struct{}
	clearedpartner                         bool
	surveys                                map[string]struct{}
	removedsurveys                         map[string]struct{}
	clearedsurveys                         bool
	survey_progress                        map[string]struct{}
	removedsurvey_progress                 map[string]struct{}
	clearedsurvey_progress                 bool
	created_training_videos                map[string]struct{}
	removedcreated_training_videos         map[string]struct{}
	clearedcreated_training_videos         bool
	created_training_courses               map[string]struct{}
	removedcreated_training_courses        map[string]struct{}
	clearedcreated_training_courses        bool
	job_notes                              map[string]struct{}
	removedjob_notes                       map[string]struct{}
	clearedjob_notes                       bool
	chat_channels                          map[string]struct{}
	removedchat_channels                   map[string]struct{}
	clearedchat_channels                   bool
	sent_messages                          map[string]struct{}
	removedsent_messages                   map[string]struct{}
	clearedsent_messages                   bool
	received_messages                      map[string]struct{}
	removedreceived_messages               map[string]struct{}
	clearedreceived_messages               bool
	channel_message_read                   map[string]struct{}
	removedchannel_message_read            map[string]struct{}
	clearedchannel_message_read            bool
	products_created                       map[string]struct{}
	removedproducts_created                map[string]struct{}
	clearedproducts_created                bool
	product_pkg_created                    map[string]struct{}
	removedproduct_pkg_created             map[string]struct{}
	clearedproduct_pkg_created             bool
	job_doc_urls                           map[string]struct{}
	removedjob_doc_urls                    map[string]struct{}
	clearedjob_doc_urls                    bool
	partner_contacts                       map[string]struct{}
	removedpartner_contacts                map[string]struct{}
	clearedpartner_contacts                bool
	done                                   bool
	oldValue                               func(context.Context) (*User, error)
	predicates                             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExternalID sets the "external_id" field.
func (m *UserMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *UserMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *UserMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[user.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *UserMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[user.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *UserMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, user.FieldExternalID)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetPwd sets the "pwd" field.
func (m *UserMutation) SetPwd(s string) {
	m.pwd = &s
}

// Pwd returns the value of the "pwd" field in the mutation.
func (m *UserMutation) Pwd() (r string, exists bool) {
	v := m.pwd
	if v == nil {
		return
	}
	return *v, true
}

// OldPwd returns the old "pwd" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPwd(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPwd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPwd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPwd: %w", err)
	}
	return oldValue.Pwd, nil
}

// ResetPwd resets all changes to the "pwd" field.
func (m *UserMutation) ResetPwd() {
	m.pwd = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetEmailVerified sets the "email_verified" field.
func (m *UserMutation) SetEmailVerified(b bool) {
	m.email_verified = &b
}

// EmailVerified returns the value of the "email_verified" field in the mutation.
func (m *UserMutation) EmailVerified() (r bool, exists bool) {
	v := m.email_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailVerified returns the old "email_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmailVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailVerified: %w", err)
	}
	return oldValue.EmailVerified, nil
}

// ResetEmailVerified resets all changes to the "email_verified" field.
func (m *UserMutation) ResetEmailVerified() {
	m.email_verified = nil
}

// SetPhoneVerified sets the "phone_verified" field.
func (m *UserMutation) SetPhoneVerified(b bool) {
	m.phone_verified = &b
}

// PhoneVerified returns the value of the "phone_verified" field in the mutation.
func (m *UserMutation) PhoneVerified() (r bool, exists bool) {
	v := m.phone_verified
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneVerified returns the old "phone_verified" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneVerified(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneVerified is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneVerified requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneVerified: %w", err)
	}
	return oldValue.PhoneVerified, nil
}

// ResetPhoneVerified resets all changes to the "phone_verified" field.
func (m *UserMutation) ResetPhoneVerified() {
	m.phone_verified = nil
}

// SetPicture sets the "picture" field.
func (m *UserMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *UserMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPicture(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *UserMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[user.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *UserMutation) PictureCleared() bool {
	_, ok := m.clearedFields[user.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *UserMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, user.FieldPicture)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(es enum.AccountStatus) {
	m.status = &es
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r enum.AccountStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v enum.AccountStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(e enum.Role) {
	m.role = &e
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r enum.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v enum.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetNote sets the "note" field.
func (m *UserMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *UserMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *UserMutation) ClearNote() {
	m.note = nil
	m.clearedFields[user.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *UserMutation) NoteCleared() bool {
	_, ok := m.clearedFields[user.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *UserMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, user.FieldNote)
}

// SetWrongAttempts sets the "wrong_attempts" field.
func (m *UserMutation) SetWrongAttempts(u uint8) {
	m.wrong_attempts = &u
	m.addwrong_attempts = nil
}

// WrongAttempts returns the value of the "wrong_attempts" field in the mutation.
func (m *UserMutation) WrongAttempts() (r uint8, exists bool) {
	v := m.wrong_attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldWrongAttempts returns the old "wrong_attempts" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWrongAttempts(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWrongAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWrongAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWrongAttempts: %w", err)
	}
	return oldValue.WrongAttempts, nil
}

// AddWrongAttempts adds u to the "wrong_attempts" field.
func (m *UserMutation) AddWrongAttempts(u int8) {
	if m.addwrong_attempts != nil {
		*m.addwrong_attempts += u
	} else {
		m.addwrong_attempts = &u
	}
}

// AddedWrongAttempts returns the value that was added to the "wrong_attempts" field in this mutation.
func (m *UserMutation) AddedWrongAttempts() (r int8, exists bool) {
	v := m.addwrong_attempts
	if v == nil {
		return
	}
	return *v, true
}

// ClearWrongAttempts clears the value of the "wrong_attempts" field.
func (m *UserMutation) ClearWrongAttempts() {
	m.wrong_attempts = nil
	m.addwrong_attempts = nil
	m.clearedFields[user.FieldWrongAttempts] = struct{}{}
}

// WrongAttemptsCleared returns if the "wrong_attempts" field was cleared in this mutation.
func (m *UserMutation) WrongAttemptsCleared() bool {
	_, ok := m.clearedFields[user.FieldWrongAttempts]
	return ok
}

// ResetWrongAttempts resets all changes to the "wrong_attempts" field.
func (m *UserMutation) ResetWrongAttempts() {
	m.wrong_attempts = nil
	m.addwrong_attempts = nil
	delete(m.clearedFields, user.FieldWrongAttempts)
}

// SetWrongAttemptAt sets the "wrong_attempt_at" field.
func (m *UserMutation) SetWrongAttemptAt(t time.Time) {
	m.wrong_attempt_at = &t
}

// WrongAttemptAt returns the value of the "wrong_attempt_at" field in the mutation.
func (m *UserMutation) WrongAttemptAt() (r time.Time, exists bool) {
	v := m.wrong_attempt_at
	if v == nil {
		return
	}
	return *v, true
}

// OldWrongAttemptAt returns the old "wrong_attempt_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWrongAttemptAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWrongAttemptAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWrongAttemptAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWrongAttemptAt: %w", err)
	}
	return oldValue.WrongAttemptAt, nil
}

// ClearWrongAttemptAt clears the value of the "wrong_attempt_at" field.
func (m *UserMutation) ClearWrongAttemptAt() {
	m.wrong_attempt_at = nil
	m.clearedFields[user.FieldWrongAttemptAt] = struct{}{}
}

// WrongAttemptAtCleared returns if the "wrong_attempt_at" field was cleared in this mutation.
func (m *UserMutation) WrongAttemptAtCleared() bool {
	_, ok := m.clearedFields[user.FieldWrongAttemptAt]
	return ok
}

// ResetWrongAttemptAt resets all changes to the "wrong_attempt_at" field.
func (m *UserMutation) ResetWrongAttemptAt() {
	m.wrong_attempt_at = nil
	delete(m.clearedFields, user.FieldWrongAttemptAt)
}

// SetLockedUntil sets the "locked_until" field.
func (m *UserMutation) SetLockedUntil(t time.Time) {
	m.locked_until = &t
}

// LockedUntil returns the value of the "locked_until" field in the mutation.
func (m *UserMutation) LockedUntil() (r time.Time, exists bool) {
	v := m.locked_until
	if v == nil {
		return
	}
	return *v, true
}

// OldLockedUntil returns the old "locked_until" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLockedUntil(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLockedUntil is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLockedUntil requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLockedUntil: %w", err)
	}
	return oldValue.LockedUntil, nil
}

// ClearLockedUntil clears the value of the "locked_until" field.
func (m *UserMutation) ClearLockedUntil() {
	m.locked_until = nil
	m.clearedFields[user.FieldLockedUntil] = struct{}{}
}

// LockedUntilCleared returns if the "locked_until" field was cleared in this mutation.
func (m *UserMutation) LockedUntilCleared() bool {
	_, ok := m.clearedFields[user.FieldLockedUntil]
	return ok
}

// ResetLockedUntil resets all changes to the "locked_until" field.
func (m *UserMutation) ResetLockedUntil() {
	m.locked_until = nil
	delete(m.clearedFields, user.FieldLockedUntil)
}

// SetLocation sets the "location" field.
func (m *UserMutation) SetLocation(s string) {
	m.location = &s
}

// Location returns the value of the "location" field in the mutation.
func (m *UserMutation) Location() (r string, exists bool) {
	v := m.location
	if v == nil {
		return
	}
	return *v, true
}

// OldLocation returns the old "location" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocation: %w", err)
	}
	return oldValue.Location, nil
}

// ClearLocation clears the value of the "location" field.
func (m *UserMutation) ClearLocation() {
	m.location = nil
	m.clearedFields[user.FieldLocation] = struct{}{}
}

// LocationCleared returns if the "location" field was cleared in this mutation.
func (m *UserMutation) LocationCleared() bool {
	_, ok := m.clearedFields[user.FieldLocation]
	return ok
}

// ResetLocation resets all changes to the "location" field.
func (m *UserMutation) ResetLocation() {
	m.location = nil
	delete(m.clearedFields, user.FieldLocation)
}

// SetAcceptedGeneralTerms sets the "accepted_general_terms" field.
func (m *UserMutation) SetAcceptedGeneralTerms(b bool) {
	m.accepted_general_terms = &b
}

// AcceptedGeneralTerms returns the value of the "accepted_general_terms" field in the mutation.
func (m *UserMutation) AcceptedGeneralTerms() (r bool, exists bool) {
	v := m.accepted_general_terms
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedGeneralTerms returns the old "accepted_general_terms" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAcceptedGeneralTerms(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedGeneralTerms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedGeneralTerms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedGeneralTerms: %w", err)
	}
	return oldValue.AcceptedGeneralTerms, nil
}

// ClearAcceptedGeneralTerms clears the value of the "accepted_general_terms" field.
func (m *UserMutation) ClearAcceptedGeneralTerms() {
	m.accepted_general_terms = nil
	m.clearedFields[user.FieldAcceptedGeneralTerms] = struct{}{}
}

// AcceptedGeneralTermsCleared returns if the "accepted_general_terms" field was cleared in this mutation.
func (m *UserMutation) AcceptedGeneralTermsCleared() bool {
	_, ok := m.clearedFields[user.FieldAcceptedGeneralTerms]
	return ok
}

// ResetAcceptedGeneralTerms resets all changes to the "accepted_general_terms" field.
func (m *UserMutation) ResetAcceptedGeneralTerms() {
	m.accepted_general_terms = nil
	delete(m.clearedFields, user.FieldAcceptedGeneralTerms)
}

// SetAcceptedTermsNPrivacy sets the "accepted_terms_n_privacy" field.
func (m *UserMutation) SetAcceptedTermsNPrivacy(b bool) {
	m.accepted_terms_n_privacy = &b
}

// AcceptedTermsNPrivacy returns the value of the "accepted_terms_n_privacy" field in the mutation.
func (m *UserMutation) AcceptedTermsNPrivacy() (r bool, exists bool) {
	v := m.accepted_terms_n_privacy
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedTermsNPrivacy returns the old "accepted_terms_n_privacy" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAcceptedTermsNPrivacy(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedTermsNPrivacy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedTermsNPrivacy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedTermsNPrivacy: %w", err)
	}
	return oldValue.AcceptedTermsNPrivacy, nil
}

// ClearAcceptedTermsNPrivacy clears the value of the "accepted_terms_n_privacy" field.
func (m *UserMutation) ClearAcceptedTermsNPrivacy() {
	m.accepted_terms_n_privacy = nil
	m.clearedFields[user.FieldAcceptedTermsNPrivacy] = struct{}{}
}

// AcceptedTermsNPrivacyCleared returns if the "accepted_terms_n_privacy" field was cleared in this mutation.
func (m *UserMutation) AcceptedTermsNPrivacyCleared() bool {
	_, ok := m.clearedFields[user.FieldAcceptedTermsNPrivacy]
	return ok
}

// ResetAcceptedTermsNPrivacy resets all changes to the "accepted_terms_n_privacy" field.
func (m *UserMutation) ResetAcceptedTermsNPrivacy() {
	m.accepted_terms_n_privacy = nil
	delete(m.clearedFields, user.FieldAcceptedTermsNPrivacy)
}

// SetAuthsID sets the "auths" edge to the UserAuth entity by id.
func (m *UserMutation) SetAuthsID(id string) {
	m.auths = &id
}

// ClearAuths clears the "auths" edge to the UserAuth entity.
func (m *UserMutation) ClearAuths() {
	m.clearedauths = true
}

// AuthsCleared reports if the "auths" edge to the UserAuth entity was cleared.
func (m *UserMutation) AuthsCleared() bool {
	return m.clearedauths
}

// AuthsID returns the "auths" edge ID in the mutation.
func (m *UserMutation) AuthsID() (id string, exists bool) {
	if m.auths != nil {
		return *m.auths, true
	}
	return
}

// AuthsIDs returns the "auths" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) AuthsIDs() (ids []string) {
	if id := m.auths; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuths resets all changes to the "auths" edge.
func (m *UserMutation) ResetAuths() {
	m.auths = nil
	m.clearedauths = false
}

// AddSessionIDs adds the "sessions" edge to the UserSession entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the UserSession entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the UserSession entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the UserSession entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the UserSession entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddAuditLogIDs adds the "audit_logs" edge to the AuditLog entity by ids.
func (m *UserMutation) AddAuditLogIDs(ids ...string) {
	if m.audit_logs == nil {
		m.audit_logs = make(map[string]struct{})
	}
	for i := range ids {
		m.audit_logs[ids[i]] = struct{}{}
	}
}

// ClearAuditLogs clears the "audit_logs" edge to the AuditLog entity.
func (m *UserMutation) ClearAuditLogs() {
	m.clearedaudit_logs = true
}

// AuditLogsCleared reports if the "audit_logs" edge to the AuditLog entity was cleared.
func (m *UserMutation) AuditLogsCleared() bool {
	return m.clearedaudit_logs
}

// RemoveAuditLogIDs removes the "audit_logs" edge to the AuditLog entity by IDs.
func (m *UserMutation) RemoveAuditLogIDs(ids ...string) {
	if m.removedaudit_logs == nil {
		m.removedaudit_logs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.audit_logs, ids[i])
		m.removedaudit_logs[ids[i]] = struct{}{}
	}
}

// RemovedAuditLogs returns the removed IDs of the "audit_logs" edge to the AuditLog entity.
func (m *UserMutation) RemovedAuditLogsIDs() (ids []string) {
	for id := range m.removedaudit_logs {
		ids = append(ids, id)
	}
	return
}

// AuditLogsIDs returns the "audit_logs" edge IDs in the mutation.
func (m *UserMutation) AuditLogsIDs() (ids []string) {
	for id := range m.audit_logs {
		ids = append(ids, id)
	}
	return
}

// ResetAuditLogs resets all changes to the "audit_logs" edge.
func (m *UserMutation) ResetAuditLogs() {
	m.audit_logs = nil
	m.clearedaudit_logs = false
	m.removedaudit_logs = nil
}

// AddNotifyIDs adds the "notify" edge to the NotifySetting entity by ids.
func (m *UserMutation) AddNotifyIDs(ids ...string) {
	if m.notify == nil {
		m.notify = make(map[string]struct{})
	}
	for i := range ids {
		m.notify[ids[i]] = struct{}{}
	}
}

// ClearNotify clears the "notify" edge to the NotifySetting entity.
func (m *UserMutation) ClearNotify() {
	m.clearednotify = true
}

// NotifyCleared reports if the "notify" edge to the NotifySetting entity was cleared.
func (m *UserMutation) NotifyCleared() bool {
	return m.clearednotify
}

// RemoveNotifyIDs removes the "notify" edge to the NotifySetting entity by IDs.
func (m *UserMutation) RemoveNotifyIDs(ids ...string) {
	if m.removednotify == nil {
		m.removednotify = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.notify, ids[i])
		m.removednotify[ids[i]] = struct{}{}
	}
}

// RemovedNotify returns the removed IDs of the "notify" edge to the NotifySetting entity.
func (m *UserMutation) RemovedNotifyIDs() (ids []string) {
	for id := range m.removednotify {
		ids = append(ids, id)
	}
	return
}

// NotifyIDs returns the "notify" edge IDs in the mutation.
func (m *UserMutation) NotifyIDs() (ids []string) {
	for id := range m.notify {
		ids = append(ids, id)
	}
	return
}

// ResetNotify resets all changes to the "notify" edge.
func (m *UserMutation) ResetNotify() {
	m.notify = nil
	m.clearednotify = false
	m.removednotify = nil
}

// AddCreatedJobIDs adds the "created_jobs" edge to the Job entity by ids.
func (m *UserMutation) AddCreatedJobIDs(ids ...string) {
	if m.created_jobs == nil {
		m.created_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.created_jobs[ids[i]] = struct{}{}
	}
}

// ClearCreatedJobs clears the "created_jobs" edge to the Job entity.
func (m *UserMutation) ClearCreatedJobs() {
	m.clearedcreated_jobs = true
}

// CreatedJobsCleared reports if the "created_jobs" edge to the Job entity was cleared.
func (m *UserMutation) CreatedJobsCleared() bool {
	return m.clearedcreated_jobs
}

// RemoveCreatedJobIDs removes the "created_jobs" edge to the Job entity by IDs.
func (m *UserMutation) RemoveCreatedJobIDs(ids ...string) {
	if m.removedcreated_jobs == nil {
		m.removedcreated_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_jobs, ids[i])
		m.removedcreated_jobs[ids[i]] = struct{}{}
	}
}

// RemovedCreatedJobs returns the removed IDs of the "created_jobs" edge to the Job entity.
func (m *UserMutation) RemovedCreatedJobsIDs() (ids []string) {
	for id := range m.removedcreated_jobs {
		ids = append(ids, id)
	}
	return
}

// CreatedJobsIDs returns the "created_jobs" edge IDs in the mutation.
func (m *UserMutation) CreatedJobsIDs() (ids []string) {
	for id := range m.created_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedJobs resets all changes to the "created_jobs" edge.
func (m *UserMutation) ResetCreatedJobs() {
	m.created_jobs = nil
	m.clearedcreated_jobs = false
	m.removedcreated_jobs = nil
}

// AddCreatedEstimateIDs adds the "created_estimates" edge to the Estimate entity by ids.
func (m *UserMutation) AddCreatedEstimateIDs(ids ...string) {
	if m.created_estimates == nil {
		m.created_estimates = make(map[string]struct{})
	}
	for i := range ids {
		m.created_estimates[ids[i]] = struct{}{}
	}
}

// ClearCreatedEstimates clears the "created_estimates" edge to the Estimate entity.
func (m *UserMutation) ClearCreatedEstimates() {
	m.clearedcreated_estimates = true
}

// CreatedEstimatesCleared reports if the "created_estimates" edge to the Estimate entity was cleared.
func (m *UserMutation) CreatedEstimatesCleared() bool {
	return m.clearedcreated_estimates
}

// RemoveCreatedEstimateIDs removes the "created_estimates" edge to the Estimate entity by IDs.
func (m *UserMutation) RemoveCreatedEstimateIDs(ids ...string) {
	if m.removedcreated_estimates == nil {
		m.removedcreated_estimates = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_estimates, ids[i])
		m.removedcreated_estimates[ids[i]] = struct{}{}
	}
}

// RemovedCreatedEstimates returns the removed IDs of the "created_estimates" edge to the Estimate entity.
func (m *UserMutation) RemovedCreatedEstimatesIDs() (ids []string) {
	for id := range m.removedcreated_estimates {
		ids = append(ids, id)
	}
	return
}

// CreatedEstimatesIDs returns the "created_estimates" edge IDs in the mutation.
func (m *UserMutation) CreatedEstimatesIDs() (ids []string) {
	for id := range m.created_estimates {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedEstimates resets all changes to the "created_estimates" edge.
func (m *UserMutation) ResetCreatedEstimates() {
	m.created_estimates = nil
	m.clearedcreated_estimates = false
	m.removedcreated_estimates = nil
}

// AddSalesRepEstimateIDs adds the "sales_rep_estimates" edge to the Estimate entity by ids.
func (m *UserMutation) AddSalesRepEstimateIDs(ids ...string) {
	if m.sales_rep_estimates == nil {
		m.sales_rep_estimates = make(map[string]struct{})
	}
	for i := range ids {
		m.sales_rep_estimates[ids[i]] = struct{}{}
	}
}

// ClearSalesRepEstimates clears the "sales_rep_estimates" edge to the Estimate entity.
func (m *UserMutation) ClearSalesRepEstimates() {
	m.clearedsales_rep_estimates = true
}

// SalesRepEstimatesCleared reports if the "sales_rep_estimates" edge to the Estimate entity was cleared.
func (m *UserMutation) SalesRepEstimatesCleared() bool {
	return m.clearedsales_rep_estimates
}

// RemoveSalesRepEstimateIDs removes the "sales_rep_estimates" edge to the Estimate entity by IDs.
func (m *UserMutation) RemoveSalesRepEstimateIDs(ids ...string) {
	if m.removedsales_rep_estimates == nil {
		m.removedsales_rep_estimates = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sales_rep_estimates, ids[i])
		m.removedsales_rep_estimates[ids[i]] = struct{}{}
	}
}

// RemovedSalesRepEstimates returns the removed IDs of the "sales_rep_estimates" edge to the Estimate entity.
func (m *UserMutation) RemovedSalesRepEstimatesIDs() (ids []string) {
	for id := range m.removedsales_rep_estimates {
		ids = append(ids, id)
	}
	return
}

// SalesRepEstimatesIDs returns the "sales_rep_estimates" edge IDs in the mutation.
func (m *UserMutation) SalesRepEstimatesIDs() (ids []string) {
	for id := range m.sales_rep_estimates {
		ids = append(ids, id)
	}
	return
}

// ResetSalesRepEstimates resets all changes to the "sales_rep_estimates" edge.
func (m *UserMutation) ResetSalesRepEstimates() {
	m.sales_rep_estimates = nil
	m.clearedsales_rep_estimates = false
	m.removedsales_rep_estimates = nil
}

// AddSaleIDs adds the "sales" edge to the Job entity by ids.
func (m *UserMutation) AddSaleIDs(ids ...string) {
	if m.sales == nil {
		m.sales = make(map[string]struct{})
	}
	for i := range ids {
		m.sales[ids[i]] = struct{}{}
	}
}

// ClearSales clears the "sales" edge to the Job entity.
func (m *UserMutation) ClearSales() {
	m.clearedsales = true
}

// SalesCleared reports if the "sales" edge to the Job entity was cleared.
func (m *UserMutation) SalesCleared() bool {
	return m.clearedsales
}

// RemoveSaleIDs removes the "sales" edge to the Job entity by IDs.
func (m *UserMutation) RemoveSaleIDs(ids ...string) {
	if m.removedsales == nil {
		m.removedsales = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sales, ids[i])
		m.removedsales[ids[i]] = struct{}{}
	}
}

// RemovedSales returns the removed IDs of the "sales" edge to the Job entity.
func (m *UserMutation) RemovedSalesIDs() (ids []string) {
	for id := range m.removedsales {
		ids = append(ids, id)
	}
	return
}

// SalesIDs returns the "sales" edge IDs in the mutation.
func (m *UserMutation) SalesIDs() (ids []string) {
	for id := range m.sales {
		ids = append(ids, id)
	}
	return
}

// ResetSales resets all changes to the "sales" edge.
func (m *UserMutation) ResetSales() {
	m.sales = nil
	m.clearedsales = false
	m.removedsales = nil
}

// AddCreatedInstallationJobIDs adds the "created_installation_jobs" edge to the InstallationJob entity by ids.
func (m *UserMutation) AddCreatedInstallationJobIDs(ids ...string) {
	if m.created_installation_jobs == nil {
		m.created_installation_jobs = make(map[string]struct{})
	}
	for i := range ids {
		m.created_installation_jobs[ids[i]] = struct{}{}
	}
}

// ClearCreatedInstallationJobs clears the "created_installation_jobs" edge to the InstallationJob entity.
func (m *UserMutation) ClearCreatedInstallationJobs() {
	m.clearedcreated_installation_jobs = true
}

// CreatedInstallationJobsCleared reports if the "created_installation_jobs" edge to the InstallationJob entity was cleared.
func (m *UserMutation) CreatedInstallationJobsCleared() bool {
	return m.clearedcreated_installation_jobs
}

// RemoveCreatedInstallationJobIDs removes the "created_installation_jobs" edge to the InstallationJob entity by IDs.
func (m *UserMutation) RemoveCreatedInstallationJobIDs(ids ...string) {
	if m.removedcreated_installation_jobs == nil {
		m.removedcreated_installation_jobs = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_installation_jobs, ids[i])
		m.removedcreated_installation_jobs[ids[i]] = struct{}{}
	}
}

// RemovedCreatedInstallationJobs returns the removed IDs of the "created_installation_jobs" edge to the InstallationJob entity.
func (m *UserMutation) RemovedCreatedInstallationJobsIDs() (ids []string) {
	for id := range m.removedcreated_installation_jobs {
		ids = append(ids, id)
	}
	return
}

// CreatedInstallationJobsIDs returns the "created_installation_jobs" edge IDs in the mutation.
func (m *UserMutation) CreatedInstallationJobsIDs() (ids []string) {
	for id := range m.created_installation_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedInstallationJobs resets all changes to the "created_installation_jobs" edge.
func (m *UserMutation) ResetCreatedInstallationJobs() {
	m.created_installation_jobs = nil
	m.clearedcreated_installation_jobs = false
	m.removedcreated_installation_jobs = nil
}

// AddInstallationLeadIDs adds the "installation_leads" edge to the InstallationJob entity by ids.
func (m *UserMutation) AddInstallationLeadIDs(ids ...string) {
	if m.installation_leads == nil {
		m.installation_leads = make(map[string]struct{})
	}
	for i := range ids {
		m.installation_leads[ids[i]] = struct{}{}
	}
}

// ClearInstallationLeads clears the "installation_leads" edge to the InstallationJob entity.
func (m *UserMutation) ClearInstallationLeads() {
	m.clearedinstallation_leads = true
}

// InstallationLeadsCleared reports if the "installation_leads" edge to the InstallationJob entity was cleared.
func (m *UserMutation) InstallationLeadsCleared() bool {
	return m.clearedinstallation_leads
}

// RemoveInstallationLeadIDs removes the "installation_leads" edge to the InstallationJob entity by IDs.
func (m *UserMutation) RemoveInstallationLeadIDs(ids ...string) {
	if m.removedinstallation_leads == nil {
		m.removedinstallation_leads = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.installation_leads, ids[i])
		m.removedinstallation_leads[ids[i]] = struct{}{}
	}
}

// RemovedInstallationLeads returns the removed IDs of the "installation_leads" edge to the InstallationJob entity.
func (m *UserMutation) RemovedInstallationLeadsIDs() (ids []string) {
	for id := range m.removedinstallation_leads {
		ids = append(ids, id)
	}
	return
}

// InstallationLeadsIDs returns the "installation_leads" edge IDs in the mutation.
func (m *UserMutation) InstallationLeadsIDs() (ids []string) {
	for id := range m.installation_leads {
		ids = append(ids, id)
	}
	return
}

// ResetInstallationLeads resets all changes to the "installation_leads" edge.
func (m *UserMutation) ResetInstallationLeads() {
	m.installation_leads = nil
	m.clearedinstallation_leads = false
	m.removedinstallation_leads = nil
}

// AddEstimateActivityIDs adds the "estimate_activities" edge to the EstimateActivity entity by ids.
func (m *UserMutation) AddEstimateActivityIDs(ids ...string) {
	if m.estimate_activities == nil {
		m.estimate_activities = make(map[string]struct{})
	}
	for i := range ids {
		m.estimate_activities[ids[i]] = struct{}{}
	}
}

// ClearEstimateActivities clears the "estimate_activities" edge to the EstimateActivity entity.
func (m *UserMutation) ClearEstimateActivities() {
	m.clearedestimate_activities = true
}

// EstimateActivitiesCleared reports if the "estimate_activities" edge to the EstimateActivity entity was cleared.
func (m *UserMutation) EstimateActivitiesCleared() bool {
	return m.clearedestimate_activities
}

// RemoveEstimateActivityIDs removes the "estimate_activities" edge to the EstimateActivity entity by IDs.
func (m *UserMutation) RemoveEstimateActivityIDs(ids ...string) {
	if m.removedestimate_activities == nil {
		m.removedestimate_activities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.estimate_activities, ids[i])
		m.removedestimate_activities[ids[i]] = struct{}{}
	}
}

// RemovedEstimateActivities returns the removed IDs of the "estimate_activities" edge to the EstimateActivity entity.
func (m *UserMutation) RemovedEstimateActivitiesIDs() (ids []string) {
	for id := range m.removedestimate_activities {
		ids = append(ids, id)
	}
	return
}

// EstimateActivitiesIDs returns the "estimate_activities" edge IDs in the mutation.
func (m *UserMutation) EstimateActivitiesIDs() (ids []string) {
	for id := range m.estimate_activities {
		ids = append(ids, id)
	}
	return
}

// ResetEstimateActivities resets all changes to the "estimate_activities" edge.
func (m *UserMutation) ResetEstimateActivities() {
	m.estimate_activities = nil
	m.clearedestimate_activities = false
	m.removedestimate_activities = nil
}

// AddJobActivityIDs adds the "job_activities" edge to the JobActivity entity by ids.
func (m *UserMutation) AddJobActivityIDs(ids ...string) {
	if m.job_activities == nil {
		m.job_activities = make(map[string]struct{})
	}
	for i := range ids {
		m.job_activities[ids[i]] = struct{}{}
	}
}

// ClearJobActivities clears the "job_activities" edge to the JobActivity entity.
func (m *UserMutation) ClearJobActivities() {
	m.clearedjob_activities = true
}

// JobActivitiesCleared reports if the "job_activities" edge to the JobActivity entity was cleared.
func (m *UserMutation) JobActivitiesCleared() bool {
	return m.clearedjob_activities
}

// RemoveJobActivityIDs removes the "job_activities" edge to the JobActivity entity by IDs.
func (m *UserMutation) RemoveJobActivityIDs(ids ...string) {
	if m.removedjob_activities == nil {
		m.removedjob_activities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.job_activities, ids[i])
		m.removedjob_activities[ids[i]] = struct{}{}
	}
}

// RemovedJobActivities returns the removed IDs of the "job_activities" edge to the JobActivity entity.
func (m *UserMutation) RemovedJobActivitiesIDs() (ids []string) {
	for id := range m.removedjob_activities {
		ids = append(ids, id)
	}
	return
}

// JobActivitiesIDs returns the "job_activities" edge IDs in the mutation.
func (m *UserMutation) JobActivitiesIDs() (ids []string) {
	for id := range m.job_activities {
		ids = append(ids, id)
	}
	return
}

// ResetJobActivities resets all changes to the "job_activities" edge.
func (m *UserMutation) ResetJobActivities() {
	m.job_activities = nil
	m.clearedjob_activities = false
	m.removedjob_activities = nil
}

// AddPartnerActivityIDs adds the "partner_activities" edge to the PartnerActivity entity by ids.
func (m *UserMutation) AddPartnerActivityIDs(ids ...string) {
	if m.partner_activities == nil {
		m.partner_activities = make(map[string]struct{})
	}
	for i := range ids {
		m.partner_activities[ids[i]] = struct{}{}
	}
}

// ClearPartnerActivities clears the "partner_activities" edge to the PartnerActivity entity.
func (m *UserMutation) ClearPartnerActivities() {
	m.clearedpartner_activities = true
}

// PartnerActivitiesCleared reports if the "partner_activities" edge to the PartnerActivity entity was cleared.
func (m *UserMutation) PartnerActivitiesCleared() bool {
	return m.clearedpartner_activities
}

// RemovePartnerActivityIDs removes the "partner_activities" edge to the PartnerActivity entity by IDs.
func (m *UserMutation) RemovePartnerActivityIDs(ids ...string) {
	if m.removedpartner_activities == nil {
		m.removedpartner_activities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.partner_activities, ids[i])
		m.removedpartner_activities[ids[i]] = struct{}{}
	}
}

// RemovedPartnerActivities returns the removed IDs of the "partner_activities" edge to the PartnerActivity entity.
func (m *UserMutation) RemovedPartnerActivitiesIDs() (ids []string) {
	for id := range m.removedpartner_activities {
		ids = append(ids, id)
	}
	return
}

// PartnerActivitiesIDs returns the "partner_activities" edge IDs in the mutation.
func (m *UserMutation) PartnerActivitiesIDs() (ids []string) {
	for id := range m.partner_activities {
		ids = append(ids, id)
	}
	return
}

// ResetPartnerActivities resets all changes to the "partner_activities" edge.
func (m *UserMutation) ResetPartnerActivities() {
	m.partner_activities = nil
	m.clearedpartner_activities = false
	m.removedpartner_activities = nil
}

// AddUserActivityIDs adds the "user_activities" edge to the UserActivity entity by ids.
func (m *UserMutation) AddUserActivityIDs(ids ...string) {
	if m.user_activities == nil {
		m.user_activities = make(map[string]struct{})
	}
	for i := range ids {
		m.user_activities[ids[i]] = struct{}{}
	}
}

// ClearUserActivities clears the "user_activities" edge to the UserActivity entity.
func (m *UserMutation) ClearUserActivities() {
	m.cleareduser_activities = true
}

// UserActivitiesCleared reports if the "user_activities" edge to the UserActivity entity was cleared.
func (m *UserMutation) UserActivitiesCleared() bool {
	return m.cleareduser_activities
}

// RemoveUserActivityIDs removes the "user_activities" edge to the UserActivity entity by IDs.
func (m *UserMutation) RemoveUserActivityIDs(ids ...string) {
	if m.removeduser_activities == nil {
		m.removeduser_activities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.user_activities, ids[i])
		m.removeduser_activities[ids[i]] = struct{}{}
	}
}

// RemovedUserActivities returns the removed IDs of the "user_activities" edge to the UserActivity entity.
func (m *UserMutation) RemovedUserActivitiesIDs() (ids []string) {
	for id := range m.removeduser_activities {
		ids = append(ids, id)
	}
	return
}

// UserActivitiesIDs returns the "user_activities" edge IDs in the mutation.
func (m *UserMutation) UserActivitiesIDs() (ids []string) {
	for id := range m.user_activities {
		ids = append(ids, id)
	}
	return
}

// ResetUserActivities resets all changes to the "user_activities" edge.
func (m *UserMutation) ResetUserActivities() {
	m.user_activities = nil
	m.cleareduser_activities = false
	m.removeduser_activities = nil
}

// AddActivityIDs adds the "activities" edge to the UserActivity entity by ids.
func (m *UserMutation) AddActivityIDs(ids ...string) {
	if m.activities == nil {
		m.activities = make(map[string]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the UserActivity entity.
func (m *UserMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the UserActivity entity was cleared.
func (m *UserMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the UserActivity entity by IDs.
func (m *UserMutation) RemoveActivityIDs(ids ...string) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the UserActivity entity.
func (m *UserMutation) RemovedActivitiesIDs() (ids []string) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *UserMutation) ActivitiesIDs() (ids []string) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *UserMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// AddJobProgressHistoryIDs adds the "job_progress_history" edge to the JobProgressHistory entity by ids.
func (m *UserMutation) AddJobProgressHistoryIDs(ids ...string) {
	if m.job_progress_history == nil {
		m.job_progress_history = make(map[string]struct{})
	}
	for i := range ids {
		m.job_progress_history[ids[i]] = struct{}{}
	}
}

// ClearJobProgressHistory clears the "job_progress_history" edge to the JobProgressHistory entity.
func (m *UserMutation) ClearJobProgressHistory() {
	m.clearedjob_progress_history = true
}

// JobProgressHistoryCleared reports if the "job_progress_history" edge to the JobProgressHistory entity was cleared.
func (m *UserMutation) JobProgressHistoryCleared() bool {
	return m.clearedjob_progress_history
}

// RemoveJobProgressHistoryIDs removes the "job_progress_history" edge to the JobProgressHistory entity by IDs.
func (m *UserMutation) RemoveJobProgressHistoryIDs(ids ...string) {
	if m.removedjob_progress_history == nil {
		m.removedjob_progress_history = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.job_progress_history, ids[i])
		m.removedjob_progress_history[ids[i]] = struct{}{}
	}
}

// RemovedJobProgressHistory returns the removed IDs of the "job_progress_history" edge to the JobProgressHistory entity.
func (m *UserMutation) RemovedJobProgressHistoryIDs() (ids []string) {
	for id := range m.removedjob_progress_history {
		ids = append(ids, id)
	}
	return
}

// JobProgressHistoryIDs returns the "job_progress_history" edge IDs in the mutation.
func (m *UserMutation) JobProgressHistoryIDs() (ids []string) {
	for id := range m.job_progress_history {
		ids = append(ids, id)
	}
	return
}

// ResetJobProgressHistory resets all changes to the "job_progress_history" edge.
func (m *UserMutation) ResetJobProgressHistory() {
	m.job_progress_history = nil
	m.clearedjob_progress_history = false
	m.removedjob_progress_history = nil
}

// AddInstallationJobStatusChangerIDs adds the "installation_job_status_changer" edge to the InstallationJobProgress entity by ids.
func (m *UserMutation) AddInstallationJobStatusChangerIDs(ids ...string) {
	if m.installation_job_status_changer == nil {
		m.installation_job_status_changer = make(map[string]struct{})
	}
	for i := range ids {
		m.installation_job_status_changer[ids[i]] = struct{}{}
	}
}

// ClearInstallationJobStatusChanger clears the "installation_job_status_changer" edge to the InstallationJobProgress entity.
func (m *UserMutation) ClearInstallationJobStatusChanger() {
	m.clearedinstallation_job_status_changer = true
}

// InstallationJobStatusChangerCleared reports if the "installation_job_status_changer" edge to the InstallationJobProgress entity was cleared.
func (m *UserMutation) InstallationJobStatusChangerCleared() bool {
	return m.clearedinstallation_job_status_changer
}

// RemoveInstallationJobStatusChangerIDs removes the "installation_job_status_changer" edge to the InstallationJobProgress entity by IDs.
func (m *UserMutation) RemoveInstallationJobStatusChangerIDs(ids ...string) {
	if m.removedinstallation_job_status_changer == nil {
		m.removedinstallation_job_status_changer = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.installation_job_status_changer, ids[i])
		m.removedinstallation_job_status_changer[ids[i]] = struct{}{}
	}
}

// RemovedInstallationJobStatusChanger returns the removed IDs of the "installation_job_status_changer" edge to the InstallationJobProgress entity.
func (m *UserMutation) RemovedInstallationJobStatusChangerIDs() (ids []string) {
	for id := range m.removedinstallation_job_status_changer {
		ids = append(ids, id)
	}
	return
}

// InstallationJobStatusChangerIDs returns the "installation_job_status_changer" edge IDs in the mutation.
func (m *UserMutation) InstallationJobStatusChangerIDs() (ids []string) {
	for id := range m.installation_job_status_changer {
		ids = append(ids, id)
	}
	return
}

// ResetInstallationJobStatusChanger resets all changes to the "installation_job_status_changer" edge.
func (m *UserMutation) ResetInstallationJobStatusChanger() {
	m.installation_job_status_changer = nil
	m.clearedinstallation_job_status_changer = false
	m.removedinstallation_job_status_changer = nil
}

// AddContactUsRequestIDs adds the "contact_us_requests" edge to the ContactUs entity by ids.
func (m *UserMutation) AddContactUsRequestIDs(ids ...string) {
	if m.contact_us_requests == nil {
		m.contact_us_requests = make(map[string]struct{})
	}
	for i := range ids {
		m.contact_us_requests[ids[i]] = struct{}{}
	}
}

// ClearContactUsRequests clears the "contact_us_requests" edge to the ContactUs entity.
func (m *UserMutation) ClearContactUsRequests() {
	m.clearedcontact_us_requests = true
}

// ContactUsRequestsCleared reports if the "contact_us_requests" edge to the ContactUs entity was cleared.
func (m *UserMutation) ContactUsRequestsCleared() bool {
	return m.clearedcontact_us_requests
}

// RemoveContactUsRequestIDs removes the "contact_us_requests" edge to the ContactUs entity by IDs.
func (m *UserMutation) RemoveContactUsRequestIDs(ids ...string) {
	if m.removedcontact_us_requests == nil {
		m.removedcontact_us_requests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.contact_us_requests, ids[i])
		m.removedcontact_us_requests[ids[i]] = struct{}{}
	}
}

// RemovedContactUsRequests returns the removed IDs of the "contact_us_requests" edge to the ContactUs entity.
func (m *UserMutation) RemovedContactUsRequestsIDs() (ids []string) {
	for id := range m.removedcontact_us_requests {
		ids = append(ids, id)
	}
	return
}

// ContactUsRequestsIDs returns the "contact_us_requests" edge IDs in the mutation.
func (m *UserMutation) ContactUsRequestsIDs() (ids []string) {
	for id := range m.contact_us_requests {
		ids = append(ids, id)
	}
	return
}

// ResetContactUsRequests resets all changes to the "contact_us_requests" edge.
func (m *UserMutation) ResetContactUsRequests() {
	m.contact_us_requests = nil
	m.clearedcontact_us_requests = false
	m.removedcontact_us_requests = nil
}

// AddPartnerIDs adds the "partner" edge to the Partner entity by ids.
func (m *UserMutation) AddPartnerIDs(ids ...string) {
	if m.partner == nil {
		m.partner = make(map[string]struct{})
	}
	for i := range ids {
		m.partner[ids[i]] = struct{}{}
	}
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *UserMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *UserMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// RemovePartnerIDs removes the "partner" edge to the Partner entity by IDs.
func (m *UserMutation) RemovePartnerIDs(ids ...string) {
	if m.removedpartner == nil {
		m.removedpartner = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.partner, ids[i])
		m.removedpartner[ids[i]] = struct{}{}
	}
}

// RemovedPartner returns the removed IDs of the "partner" edge to the Partner entity.
func (m *UserMutation) RemovedPartnerIDs() (ids []string) {
	for id := range m.removedpartner {
		ids = append(ids, id)
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
func (m *UserMutation) PartnerIDs() (ids []string) {
	for id := range m.partner {
		ids = append(ids, id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *UserMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
	m.removedpartner = nil
}

// AddSurveyIDs adds the "surveys" edge to the Survey entity by ids.
func (m *UserMutation) AddSurveyIDs(ids ...string) {
	if m.surveys == nil {
		m.surveys = make(map[string]struct{})
	}
	for i := range ids {
		m.surveys[ids[i]] = struct{}{}
	}
}

// ClearSurveys clears the "surveys" edge to the Survey entity.
func (m *UserMutation) ClearSurveys() {
	m.clearedsurveys = true
}

// SurveysCleared reports if the "surveys" edge to the Survey entity was cleared.
func (m *UserMutation) SurveysCleared() bool {
	return m.clearedsurveys
}

// RemoveSurveyIDs removes the "surveys" edge to the Survey entity by IDs.
func (m *UserMutation) RemoveSurveyIDs(ids ...string) {
	if m.removedsurveys == nil {
		m.removedsurveys = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.surveys, ids[i])
		m.removedsurveys[ids[i]] = struct{}{}
	}
}

// RemovedSurveys returns the removed IDs of the "surveys" edge to the Survey entity.
func (m *UserMutation) RemovedSurveysIDs() (ids []string) {
	for id := range m.removedsurveys {
		ids = append(ids, id)
	}
	return
}

// SurveysIDs returns the "surveys" edge IDs in the mutation.
func (m *UserMutation) SurveysIDs() (ids []string) {
	for id := range m.surveys {
		ids = append(ids, id)
	}
	return
}

// ResetSurveys resets all changes to the "surveys" edge.
func (m *UserMutation) ResetSurveys() {
	m.surveys = nil
	m.clearedsurveys = false
	m.removedsurveys = nil
}

// AddSurveyProgresIDs adds the "survey_progress" edge to the SurveyProgress entity by ids.
func (m *UserMutation) AddSurveyProgresIDs(ids ...string) {
	if m.survey_progress == nil {
		m.survey_progress = make(map[string]struct{})
	}
	for i := range ids {
		m.survey_progress[ids[i]] = struct{}{}
	}
}

// ClearSurveyProgress clears the "survey_progress" edge to the SurveyProgress entity.
func (m *UserMutation) ClearSurveyProgress() {
	m.clearedsurvey_progress = true
}

// SurveyProgressCleared reports if the "survey_progress" edge to the SurveyProgress entity was cleared.
func (m *UserMutation) SurveyProgressCleared() bool {
	return m.clearedsurvey_progress
}

// RemoveSurveyProgresIDs removes the "survey_progress" edge to the SurveyProgress entity by IDs.
func (m *UserMutation) RemoveSurveyProgresIDs(ids ...string) {
	if m.removedsurvey_progress == nil {
		m.removedsurvey_progress = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.survey_progress, ids[i])
		m.removedsurvey_progress[ids[i]] = struct{}{}
	}
}

// RemovedSurveyProgress returns the removed IDs of the "survey_progress" edge to the SurveyProgress entity.
func (m *UserMutation) RemovedSurveyProgressIDs() (ids []string) {
	for id := range m.removedsurvey_progress {
		ids = append(ids, id)
	}
	return
}

// SurveyProgressIDs returns the "survey_progress" edge IDs in the mutation.
func (m *UserMutation) SurveyProgressIDs() (ids []string) {
	for id := range m.survey_progress {
		ids = append(ids, id)
	}
	return
}

// ResetSurveyProgress resets all changes to the "survey_progress" edge.
func (m *UserMutation) ResetSurveyProgress() {
	m.survey_progress = nil
	m.clearedsurvey_progress = false
	m.removedsurvey_progress = nil
}

// AddCreatedTrainingVideoIDs adds the "created_training_videos" edge to the TrainingVideo entity by ids.
func (m *UserMutation) AddCreatedTrainingVideoIDs(ids ...string) {
	if m.created_training_videos == nil {
		m.created_training_videos = make(map[string]struct{})
	}
	for i := range ids {
		m.created_training_videos[ids[i]] = struct{}{}
	}
}

// ClearCreatedTrainingVideos clears the "created_training_videos" edge to the TrainingVideo entity.
func (m *UserMutation) ClearCreatedTrainingVideos() {
	m.clearedcreated_training_videos = true
}

// CreatedTrainingVideosCleared reports if the "created_training_videos" edge to the TrainingVideo entity was cleared.
func (m *UserMutation) CreatedTrainingVideosCleared() bool {
	return m.clearedcreated_training_videos
}

// RemoveCreatedTrainingVideoIDs removes the "created_training_videos" edge to the TrainingVideo entity by IDs.
func (m *UserMutation) RemoveCreatedTrainingVideoIDs(ids ...string) {
	if m.removedcreated_training_videos == nil {
		m.removedcreated_training_videos = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_training_videos, ids[i])
		m.removedcreated_training_videos[ids[i]] = struct{}{}
	}
}

// RemovedCreatedTrainingVideos returns the removed IDs of the "created_training_videos" edge to the TrainingVideo entity.
func (m *UserMutation) RemovedCreatedTrainingVideosIDs() (ids []string) {
	for id := range m.removedcreated_training_videos {
		ids = append(ids, id)
	}
	return
}

// CreatedTrainingVideosIDs returns the "created_training_videos" edge IDs in the mutation.
func (m *UserMutation) CreatedTrainingVideosIDs() (ids []string) {
	for id := range m.created_training_videos {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedTrainingVideos resets all changes to the "created_training_videos" edge.
func (m *UserMutation) ResetCreatedTrainingVideos() {
	m.created_training_videos = nil
	m.clearedcreated_training_videos = false
	m.removedcreated_training_videos = nil
}

// AddCreatedTrainingCourseIDs adds the "created_training_courses" edge to the TrainingCourse entity by ids.
func (m *UserMutation) AddCreatedTrainingCourseIDs(ids ...string) {
	if m.created_training_courses == nil {
		m.created_training_courses = make(map[string]struct{})
	}
	for i := range ids {
		m.created_training_courses[ids[i]] = struct{}{}
	}
}

// ClearCreatedTrainingCourses clears the "created_training_courses" edge to the TrainingCourse entity.
func (m *UserMutation) ClearCreatedTrainingCourses() {
	m.clearedcreated_training_courses = true
}

// CreatedTrainingCoursesCleared reports if the "created_training_courses" edge to the TrainingCourse entity was cleared.
func (m *UserMutation) CreatedTrainingCoursesCleared() bool {
	return m.clearedcreated_training_courses
}

// RemoveCreatedTrainingCourseIDs removes the "created_training_courses" edge to the TrainingCourse entity by IDs.
func (m *UserMutation) RemoveCreatedTrainingCourseIDs(ids ...string) {
	if m.removedcreated_training_courses == nil {
		m.removedcreated_training_courses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.created_training_courses, ids[i])
		m.removedcreated_training_courses[ids[i]] = struct{}{}
	}
}

// RemovedCreatedTrainingCourses returns the removed IDs of the "created_training_courses" edge to the TrainingCourse entity.
func (m *UserMutation) RemovedCreatedTrainingCoursesIDs() (ids []string) {
	for id := range m.removedcreated_training_courses {
		ids = append(ids, id)
	}
	return
}

// CreatedTrainingCoursesIDs returns the "created_training_courses" edge IDs in the mutation.
func (m *UserMutation) CreatedTrainingCoursesIDs() (ids []string) {
	for id := range m.created_training_courses {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedTrainingCourses resets all changes to the "created_training_courses" edge.
func (m *UserMutation) ResetCreatedTrainingCourses() {
	m.created_training_courses = nil
	m.clearedcreated_training_courses = false
	m.removedcreated_training_courses = nil
}

// AddJobNoteIDs adds the "job_notes" edge to the JobNote entity by ids.
func (m *UserMutation) AddJobNoteIDs(ids ...string) {
	if m.job_notes == nil {
		m.job_notes = make(map[string]struct{})
	}
	for i := range ids {
		m.job_notes[ids[i]] = struct{}{}
	}
}

// ClearJobNotes clears the "job_notes" edge to the JobNote entity.
func (m *UserMutation) ClearJobNotes() {
	m.clearedjob_notes = true
}

// JobNotesCleared reports if the "job_notes" edge to the JobNote entity was cleared.
func (m *UserMutation) JobNotesCleared() bool {
	return m.clearedjob_notes
}

// RemoveJobNoteIDs removes the "job_notes" edge to the JobNote entity by IDs.
func (m *UserMutation) RemoveJobNoteIDs(ids ...string) {
	if m.removedjob_notes == nil {
		m.removedjob_notes = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.job_notes, ids[i])
		m.removedjob_notes[ids[i]] = struct{}{}
	}
}

// RemovedJobNotes returns the removed IDs of the "job_notes" edge to the JobNote entity.
func (m *UserMutation) RemovedJobNotesIDs() (ids []string) {
	for id := range m.removedjob_notes {
		ids = append(ids, id)
	}
	return
}

// JobNotesIDs returns the "job_notes" edge IDs in the mutation.
func (m *UserMutation) JobNotesIDs() (ids []string) {
	for id := range m.job_notes {
		ids = append(ids, id)
	}
	return
}

// ResetJobNotes resets all changes to the "job_notes" edge.
func (m *UserMutation) ResetJobNotes() {
	m.job_notes = nil
	m.clearedjob_notes = false
	m.removedjob_notes = nil
}

// AddChatChannelIDs adds the "chat_channels" edge to the ChannelSub entity by ids.
func (m *UserMutation) AddChatChannelIDs(ids ...string) {
	if m.chat_channels == nil {
		m.chat_channels = make(map[string]struct{})
	}
	for i := range ids {
		m.chat_channels[ids[i]] = struct{}{}
	}
}

// ClearChatChannels clears the "chat_channels" edge to the ChannelSub entity.
func (m *UserMutation) ClearChatChannels() {
	m.clearedchat_channels = true
}

// ChatChannelsCleared reports if the "chat_channels" edge to the ChannelSub entity was cleared.
func (m *UserMutation) ChatChannelsCleared() bool {
	return m.clearedchat_channels
}

// RemoveChatChannelIDs removes the "chat_channels" edge to the ChannelSub entity by IDs.
func (m *UserMutation) RemoveChatChannelIDs(ids ...string) {
	if m.removedchat_channels == nil {
		m.removedchat_channels = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.chat_channels, ids[i])
		m.removedchat_channels[ids[i]] = struct{}{}
	}
}

// RemovedChatChannels returns the removed IDs of the "chat_channels" edge to the ChannelSub entity.
func (m *UserMutation) RemovedChatChannelsIDs() (ids []string) {
	for id := range m.removedchat_channels {
		ids = append(ids, id)
	}
	return
}

// ChatChannelsIDs returns the "chat_channels" edge IDs in the mutation.
func (m *UserMutation) ChatChannelsIDs() (ids []string) {
	for id := range m.chat_channels {
		ids = append(ids, id)
	}
	return
}

// ResetChatChannels resets all changes to the "chat_channels" edge.
func (m *UserMutation) ResetChatChannels() {
	m.chat_channels = nil
	m.clearedchat_channels = false
	m.removedchat_channels = nil
}

// AddSentMessageIDs adds the "sent_messages" edge to the ChannelMessage entity by ids.
func (m *UserMutation) AddSentMessageIDs(ids ...string) {
	if m.sent_messages == nil {
		m.sent_messages = make(map[string]struct{})
	}
	for i := range ids {
		m.sent_messages[ids[i]] = struct{}{}
	}
}

// ClearSentMessages clears the "sent_messages" edge to the ChannelMessage entity.
func (m *UserMutation) ClearSentMessages() {
	m.clearedsent_messages = true
}

// SentMessagesCleared reports if the "sent_messages" edge to the ChannelMessage entity was cleared.
func (m *UserMutation) SentMessagesCleared() bool {
	return m.clearedsent_messages
}

// RemoveSentMessageIDs removes the "sent_messages" edge to the ChannelMessage entity by IDs.
func (m *UserMutation) RemoveSentMessageIDs(ids ...string) {
	if m.removedsent_messages == nil {
		m.removedsent_messages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sent_messages, ids[i])
		m.removedsent_messages[ids[i]] = struct{}{}
	}
}

// RemovedSentMessages returns the removed IDs of the "sent_messages" edge to the ChannelMessage entity.
func (m *UserMutation) RemovedSentMessagesIDs() (ids []string) {
	for id := range m.removedsent_messages {
		ids = append(ids, id)
	}
	return
}

// SentMessagesIDs returns the "sent_messages" edge IDs in the mutation.
func (m *UserMutation) SentMessagesIDs() (ids []string) {
	for id := range m.sent_messages {
		ids = append(ids, id)
	}
	return
}

// ResetSentMessages resets all changes to the "sent_messages" edge.
func (m *UserMutation) ResetSentMessages() {
	m.sent_messages = nil
	m.clearedsent_messages = false
	m.removedsent_messages = nil
}

// AddReceivedMessageIDs adds the "received_messages" edge to the ChannelMessage entity by ids.
func (m *UserMutation) AddReceivedMessageIDs(ids ...string) {
	if m.received_messages == nil {
		m.received_messages = make(map[string]struct{})
	}
	for i := range ids {
		m.received_messages[ids[i]] = struct{}{}
	}
}

// ClearReceivedMessages clears the "received_messages" edge to the ChannelMessage entity.
func (m *UserMutation) ClearReceivedMessages() {
	m.clearedreceived_messages = true
}

// ReceivedMessagesCleared reports if the "received_messages" edge to the ChannelMessage entity was cleared.
func (m *UserMutation) ReceivedMessagesCleared() bool {
	return m.clearedreceived_messages
}

// RemoveReceivedMessageIDs removes the "received_messages" edge to the ChannelMessage entity by IDs.
func (m *UserMutation) RemoveReceivedMessageIDs(ids ...string) {
	if m.removedreceived_messages == nil {
		m.removedreceived_messages = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.received_messages, ids[i])
		m.removedreceived_messages[ids[i]] = struct{}{}
	}
}

// RemovedReceivedMessages returns the removed IDs of the "received_messages" edge to the ChannelMessage entity.
func (m *UserMutation) RemovedReceivedMessagesIDs() (ids []string) {
	for id := range m.removedreceived_messages {
		ids = append(ids, id)
	}
	return
}

// ReceivedMessagesIDs returns the "received_messages" edge IDs in the mutation.
func (m *UserMutation) ReceivedMessagesIDs() (ids []string) {
	for id := range m.received_messages {
		ids = append(ids, id)
	}
	return
}

// ResetReceivedMessages resets all changes to the "received_messages" edge.
func (m *UserMutation) ResetReceivedMessages() {
	m.received_messages = nil
	m.clearedreceived_messages = false
	m.removedreceived_messages = nil
}

// AddChannelMessageReadIDs adds the "channel_message_read" edge to the ChannelMessageRead entity by ids.
func (m *UserMutation) AddChannelMessageReadIDs(ids ...string) {
	if m.channel_message_read == nil {
		m.channel_message_read = make(map[string]struct{})
	}
	for i := range ids {
		m.channel_message_read[ids[i]] = struct{}{}
	}
}

// ClearChannelMessageRead clears the "channel_message_read" edge to the ChannelMessageRead entity.
func (m *UserMutation) ClearChannelMessageRead() {
	m.clearedchannel_message_read = true
}

// ChannelMessageReadCleared reports if the "channel_message_read" edge to the ChannelMessageRead entity was cleared.
func (m *UserMutation) ChannelMessageReadCleared() bool {
	return m.clearedchannel_message_read
}

// RemoveChannelMessageReadIDs removes the "channel_message_read" edge to the ChannelMessageRead entity by IDs.
func (m *UserMutation) RemoveChannelMessageReadIDs(ids ...string) {
	if m.removedchannel_message_read == nil {
		m.removedchannel_message_read = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.channel_message_read, ids[i])
		m.removedchannel_message_read[ids[i]] = struct{}{}
	}
}

// RemovedChannelMessageRead returns the removed IDs of the "channel_message_read" edge to the ChannelMessageRead entity.
func (m *UserMutation) RemovedChannelMessageReadIDs() (ids []string) {
	for id := range m.removedchannel_message_read {
		ids = append(ids, id)
	}
	return
}

// ChannelMessageReadIDs returns the "channel_message_read" edge IDs in the mutation.
func (m *UserMutation) ChannelMessageReadIDs() (ids []string) {
	for id := range m.channel_message_read {
		ids = append(ids, id)
	}
	return
}

// ResetChannelMessageRead resets all changes to the "channel_message_read" edge.
func (m *UserMutation) ResetChannelMessageRead() {
	m.channel_message_read = nil
	m.clearedchannel_message_read = false
	m.removedchannel_message_read = nil
}

// AddProductsCreatedIDs adds the "products_created" edge to the Product entity by ids.
func (m *UserMutation) AddProductsCreatedIDs(ids ...string) {
	if m.products_created == nil {
		m.products_created = make(map[string]struct{})
	}
	for i := range ids {
		m.products_created[ids[i]] = struct{}{}
	}
}

// ClearProductsCreated clears the "products_created" edge to the Product entity.
func (m *UserMutation) ClearProductsCreated() {
	m.clearedproducts_created = true
}

// ProductsCreatedCleared reports if the "products_created" edge to the Product entity was cleared.
func (m *UserMutation) ProductsCreatedCleared() bool {
	return m.clearedproducts_created
}

// RemoveProductsCreatedIDs removes the "products_created" edge to the Product entity by IDs.
func (m *UserMutation) RemoveProductsCreatedIDs(ids ...string) {
	if m.removedproducts_created == nil {
		m.removedproducts_created = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.products_created, ids[i])
		m.removedproducts_created[ids[i]] = struct{}{}
	}
}

// RemovedProductsCreated returns the removed IDs of the "products_created" edge to the Product entity.
func (m *UserMutation) RemovedProductsCreatedIDs() (ids []string) {
	for id := range m.removedproducts_created {
		ids = append(ids, id)
	}
	return
}

// ProductsCreatedIDs returns the "products_created" edge IDs in the mutation.
func (m *UserMutation) ProductsCreatedIDs() (ids []string) {
	for id := range m.products_created {
		ids = append(ids, id)
	}
	return
}

// ResetProductsCreated resets all changes to the "products_created" edge.
func (m *UserMutation) ResetProductsCreated() {
	m.products_created = nil
	m.clearedproducts_created = false
	m.removedproducts_created = nil
}

// AddProductPkgCreatedIDs adds the "product_pkg_created" edge to the ProductPackage entity by ids.
func (m *UserMutation) AddProductPkgCreatedIDs(ids ...string) {
	if m.product_pkg_created == nil {
		m.product_pkg_created = make(map[string]struct{})
	}
	for i := range ids {
		m.product_pkg_created[ids[i]] = struct{}{}
	}
}

// ClearProductPkgCreated clears the "product_pkg_created" edge to the ProductPackage entity.
func (m *UserMutation) ClearProductPkgCreated() {
	m.clearedproduct_pkg_created = true
}

// ProductPkgCreatedCleared reports if the "product_pkg_created" edge to the ProductPackage entity was cleared.
func (m *UserMutation) ProductPkgCreatedCleared() bool {
	return m.clearedproduct_pkg_created
}

// RemoveProductPkgCreatedIDs removes the "product_pkg_created" edge to the ProductPackage entity by IDs.
func (m *UserMutation) RemoveProductPkgCreatedIDs(ids ...string) {
	if m.removedproduct_pkg_created == nil {
		m.removedproduct_pkg_created = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.product_pkg_created, ids[i])
		m.removedproduct_pkg_created[ids[i]] = struct{}{}
	}
}

// RemovedProductPkgCreated returns the removed IDs of the "product_pkg_created" edge to the ProductPackage entity.
func (m *UserMutation) RemovedProductPkgCreatedIDs() (ids []string) {
	for id := range m.removedproduct_pkg_created {
		ids = append(ids, id)
	}
	return
}

// ProductPkgCreatedIDs returns the "product_pkg_created" edge IDs in the mutation.
func (m *UserMutation) ProductPkgCreatedIDs() (ids []string) {
	for id := range m.product_pkg_created {
		ids = append(ids, id)
	}
	return
}

// ResetProductPkgCreated resets all changes to the "product_pkg_created" edge.
func (m *UserMutation) ResetProductPkgCreated() {
	m.product_pkg_created = nil
	m.clearedproduct_pkg_created = false
	m.removedproduct_pkg_created = nil
}

// AddJobDocURLIDs adds the "job_doc_urls" edge to the JobDocURL entity by ids.
func (m *UserMutation) AddJobDocURLIDs(ids ...string) {
	if m.job_doc_urls == nil {
		m.job_doc_urls = make(map[string]struct{})
	}
	for i := range ids {
		m.job_doc_urls[ids[i]] = struct{}{}
	}
}

// ClearJobDocUrls clears the "job_doc_urls" edge to the JobDocURL entity.
func (m *UserMutation) ClearJobDocUrls() {
	m.clearedjob_doc_urls = true
}

// JobDocUrlsCleared reports if the "job_doc_urls" edge to the JobDocURL entity was cleared.
func (m *UserMutation) JobDocUrlsCleared() bool {
	return m.clearedjob_doc_urls
}

// RemoveJobDocURLIDs removes the "job_doc_urls" edge to the JobDocURL entity by IDs.
func (m *UserMutation) RemoveJobDocURLIDs(ids ...string) {
	if m.removedjob_doc_urls == nil {
		m.removedjob_doc_urls = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.job_doc_urls, ids[i])
		m.removedjob_doc_urls[ids[i]] = struct{}{}
	}
}

// RemovedJobDocUrls returns the removed IDs of the "job_doc_urls" edge to the JobDocURL entity.
func (m *UserMutation) RemovedJobDocUrlsIDs() (ids []string) {
	for id := range m.removedjob_doc_urls {
		ids = append(ids, id)
	}
	return
}

// JobDocUrlsIDs returns the "job_doc_urls" edge IDs in the mutation.
func (m *UserMutation) JobDocUrlsIDs() (ids []string) {
	for id := range m.job_doc_urls {
		ids = append(ids, id)
	}
	return
}

// ResetJobDocUrls resets all changes to the "job_doc_urls" edge.
func (m *UserMutation) ResetJobDocUrls() {
	m.job_doc_urls = nil
	m.clearedjob_doc_urls = false
	m.removedjob_doc_urls = nil
}

// AddPartnerContactIDs adds the "partner_contacts" edge to the PartnerContact entity by ids.
func (m *UserMutation) AddPartnerContactIDs(ids ...string) {
	if m.partner_contacts == nil {
		m.partner_contacts = make(map[string]struct{})
	}
	for i := range ids {
		m.partner_contacts[ids[i]] = struct{}{}
	}
}

// ClearPartnerContacts clears the "partner_contacts" edge to the PartnerContact entity.
func (m *UserMutation) ClearPartnerContacts() {
	m.clearedpartner_contacts = true
}

// PartnerContactsCleared reports if the "partner_contacts" edge to the PartnerContact entity was cleared.
func (m *UserMutation) PartnerContactsCleared() bool {
	return m.clearedpartner_contacts
}

// RemovePartnerContactIDs removes the "partner_contacts" edge to the PartnerContact entity by IDs.
func (m *UserMutation) RemovePartnerContactIDs(ids ...string) {
	if m.removedpartner_contacts == nil {
		m.removedpartner_contacts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.partner_contacts, ids[i])
		m.removedpartner_contacts[ids[i]] = struct{}{}
	}
}

// RemovedPartnerContacts returns the removed IDs of the "partner_contacts" edge to the PartnerContact entity.
func (m *UserMutation) RemovedPartnerContactsIDs() (ids []string) {
	for id := range m.removedpartner_contacts {
		ids = append(ids, id)
	}
	return
}

// PartnerContactsIDs returns the "partner_contacts" edge IDs in the mutation.
func (m *UserMutation) PartnerContactsIDs() (ids []string) {
	for id := range m.partner_contacts {
		ids = append(ids, id)
	}
	return
}

// ResetPartnerContacts resets all changes to the "partner_contacts" edge.
func (m *UserMutation) ResetPartnerContacts() {
	m.partner_contacts = nil
	m.clearedpartner_contacts = false
	m.removedpartner_contacts = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.external_id != nil {
		fields = append(fields, user.FieldExternalID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.pwd != nil {
		fields = append(fields, user.FieldPwd)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.email_verified != nil {
		fields = append(fields, user.FieldEmailVerified)
	}
	if m.phone_verified != nil {
		fields = append(fields, user.FieldPhoneVerified)
	}
	if m.picture != nil {
		fields = append(fields, user.FieldPicture)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.note != nil {
		fields = append(fields, user.FieldNote)
	}
	if m.wrong_attempts != nil {
		fields = append(fields, user.FieldWrongAttempts)
	}
	if m.wrong_attempt_at != nil {
		fields = append(fields, user.FieldWrongAttemptAt)
	}
	if m.locked_until != nil {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.location != nil {
		fields = append(fields, user.FieldLocation)
	}
	if m.accepted_general_terms != nil {
		fields = append(fields, user.FieldAcceptedGeneralTerms)
	}
	if m.accepted_terms_n_privacy != nil {
		fields = append(fields, user.FieldAcceptedTermsNPrivacy)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldExternalID:
		return m.ExternalID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldPwd:
		return m.Pwd()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldEmailVerified:
		return m.EmailVerified()
	case user.FieldPhoneVerified:
		return m.PhoneVerified()
	case user.FieldPicture:
		return m.Picture()
	case user.FieldStatus:
		return m.Status()
	case user.FieldRole:
		return m.Role()
	case user.FieldNote:
		return m.Note()
	case user.FieldWrongAttempts:
		return m.WrongAttempts()
	case user.FieldWrongAttemptAt:
		return m.WrongAttemptAt()
	case user.FieldLockedUntil:
		return m.LockedUntil()
	case user.FieldLocation:
		return m.Location()
	case user.FieldAcceptedGeneralTerms:
		return m.AcceptedGeneralTerms()
	case user.FieldAcceptedTermsNPrivacy:
		return m.AcceptedTermsNPrivacy()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldExternalID:
		return m.OldExternalID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldPwd:
		return m.OldPwd(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldEmailVerified:
		return m.OldEmailVerified(ctx)
	case user.FieldPhoneVerified:
		return m.OldPhoneVerified(ctx)
	case user.FieldPicture:
		return m.OldPicture(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldNote:
		return m.OldNote(ctx)
	case user.FieldWrongAttempts:
		return m.OldWrongAttempts(ctx)
	case user.FieldWrongAttemptAt:
		return m.OldWrongAttemptAt(ctx)
	case user.FieldLockedUntil:
		return m.OldLockedUntil(ctx)
	case user.FieldLocation:
		return m.OldLocation(ctx)
	case user.FieldAcceptedGeneralTerms:
		return m.OldAcceptedGeneralTerms(ctx)
	case user.FieldAcceptedTermsNPrivacy:
		return m.OldAcceptedTermsNPrivacy(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldPwd:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPwd(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldEmailVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailVerified(v)
		return nil
	case user.FieldPhoneVerified:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneVerified(v)
		return nil
	case user.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(enum.AccountStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldRole:
		v, ok := value.(enum.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case user.FieldWrongAttempts:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWrongAttempts(v)
		return nil
	case user.FieldWrongAttemptAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWrongAttemptAt(v)
		return nil
	case user.FieldLockedUntil:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLockedUntil(v)
		return nil
	case user.FieldLocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocation(v)
		return nil
	case user.FieldAcceptedGeneralTerms:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedGeneralTerms(v)
		return nil
	case user.FieldAcceptedTermsNPrivacy:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedTermsNPrivacy(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addwrong_attempts != nil {
		fields = append(fields, user.FieldWrongAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldWrongAttempts:
		return m.AddedWrongAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldWrongAttempts:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWrongAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldExternalID) {
		fields = append(fields, user.FieldExternalID)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldPicture) {
		fields = append(fields, user.FieldPicture)
	}
	if m.FieldCleared(user.FieldNote) {
		fields = append(fields, user.FieldNote)
	}
	if m.FieldCleared(user.FieldWrongAttempts) {
		fields = append(fields, user.FieldWrongAttempts)
	}
	if m.FieldCleared(user.FieldWrongAttemptAt) {
		fields = append(fields, user.FieldWrongAttemptAt)
	}
	if m.FieldCleared(user.FieldLockedUntil) {
		fields = append(fields, user.FieldLockedUntil)
	}
	if m.FieldCleared(user.FieldLocation) {
		fields = append(fields, user.FieldLocation)
	}
	if m.FieldCleared(user.FieldAcceptedGeneralTerms) {
		fields = append(fields, user.FieldAcceptedGeneralTerms)
	}
	if m.FieldCleared(user.FieldAcceptedTermsNPrivacy) {
		fields = append(fields, user.FieldAcceptedTermsNPrivacy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldExternalID:
		m.ClearExternalID()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldPicture:
		m.ClearPicture()
		return nil
	case user.FieldNote:
		m.ClearNote()
		return nil
	case user.FieldWrongAttempts:
		m.ClearWrongAttempts()
		return nil
	case user.FieldWrongAttemptAt:
		m.ClearWrongAttemptAt()
		return nil
	case user.FieldLockedUntil:
		m.ClearLockedUntil()
		return nil
	case user.FieldLocation:
		m.ClearLocation()
		return nil
	case user.FieldAcceptedGeneralTerms:
		m.ClearAcceptedGeneralTerms()
		return nil
	case user.FieldAcceptedTermsNPrivacy:
		m.ClearAcceptedTermsNPrivacy()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldExternalID:
		m.ResetExternalID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldPwd:
		m.ResetPwd()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldEmailVerified:
		m.ResetEmailVerified()
		return nil
	case user.FieldPhoneVerified:
		m.ResetPhoneVerified()
		return nil
	case user.FieldPicture:
		m.ResetPicture()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldNote:
		m.ResetNote()
		return nil
	case user.FieldWrongAttempts:
		m.ResetWrongAttempts()
		return nil
	case user.FieldWrongAttemptAt:
		m.ResetWrongAttemptAt()
		return nil
	case user.FieldLockedUntil:
		m.ResetLockedUntil()
		return nil
	case user.FieldLocation:
		m.ResetLocation()
		return nil
	case user.FieldAcceptedGeneralTerms:
		m.ResetAcceptedGeneralTerms()
		return nil
	case user.FieldAcceptedTermsNPrivacy:
		m.ResetAcceptedTermsNPrivacy()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 32)
	if m.auths != nil {
		edges = append(edges, user.EdgeAuths)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.audit_logs != nil {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.notify != nil {
		edges = append(edges, user.EdgeNotify)
	}
	if m.created_jobs != nil {
		edges = append(edges, user.EdgeCreatedJobs)
	}
	if m.created_estimates != nil {
		edges = append(edges, user.EdgeCreatedEstimates)
	}
	if m.sales_rep_estimates != nil {
		edges = append(edges, user.EdgeSalesRepEstimates)
	}
	if m.sales != nil {
		edges = append(edges, user.EdgeSales)
	}
	if m.created_installation_jobs != nil {
		edges = append(edges, user.EdgeCreatedInstallationJobs)
	}
	if m.installation_leads != nil {
		edges = append(edges, user.EdgeInstallationLeads)
	}
	if m.estimate_activities != nil {
		edges = append(edges, user.EdgeEstimateActivities)
	}
	if m.job_activities != nil {
		edges = append(edges, user.EdgeJobActivities)
	}
	if m.partner_activities != nil {
		edges = append(edges, user.EdgePartnerActivities)
	}
	if m.user_activities != nil {
		edges = append(edges, user.EdgeUserActivities)
	}
	if m.activities != nil {
		edges = append(edges, user.EdgeActivities)
	}
	if m.job_progress_history != nil {
		edges = append(edges, user.EdgeJobProgressHistory)
	}
	if m.installation_job_status_changer != nil {
		edges = append(edges, user.EdgeInstallationJobStatusChanger)
	}
	if m.contact_us_requests != nil {
		edges = append(edges, user.EdgeContactUsRequests)
	}
	if m.partner != nil {
		edges = append(edges, user.EdgePartner)
	}
	if m.surveys != nil {
		edges = append(edges, user.EdgeSurveys)
	}
	if m.survey_progress != nil {
		edges = append(edges, user.EdgeSurveyProgress)
	}
	if m.created_training_videos != nil {
		edges = append(edges, user.EdgeCreatedTrainingVideos)
	}
	if m.created_training_courses != nil {
		edges = append(edges, user.EdgeCreatedTrainingCourses)
	}
	if m.job_notes != nil {
		edges = append(edges, user.EdgeJobNotes)
	}
	if m.chat_channels != nil {
		edges = append(edges, user.EdgeChatChannels)
	}
	if m.sent_messages != nil {
		edges = append(edges, user.EdgeSentMessages)
	}
	if m.received_messages != nil {
		edges = append(edges, user.EdgeReceivedMessages)
	}
	if m.channel_message_read != nil {
		edges = append(edges, user.EdgeChannelMessageRead)
	}
	if m.products_created != nil {
		edges = append(edges, user.EdgeProductsCreated)
	}
	if m.product_pkg_created != nil {
		edges = append(edges, user.EdgeProductPkgCreated)
	}
	if m.job_doc_urls != nil {
		edges = append(edges, user.EdgeJobDocUrls)
	}
	if m.partner_contacts != nil {
		edges = append(edges, user.EdgePartnerContacts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeAuths:
		if id := m.auths; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.audit_logs))
		for id := range m.audit_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotify:
		ids := make([]ent.Value, 0, len(m.notify))
		for id := range m.notify {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedJobs:
		ids := make([]ent.Value, 0, len(m.created_jobs))
		for id := range m.created_jobs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedEstimates:
		ids := make([]ent.Value, 0, len(m.created_estimates))
		for id := range m.created_estimates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSalesRepEstimates:
		ids := make([]ent.Value, 0, len(m.sales_rep_estimates))
		for id := range m.sales_rep_estimates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSales:
		ids := make([]ent.Value, 0, len(m.sales))
		for id := range m.sales {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedInstallationJobs:
		ids := make([]ent.Value, 0, len(m.created_installation_jobs))
		for id := range m.created_installation_jobs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInstallationLeads:
		ids := make([]ent.Value, 0, len(m.installation_leads))
		for id := range m.installation_leads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEstimateActivities:
		ids := make([]ent.Value, 0, len(m.estimate_activities))
		for id := range m.estimate_activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobActivities:
		ids := make([]ent.Value, 0, len(m.job_activities))
		for id := range m.job_activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePartnerActivities:
		ids := make([]ent.Value, 0, len(m.partner_activities))
		for id := range m.partner_activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserActivities:
		ids := make([]ent.Value, 0, len(m.user_activities))
		for id := range m.user_activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobProgressHistory:
		ids := make([]ent.Value, 0, len(m.job_progress_history))
		for id := range m.job_progress_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInstallationJobStatusChanger:
		ids := make([]ent.Value, 0, len(m.installation_job_status_changer))
		for id := range m.installation_job_status_changer {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeContactUsRequests:
		ids := make([]ent.Value, 0, len(m.contact_us_requests))
		for id := range m.contact_us_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePartner:
		ids := make([]ent.Value, 0, len(m.partner))
		for id := range m.partner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSurveys:
		ids := make([]ent.Value, 0, len(m.surveys))
		for id := range m.surveys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSurveyProgress:
		ids := make([]ent.Value, 0, len(m.survey_progress))
		for id := range m.survey_progress {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTrainingVideos:
		ids := make([]ent.Value, 0, len(m.created_training_videos))
		for id := range m.created_training_videos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTrainingCourses:
		ids := make([]ent.Value, 0, len(m.created_training_courses))
		for id := range m.created_training_courses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobNotes:
		ids := make([]ent.Value, 0, len(m.job_notes))
		for id := range m.job_notes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChatChannels:
		ids := make([]ent.Value, 0, len(m.chat_channels))
		for id := range m.chat_channels {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentMessages:
		ids := make([]ent.Value, 0, len(m.sent_messages))
		for id := range m.sent_messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReceivedMessages:
		ids := make([]ent.Value, 0, len(m.received_messages))
		for id := range m.received_messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannelMessageRead:
		ids := make([]ent.Value, 0, len(m.channel_message_read))
		for id := range m.channel_message_read {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProductsCreated:
		ids := make([]ent.Value, 0, len(m.products_created))
		for id := range m.products_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProductPkgCreated:
		ids := make([]ent.Value, 0, len(m.product_pkg_created))
		for id := range m.product_pkg_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobDocUrls:
		ids := make([]ent.Value, 0, len(m.job_doc_urls))
		for id := range m.job_doc_urls {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePartnerContacts:
		ids := make([]ent.Value, 0, len(m.partner_contacts))
		for id := range m.partner_contacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 32)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedaudit_logs != nil {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.removednotify != nil {
		edges = append(edges, user.EdgeNotify)
	}
	if m.removedcreated_jobs != nil {
		edges = append(edges, user.EdgeCreatedJobs)
	}
	if m.removedcreated_estimates != nil {
		edges = append(edges, user.EdgeCreatedEstimates)
	}
	if m.removedsales_rep_estimates != nil {
		edges = append(edges, user.EdgeSalesRepEstimates)
	}
	if m.removedsales != nil {
		edges = append(edges, user.EdgeSales)
	}
	if m.removedcreated_installation_jobs != nil {
		edges = append(edges, user.EdgeCreatedInstallationJobs)
	}
	if m.removedinstallation_leads != nil {
		edges = append(edges, user.EdgeInstallationLeads)
	}
	if m.removedestimate_activities != nil {
		edges = append(edges, user.EdgeEstimateActivities)
	}
	if m.removedjob_activities != nil {
		edges = append(edges, user.EdgeJobActivities)
	}
	if m.removedpartner_activities != nil {
		edges = append(edges, user.EdgePartnerActivities)
	}
	if m.removeduser_activities != nil {
		edges = append(edges, user.EdgeUserActivities)
	}
	if m.removedactivities != nil {
		edges = append(edges, user.EdgeActivities)
	}
	if m.removedjob_progress_history != nil {
		edges = append(edges, user.EdgeJobProgressHistory)
	}
	if m.removedinstallation_job_status_changer != nil {
		edges = append(edges, user.EdgeInstallationJobStatusChanger)
	}
	if m.removedcontact_us_requests != nil {
		edges = append(edges, user.EdgeContactUsRequests)
	}
	if m.removedpartner != nil {
		edges = append(edges, user.EdgePartner)
	}
	if m.removedsurveys != nil {
		edges = append(edges, user.EdgeSurveys)
	}
	if m.removedsurvey_progress != nil {
		edges = append(edges, user.EdgeSurveyProgress)
	}
	if m.removedcreated_training_videos != nil {
		edges = append(edges, user.EdgeCreatedTrainingVideos)
	}
	if m.removedcreated_training_courses != nil {
		edges = append(edges, user.EdgeCreatedTrainingCourses)
	}
	if m.removedjob_notes != nil {
		edges = append(edges, user.EdgeJobNotes)
	}
	if m.removedchat_channels != nil {
		edges = append(edges, user.EdgeChatChannels)
	}
	if m.removedsent_messages != nil {
		edges = append(edges, user.EdgeSentMessages)
	}
	if m.removedreceived_messages != nil {
		edges = append(edges, user.EdgeReceivedMessages)
	}
	if m.removedchannel_message_read != nil {
		edges = append(edges, user.EdgeChannelMessageRead)
	}
	if m.removedproducts_created != nil {
		edges = append(edges, user.EdgeProductsCreated)
	}
	if m.removedproduct_pkg_created != nil {
		edges = append(edges, user.EdgeProductPkgCreated)
	}
	if m.removedjob_doc_urls != nil {
		edges = append(edges, user.EdgeJobDocUrls)
	}
	if m.removedpartner_contacts != nil {
		edges = append(edges, user.EdgePartnerContacts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAuditLogs:
		ids := make([]ent.Value, 0, len(m.removedaudit_logs))
		for id := range m.removedaudit_logs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeNotify:
		ids := make([]ent.Value, 0, len(m.removednotify))
		for id := range m.removednotify {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedJobs:
		ids := make([]ent.Value, 0, len(m.removedcreated_jobs))
		for id := range m.removedcreated_jobs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedEstimates:
		ids := make([]ent.Value, 0, len(m.removedcreated_estimates))
		for id := range m.removedcreated_estimates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSalesRepEstimates:
		ids := make([]ent.Value, 0, len(m.removedsales_rep_estimates))
		for id := range m.removedsales_rep_estimates {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSales:
		ids := make([]ent.Value, 0, len(m.removedsales))
		for id := range m.removedsales {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedInstallationJobs:
		ids := make([]ent.Value, 0, len(m.removedcreated_installation_jobs))
		for id := range m.removedcreated_installation_jobs {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInstallationLeads:
		ids := make([]ent.Value, 0, len(m.removedinstallation_leads))
		for id := range m.removedinstallation_leads {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeEstimateActivities:
		ids := make([]ent.Value, 0, len(m.removedestimate_activities))
		for id := range m.removedestimate_activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobActivities:
		ids := make([]ent.Value, 0, len(m.removedjob_activities))
		for id := range m.removedjob_activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePartnerActivities:
		ids := make([]ent.Value, 0, len(m.removedpartner_activities))
		for id := range m.removedpartner_activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeUserActivities:
		ids := make([]ent.Value, 0, len(m.removeduser_activities))
		for id := range m.removeduser_activities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobProgressHistory:
		ids := make([]ent.Value, 0, len(m.removedjob_progress_history))
		for id := range m.removedjob_progress_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeInstallationJobStatusChanger:
		ids := make([]ent.Value, 0, len(m.removedinstallation_job_status_changer))
		for id := range m.removedinstallation_job_status_changer {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeContactUsRequests:
		ids := make([]ent.Value, 0, len(m.removedcontact_us_requests))
		for id := range m.removedcontact_us_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePartner:
		ids := make([]ent.Value, 0, len(m.removedpartner))
		for id := range m.removedpartner {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSurveys:
		ids := make([]ent.Value, 0, len(m.removedsurveys))
		for id := range m.removedsurveys {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSurveyProgress:
		ids := make([]ent.Value, 0, len(m.removedsurvey_progress))
		for id := range m.removedsurvey_progress {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTrainingVideos:
		ids := make([]ent.Value, 0, len(m.removedcreated_training_videos))
		for id := range m.removedcreated_training_videos {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedTrainingCourses:
		ids := make([]ent.Value, 0, len(m.removedcreated_training_courses))
		for id := range m.removedcreated_training_courses {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobNotes:
		ids := make([]ent.Value, 0, len(m.removedjob_notes))
		for id := range m.removedjob_notes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChatChannels:
		ids := make([]ent.Value, 0, len(m.removedchat_channels))
		for id := range m.removedchat_channels {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSentMessages:
		ids := make([]ent.Value, 0, len(m.removedsent_messages))
		for id := range m.removedsent_messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeReceivedMessages:
		ids := make([]ent.Value, 0, len(m.removedreceived_messages))
		for id := range m.removedreceived_messages {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChannelMessageRead:
		ids := make([]ent.Value, 0, len(m.removedchannel_message_read))
		for id := range m.removedchannel_message_read {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProductsCreated:
		ids := make([]ent.Value, 0, len(m.removedproducts_created))
		for id := range m.removedproducts_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeProductPkgCreated:
		ids := make([]ent.Value, 0, len(m.removedproduct_pkg_created))
		for id := range m.removedproduct_pkg_created {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeJobDocUrls:
		ids := make([]ent.Value, 0, len(m.removedjob_doc_urls))
		for id := range m.removedjob_doc_urls {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePartnerContacts:
		ids := make([]ent.Value, 0, len(m.removedpartner_contacts))
		for id := range m.removedpartner_contacts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 32)
	if m.clearedauths {
		edges = append(edges, user.EdgeAuths)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedaudit_logs {
		edges = append(edges, user.EdgeAuditLogs)
	}
	if m.clearednotify {
		edges = append(edges, user.EdgeNotify)
	}
	if m.clearedcreated_jobs {
		edges = append(edges, user.EdgeCreatedJobs)
	}
	if m.clearedcreated_estimates {
		edges = append(edges, user.EdgeCreatedEstimates)
	}
	if m.clearedsales_rep_estimates {
		edges = append(edges, user.EdgeSalesRepEstimates)
	}
	if m.clearedsales {
		edges = append(edges, user.EdgeSales)
	}
	if m.clearedcreated_installation_jobs {
		edges = append(edges, user.EdgeCreatedInstallationJobs)
	}
	if m.clearedinstallation_leads {
		edges = append(edges, user.EdgeInstallationLeads)
	}
	if m.clearedestimate_activities {
		edges = append(edges, user.EdgeEstimateActivities)
	}
	if m.clearedjob_activities {
		edges = append(edges, user.EdgeJobActivities)
	}
	if m.clearedpartner_activities {
		edges = append(edges, user.EdgePartnerActivities)
	}
	if m.cleareduser_activities {
		edges = append(edges, user.EdgeUserActivities)
	}
	if m.clearedactivities {
		edges = append(edges, user.EdgeActivities)
	}
	if m.clearedjob_progress_history {
		edges = append(edges, user.EdgeJobProgressHistory)
	}
	if m.clearedinstallation_job_status_changer {
		edges = append(edges, user.EdgeInstallationJobStatusChanger)
	}
	if m.clearedcontact_us_requests {
		edges = append(edges, user.EdgeContactUsRequests)
	}
	if m.clearedpartner {
		edges = append(edges, user.EdgePartner)
	}
	if m.clearedsurveys {
		edges = append(edges, user.EdgeSurveys)
	}
	if m.clearedsurvey_progress {
		edges = append(edges, user.EdgeSurveyProgress)
	}
	if m.clearedcreated_training_videos {
		edges = append(edges, user.EdgeCreatedTrainingVideos)
	}
	if m.clearedcreated_training_courses {
		edges = append(edges, user.EdgeCreatedTrainingCourses)
	}
	if m.clearedjob_notes {
		edges = append(edges, user.EdgeJobNotes)
	}
	if m.clearedchat_channels {
		edges = append(edges, user.EdgeChatChannels)
	}
	if m.clearedsent_messages {
		edges = append(edges, user.EdgeSentMessages)
	}
	if m.clearedreceived_messages {
		edges = append(edges, user.EdgeReceivedMessages)
	}
	if m.clearedchannel_message_read {
		edges = append(edges, user.EdgeChannelMessageRead)
	}
	if m.clearedproducts_created {
		edges = append(edges, user.EdgeProductsCreated)
	}
	if m.clearedproduct_pkg_created {
		edges = append(edges, user.EdgeProductPkgCreated)
	}
	if m.clearedjob_doc_urls {
		edges = append(edges, user.EdgeJobDocUrls)
	}
	if m.clearedpartner_contacts {
		edges = append(edges, user.EdgePartnerContacts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeAuths:
		return m.clearedauths
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeAuditLogs:
		return m.clearedaudit_logs
	case user.EdgeNotify:
		return m.clearednotify
	case user.EdgeCreatedJobs:
		return m.clearedcreated_jobs
	case user.EdgeCreatedEstimates:
		return m.clearedcreated_estimates
	case user.EdgeSalesRepEstimates:
		return m.clearedsales_rep_estimates
	case user.EdgeSales:
		return m.clearedsales
	case user.EdgeCreatedInstallationJobs:
		return m.clearedcreated_installation_jobs
	case user.EdgeInstallationLeads:
		return m.clearedinstallation_leads
	case user.EdgeEstimateActivities:
		return m.clearedestimate_activities
	case user.EdgeJobActivities:
		return m.clearedjob_activities
	case user.EdgePartnerActivities:
		return m.clearedpartner_activities
	case user.EdgeUserActivities:
		return m.cleareduser_activities
	case user.EdgeActivities:
		return m.clearedactivities
	case user.EdgeJobProgressHistory:
		return m.clearedjob_progress_history
	case user.EdgeInstallationJobStatusChanger:
		return m.clearedinstallation_job_status_changer
	case user.EdgeContactUsRequests:
		return m.clearedcontact_us_requests
	case user.EdgePartner:
		return m.clearedpartner
	case user.EdgeSurveys:
		return m.clearedsurveys
	case user.EdgeSurveyProgress:
		return m.clearedsurvey_progress
	case user.EdgeCreatedTrainingVideos:
		return m.clearedcreated_training_videos
	case user.EdgeCreatedTrainingCourses:
		return m.clearedcreated_training_courses
	case user.EdgeJobNotes:
		return m.clearedjob_notes
	case user.EdgeChatChannels:
		return m.clearedchat_channels
	case user.EdgeSentMessages:
		return m.clearedsent_messages
	case user.EdgeReceivedMessages:
		return m.clearedreceived_messages
	case user.EdgeChannelMessageRead:
		return m.clearedchannel_message_read
	case user.EdgeProductsCreated:
		return m.clearedproducts_created
	case user.EdgeProductPkgCreated:
		return m.clearedproduct_pkg_created
	case user.EdgeJobDocUrls:
		return m.clearedjob_doc_urls
	case user.EdgePartnerContacts:
		return m.clearedpartner_contacts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeAuths:
		m.ClearAuths()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeAuths:
		m.ResetAuths()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeAuditLogs:
		m.ResetAuditLogs()
		return nil
	case user.EdgeNotify:
		m.ResetNotify()
		return nil
	case user.EdgeCreatedJobs:
		m.ResetCreatedJobs()
		return nil
	case user.EdgeCreatedEstimates:
		m.ResetCreatedEstimates()
		return nil
	case user.EdgeSalesRepEstimates:
		m.ResetSalesRepEstimates()
		return nil
	case user.EdgeSales:
		m.ResetSales()
		return nil
	case user.EdgeCreatedInstallationJobs:
		m.ResetCreatedInstallationJobs()
		return nil
	case user.EdgeInstallationLeads:
		m.ResetInstallationLeads()
		return nil
	case user.EdgeEstimateActivities:
		m.ResetEstimateActivities()
		return nil
	case user.EdgeJobActivities:
		m.ResetJobActivities()
		return nil
	case user.EdgePartnerActivities:
		m.ResetPartnerActivities()
		return nil
	case user.EdgeUserActivities:
		m.ResetUserActivities()
		return nil
	case user.EdgeActivities:
		m.ResetActivities()
		return nil
	case user.EdgeJobProgressHistory:
		m.ResetJobProgressHistory()
		return nil
	case user.EdgeInstallationJobStatusChanger:
		m.ResetInstallationJobStatusChanger()
		return nil
	case user.EdgeContactUsRequests:
		m.ResetContactUsRequests()
		return nil
	case user.EdgePartner:
		m.ResetPartner()
		return nil
	case user.EdgeSurveys:
		m.ResetSurveys()
		return nil
	case user.EdgeSurveyProgress:
		m.ResetSurveyProgress()
		return nil
	case user.EdgeCreatedTrainingVideos:
		m.ResetCreatedTrainingVideos()
		return nil
	case user.EdgeCreatedTrainingCourses:
		m.ResetCreatedTrainingCourses()
		return nil
	case user.EdgeJobNotes:
		m.ResetJobNotes()
		return nil
	case user.EdgeChatChannels:
		m.ResetChatChannels()
		return nil
	case user.EdgeSentMessages:
		m.ResetSentMessages()
		return nil
	case user.EdgeReceivedMessages:
		m.ResetReceivedMessages()
		return nil
	case user.EdgeChannelMessageRead:
		m.ResetChannelMessageRead()
		return nil
	case user.EdgeProductsCreated:
		m.ResetProductsCreated()
		return nil
	case user.EdgeProductPkgCreated:
		m.ResetProductPkgCreated()
		return nil
	case user.EdgeJobDocUrls:
		m.ResetJobDocUrls()
		return nil
	case user.EdgePartnerContacts:
		m.ResetPartnerContacts()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserActivityMutation represents an operation that mutates the UserActivity nodes in the graph.
type UserActivityMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	description        *string
	raw                *map[string]interface{}
	clearedFields      map[string]struct{}
	user               *string
	cleareduser        bool
	creator            *string
	clearedcreator     bool
	creator_api        *string
	clearedcreator_api bool
	done               bool
	oldValue           func(context.Context) (*UserActivity, error)
	predicates         []predicate.UserActivity
}

var _ ent.Mutation = (*UserActivityMutation)(nil)

// useractivityOption allows management of the mutation configuration using functional options.
type useractivityOption func(*UserActivityMutation)

// newUserActivityMutation creates new mutation for the UserActivity entity.
func newUserActivityMutation(c config, op Op, opts ...useractivityOption) *UserActivityMutation {
	m := &UserActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeUserActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserActivityID sets the ID field of the mutation.
func withUserActivityID(id string) useractivityOption {
	return func(m *UserActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *UserActivity
		)
		m.oldValue = func(ctx context.Context) (*UserActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserActivity sets the old UserActivity of the mutation.
func withUserActivity(node *UserActivity) useractivityOption {
	return func(m *UserActivityMutation) {
		m.oldValue = func(context.Context) (*UserActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserActivity entities.
func (m *UserActivityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserActivityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserActivityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetDescription sets the "description" field.
func (m *UserActivityMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserActivityMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *UserActivityMutation) ResetDescription() {
	m.description = nil
}

// SetRaw sets the "raw" field.
func (m *UserActivityMutation) SetRaw(value map[string]interface{}) {
	m.raw = &value
}

// Raw returns the value of the "raw" field in the mutation.
func (m *UserActivityMutation) Raw() (r map[string]interface{}, exists bool) {
	v := m.raw
	if v == nil {
		return
	}
	return *v, true
}

// OldRaw returns the old "raw" field's value of the UserActivity entity.
// If the UserActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserActivityMutation) OldRaw(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRaw: %w", err)
	}
	return oldValue.Raw, nil
}

// ClearRaw clears the value of the "raw" field.
func (m *UserActivityMutation) ClearRaw() {
	m.raw = nil
	m.clearedFields[useractivity.FieldRaw] = struct{}{}
}

// RawCleared returns if the "raw" field was cleared in this mutation.
func (m *UserActivityMutation) RawCleared() bool {
	_, ok := m.clearedFields[useractivity.FieldRaw]
	return ok
}

// ResetRaw resets all changes to the "raw" field.
func (m *UserActivityMutation) ResetRaw() {
	m.raw = nil
	delete(m.clearedFields, useractivity.FieldRaw)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserActivityMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserActivityMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserActivityMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserActivityMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserActivityMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserActivityMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *UserActivityMutation) SetCreatorID(id string) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *UserActivityMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *UserActivityMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *UserActivityMutation) CreatorID() (id string, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *UserActivityMutation) CreatorIDs() (ids []string) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *UserActivityMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetCreatorAPIID sets the "creator_api" edge to the ApiUser entity by id.
func (m *UserActivityMutation) SetCreatorAPIID(id string) {
	m.creator_api = &id
}

// ClearCreatorAPI clears the "creator_api" edge to the ApiUser entity.
func (m *UserActivityMutation) ClearCreatorAPI() {
	m.clearedcreator_api = true
}

// CreatorAPICleared reports if the "creator_api" edge to the ApiUser entity was cleared.
func (m *UserActivityMutation) CreatorAPICleared() bool {
	return m.clearedcreator_api
}

// CreatorAPIID returns the "creator_api" edge ID in the mutation.
func (m *UserActivityMutation) CreatorAPIID() (id string, exists bool) {
	if m.creator_api != nil {
		return *m.creator_api, true
	}
	return
}

// CreatorAPIIDs returns the "creator_api" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorAPIID instead. It exists only for internal usage by the builders.
func (m *UserActivityMutation) CreatorAPIIDs() (ids []string) {
	if id := m.creator_api; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreatorAPI resets all changes to the "creator_api" edge.
func (m *UserActivityMutation) ResetCreatorAPI() {
	m.creator_api = nil
	m.clearedcreator_api = false
}

// Where appends a list predicates to the UserActivityMutation builder.
func (m *UserActivityMutation) Where(ps ...predicate.UserActivity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserActivityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserActivityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserActivity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserActivityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserActivityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserActivity).
func (m *UserActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserActivityMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, useractivity.FieldCreatedAt)
	}
	if m.description != nil {
		fields = append(fields, useractivity.FieldDescription)
	}
	if m.raw != nil {
		fields = append(fields, useractivity.FieldRaw)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case useractivity.FieldCreatedAt:
		return m.CreatedAt()
	case useractivity.FieldDescription:
		return m.Description()
	case useractivity.FieldRaw:
		return m.Raw()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case useractivity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case useractivity.FieldDescription:
		return m.OldDescription(ctx)
	case useractivity.FieldRaw:
		return m.OldRaw(ctx)
	}
	return nil, fmt.Errorf("unknown UserActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case useractivity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case useractivity.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case useractivity.FieldRaw:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRaw(v)
		return nil
	}
	return fmt.Errorf("unknown UserActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(useractivity.FieldRaw) {
		fields = append(fields, useractivity.FieldRaw)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserActivityMutation) ClearField(name string) error {
	switch name {
	case useractivity.FieldRaw:
		m.ClearRaw()
		return nil
	}
	return fmt.Errorf("unknown UserActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserActivityMutation) ResetField(name string) error {
	switch name {
	case useractivity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case useractivity.FieldDescription:
		m.ResetDescription()
		return nil
	case useractivity.FieldRaw:
		m.ResetRaw()
		return nil
	}
	return fmt.Errorf("unknown UserActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, useractivity.EdgeUser)
	}
	if m.creator != nil {
		edges = append(edges, useractivity.EdgeCreator)
	}
	if m.creator_api != nil {
		edges = append(edges, useractivity.EdgeCreatorAPI)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case useractivity.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case useractivity.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case useractivity.EdgeCreatorAPI:
		if id := m.creator_api; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserActivityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, useractivity.EdgeUser)
	}
	if m.clearedcreator {
		edges = append(edges, useractivity.EdgeCreator)
	}
	if m.clearedcreator_api {
		edges = append(edges, useractivity.EdgeCreatorAPI)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case useractivity.EdgeUser:
		return m.cleareduser
	case useractivity.EdgeCreator:
		return m.clearedcreator
	case useractivity.EdgeCreatorAPI:
		return m.clearedcreator_api
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserActivityMutation) ClearEdge(name string) error {
	switch name {
	case useractivity.EdgeUser:
		m.ClearUser()
		return nil
	case useractivity.EdgeCreator:
		m.ClearCreator()
		return nil
	case useractivity.EdgeCreatorAPI:
		m.ClearCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown UserActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserActivityMutation) ResetEdge(name string) error {
	switch name {
	case useractivity.EdgeUser:
		m.ResetUser()
		return nil
	case useractivity.EdgeCreator:
		m.ResetCreator()
		return nil
	case useractivity.EdgeCreatorAPI:
		m.ResetCreatorAPI()
		return nil
	}
	return fmt.Errorf("unknown UserActivity edge %s", name)
}

// UserAuthMutation represents an operation that mutates the UserAuth nodes in the graph.
type UserAuthMutation struct {
	config
	op             Op
	typ            string
	id             *string
	provider_id    *uint8
	addprovider_id *int8
	created_at     *time.Time
	clearedFields  map[string]struct{}
	user           *string
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*UserAuth, error)
	predicates     []predicate.UserAuth
}

var _ ent.Mutation = (*UserAuthMutation)(nil)

// userauthOption allows management of the mutation configuration using functional options.
type userauthOption func(*UserAuthMutation)

// newUserAuthMutation creates new mutation for the UserAuth entity.
func newUserAuthMutation(c config, op Op, opts ...userauthOption) *UserAuthMutation {
	m := &UserAuthMutation{
		config:        c,
		op:            op,
		typ:           TypeUserAuth,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserAuthID sets the ID field of the mutation.
func withUserAuthID(id string) userauthOption {
	return func(m *UserAuthMutation) {
		var (
			err   error
			once  sync.Once
			value *UserAuth
		)
		m.oldValue = func(ctx context.Context) (*UserAuth, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserAuth.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserAuth sets the old UserAuth of the mutation.
func withUserAuth(node *UserAuth) userauthOption {
	return func(m *UserAuthMutation) {
		m.oldValue = func(context.Context) (*UserAuth, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserAuthMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserAuthMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserAuth entities.
func (m *UserAuthMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserAuthMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserAuthMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserAuth.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetProviderID sets the "provider_id" field.
func (m *UserAuthMutation) SetProviderID(u uint8) {
	m.provider_id = &u
	m.addprovider_id = nil
}

// ProviderID returns the value of the "provider_id" field in the mutation.
func (m *UserAuthMutation) ProviderID() (r uint8, exists bool) {
	v := m.provider_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProviderID returns the old "provider_id" field's value of the UserAuth entity.
// If the UserAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldProviderID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProviderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProviderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProviderID: %w", err)
	}
	return oldValue.ProviderID, nil
}

// AddProviderID adds u to the "provider_id" field.
func (m *UserAuthMutation) AddProviderID(u int8) {
	if m.addprovider_id != nil {
		*m.addprovider_id += u
	} else {
		m.addprovider_id = &u
	}
}

// AddedProviderID returns the value that was added to the "provider_id" field in this mutation.
func (m *UserAuthMutation) AddedProviderID() (r int8, exists bool) {
	v := m.addprovider_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProviderID resets all changes to the "provider_id" field.
func (m *UserAuthMutation) ResetProviderID() {
	m.provider_id = nil
	m.addprovider_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserAuthMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserAuthMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserAuth entity.
// If the UserAuth object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserAuthMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserAuthMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserAuthMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserAuthMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserAuthMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserAuthMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserAuthMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserAuthMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserAuthMutation builder.
func (m *UserAuthMutation) Where(ps ...predicate.UserAuth) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserAuthMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserAuthMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserAuth, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserAuthMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserAuthMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserAuth).
func (m *UserAuthMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserAuthMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.provider_id != nil {
		fields = append(fields, userauth.FieldProviderID)
	}
	if m.created_at != nil {
		fields = append(fields, userauth.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserAuthMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userauth.FieldProviderID:
		return m.ProviderID()
	case userauth.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserAuthMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userauth.FieldProviderID:
		return m.OldProviderID(ctx)
	case userauth.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserAuth field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAuthMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userauth.FieldProviderID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProviderID(v)
		return nil
	case userauth.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserAuth field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserAuthMutation) AddedFields() []string {
	var fields []string
	if m.addprovider_id != nil {
		fields = append(fields, userauth.FieldProviderID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserAuthMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userauth.FieldProviderID:
		return m.AddedProviderID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserAuthMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userauth.FieldProviderID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProviderID(v)
		return nil
	}
	return fmt.Errorf("unknown UserAuth numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserAuthMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserAuthMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserAuthMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserAuth nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserAuthMutation) ResetField(name string) error {
	switch name {
	case userauth.FieldProviderID:
		m.ResetProviderID()
		return nil
	case userauth.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserAuth field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserAuthMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userauth.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserAuthMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userauth.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserAuthMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserAuthMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserAuthMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userauth.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserAuthMutation) EdgeCleared(name string) bool {
	switch name {
	case userauth.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserAuthMutation) ClearEdge(name string) error {
	switch name {
	case userauth.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserAuth unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserAuthMutation) ResetEdge(name string) error {
	switch name {
	case userauth.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserAuth edge %s", name)
}

// UserSessionMutation represents an operation that mutates the UserSession nodes in the graph.
type UserSessionMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	expires_at             *time.Time
	ip                     *string
	clearedFields          map[string]struct{}
	sockets                map[string]struct{}
	removedsockets         map[string]struct{}
	clearedsockets         bool
	user                   *string
	cleareduser            bool
	partner                *string
	clearedpartner         bool
	partner_contact        *string
	clearedpartner_contact bool
	done                   bool
	oldValue               func(context.Context) (*UserSession, error)
	predicates             []predicate.UserSession
}

var _ ent.Mutation = (*UserSessionMutation)(nil)

// usersessionOption allows management of the mutation configuration using functional options.
type usersessionOption func(*UserSessionMutation)

// newUserSessionMutation creates new mutation for the UserSession entity.
func newUserSessionMutation(c config, op Op, opts ...usersessionOption) *UserSessionMutation {
	m := &UserSessionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSessionID sets the ID field of the mutation.
func withUserSessionID(id string) usersessionOption {
	return func(m *UserSessionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSession
		)
		m.oldValue = func(ctx context.Context) (*UserSession, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSession.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSession sets the old UserSession of the mutation.
func withUserSession(node *UserSession) usersessionOption {
	return func(m *UserSessionMutation) {
		m.oldValue = func(context.Context) (*UserSession, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSession entities.
func (m *UserSessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSession.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserSessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserSessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserSessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIP sets the "ip" field.
func (m *UserSessionMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *UserSessionMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the UserSession entity.
// If the UserSession object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *UserSessionMutation) ResetIP() {
	m.ip = nil
}

// AddSocketIDs adds the "sockets" edge to the UserSessionSocket entity by ids.
func (m *UserSessionMutation) AddSocketIDs(ids ...string) {
	if m.sockets == nil {
		m.sockets = make(map[string]struct{})
	}
	for i := range ids {
		m.sockets[ids[i]] = struct{}{}
	}
}

// ClearSockets clears the "sockets" edge to the UserSessionSocket entity.
func (m *UserSessionMutation) ClearSockets() {
	m.clearedsockets = true
}

// SocketsCleared reports if the "sockets" edge to the UserSessionSocket entity was cleared.
func (m *UserSessionMutation) SocketsCleared() bool {
	return m.clearedsockets
}

// RemoveSocketIDs removes the "sockets" edge to the UserSessionSocket entity by IDs.
func (m *UserSessionMutation) RemoveSocketIDs(ids ...string) {
	if m.removedsockets == nil {
		m.removedsockets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sockets, ids[i])
		m.removedsockets[ids[i]] = struct{}{}
	}
}

// RemovedSockets returns the removed IDs of the "sockets" edge to the UserSessionSocket entity.
func (m *UserSessionMutation) RemovedSocketsIDs() (ids []string) {
	for id := range m.removedsockets {
		ids = append(ids, id)
	}
	return
}

// SocketsIDs returns the "sockets" edge IDs in the mutation.
func (m *UserSessionMutation) SocketsIDs() (ids []string) {
	for id := range m.sockets {
		ids = append(ids, id)
	}
	return
}

// ResetSockets resets all changes to the "sockets" edge.
func (m *UserSessionMutation) ResetSockets() {
	m.sockets = nil
	m.clearedsockets = false
	m.removedsockets = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserSessionMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserSessionMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSessionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetPartnerID sets the "partner" edge to the Partner entity by id.
func (m *UserSessionMutation) SetPartnerID(id string) {
	m.partner = &id
}

// ClearPartner clears the "partner" edge to the Partner entity.
func (m *UserSessionMutation) ClearPartner() {
	m.clearedpartner = true
}

// PartnerCleared reports if the "partner" edge to the Partner entity was cleared.
func (m *UserSessionMutation) PartnerCleared() bool {
	return m.clearedpartner
}

// PartnerID returns the "partner" edge ID in the mutation.
func (m *UserSessionMutation) PartnerID() (id string, exists bool) {
	if m.partner != nil {
		return *m.partner, true
	}
	return
}

// PartnerIDs returns the "partner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerID instead. It exists only for internal usage by the builders.
func (m *UserSessionMutation) PartnerIDs() (ids []string) {
	if id := m.partner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartner resets all changes to the "partner" edge.
func (m *UserSessionMutation) ResetPartner() {
	m.partner = nil
	m.clearedpartner = false
}

// SetPartnerContactID sets the "partner_contact" edge to the PartnerContact entity by id.
func (m *UserSessionMutation) SetPartnerContactID(id string) {
	m.partner_contact = &id
}

// ClearPartnerContact clears the "partner_contact" edge to the PartnerContact entity.
func (m *UserSessionMutation) ClearPartnerContact() {
	m.clearedpartner_contact = true
}

// PartnerContactCleared reports if the "partner_contact" edge to the PartnerContact entity was cleared.
func (m *UserSessionMutation) PartnerContactCleared() bool {
	return m.clearedpartner_contact
}

// PartnerContactID returns the "partner_contact" edge ID in the mutation.
func (m *UserSessionMutation) PartnerContactID() (id string, exists bool) {
	if m.partner_contact != nil {
		return *m.partner_contact, true
	}
	return
}

// PartnerContactIDs returns the "partner_contact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PartnerContactID instead. It exists only for internal usage by the builders.
func (m *UserSessionMutation) PartnerContactIDs() (ids []string) {
	if id := m.partner_contact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPartnerContact resets all changes to the "partner_contact" edge.
func (m *UserSessionMutation) ResetPartnerContact() {
	m.partner_contact = nil
	m.clearedpartner_contact = false
}

// Where appends a list predicates to the UserSessionMutation builder.
func (m *UserSessionMutation) Where(ps ...predicate.UserSession) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSession, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSession).
func (m *UserSessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSessionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, usersession.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersession.FieldUpdatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, usersession.FieldExpiresAt)
	}
	if m.ip != nil {
		fields = append(fields, usersession.FieldIP)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersession.FieldCreatedAt:
		return m.CreatedAt()
	case usersession.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersession.FieldExpiresAt:
		return m.ExpiresAt()
	case usersession.FieldIP:
		return m.IP()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersession.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersession.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersession.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case usersession.FieldIP:
		return m.OldIP(ctx)
	}
	return nil, fmt.Errorf("unknown UserSession field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersession.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersession.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersession.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case usersession.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSession numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserSession nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSessionMutation) ResetField(name string) error {
	switch name {
	case usersession.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersession.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersession.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case usersession.FieldIP:
		m.ResetIP()
		return nil
	}
	return fmt.Errorf("unknown UserSession field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.sockets != nil {
		edges = append(edges, usersession.EdgeSockets)
	}
	if m.user != nil {
		edges = append(edges, usersession.EdgeUser)
	}
	if m.partner != nil {
		edges = append(edges, usersession.EdgePartner)
	}
	if m.partner_contact != nil {
		edges = append(edges, usersession.EdgePartnerContact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersession.EdgeSockets:
		ids := make([]ent.Value, 0, len(m.sockets))
		for id := range m.sockets {
			ids = append(ids, id)
		}
		return ids
	case usersession.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case usersession.EdgePartner:
		if id := m.partner; id != nil {
			return []ent.Value{*id}
		}
	case usersession.EdgePartnerContact:
		if id := m.partner_contact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedsockets != nil {
		edges = append(edges, usersession.EdgeSockets)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSessionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case usersession.EdgeSockets:
		ids := make([]ent.Value, 0, len(m.removedsockets))
		for id := range m.removedsockets {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedsockets {
		edges = append(edges, usersession.EdgeSockets)
	}
	if m.cleareduser {
		edges = append(edges, usersession.EdgeUser)
	}
	if m.clearedpartner {
		edges = append(edges, usersession.EdgePartner)
	}
	if m.clearedpartner_contact {
		edges = append(edges, usersession.EdgePartnerContact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSessionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersession.EdgeSockets:
		return m.clearedsockets
	case usersession.EdgeUser:
		return m.cleareduser
	case usersession.EdgePartner:
		return m.clearedpartner
	case usersession.EdgePartnerContact:
		return m.clearedpartner_contact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSessionMutation) ClearEdge(name string) error {
	switch name {
	case usersession.EdgeUser:
		m.ClearUser()
		return nil
	case usersession.EdgePartner:
		m.ClearPartner()
		return nil
	case usersession.EdgePartnerContact:
		m.ClearPartnerContact()
		return nil
	}
	return fmt.Errorf("unknown UserSession unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSessionMutation) ResetEdge(name string) error {
	switch name {
	case usersession.EdgeSockets:
		m.ResetSockets()
		return nil
	case usersession.EdgeUser:
		m.ResetUser()
		return nil
	case usersession.EdgePartner:
		m.ResetPartner()
		return nil
	case usersession.EdgePartnerContact:
		m.ResetPartnerContact()
		return nil
	}
	return fmt.Errorf("unknown UserSession edge %s", name)
}

// UserSessionSocketMutation represents an operation that mutates the UserSessionSocket nodes in the graph.
type UserSessionSocketMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	clearedFields  map[string]struct{}
	session        *string
	clearedsession bool
	done           bool
	oldValue       func(context.Context) (*UserSessionSocket, error)
	predicates     []predicate.UserSessionSocket
}

var _ ent.Mutation = (*UserSessionSocketMutation)(nil)

// usersessionsocketOption allows management of the mutation configuration using functional options.
type usersessionsocketOption func(*UserSessionSocketMutation)

// newUserSessionSocketMutation creates new mutation for the UserSessionSocket entity.
func newUserSessionSocketMutation(c config, op Op, opts ...usersessionsocketOption) *UserSessionSocketMutation {
	m := &UserSessionSocketMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSessionSocket,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSessionSocketID sets the ID field of the mutation.
func withUserSessionSocketID(id string) usersessionsocketOption {
	return func(m *UserSessionSocketMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSessionSocket
		)
		m.oldValue = func(ctx context.Context) (*UserSessionSocket, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSessionSocket.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSessionSocket sets the old UserSessionSocket of the mutation.
func withUserSessionSocket(node *UserSessionSocket) usersessionsocketOption {
	return func(m *UserSessionSocketMutation) {
		m.oldValue = func(context.Context) (*UserSessionSocket, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSessionSocketMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSessionSocketMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSessionSocket entities.
func (m *UserSessionSocketMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSessionSocketMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSessionSocketMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSessionSocket.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSessionSocketMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSessionSocketMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSessionSocket entity.
// If the UserSessionSocket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionSocketMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSessionSocketMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSessionSocketMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSessionSocketMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSessionSocket entity.
// If the UserSessionSocket object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSessionSocketMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSessionSocketMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSessionID sets the "session" edge to the UserSession entity by id.
func (m *UserSessionSocketMutation) SetSessionID(id string) {
	m.session = &id
}

// ClearSession clears the "session" edge to the UserSession entity.
func (m *UserSessionSocketMutation) ClearSession() {
	m.clearedsession = true
}

// SessionCleared reports if the "session" edge to the UserSession entity was cleared.
func (m *UserSessionSocketMutation) SessionCleared() bool {
	return m.clearedsession
}

// SessionID returns the "session" edge ID in the mutation.
func (m *UserSessionSocketMutation) SessionID() (id string, exists bool) {
	if m.session != nil {
		return *m.session, true
	}
	return
}

// SessionIDs returns the "session" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SessionID instead. It exists only for internal usage by the builders.
func (m *UserSessionSocketMutation) SessionIDs() (ids []string) {
	if id := m.session; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSession resets all changes to the "session" edge.
func (m *UserSessionSocketMutation) ResetSession() {
	m.session = nil
	m.clearedsession = false
}

// Where appends a list predicates to the UserSessionSocketMutation builder.
func (m *UserSessionSocketMutation) Where(ps ...predicate.UserSessionSocket) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSessionSocketMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSessionSocketMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSessionSocket, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSessionSocketMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSessionSocketMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSessionSocket).
func (m *UserSessionSocketMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSessionSocketMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, usersessionsocket.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersessionsocket.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSessionSocketMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersessionsocket.FieldCreatedAt:
		return m.CreatedAt()
	case usersessionsocket.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSessionSocketMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersessionsocket.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersessionsocket.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserSessionSocket field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionSocketMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersessionsocket.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersessionsocket.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserSessionSocket field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSessionSocketMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSessionSocketMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSessionSocketMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSessionSocket numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSessionSocketMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSessionSocketMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSessionSocketMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserSessionSocket nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSessionSocketMutation) ResetField(name string) error {
	switch name {
	case usersessionsocket.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersessionsocket.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserSessionSocket field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSessionSocketMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.session != nil {
		edges = append(edges, usersessionsocket.EdgeSession)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSessionSocketMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersessionsocket.EdgeSession:
		if id := m.session; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSessionSocketMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSessionSocketMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSessionSocketMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsession {
		edges = append(edges, usersessionsocket.EdgeSession)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSessionSocketMutation) EdgeCleared(name string) bool {
	switch name {
	case usersessionsocket.EdgeSession:
		return m.clearedsession
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSessionSocketMutation) ClearEdge(name string) error {
	switch name {
	case usersessionsocket.EdgeSession:
		m.ClearSession()
		return nil
	}
	return fmt.Errorf("unknown UserSessionSocket unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSessionSocketMutation) ResetEdge(name string) error {
	switch name {
	case usersessionsocket.EdgeSession:
		m.ResetSession()
		return nil
	}
	return fmt.Errorf("unknown UserSessionSocket edge %s", name)
}
