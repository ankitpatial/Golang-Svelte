// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"fmt"
	"math"
	"roofix/ent/auditlog"
	"roofix/ent/channelmessage"
	"roofix/ent/channelmessageread"
	"roofix/ent/channelsub"
	"roofix/ent/contactus"
	"roofix/ent/estimate"
	"roofix/ent/estimateactivity"
	"roofix/ent/installationjob"
	"roofix/ent/installationjobprogress"
	"roofix/ent/job"
	"roofix/ent/jobactivity"
	"roofix/ent/jobdocurl"
	"roofix/ent/jobnote"
	"roofix/ent/jobprogresshistory"
	"roofix/ent/notifysetting"
	"roofix/ent/partner"
	"roofix/ent/partneractivity"
	"roofix/ent/partnercontact"
	"roofix/ent/predicate"
	"roofix/ent/product"
	"roofix/ent/productpackage"
	"roofix/ent/survey"
	"roofix/ent/surveyprogress"
	"roofix/ent/trainingcourse"
	"roofix/ent/trainingvideo"
	"roofix/ent/user"
	"roofix/ent/useractivity"
	"roofix/ent/userauth"
	"roofix/ent/usersession"

	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// UserQuery is the builder for querying User entities.
type UserQuery struct {
	config
	ctx                                   *QueryContext
	order                                 []user.OrderOption
	inters                                []Interceptor
	predicates                            []predicate.User
	withAuths                             *UserAuthQuery
	withSessions                          *UserSessionQuery
	withAuditLogs                         *AuditLogQuery
	withNotify                            *NotifySettingQuery
	withCreatedJobs                       *JobQuery
	withCreatedEstimates                  *EstimateQuery
	withSalesRepEstimates                 *EstimateQuery
	withSales                             *JobQuery
	withCreatedInstallationJobs           *InstallationJobQuery
	withInstallationLeads                 *InstallationJobQuery
	withEstimateActivities                *EstimateActivityQuery
	withJobActivities                     *JobActivityQuery
	withPartnerActivities                 *PartnerActivityQuery
	withUserActivities                    *UserActivityQuery
	withActivities                        *UserActivityQuery
	withJobProgressHistory                *JobProgressHistoryQuery
	withInstallationJobStatusChanger      *InstallationJobProgressQuery
	withContactUsRequests                 *ContactUsQuery
	withPartner                           *PartnerQuery
	withSurveys                           *SurveyQuery
	withSurveyProgress                    *SurveyProgressQuery
	withCreatedTrainingVideos             *TrainingVideoQuery
	withCreatedTrainingCourses            *TrainingCourseQuery
	withJobNotes                          *JobNoteQuery
	withChatChannels                      *ChannelSubQuery
	withSentMessages                      *ChannelMessageQuery
	withReceivedMessages                  *ChannelMessageQuery
	withChannelMessageRead                *ChannelMessageReadQuery
	withProductsCreated                   *ProductQuery
	withProductPkgCreated                 *ProductPackageQuery
	withJobDocUrls                        *JobDocURLQuery
	withPartnerContacts                   *PartnerContactQuery
	loadTotal                             []func(context.Context, []*User) error
	modifiers                             []func(*sql.Selector)
	withNamedSessions                     map[string]*UserSessionQuery
	withNamedAuditLogs                    map[string]*AuditLogQuery
	withNamedNotify                       map[string]*NotifySettingQuery
	withNamedCreatedJobs                  map[string]*JobQuery
	withNamedCreatedEstimates             map[string]*EstimateQuery
	withNamedSalesRepEstimates            map[string]*EstimateQuery
	withNamedSales                        map[string]*JobQuery
	withNamedCreatedInstallationJobs      map[string]*InstallationJobQuery
	withNamedInstallationLeads            map[string]*InstallationJobQuery
	withNamedEstimateActivities           map[string]*EstimateActivityQuery
	withNamedJobActivities                map[string]*JobActivityQuery
	withNamedPartnerActivities            map[string]*PartnerActivityQuery
	withNamedUserActivities               map[string]*UserActivityQuery
	withNamedActivities                   map[string]*UserActivityQuery
	withNamedJobProgressHistory           map[string]*JobProgressHistoryQuery
	withNamedInstallationJobStatusChanger map[string]*InstallationJobProgressQuery
	withNamedContactUsRequests            map[string]*ContactUsQuery
	withNamedPartner                      map[string]*PartnerQuery
	withNamedSurveys                      map[string]*SurveyQuery
	withNamedSurveyProgress               map[string]*SurveyProgressQuery
	withNamedCreatedTrainingVideos        map[string]*TrainingVideoQuery
	withNamedCreatedTrainingCourses       map[string]*TrainingCourseQuery
	withNamedJobNotes                     map[string]*JobNoteQuery
	withNamedChatChannels                 map[string]*ChannelSubQuery
	withNamedSentMessages                 map[string]*ChannelMessageQuery
	withNamedReceivedMessages             map[string]*ChannelMessageQuery
	withNamedChannelMessageRead           map[string]*ChannelMessageReadQuery
	withNamedProductsCreated              map[string]*ProductQuery
	withNamedProductPkgCreated            map[string]*ProductPackageQuery
	withNamedJobDocUrls                   map[string]*JobDocURLQuery
	withNamedPartnerContacts              map[string]*PartnerContactQuery
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the UserQuery builder.
func (uq *UserQuery) Where(ps ...predicate.User) *UserQuery {
	uq.predicates = append(uq.predicates, ps...)
	return uq
}

// Limit the number of records to be returned by this query.
func (uq *UserQuery) Limit(limit int) *UserQuery {
	uq.ctx.Limit = &limit
	return uq
}

// Offset to start from.
func (uq *UserQuery) Offset(offset int) *UserQuery {
	uq.ctx.Offset = &offset
	return uq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (uq *UserQuery) Unique(unique bool) *UserQuery {
	uq.ctx.Unique = &unique
	return uq
}

// Order specifies how the records should be ordered.
func (uq *UserQuery) Order(o ...user.OrderOption) *UserQuery {
	uq.order = append(uq.order, o...)
	return uq
}

// QueryAuths chains the current query on the "auths" edge.
func (uq *UserQuery) QueryAuths() *UserAuthQuery {
	query := (&UserAuthClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(userauth.Table, userauth.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, user.AuthsTable, user.AuthsColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySessions chains the current query on the "sessions" edge.
func (uq *UserQuery) QuerySessions() *UserSessionQuery {
	query := (&UserSessionClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(usersession.Table, usersession.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryAuditLogs chains the current query on the "audit_logs" edge.
func (uq *UserQuery) QueryAuditLogs() *AuditLogQuery {
	query := (&AuditLogClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(auditlog.Table, auditlog.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AuditLogsTable, user.AuditLogsColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryNotify chains the current query on the "notify" edge.
func (uq *UserQuery) QueryNotify() *NotifySettingQuery {
	query := (&NotifySettingClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(notifysetting.Table, notifysetting.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.NotifyTable, user.NotifyColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCreatedJobs chains the current query on the "created_jobs" edge.
func (uq *UserQuery) QueryCreatedJobs() *JobQuery {
	query := (&JobClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedJobsTable, user.CreatedJobsColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCreatedEstimates chains the current query on the "created_estimates" edge.
func (uq *UserQuery) QueryCreatedEstimates() *EstimateQuery {
	query := (&EstimateClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(estimate.Table, estimate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedEstimatesTable, user.CreatedEstimatesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySalesRepEstimates chains the current query on the "sales_rep_estimates" edge.
func (uq *UserQuery) QuerySalesRepEstimates() *EstimateQuery {
	query := (&EstimateClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(estimate.Table, estimate.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SalesRepEstimatesTable, user.SalesRepEstimatesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySales chains the current query on the "sales" edge.
func (uq *UserQuery) QuerySales() *JobQuery {
	query := (&JobClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(job.Table, job.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SalesTable, user.SalesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCreatedInstallationJobs chains the current query on the "created_installation_jobs" edge.
func (uq *UserQuery) QueryCreatedInstallationJobs() *InstallationJobQuery {
	query := (&InstallationJobClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(installationjob.Table, installationjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedInstallationJobsTable, user.CreatedInstallationJobsColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryInstallationLeads chains the current query on the "installation_leads" edge.
func (uq *UserQuery) QueryInstallationLeads() *InstallationJobQuery {
	query := (&InstallationJobClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(installationjob.Table, installationjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.InstallationLeadsTable, user.InstallationLeadsColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryEstimateActivities chains the current query on the "estimate_activities" edge.
func (uq *UserQuery) QueryEstimateActivities() *EstimateActivityQuery {
	query := (&EstimateActivityClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(estimateactivity.Table, estimateactivity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.EstimateActivitiesTable, user.EstimateActivitiesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryJobActivities chains the current query on the "job_activities" edge.
func (uq *UserQuery) QueryJobActivities() *JobActivityQuery {
	query := (&JobActivityClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(jobactivity.Table, jobactivity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.JobActivitiesTable, user.JobActivitiesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryPartnerActivities chains the current query on the "partner_activities" edge.
func (uq *UserQuery) QueryPartnerActivities() *PartnerActivityQuery {
	query := (&PartnerActivityClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(partneractivity.Table, partneractivity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.PartnerActivitiesTable, user.PartnerActivitiesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryUserActivities chains the current query on the "user_activities" edge.
func (uq *UserQuery) QueryUserActivities() *UserActivityQuery {
	query := (&UserActivityClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(useractivity.Table, useractivity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserActivitiesTable, user.UserActivitiesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryActivities chains the current query on the "activities" edge.
func (uq *UserQuery) QueryActivities() *UserActivityQuery {
	query := (&UserActivityClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(useractivity.Table, useractivity.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ActivitiesTable, user.ActivitiesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryJobProgressHistory chains the current query on the "job_progress_history" edge.
func (uq *UserQuery) QueryJobProgressHistory() *JobProgressHistoryQuery {
	query := (&JobProgressHistoryClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(jobprogresshistory.Table, jobprogresshistory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.JobProgressHistoryTable, user.JobProgressHistoryColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryInstallationJobStatusChanger chains the current query on the "installation_job_status_changer" edge.
func (uq *UserQuery) QueryInstallationJobStatusChanger() *InstallationJobProgressQuery {
	query := (&InstallationJobProgressClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(installationjobprogress.Table, installationjobprogress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.InstallationJobStatusChangerTable, user.InstallationJobStatusChangerColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryContactUsRequests chains the current query on the "contact_us_requests" edge.
func (uq *UserQuery) QueryContactUsRequests() *ContactUsQuery {
	query := (&ContactUsClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(contactus.Table, contactus.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ContactUsRequestsTable, user.ContactUsRequestsColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryPartner chains the current query on the "partner" edge.
func (uq *UserQuery) QueryPartner() *PartnerQuery {
	query := (&PartnerClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(partner.Table, partner.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.PartnerTable, user.PartnerPrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySurveys chains the current query on the "surveys" edge.
func (uq *UserQuery) QuerySurveys() *SurveyQuery {
	query := (&SurveyClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(survey.Table, survey.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SurveysTable, user.SurveysColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySurveyProgress chains the current query on the "survey_progress" edge.
func (uq *UserQuery) QuerySurveyProgress() *SurveyProgressQuery {
	query := (&SurveyProgressClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(surveyprogress.Table, surveyprogress.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SurveyProgressTable, user.SurveyProgressColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCreatedTrainingVideos chains the current query on the "created_training_videos" edge.
func (uq *UserQuery) QueryCreatedTrainingVideos() *TrainingVideoQuery {
	query := (&TrainingVideoClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(trainingvideo.Table, trainingvideo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedTrainingVideosTable, user.CreatedTrainingVideosColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCreatedTrainingCourses chains the current query on the "created_training_courses" edge.
func (uq *UserQuery) QueryCreatedTrainingCourses() *TrainingCourseQuery {
	query := (&TrainingCourseClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(trainingcourse.Table, trainingcourse.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedTrainingCoursesTable, user.CreatedTrainingCoursesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryJobNotes chains the current query on the "job_notes" edge.
func (uq *UserQuery) QueryJobNotes() *JobNoteQuery {
	query := (&JobNoteClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(jobnote.Table, jobnote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.JobNotesTable, user.JobNotesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryChatChannels chains the current query on the "chat_channels" edge.
func (uq *UserQuery) QueryChatChannels() *ChannelSubQuery {
	query := (&ChannelSubClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(channelsub.Table, channelsub.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ChatChannelsTable, user.ChatChannelsColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QuerySentMessages chains the current query on the "sent_messages" edge.
func (uq *UserQuery) QuerySentMessages() *ChannelMessageQuery {
	query := (&ChannelMessageClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(channelmessage.Table, channelmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SentMessagesTable, user.SentMessagesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryReceivedMessages chains the current query on the "received_messages" edge.
func (uq *UserQuery) QueryReceivedMessages() *ChannelMessageQuery {
	query := (&ChannelMessageClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(channelmessage.Table, channelmessage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReceivedMessagesTable, user.ReceivedMessagesColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryChannelMessageRead chains the current query on the "channel_message_read" edge.
func (uq *UserQuery) QueryChannelMessageRead() *ChannelMessageReadQuery {
	query := (&ChannelMessageReadClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(channelmessageread.Table, channelmessageread.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ChannelMessageReadTable, user.ChannelMessageReadColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryProductsCreated chains the current query on the "products_created" edge.
func (uq *UserQuery) QueryProductsCreated() *ProductQuery {
	query := (&ProductClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(product.Table, product.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ProductsCreatedTable, user.ProductsCreatedColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryProductPkgCreated chains the current query on the "product_pkg_created" edge.
func (uq *UserQuery) QueryProductPkgCreated() *ProductPackageQuery {
	query := (&ProductPackageClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(productpackage.Table, productpackage.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ProductPkgCreatedTable, user.ProductPkgCreatedColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryJobDocUrls chains the current query on the "job_doc_urls" edge.
func (uq *UserQuery) QueryJobDocUrls() *JobDocURLQuery {
	query := (&JobDocURLClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(jobdocurl.Table, jobdocurl.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.JobDocUrlsTable, user.JobDocUrlsColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryPartnerContacts chains the current query on the "partner_contacts" edge.
func (uq *UserQuery) QueryPartnerContacts() *PartnerContactQuery {
	query := (&PartnerContactClient{config: uq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := uq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := uq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, selector),
			sqlgraph.To(partnercontact.Table, partnercontact.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.PartnerContactsTable, user.PartnerContactsColumn),
		)
		fromU = sqlgraph.SetNeighbors(uq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first User entity from the query.
// Returns a *NotFoundError when no User was found.
func (uq *UserQuery) First(ctx context.Context) (*User, error) {
	nodes, err := uq.Limit(1).All(setContextOp(ctx, uq.ctx, "First"))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{user.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (uq *UserQuery) FirstX(ctx context.Context) *User {
	node, err := uq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first User ID from the query.
// Returns a *NotFoundError when no User ID was found.
func (uq *UserQuery) FirstID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = uq.Limit(1).IDs(setContextOp(ctx, uq.ctx, "FirstID")); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{user.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (uq *UserQuery) FirstIDX(ctx context.Context) string {
	id, err := uq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single User entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one User entity is found.
// Returns a *NotFoundError when no User entities are found.
func (uq *UserQuery) Only(ctx context.Context) (*User, error) {
	nodes, err := uq.Limit(2).All(setContextOp(ctx, uq.ctx, "Only"))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{user.Label}
	default:
		return nil, &NotSingularError{user.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (uq *UserQuery) OnlyX(ctx context.Context) *User {
	node, err := uq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only User ID in the query.
// Returns a *NotSingularError when more than one User ID is found.
// Returns a *NotFoundError when no entities are found.
func (uq *UserQuery) OnlyID(ctx context.Context) (id string, err error) {
	var ids []string
	if ids, err = uq.Limit(2).IDs(setContextOp(ctx, uq.ctx, "OnlyID")); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{user.Label}
	default:
		err = &NotSingularError{user.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (uq *UserQuery) OnlyIDX(ctx context.Context) string {
	id, err := uq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of Users.
func (uq *UserQuery) All(ctx context.Context) ([]*User, error) {
	ctx = setContextOp(ctx, uq.ctx, "All")
	if err := uq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*User, *UserQuery]()
	return withInterceptors[[]*User](ctx, uq, qr, uq.inters)
}

// AllX is like All, but panics if an error occurs.
func (uq *UserQuery) AllX(ctx context.Context) []*User {
	nodes, err := uq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of User IDs.
func (uq *UserQuery) IDs(ctx context.Context) (ids []string, err error) {
	if uq.ctx.Unique == nil && uq.path != nil {
		uq.Unique(true)
	}
	ctx = setContextOp(ctx, uq.ctx, "IDs")
	if err = uq.Select(user.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (uq *UserQuery) IDsX(ctx context.Context) []string {
	ids, err := uq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (uq *UserQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, uq.ctx, "Count")
	if err := uq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, uq, querierCount[*UserQuery](), uq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (uq *UserQuery) CountX(ctx context.Context) int {
	count, err := uq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (uq *UserQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, uq.ctx, "Exist")
	switch _, err := uq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("ent: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (uq *UserQuery) ExistX(ctx context.Context) bool {
	exist, err := uq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the UserQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (uq *UserQuery) Clone() *UserQuery {
	if uq == nil {
		return nil
	}
	return &UserQuery{
		config:                           uq.config,
		ctx:                              uq.ctx.Clone(),
		order:                            append([]user.OrderOption{}, uq.order...),
		inters:                           append([]Interceptor{}, uq.inters...),
		predicates:                       append([]predicate.User{}, uq.predicates...),
		withAuths:                        uq.withAuths.Clone(),
		withSessions:                     uq.withSessions.Clone(),
		withAuditLogs:                    uq.withAuditLogs.Clone(),
		withNotify:                       uq.withNotify.Clone(),
		withCreatedJobs:                  uq.withCreatedJobs.Clone(),
		withCreatedEstimates:             uq.withCreatedEstimates.Clone(),
		withSalesRepEstimates:            uq.withSalesRepEstimates.Clone(),
		withSales:                        uq.withSales.Clone(),
		withCreatedInstallationJobs:      uq.withCreatedInstallationJobs.Clone(),
		withInstallationLeads:            uq.withInstallationLeads.Clone(),
		withEstimateActivities:           uq.withEstimateActivities.Clone(),
		withJobActivities:                uq.withJobActivities.Clone(),
		withPartnerActivities:            uq.withPartnerActivities.Clone(),
		withUserActivities:               uq.withUserActivities.Clone(),
		withActivities:                   uq.withActivities.Clone(),
		withJobProgressHistory:           uq.withJobProgressHistory.Clone(),
		withInstallationJobStatusChanger: uq.withInstallationJobStatusChanger.Clone(),
		withContactUsRequests:            uq.withContactUsRequests.Clone(),
		withPartner:                      uq.withPartner.Clone(),
		withSurveys:                      uq.withSurveys.Clone(),
		withSurveyProgress:               uq.withSurveyProgress.Clone(),
		withCreatedTrainingVideos:        uq.withCreatedTrainingVideos.Clone(),
		withCreatedTrainingCourses:       uq.withCreatedTrainingCourses.Clone(),
		withJobNotes:                     uq.withJobNotes.Clone(),
		withChatChannels:                 uq.withChatChannels.Clone(),
		withSentMessages:                 uq.withSentMessages.Clone(),
		withReceivedMessages:             uq.withReceivedMessages.Clone(),
		withChannelMessageRead:           uq.withChannelMessageRead.Clone(),
		withProductsCreated:              uq.withProductsCreated.Clone(),
		withProductPkgCreated:            uq.withProductPkgCreated.Clone(),
		withJobDocUrls:                   uq.withJobDocUrls.Clone(),
		withPartnerContacts:              uq.withPartnerContacts.Clone(),
		// clone intermediate query.
		sql:  uq.sql.Clone(),
		path: uq.path,
	}
}

// WithAuths tells the query-builder to eager-load the nodes that are connected to
// the "auths" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithAuths(opts ...func(*UserAuthQuery)) *UserQuery {
	query := (&UserAuthClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withAuths = query
	return uq
}

// WithSessions tells the query-builder to eager-load the nodes that are connected to
// the "sessions" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithSessions(opts ...func(*UserSessionQuery)) *UserQuery {
	query := (&UserSessionClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withSessions = query
	return uq
}

// WithAuditLogs tells the query-builder to eager-load the nodes that are connected to
// the "audit_logs" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithAuditLogs(opts ...func(*AuditLogQuery)) *UserQuery {
	query := (&AuditLogClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withAuditLogs = query
	return uq
}

// WithNotify tells the query-builder to eager-load the nodes that are connected to
// the "notify" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNotify(opts ...func(*NotifySettingQuery)) *UserQuery {
	query := (&NotifySettingClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withNotify = query
	return uq
}

// WithCreatedJobs tells the query-builder to eager-load the nodes that are connected to
// the "created_jobs" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithCreatedJobs(opts ...func(*JobQuery)) *UserQuery {
	query := (&JobClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withCreatedJobs = query
	return uq
}

// WithCreatedEstimates tells the query-builder to eager-load the nodes that are connected to
// the "created_estimates" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithCreatedEstimates(opts ...func(*EstimateQuery)) *UserQuery {
	query := (&EstimateClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withCreatedEstimates = query
	return uq
}

// WithSalesRepEstimates tells the query-builder to eager-load the nodes that are connected to
// the "sales_rep_estimates" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithSalesRepEstimates(opts ...func(*EstimateQuery)) *UserQuery {
	query := (&EstimateClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withSalesRepEstimates = query
	return uq
}

// WithSales tells the query-builder to eager-load the nodes that are connected to
// the "sales" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithSales(opts ...func(*JobQuery)) *UserQuery {
	query := (&JobClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withSales = query
	return uq
}

// WithCreatedInstallationJobs tells the query-builder to eager-load the nodes that are connected to
// the "created_installation_jobs" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithCreatedInstallationJobs(opts ...func(*InstallationJobQuery)) *UserQuery {
	query := (&InstallationJobClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withCreatedInstallationJobs = query
	return uq
}

// WithInstallationLeads tells the query-builder to eager-load the nodes that are connected to
// the "installation_leads" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithInstallationLeads(opts ...func(*InstallationJobQuery)) *UserQuery {
	query := (&InstallationJobClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withInstallationLeads = query
	return uq
}

// WithEstimateActivities tells the query-builder to eager-load the nodes that are connected to
// the "estimate_activities" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithEstimateActivities(opts ...func(*EstimateActivityQuery)) *UserQuery {
	query := (&EstimateActivityClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withEstimateActivities = query
	return uq
}

// WithJobActivities tells the query-builder to eager-load the nodes that are connected to
// the "job_activities" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithJobActivities(opts ...func(*JobActivityQuery)) *UserQuery {
	query := (&JobActivityClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withJobActivities = query
	return uq
}

// WithPartnerActivities tells the query-builder to eager-load the nodes that are connected to
// the "partner_activities" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithPartnerActivities(opts ...func(*PartnerActivityQuery)) *UserQuery {
	query := (&PartnerActivityClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withPartnerActivities = query
	return uq
}

// WithUserActivities tells the query-builder to eager-load the nodes that are connected to
// the "user_activities" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithUserActivities(opts ...func(*UserActivityQuery)) *UserQuery {
	query := (&UserActivityClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withUserActivities = query
	return uq
}

// WithActivities tells the query-builder to eager-load the nodes that are connected to
// the "activities" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithActivities(opts ...func(*UserActivityQuery)) *UserQuery {
	query := (&UserActivityClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withActivities = query
	return uq
}

// WithJobProgressHistory tells the query-builder to eager-load the nodes that are connected to
// the "job_progress_history" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithJobProgressHistory(opts ...func(*JobProgressHistoryQuery)) *UserQuery {
	query := (&JobProgressHistoryClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withJobProgressHistory = query
	return uq
}

// WithInstallationJobStatusChanger tells the query-builder to eager-load the nodes that are connected to
// the "installation_job_status_changer" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithInstallationJobStatusChanger(opts ...func(*InstallationJobProgressQuery)) *UserQuery {
	query := (&InstallationJobProgressClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withInstallationJobStatusChanger = query
	return uq
}

// WithContactUsRequests tells the query-builder to eager-load the nodes that are connected to
// the "contact_us_requests" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithContactUsRequests(opts ...func(*ContactUsQuery)) *UserQuery {
	query := (&ContactUsClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withContactUsRequests = query
	return uq
}

// WithPartner tells the query-builder to eager-load the nodes that are connected to
// the "partner" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithPartner(opts ...func(*PartnerQuery)) *UserQuery {
	query := (&PartnerClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withPartner = query
	return uq
}

// WithSurveys tells the query-builder to eager-load the nodes that are connected to
// the "surveys" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithSurveys(opts ...func(*SurveyQuery)) *UserQuery {
	query := (&SurveyClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withSurveys = query
	return uq
}

// WithSurveyProgress tells the query-builder to eager-load the nodes that are connected to
// the "survey_progress" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithSurveyProgress(opts ...func(*SurveyProgressQuery)) *UserQuery {
	query := (&SurveyProgressClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withSurveyProgress = query
	return uq
}

// WithCreatedTrainingVideos tells the query-builder to eager-load the nodes that are connected to
// the "created_training_videos" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithCreatedTrainingVideos(opts ...func(*TrainingVideoQuery)) *UserQuery {
	query := (&TrainingVideoClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withCreatedTrainingVideos = query
	return uq
}

// WithCreatedTrainingCourses tells the query-builder to eager-load the nodes that are connected to
// the "created_training_courses" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithCreatedTrainingCourses(opts ...func(*TrainingCourseQuery)) *UserQuery {
	query := (&TrainingCourseClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withCreatedTrainingCourses = query
	return uq
}

// WithJobNotes tells the query-builder to eager-load the nodes that are connected to
// the "job_notes" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithJobNotes(opts ...func(*JobNoteQuery)) *UserQuery {
	query := (&JobNoteClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withJobNotes = query
	return uq
}

// WithChatChannels tells the query-builder to eager-load the nodes that are connected to
// the "chat_channels" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithChatChannels(opts ...func(*ChannelSubQuery)) *UserQuery {
	query := (&ChannelSubClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withChatChannels = query
	return uq
}

// WithSentMessages tells the query-builder to eager-load the nodes that are connected to
// the "sent_messages" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithSentMessages(opts ...func(*ChannelMessageQuery)) *UserQuery {
	query := (&ChannelMessageClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withSentMessages = query
	return uq
}

// WithReceivedMessages tells the query-builder to eager-load the nodes that are connected to
// the "received_messages" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithReceivedMessages(opts ...func(*ChannelMessageQuery)) *UserQuery {
	query := (&ChannelMessageClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withReceivedMessages = query
	return uq
}

// WithChannelMessageRead tells the query-builder to eager-load the nodes that are connected to
// the "channel_message_read" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithChannelMessageRead(opts ...func(*ChannelMessageReadQuery)) *UserQuery {
	query := (&ChannelMessageReadClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withChannelMessageRead = query
	return uq
}

// WithProductsCreated tells the query-builder to eager-load the nodes that are connected to
// the "products_created" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithProductsCreated(opts ...func(*ProductQuery)) *UserQuery {
	query := (&ProductClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withProductsCreated = query
	return uq
}

// WithProductPkgCreated tells the query-builder to eager-load the nodes that are connected to
// the "product_pkg_created" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithProductPkgCreated(opts ...func(*ProductPackageQuery)) *UserQuery {
	query := (&ProductPackageClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withProductPkgCreated = query
	return uq
}

// WithJobDocUrls tells the query-builder to eager-load the nodes that are connected to
// the "job_doc_urls" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithJobDocUrls(opts ...func(*JobDocURLQuery)) *UserQuery {
	query := (&JobDocURLClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withJobDocUrls = query
	return uq
}

// WithPartnerContacts tells the query-builder to eager-load the nodes that are connected to
// the "partner_contacts" edge. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithPartnerContacts(opts ...func(*PartnerContactQuery)) *UserQuery {
	query := (&PartnerContactClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withPartnerContacts = query
	return uq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"createdAt"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.User.Query().
//		GroupBy(user.FieldCreatedAt).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
func (uq *UserQuery) GroupBy(field string, fields ...string) *UserGroupBy {
	uq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &UserGroupBy{build: uq}
	grbuild.flds = &uq.ctx.Fields
	grbuild.label = user.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		CreatedAt time.Time `json:"createdAt"`
//	}
//
//	client.User.Query().
//		Select(user.FieldCreatedAt).
//		Scan(ctx, &v)
func (uq *UserQuery) Select(fields ...string) *UserSelect {
	uq.ctx.Fields = append(uq.ctx.Fields, fields...)
	sbuild := &UserSelect{UserQuery: uq}
	sbuild.label = user.Label
	sbuild.flds, sbuild.scan = &uq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a UserSelect configured with the given aggregations.
func (uq *UserQuery) Aggregate(fns ...AggregateFunc) *UserSelect {
	return uq.Select().Aggregate(fns...)
}

func (uq *UserQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range uq.inters {
		if inter == nil {
			return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, uq); err != nil {
				return err
			}
		}
	}
	for _, f := range uq.ctx.Fields {
		if !user.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if uq.path != nil {
		prev, err := uq.path(ctx)
		if err != nil {
			return err
		}
		uq.sql = prev
	}
	return nil
}

func (uq *UserQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*User, error) {
	var (
		nodes       = []*User{}
		_spec       = uq.querySpec()
		loadedTypes = [32]bool{
			uq.withAuths != nil,
			uq.withSessions != nil,
			uq.withAuditLogs != nil,
			uq.withNotify != nil,
			uq.withCreatedJobs != nil,
			uq.withCreatedEstimates != nil,
			uq.withSalesRepEstimates != nil,
			uq.withSales != nil,
			uq.withCreatedInstallationJobs != nil,
			uq.withInstallationLeads != nil,
			uq.withEstimateActivities != nil,
			uq.withJobActivities != nil,
			uq.withPartnerActivities != nil,
			uq.withUserActivities != nil,
			uq.withActivities != nil,
			uq.withJobProgressHistory != nil,
			uq.withInstallationJobStatusChanger != nil,
			uq.withContactUsRequests != nil,
			uq.withPartner != nil,
			uq.withSurveys != nil,
			uq.withSurveyProgress != nil,
			uq.withCreatedTrainingVideos != nil,
			uq.withCreatedTrainingCourses != nil,
			uq.withJobNotes != nil,
			uq.withChatChannels != nil,
			uq.withSentMessages != nil,
			uq.withReceivedMessages != nil,
			uq.withChannelMessageRead != nil,
			uq.withProductsCreated != nil,
			uq.withProductPkgCreated != nil,
			uq.withJobDocUrls != nil,
			uq.withPartnerContacts != nil,
		}
	)
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*User).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &User{config: uq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	if len(uq.modifiers) > 0 {
		_spec.Modifiers = uq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, uq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := uq.withAuths; query != nil {
		if err := uq.loadAuths(ctx, query, nodes, nil,
			func(n *User, e *UserAuth) { n.Edges.Auths = e }); err != nil {
			return nil, err
		}
	}
	if query := uq.withSessions; query != nil {
		if err := uq.loadSessions(ctx, query, nodes,
			func(n *User) { n.Edges.Sessions = []*UserSession{} },
			func(n *User, e *UserSession) { n.Edges.Sessions = append(n.Edges.Sessions, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withAuditLogs; query != nil {
		if err := uq.loadAuditLogs(ctx, query, nodes,
			func(n *User) { n.Edges.AuditLogs = []*AuditLog{} },
			func(n *User, e *AuditLog) { n.Edges.AuditLogs = append(n.Edges.AuditLogs, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withNotify; query != nil {
		if err := uq.loadNotify(ctx, query, nodes,
			func(n *User) { n.Edges.Notify = []*NotifySetting{} },
			func(n *User, e *NotifySetting) { n.Edges.Notify = append(n.Edges.Notify, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withCreatedJobs; query != nil {
		if err := uq.loadCreatedJobs(ctx, query, nodes,
			func(n *User) { n.Edges.CreatedJobs = []*Job{} },
			func(n *User, e *Job) { n.Edges.CreatedJobs = append(n.Edges.CreatedJobs, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withCreatedEstimates; query != nil {
		if err := uq.loadCreatedEstimates(ctx, query, nodes,
			func(n *User) { n.Edges.CreatedEstimates = []*Estimate{} },
			func(n *User, e *Estimate) { n.Edges.CreatedEstimates = append(n.Edges.CreatedEstimates, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withSalesRepEstimates; query != nil {
		if err := uq.loadSalesRepEstimates(ctx, query, nodes,
			func(n *User) { n.Edges.SalesRepEstimates = []*Estimate{} },
			func(n *User, e *Estimate) { n.Edges.SalesRepEstimates = append(n.Edges.SalesRepEstimates, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withSales; query != nil {
		if err := uq.loadSales(ctx, query, nodes,
			func(n *User) { n.Edges.Sales = []*Job{} },
			func(n *User, e *Job) { n.Edges.Sales = append(n.Edges.Sales, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withCreatedInstallationJobs; query != nil {
		if err := uq.loadCreatedInstallationJobs(ctx, query, nodes,
			func(n *User) { n.Edges.CreatedInstallationJobs = []*InstallationJob{} },
			func(n *User, e *InstallationJob) {
				n.Edges.CreatedInstallationJobs = append(n.Edges.CreatedInstallationJobs, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := uq.withInstallationLeads; query != nil {
		if err := uq.loadInstallationLeads(ctx, query, nodes,
			func(n *User) { n.Edges.InstallationLeads = []*InstallationJob{} },
			func(n *User, e *InstallationJob) { n.Edges.InstallationLeads = append(n.Edges.InstallationLeads, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withEstimateActivities; query != nil {
		if err := uq.loadEstimateActivities(ctx, query, nodes,
			func(n *User) { n.Edges.EstimateActivities = []*EstimateActivity{} },
			func(n *User, e *EstimateActivity) { n.Edges.EstimateActivities = append(n.Edges.EstimateActivities, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withJobActivities; query != nil {
		if err := uq.loadJobActivities(ctx, query, nodes,
			func(n *User) { n.Edges.JobActivities = []*JobActivity{} },
			func(n *User, e *JobActivity) { n.Edges.JobActivities = append(n.Edges.JobActivities, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withPartnerActivities; query != nil {
		if err := uq.loadPartnerActivities(ctx, query, nodes,
			func(n *User) { n.Edges.PartnerActivities = []*PartnerActivity{} },
			func(n *User, e *PartnerActivity) { n.Edges.PartnerActivities = append(n.Edges.PartnerActivities, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withUserActivities; query != nil {
		if err := uq.loadUserActivities(ctx, query, nodes,
			func(n *User) { n.Edges.UserActivities = []*UserActivity{} },
			func(n *User, e *UserActivity) { n.Edges.UserActivities = append(n.Edges.UserActivities, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withActivities; query != nil {
		if err := uq.loadActivities(ctx, query, nodes,
			func(n *User) { n.Edges.Activities = []*UserActivity{} },
			func(n *User, e *UserActivity) { n.Edges.Activities = append(n.Edges.Activities, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withJobProgressHistory; query != nil {
		if err := uq.loadJobProgressHistory(ctx, query, nodes,
			func(n *User) { n.Edges.JobProgressHistory = []*JobProgressHistory{} },
			func(n *User, e *JobProgressHistory) {
				n.Edges.JobProgressHistory = append(n.Edges.JobProgressHistory, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := uq.withInstallationJobStatusChanger; query != nil {
		if err := uq.loadInstallationJobStatusChanger(ctx, query, nodes,
			func(n *User) { n.Edges.InstallationJobStatusChanger = []*InstallationJobProgress{} },
			func(n *User, e *InstallationJobProgress) {
				n.Edges.InstallationJobStatusChanger = append(n.Edges.InstallationJobStatusChanger, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := uq.withContactUsRequests; query != nil {
		if err := uq.loadContactUsRequests(ctx, query, nodes,
			func(n *User) { n.Edges.ContactUsRequests = []*ContactUs{} },
			func(n *User, e *ContactUs) { n.Edges.ContactUsRequests = append(n.Edges.ContactUsRequests, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withPartner; query != nil {
		if err := uq.loadPartner(ctx, query, nodes,
			func(n *User) { n.Edges.Partner = []*Partner{} },
			func(n *User, e *Partner) { n.Edges.Partner = append(n.Edges.Partner, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withSurveys; query != nil {
		if err := uq.loadSurveys(ctx, query, nodes,
			func(n *User) { n.Edges.Surveys = []*Survey{} },
			func(n *User, e *Survey) { n.Edges.Surveys = append(n.Edges.Surveys, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withSurveyProgress; query != nil {
		if err := uq.loadSurveyProgress(ctx, query, nodes,
			func(n *User) { n.Edges.SurveyProgress = []*SurveyProgress{} },
			func(n *User, e *SurveyProgress) { n.Edges.SurveyProgress = append(n.Edges.SurveyProgress, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withCreatedTrainingVideos; query != nil {
		if err := uq.loadCreatedTrainingVideos(ctx, query, nodes,
			func(n *User) { n.Edges.CreatedTrainingVideos = []*TrainingVideo{} },
			func(n *User, e *TrainingVideo) {
				n.Edges.CreatedTrainingVideos = append(n.Edges.CreatedTrainingVideos, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := uq.withCreatedTrainingCourses; query != nil {
		if err := uq.loadCreatedTrainingCourses(ctx, query, nodes,
			func(n *User) { n.Edges.CreatedTrainingCourses = []*TrainingCourse{} },
			func(n *User, e *TrainingCourse) {
				n.Edges.CreatedTrainingCourses = append(n.Edges.CreatedTrainingCourses, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := uq.withJobNotes; query != nil {
		if err := uq.loadJobNotes(ctx, query, nodes,
			func(n *User) { n.Edges.JobNotes = []*JobNote{} },
			func(n *User, e *JobNote) { n.Edges.JobNotes = append(n.Edges.JobNotes, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withChatChannels; query != nil {
		if err := uq.loadChatChannels(ctx, query, nodes,
			func(n *User) { n.Edges.ChatChannels = []*ChannelSub{} },
			func(n *User, e *ChannelSub) { n.Edges.ChatChannels = append(n.Edges.ChatChannels, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withSentMessages; query != nil {
		if err := uq.loadSentMessages(ctx, query, nodes,
			func(n *User) { n.Edges.SentMessages = []*ChannelMessage{} },
			func(n *User, e *ChannelMessage) { n.Edges.SentMessages = append(n.Edges.SentMessages, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withReceivedMessages; query != nil {
		if err := uq.loadReceivedMessages(ctx, query, nodes,
			func(n *User) { n.Edges.ReceivedMessages = []*ChannelMessage{} },
			func(n *User, e *ChannelMessage) { n.Edges.ReceivedMessages = append(n.Edges.ReceivedMessages, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withChannelMessageRead; query != nil {
		if err := uq.loadChannelMessageRead(ctx, query, nodes,
			func(n *User) { n.Edges.ChannelMessageRead = []*ChannelMessageRead{} },
			func(n *User, e *ChannelMessageRead) {
				n.Edges.ChannelMessageRead = append(n.Edges.ChannelMessageRead, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := uq.withProductsCreated; query != nil {
		if err := uq.loadProductsCreated(ctx, query, nodes,
			func(n *User) { n.Edges.ProductsCreated = []*Product{} },
			func(n *User, e *Product) { n.Edges.ProductsCreated = append(n.Edges.ProductsCreated, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withProductPkgCreated; query != nil {
		if err := uq.loadProductPkgCreated(ctx, query, nodes,
			func(n *User) { n.Edges.ProductPkgCreated = []*ProductPackage{} },
			func(n *User, e *ProductPackage) { n.Edges.ProductPkgCreated = append(n.Edges.ProductPkgCreated, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withJobDocUrls; query != nil {
		if err := uq.loadJobDocUrls(ctx, query, nodes,
			func(n *User) { n.Edges.JobDocUrls = []*JobDocURL{} },
			func(n *User, e *JobDocURL) { n.Edges.JobDocUrls = append(n.Edges.JobDocUrls, e) }); err != nil {
			return nil, err
		}
	}
	if query := uq.withPartnerContacts; query != nil {
		if err := uq.loadPartnerContacts(ctx, query, nodes,
			func(n *User) { n.Edges.PartnerContacts = []*PartnerContact{} },
			func(n *User, e *PartnerContact) { n.Edges.PartnerContacts = append(n.Edges.PartnerContacts, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedSessions {
		if err := uq.loadSessions(ctx, query, nodes,
			func(n *User) { n.appendNamedSessions(name) },
			func(n *User, e *UserSession) { n.appendNamedSessions(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedAuditLogs {
		if err := uq.loadAuditLogs(ctx, query, nodes,
			func(n *User) { n.appendNamedAuditLogs(name) },
			func(n *User, e *AuditLog) { n.appendNamedAuditLogs(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedNotify {
		if err := uq.loadNotify(ctx, query, nodes,
			func(n *User) { n.appendNamedNotify(name) },
			func(n *User, e *NotifySetting) { n.appendNamedNotify(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedCreatedJobs {
		if err := uq.loadCreatedJobs(ctx, query, nodes,
			func(n *User) { n.appendNamedCreatedJobs(name) },
			func(n *User, e *Job) { n.appendNamedCreatedJobs(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedCreatedEstimates {
		if err := uq.loadCreatedEstimates(ctx, query, nodes,
			func(n *User) { n.appendNamedCreatedEstimates(name) },
			func(n *User, e *Estimate) { n.appendNamedCreatedEstimates(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedSalesRepEstimates {
		if err := uq.loadSalesRepEstimates(ctx, query, nodes,
			func(n *User) { n.appendNamedSalesRepEstimates(name) },
			func(n *User, e *Estimate) { n.appendNamedSalesRepEstimates(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedSales {
		if err := uq.loadSales(ctx, query, nodes,
			func(n *User) { n.appendNamedSales(name) },
			func(n *User, e *Job) { n.appendNamedSales(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedCreatedInstallationJobs {
		if err := uq.loadCreatedInstallationJobs(ctx, query, nodes,
			func(n *User) { n.appendNamedCreatedInstallationJobs(name) },
			func(n *User, e *InstallationJob) { n.appendNamedCreatedInstallationJobs(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedInstallationLeads {
		if err := uq.loadInstallationLeads(ctx, query, nodes,
			func(n *User) { n.appendNamedInstallationLeads(name) },
			func(n *User, e *InstallationJob) { n.appendNamedInstallationLeads(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedEstimateActivities {
		if err := uq.loadEstimateActivities(ctx, query, nodes,
			func(n *User) { n.appendNamedEstimateActivities(name) },
			func(n *User, e *EstimateActivity) { n.appendNamedEstimateActivities(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedJobActivities {
		if err := uq.loadJobActivities(ctx, query, nodes,
			func(n *User) { n.appendNamedJobActivities(name) },
			func(n *User, e *JobActivity) { n.appendNamedJobActivities(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedPartnerActivities {
		if err := uq.loadPartnerActivities(ctx, query, nodes,
			func(n *User) { n.appendNamedPartnerActivities(name) },
			func(n *User, e *PartnerActivity) { n.appendNamedPartnerActivities(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedUserActivities {
		if err := uq.loadUserActivities(ctx, query, nodes,
			func(n *User) { n.appendNamedUserActivities(name) },
			func(n *User, e *UserActivity) { n.appendNamedUserActivities(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedActivities {
		if err := uq.loadActivities(ctx, query, nodes,
			func(n *User) { n.appendNamedActivities(name) },
			func(n *User, e *UserActivity) { n.appendNamedActivities(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedJobProgressHistory {
		if err := uq.loadJobProgressHistory(ctx, query, nodes,
			func(n *User) { n.appendNamedJobProgressHistory(name) },
			func(n *User, e *JobProgressHistory) { n.appendNamedJobProgressHistory(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedInstallationJobStatusChanger {
		if err := uq.loadInstallationJobStatusChanger(ctx, query, nodes,
			func(n *User) { n.appendNamedInstallationJobStatusChanger(name) },
			func(n *User, e *InstallationJobProgress) { n.appendNamedInstallationJobStatusChanger(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedContactUsRequests {
		if err := uq.loadContactUsRequests(ctx, query, nodes,
			func(n *User) { n.appendNamedContactUsRequests(name) },
			func(n *User, e *ContactUs) { n.appendNamedContactUsRequests(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedPartner {
		if err := uq.loadPartner(ctx, query, nodes,
			func(n *User) { n.appendNamedPartner(name) },
			func(n *User, e *Partner) { n.appendNamedPartner(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedSurveys {
		if err := uq.loadSurveys(ctx, query, nodes,
			func(n *User) { n.appendNamedSurveys(name) },
			func(n *User, e *Survey) { n.appendNamedSurveys(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedSurveyProgress {
		if err := uq.loadSurveyProgress(ctx, query, nodes,
			func(n *User) { n.appendNamedSurveyProgress(name) },
			func(n *User, e *SurveyProgress) { n.appendNamedSurveyProgress(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedCreatedTrainingVideos {
		if err := uq.loadCreatedTrainingVideos(ctx, query, nodes,
			func(n *User) { n.appendNamedCreatedTrainingVideos(name) },
			func(n *User, e *TrainingVideo) { n.appendNamedCreatedTrainingVideos(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedCreatedTrainingCourses {
		if err := uq.loadCreatedTrainingCourses(ctx, query, nodes,
			func(n *User) { n.appendNamedCreatedTrainingCourses(name) },
			func(n *User, e *TrainingCourse) { n.appendNamedCreatedTrainingCourses(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedJobNotes {
		if err := uq.loadJobNotes(ctx, query, nodes,
			func(n *User) { n.appendNamedJobNotes(name) },
			func(n *User, e *JobNote) { n.appendNamedJobNotes(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedChatChannels {
		if err := uq.loadChatChannels(ctx, query, nodes,
			func(n *User) { n.appendNamedChatChannels(name) },
			func(n *User, e *ChannelSub) { n.appendNamedChatChannels(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedSentMessages {
		if err := uq.loadSentMessages(ctx, query, nodes,
			func(n *User) { n.appendNamedSentMessages(name) },
			func(n *User, e *ChannelMessage) { n.appendNamedSentMessages(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedReceivedMessages {
		if err := uq.loadReceivedMessages(ctx, query, nodes,
			func(n *User) { n.appendNamedReceivedMessages(name) },
			func(n *User, e *ChannelMessage) { n.appendNamedReceivedMessages(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedChannelMessageRead {
		if err := uq.loadChannelMessageRead(ctx, query, nodes,
			func(n *User) { n.appendNamedChannelMessageRead(name) },
			func(n *User, e *ChannelMessageRead) { n.appendNamedChannelMessageRead(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedProductsCreated {
		if err := uq.loadProductsCreated(ctx, query, nodes,
			func(n *User) { n.appendNamedProductsCreated(name) },
			func(n *User, e *Product) { n.appendNamedProductsCreated(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedProductPkgCreated {
		if err := uq.loadProductPkgCreated(ctx, query, nodes,
			func(n *User) { n.appendNamedProductPkgCreated(name) },
			func(n *User, e *ProductPackage) { n.appendNamedProductPkgCreated(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedJobDocUrls {
		if err := uq.loadJobDocUrls(ctx, query, nodes,
			func(n *User) { n.appendNamedJobDocUrls(name) },
			func(n *User, e *JobDocURL) { n.appendNamedJobDocUrls(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range uq.withNamedPartnerContacts {
		if err := uq.loadPartnerContacts(ctx, query, nodes,
			func(n *User) { n.appendNamedPartnerContacts(name) },
			func(n *User, e *PartnerContact) { n.appendNamedPartnerContacts(name, e) }); err != nil {
			return nil, err
		}
	}
	for i := range uq.loadTotal {
		if err := uq.loadTotal[i](ctx, nodes); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (uq *UserQuery) loadAuths(ctx context.Context, query *UserAuthQuery, nodes []*User, init func(*User), assign func(*User, *UserAuth)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.UserAuth(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.AuthsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadSessions(ctx context.Context, query *UserSessionQuery, nodes []*User, init func(*User), assign func(*User, *UserSession)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.UserSession(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.SessionsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadAuditLogs(ctx context.Context, query *AuditLogQuery, nodes []*User, init func(*User), assign func(*User, *AuditLog)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.AuditLog(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.AuditLogsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadNotify(ctx context.Context, query *NotifySettingQuery, nodes []*User, init func(*User), assign func(*User, *NotifySetting)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.NotifySetting(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.NotifyColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadCreatedJobs(ctx context.Context, query *JobQuery, nodes []*User, init func(*User), assign func(*User, *Job)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Job(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.CreatedJobsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadCreatedEstimates(ctx context.Context, query *EstimateQuery, nodes []*User, init func(*User), assign func(*User, *Estimate)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Estimate(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.CreatedEstimatesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadSalesRepEstimates(ctx context.Context, query *EstimateQuery, nodes []*User, init func(*User), assign func(*User, *Estimate)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Estimate(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.SalesRepEstimatesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.sales_rep_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "sales_rep_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "sales_rep_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadSales(ctx context.Context, query *JobQuery, nodes []*User, init func(*User), assign func(*User, *Job)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Job(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.SalesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.sales_rep_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "sales_rep_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "sales_rep_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadCreatedInstallationJobs(ctx context.Context, query *InstallationJobQuery, nodes []*User, init func(*User), assign func(*User, *InstallationJob)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.InstallationJob(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.CreatedInstallationJobsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadInstallationLeads(ctx context.Context, query *InstallationJobQuery, nodes []*User, init func(*User), assign func(*User, *InstallationJob)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.InstallationJob(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.InstallationLeadsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.sales_rep_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "sales_rep_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "sales_rep_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadEstimateActivities(ctx context.Context, query *EstimateActivityQuery, nodes []*User, init func(*User), assign func(*User, *EstimateActivity)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.EstimateActivity(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.EstimateActivitiesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadJobActivities(ctx context.Context, query *JobActivityQuery, nodes []*User, init func(*User), assign func(*User, *JobActivity)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.JobActivity(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.JobActivitiesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadPartnerActivities(ctx context.Context, query *PartnerActivityQuery, nodes []*User, init func(*User), assign func(*User, *PartnerActivity)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.PartnerActivity(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.PartnerActivitiesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadUserActivities(ctx context.Context, query *UserActivityQuery, nodes []*User, init func(*User), assign func(*User, *UserActivity)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.UserActivity(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.UserActivitiesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadActivities(ctx context.Context, query *UserActivityQuery, nodes []*User, init func(*User), assign func(*User, *UserActivity)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.UserActivity(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.ActivitiesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadJobProgressHistory(ctx context.Context, query *JobProgressHistoryQuery, nodes []*User, init func(*User), assign func(*User, *JobProgressHistory)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.JobProgressHistory(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.JobProgressHistoryColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadInstallationJobStatusChanger(ctx context.Context, query *InstallationJobProgressQuery, nodes []*User, init func(*User), assign func(*User, *InstallationJobProgress)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.InstallationJobProgress(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.InstallationJobStatusChangerColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadContactUsRequests(ctx context.Context, query *ContactUsQuery, nodes []*User, init func(*User), assign func(*User, *ContactUs)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.ContactUs(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.ContactUsRequestsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadPartner(ctx context.Context, query *PartnerQuery, nodes []*User, init func(*User), assign func(*User, *Partner)) error {
	edgeIDs := make([]driver.Value, len(nodes))
	byID := make(map[string]*User)
	nids := make(map[string]map[*User]struct{})
	for i, node := range nodes {
		edgeIDs[i] = node.ID
		byID[node.ID] = node
		if init != nil {
			init(node)
		}
	}
	query.Where(func(s *sql.Selector) {
		joinT := sql.Table(user.PartnerTable)
		s.Join(joinT).On(s.C(partner.FieldID), joinT.C(user.PartnerPrimaryKey[0]))
		s.Where(sql.InValues(joinT.C(user.PartnerPrimaryKey[1]), edgeIDs...))
		columns := s.SelectedColumns()
		s.Select(joinT.C(user.PartnerPrimaryKey[1]))
		s.AppendSelect(columns...)
		s.SetDistinct(false)
	})
	if err := query.prepareQuery(ctx); err != nil {
		return err
	}
	qr := QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		return query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) {
			assign := spec.Assign
			values := spec.ScanValues
			spec.ScanValues = func(columns []string) ([]any, error) {
				values, err := values(columns[1:])
				if err != nil {
					return nil, err
				}
				return append([]any{new(sql.NullString)}, values...), nil
			}
			spec.Assign = func(columns []string, values []any) error {
				outValue := values[0].(*sql.NullString).String
				inValue := values[1].(*sql.NullString).String
				if nids[inValue] == nil {
					nids[inValue] = map[*User]struct{}{byID[outValue]: {}}
					return assign(columns[1:], values[1:])
				}
				nids[inValue][byID[outValue]] = struct{}{}
				return nil
			}
		})
	})
	neighbors, err := withInterceptors[[]*Partner](ctx, query, qr, query.inters)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected "partner" node returned %v`, n.ID)
		}
		for kn := range nodes {
			assign(kn, n)
		}
	}
	return nil
}
func (uq *UserQuery) loadSurveys(ctx context.Context, query *SurveyQuery, nodes []*User, init func(*User), assign func(*User, *Survey)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Survey(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.SurveysColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadSurveyProgress(ctx context.Context, query *SurveyProgressQuery, nodes []*User, init func(*User), assign func(*User, *SurveyProgress)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.SurveyProgress(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.SurveyProgressColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadCreatedTrainingVideos(ctx context.Context, query *TrainingVideoQuery, nodes []*User, init func(*User), assign func(*User, *TrainingVideo)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.TrainingVideo(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.CreatedTrainingVideosColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadCreatedTrainingCourses(ctx context.Context, query *TrainingCourseQuery, nodes []*User, init func(*User), assign func(*User, *TrainingCourse)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.TrainingCourse(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.CreatedTrainingCoursesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadJobNotes(ctx context.Context, query *JobNoteQuery, nodes []*User, init func(*User), assign func(*User, *JobNote)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.JobNote(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.JobNotesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadChatChannels(ctx context.Context, query *ChannelSubQuery, nodes []*User, init func(*User), assign func(*User, *ChannelSub)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.ChannelSub(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.ChatChannelsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadSentMessages(ctx context.Context, query *ChannelMessageQuery, nodes []*User, init func(*User), assign func(*User, *ChannelMessage)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.ChannelMessage(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.SentMessagesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.from_user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "from_user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "from_user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadReceivedMessages(ctx context.Context, query *ChannelMessageQuery, nodes []*User, init func(*User), assign func(*User, *ChannelMessage)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.ChannelMessage(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.ReceivedMessagesColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.to_user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "to_user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "to_user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadChannelMessageRead(ctx context.Context, query *ChannelMessageReadQuery, nodes []*User, init func(*User), assign func(*User, *ChannelMessageRead)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.ChannelMessageRead(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.ChannelMessageReadColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.user_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "user_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadProductsCreated(ctx context.Context, query *ProductQuery, nodes []*User, init func(*User), assign func(*User, *Product)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Product(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.ProductsCreatedColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadProductPkgCreated(ctx context.Context, query *ProductPackageQuery, nodes []*User, init func(*User), assign func(*User, *ProductPackage)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.ProductPackage(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.ProductPkgCreatedColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadJobDocUrls(ctx context.Context, query *JobDocURLQuery, nodes []*User, init func(*User), assign func(*User, *JobDocURL)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.JobDocURL(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.JobDocUrlsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.creator_id
		if fk == nil {
			return fmt.Errorf(`foreign-key "creator_id" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "creator_id" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (uq *UserQuery) loadPartnerContacts(ctx context.Context, query *PartnerContactQuery, nodes []*User, init func(*User), assign func(*User, *PartnerContact)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*User)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(partnercontact.FieldUserID)
	}
	query.Where(predicate.PartnerContact(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(user.PartnerContactsColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.UserID
		node, ok := nodeids[fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "user_id" returned %v for node %v`, fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}

func (uq *UserQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := uq.querySpec()
	if len(uq.modifiers) > 0 {
		_spec.Modifiers = uq.modifiers
	}
	_spec.Node.Columns = uq.ctx.Fields
	if len(uq.ctx.Fields) > 0 {
		_spec.Unique = uq.ctx.Unique != nil && *uq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, uq.driver, _spec)
}

func (uq *UserQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(user.Table, user.Columns, sqlgraph.NewFieldSpec(user.FieldID, field.TypeString))
	_spec.From = uq.sql
	if unique := uq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if uq.path != nil {
		_spec.Unique = true
	}
	if fields := uq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, user.FieldID)
		for i := range fields {
			if fields[i] != user.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
	}
	if ps := uq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := uq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := uq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := uq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (uq *UserQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(uq.driver.Dialect())
	t1 := builder.Table(user.Table)
	columns := uq.ctx.Fields
	if len(columns) == 0 {
		columns = user.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if uq.sql != nil {
		selector = uq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if uq.ctx.Unique != nil && *uq.ctx.Unique {
		selector.Distinct()
	}
	for _, m := range uq.modifiers {
		m(selector)
	}
	for _, p := range uq.predicates {
		p(selector)
	}
	for _, p := range uq.order {
		p(selector)
	}
	if offset := uq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := uq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// Modify adds a query modifier for attaching custom logic to queries.
func (uq *UserQuery) Modify(modifiers ...func(s *sql.Selector)) *UserSelect {
	uq.modifiers = append(uq.modifiers, modifiers...)
	return uq.Select()
}

// WithNamedSessions tells the query-builder to eager-load the nodes that are connected to the "sessions"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedSessions(name string, opts ...func(*UserSessionQuery)) *UserQuery {
	query := (&UserSessionClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedSessions == nil {
		uq.withNamedSessions = make(map[string]*UserSessionQuery)
	}
	uq.withNamedSessions[name] = query
	return uq
}

// WithNamedAuditLogs tells the query-builder to eager-load the nodes that are connected to the "audit_logs"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedAuditLogs(name string, opts ...func(*AuditLogQuery)) *UserQuery {
	query := (&AuditLogClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedAuditLogs == nil {
		uq.withNamedAuditLogs = make(map[string]*AuditLogQuery)
	}
	uq.withNamedAuditLogs[name] = query
	return uq
}

// WithNamedNotify tells the query-builder to eager-load the nodes that are connected to the "notify"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedNotify(name string, opts ...func(*NotifySettingQuery)) *UserQuery {
	query := (&NotifySettingClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedNotify == nil {
		uq.withNamedNotify = make(map[string]*NotifySettingQuery)
	}
	uq.withNamedNotify[name] = query
	return uq
}

// WithNamedCreatedJobs tells the query-builder to eager-load the nodes that are connected to the "created_jobs"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedCreatedJobs(name string, opts ...func(*JobQuery)) *UserQuery {
	query := (&JobClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedCreatedJobs == nil {
		uq.withNamedCreatedJobs = make(map[string]*JobQuery)
	}
	uq.withNamedCreatedJobs[name] = query
	return uq
}

// WithNamedCreatedEstimates tells the query-builder to eager-load the nodes that are connected to the "created_estimates"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedCreatedEstimates(name string, opts ...func(*EstimateQuery)) *UserQuery {
	query := (&EstimateClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedCreatedEstimates == nil {
		uq.withNamedCreatedEstimates = make(map[string]*EstimateQuery)
	}
	uq.withNamedCreatedEstimates[name] = query
	return uq
}

// WithNamedSalesRepEstimates tells the query-builder to eager-load the nodes that are connected to the "sales_rep_estimates"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedSalesRepEstimates(name string, opts ...func(*EstimateQuery)) *UserQuery {
	query := (&EstimateClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedSalesRepEstimates == nil {
		uq.withNamedSalesRepEstimates = make(map[string]*EstimateQuery)
	}
	uq.withNamedSalesRepEstimates[name] = query
	return uq
}

// WithNamedSales tells the query-builder to eager-load the nodes that are connected to the "sales"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedSales(name string, opts ...func(*JobQuery)) *UserQuery {
	query := (&JobClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedSales == nil {
		uq.withNamedSales = make(map[string]*JobQuery)
	}
	uq.withNamedSales[name] = query
	return uq
}

// WithNamedCreatedInstallationJobs tells the query-builder to eager-load the nodes that are connected to the "created_installation_jobs"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedCreatedInstallationJobs(name string, opts ...func(*InstallationJobQuery)) *UserQuery {
	query := (&InstallationJobClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedCreatedInstallationJobs == nil {
		uq.withNamedCreatedInstallationJobs = make(map[string]*InstallationJobQuery)
	}
	uq.withNamedCreatedInstallationJobs[name] = query
	return uq
}

// WithNamedInstallationLeads tells the query-builder to eager-load the nodes that are connected to the "installation_leads"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedInstallationLeads(name string, opts ...func(*InstallationJobQuery)) *UserQuery {
	query := (&InstallationJobClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedInstallationLeads == nil {
		uq.withNamedInstallationLeads = make(map[string]*InstallationJobQuery)
	}
	uq.withNamedInstallationLeads[name] = query
	return uq
}

// WithNamedEstimateActivities tells the query-builder to eager-load the nodes that are connected to the "estimate_activities"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedEstimateActivities(name string, opts ...func(*EstimateActivityQuery)) *UserQuery {
	query := (&EstimateActivityClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedEstimateActivities == nil {
		uq.withNamedEstimateActivities = make(map[string]*EstimateActivityQuery)
	}
	uq.withNamedEstimateActivities[name] = query
	return uq
}

// WithNamedJobActivities tells the query-builder to eager-load the nodes that are connected to the "job_activities"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedJobActivities(name string, opts ...func(*JobActivityQuery)) *UserQuery {
	query := (&JobActivityClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedJobActivities == nil {
		uq.withNamedJobActivities = make(map[string]*JobActivityQuery)
	}
	uq.withNamedJobActivities[name] = query
	return uq
}

// WithNamedPartnerActivities tells the query-builder to eager-load the nodes that are connected to the "partner_activities"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedPartnerActivities(name string, opts ...func(*PartnerActivityQuery)) *UserQuery {
	query := (&PartnerActivityClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedPartnerActivities == nil {
		uq.withNamedPartnerActivities = make(map[string]*PartnerActivityQuery)
	}
	uq.withNamedPartnerActivities[name] = query
	return uq
}

// WithNamedUserActivities tells the query-builder to eager-load the nodes that are connected to the "user_activities"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedUserActivities(name string, opts ...func(*UserActivityQuery)) *UserQuery {
	query := (&UserActivityClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedUserActivities == nil {
		uq.withNamedUserActivities = make(map[string]*UserActivityQuery)
	}
	uq.withNamedUserActivities[name] = query
	return uq
}

// WithNamedActivities tells the query-builder to eager-load the nodes that are connected to the "activities"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedActivities(name string, opts ...func(*UserActivityQuery)) *UserQuery {
	query := (&UserActivityClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedActivities == nil {
		uq.withNamedActivities = make(map[string]*UserActivityQuery)
	}
	uq.withNamedActivities[name] = query
	return uq
}

// WithNamedJobProgressHistory tells the query-builder to eager-load the nodes that are connected to the "job_progress_history"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedJobProgressHistory(name string, opts ...func(*JobProgressHistoryQuery)) *UserQuery {
	query := (&JobProgressHistoryClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedJobProgressHistory == nil {
		uq.withNamedJobProgressHistory = make(map[string]*JobProgressHistoryQuery)
	}
	uq.withNamedJobProgressHistory[name] = query
	return uq
}

// WithNamedInstallationJobStatusChanger tells the query-builder to eager-load the nodes that are connected to the "installation_job_status_changer"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedInstallationJobStatusChanger(name string, opts ...func(*InstallationJobProgressQuery)) *UserQuery {
	query := (&InstallationJobProgressClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedInstallationJobStatusChanger == nil {
		uq.withNamedInstallationJobStatusChanger = make(map[string]*InstallationJobProgressQuery)
	}
	uq.withNamedInstallationJobStatusChanger[name] = query
	return uq
}

// WithNamedContactUsRequests tells the query-builder to eager-load the nodes that are connected to the "contact_us_requests"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedContactUsRequests(name string, opts ...func(*ContactUsQuery)) *UserQuery {
	query := (&ContactUsClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedContactUsRequests == nil {
		uq.withNamedContactUsRequests = make(map[string]*ContactUsQuery)
	}
	uq.withNamedContactUsRequests[name] = query
	return uq
}

// WithNamedPartner tells the query-builder to eager-load the nodes that are connected to the "partner"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedPartner(name string, opts ...func(*PartnerQuery)) *UserQuery {
	query := (&PartnerClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedPartner == nil {
		uq.withNamedPartner = make(map[string]*PartnerQuery)
	}
	uq.withNamedPartner[name] = query
	return uq
}

// WithNamedSurveys tells the query-builder to eager-load the nodes that are connected to the "surveys"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedSurveys(name string, opts ...func(*SurveyQuery)) *UserQuery {
	query := (&SurveyClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedSurveys == nil {
		uq.withNamedSurveys = make(map[string]*SurveyQuery)
	}
	uq.withNamedSurveys[name] = query
	return uq
}

// WithNamedSurveyProgress tells the query-builder to eager-load the nodes that are connected to the "survey_progress"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedSurveyProgress(name string, opts ...func(*SurveyProgressQuery)) *UserQuery {
	query := (&SurveyProgressClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedSurveyProgress == nil {
		uq.withNamedSurveyProgress = make(map[string]*SurveyProgressQuery)
	}
	uq.withNamedSurveyProgress[name] = query
	return uq
}

// WithNamedCreatedTrainingVideos tells the query-builder to eager-load the nodes that are connected to the "created_training_videos"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedCreatedTrainingVideos(name string, opts ...func(*TrainingVideoQuery)) *UserQuery {
	query := (&TrainingVideoClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedCreatedTrainingVideos == nil {
		uq.withNamedCreatedTrainingVideos = make(map[string]*TrainingVideoQuery)
	}
	uq.withNamedCreatedTrainingVideos[name] = query
	return uq
}

// WithNamedCreatedTrainingCourses tells the query-builder to eager-load the nodes that are connected to the "created_training_courses"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedCreatedTrainingCourses(name string, opts ...func(*TrainingCourseQuery)) *UserQuery {
	query := (&TrainingCourseClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedCreatedTrainingCourses == nil {
		uq.withNamedCreatedTrainingCourses = make(map[string]*TrainingCourseQuery)
	}
	uq.withNamedCreatedTrainingCourses[name] = query
	return uq
}

// WithNamedJobNotes tells the query-builder to eager-load the nodes that are connected to the "job_notes"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedJobNotes(name string, opts ...func(*JobNoteQuery)) *UserQuery {
	query := (&JobNoteClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedJobNotes == nil {
		uq.withNamedJobNotes = make(map[string]*JobNoteQuery)
	}
	uq.withNamedJobNotes[name] = query
	return uq
}

// WithNamedChatChannels tells the query-builder to eager-load the nodes that are connected to the "chat_channels"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedChatChannels(name string, opts ...func(*ChannelSubQuery)) *UserQuery {
	query := (&ChannelSubClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedChatChannels == nil {
		uq.withNamedChatChannels = make(map[string]*ChannelSubQuery)
	}
	uq.withNamedChatChannels[name] = query
	return uq
}

// WithNamedSentMessages tells the query-builder to eager-load the nodes that are connected to the "sent_messages"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedSentMessages(name string, opts ...func(*ChannelMessageQuery)) *UserQuery {
	query := (&ChannelMessageClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedSentMessages == nil {
		uq.withNamedSentMessages = make(map[string]*ChannelMessageQuery)
	}
	uq.withNamedSentMessages[name] = query
	return uq
}

// WithNamedReceivedMessages tells the query-builder to eager-load the nodes that are connected to the "received_messages"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedReceivedMessages(name string, opts ...func(*ChannelMessageQuery)) *UserQuery {
	query := (&ChannelMessageClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedReceivedMessages == nil {
		uq.withNamedReceivedMessages = make(map[string]*ChannelMessageQuery)
	}
	uq.withNamedReceivedMessages[name] = query
	return uq
}

// WithNamedChannelMessageRead tells the query-builder to eager-load the nodes that are connected to the "channel_message_read"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedChannelMessageRead(name string, opts ...func(*ChannelMessageReadQuery)) *UserQuery {
	query := (&ChannelMessageReadClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedChannelMessageRead == nil {
		uq.withNamedChannelMessageRead = make(map[string]*ChannelMessageReadQuery)
	}
	uq.withNamedChannelMessageRead[name] = query
	return uq
}

// WithNamedProductsCreated tells the query-builder to eager-load the nodes that are connected to the "products_created"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedProductsCreated(name string, opts ...func(*ProductQuery)) *UserQuery {
	query := (&ProductClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedProductsCreated == nil {
		uq.withNamedProductsCreated = make(map[string]*ProductQuery)
	}
	uq.withNamedProductsCreated[name] = query
	return uq
}

// WithNamedProductPkgCreated tells the query-builder to eager-load the nodes that are connected to the "product_pkg_created"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedProductPkgCreated(name string, opts ...func(*ProductPackageQuery)) *UserQuery {
	query := (&ProductPackageClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedProductPkgCreated == nil {
		uq.withNamedProductPkgCreated = make(map[string]*ProductPackageQuery)
	}
	uq.withNamedProductPkgCreated[name] = query
	return uq
}

// WithNamedJobDocUrls tells the query-builder to eager-load the nodes that are connected to the "job_doc_urls"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedJobDocUrls(name string, opts ...func(*JobDocURLQuery)) *UserQuery {
	query := (&JobDocURLClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedJobDocUrls == nil {
		uq.withNamedJobDocUrls = make(map[string]*JobDocURLQuery)
	}
	uq.withNamedJobDocUrls[name] = query
	return uq
}

// WithNamedPartnerContacts tells the query-builder to eager-load the nodes that are connected to the "partner_contacts"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (uq *UserQuery) WithNamedPartnerContacts(name string, opts ...func(*PartnerContactQuery)) *UserQuery {
	query := (&PartnerContactClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if uq.withNamedPartnerContacts == nil {
		uq.withNamedPartnerContacts = make(map[string]*PartnerContactQuery)
	}
	uq.withNamedPartnerContacts[name] = query
	return uq
}

// UserGroupBy is the group-by builder for User entities.
type UserGroupBy struct {
	selector
	build *UserQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (ugb *UserGroupBy) Aggregate(fns ...AggregateFunc) *UserGroupBy {
	ugb.fns = append(ugb.fns, fns...)
	return ugb
}

// Scan applies the selector query and scans the result into the given value.
func (ugb *UserGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, ugb.build.ctx, "GroupBy")
	if err := ugb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*UserQuery, *UserGroupBy](ctx, ugb.build, ugb, ugb.build.inters, v)
}

func (ugb *UserGroupBy) sqlScan(ctx context.Context, root *UserQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(ugb.fns))
	for _, fn := range ugb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*ugb.flds)+len(ugb.fns))
		for _, f := range *ugb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*ugb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := ugb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// UserSelect is the builder for selecting fields of User entities.
type UserSelect struct {
	*UserQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (us *UserSelect) Aggregate(fns ...AggregateFunc) *UserSelect {
	us.fns = append(us.fns, fns...)
	return us
}

// Scan applies the selector query and scans the result into the given value.
func (us *UserSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, us.ctx, "Select")
	if err := us.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*UserQuery, *UserSelect](ctx, us.UserQuery, us, us.inters, v)
}

func (us *UserSelect) sqlScan(ctx context.Context, root *UserQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(us.fns))
	for _, fn := range us.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*us.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := us.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// Modify adds a query modifier for attaching custom logic to queries.
func (us *UserSelect) Modify(modifiers ...func(s *sql.Selector)) *UserSelect {
	us.modifiers = append(us.modifiers, modifiers...)
	return us
}
