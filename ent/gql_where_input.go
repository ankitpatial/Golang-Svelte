// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"roofix/ent/apiaccess"
	"roofix/ent/apiuser"
	"roofix/ent/apiusertoken"
	"roofix/ent/auditlog"
	"roofix/ent/channel"
	"roofix/ent/channelmessage"
	"roofix/ent/channelmessageread"
	"roofix/ent/channelsub"
	"roofix/ent/contactus"
	"roofix/ent/document"
	"roofix/ent/estimate"
	"roofix/ent/estimateactivity"
	"roofix/ent/homeowner"
	"roofix/ent/installationjob"
	"roofix/ent/installationjobitem"
	"roofix/ent/installationjobprogress"
	"roofix/ent/job"
	"roofix/ent/jobactivity"
	"roofix/ent/jobassignmenthistory"
	"roofix/ent/jobdocurl"
	"roofix/ent/jobnote"
	"roofix/ent/jobprogresshistory"
	"roofix/ent/notifysetting"
	"roofix/ent/optionlist"
	"roofix/ent/partner"
	"roofix/ent/partneractivity"
	"roofix/ent/partnercontact"
	"roofix/ent/partnerservice"
	"roofix/ent/partnerservicecity"
	"roofix/ent/partnerservicestate"
	"roofix/ent/partnertrainingvideo"
	"roofix/ent/payment"
	"roofix/ent/postalcode"
	"roofix/ent/predicate"
	"roofix/ent/pricing"
	"roofix/ent/product"
	"roofix/ent/productpackage"
	"roofix/ent/survey"
	"roofix/ent/surveyprogress"
	"roofix/ent/token"
	"roofix/ent/trainingcourse"
	"roofix/ent/trainingvideo"
	"roofix/ent/user"
	"roofix/ent/useractivity"
	"roofix/ent/userauth"
	"roofix/ent/usersession"
	"roofix/ent/usersessionsocket"
	"roofix/pkg/enum"
	"time"
)

// ApiAccessWhereInput represents a where input for filtering ApiAccess queries.
type ApiAccessWhereInput struct {
	Predicates []predicate.ApiAccess  `json:"-"`
	Not        *ApiAccessWhereInput   `json:"not,omitempty"`
	Or         []*ApiAccessWhereInput `json:"or,omitempty"`
	And        []*ApiAccessWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "secret" field predicates.
	Secret             *string  `json:"secret,omitempty"`
	SecretNEQ          *string  `json:"secretNEQ,omitempty"`
	SecretIn           []string `json:"secretIn,omitempty"`
	SecretNotIn        []string `json:"secretNotIn,omitempty"`
	SecretGT           *string  `json:"secretGT,omitempty"`
	SecretGTE          *string  `json:"secretGTE,omitempty"`
	SecretLT           *string  `json:"secretLT,omitempty"`
	SecretLTE          *string  `json:"secretLTE,omitempty"`
	SecretContains     *string  `json:"secretContains,omitempty"`
	SecretHasPrefix    *string  `json:"secretHasPrefix,omitempty"`
	SecretHasSuffix    *string  `json:"secretHasSuffix,omitempty"`
	SecretEqualFold    *string  `json:"secretEqualFold,omitempty"`
	SecretContainsFold *string  `json:"secretContainsFold,omitempty"`

	// "access_token" field predicates.
	AccessToken             *string  `json:"accessToken,omitempty"`
	AccessTokenNEQ          *string  `json:"accessTokenNEQ,omitempty"`
	AccessTokenIn           []string `json:"accessTokenIn,omitempty"`
	AccessTokenNotIn        []string `json:"accessTokenNotIn,omitempty"`
	AccessTokenGT           *string  `json:"accessTokenGT,omitempty"`
	AccessTokenGTE          *string  `json:"accessTokenGTE,omitempty"`
	AccessTokenLT           *string  `json:"accessTokenLT,omitempty"`
	AccessTokenLTE          *string  `json:"accessTokenLTE,omitempty"`
	AccessTokenContains     *string  `json:"accessTokenContains,omitempty"`
	AccessTokenHasPrefix    *string  `json:"accessTokenHasPrefix,omitempty"`
	AccessTokenHasSuffix    *string  `json:"accessTokenHasSuffix,omitempty"`
	AccessTokenIsNil        bool     `json:"accessTokenIsNil,omitempty"`
	AccessTokenNotNil       bool     `json:"accessTokenNotNil,omitempty"`
	AccessTokenEqualFold    *string  `json:"accessTokenEqualFold,omitempty"`
	AccessTokenContainsFold *string  `json:"accessTokenContainsFold,omitempty"`

	// "refresh_token" field predicates.
	RefreshToken             *string  `json:"refreshToken,omitempty"`
	RefreshTokenNEQ          *string  `json:"refreshTokenNEQ,omitempty"`
	RefreshTokenIn           []string `json:"refreshTokenIn,omitempty"`
	RefreshTokenNotIn        []string `json:"refreshTokenNotIn,omitempty"`
	RefreshTokenGT           *string  `json:"refreshTokenGT,omitempty"`
	RefreshTokenGTE          *string  `json:"refreshTokenGTE,omitempty"`
	RefreshTokenLT           *string  `json:"refreshTokenLT,omitempty"`
	RefreshTokenLTE          *string  `json:"refreshTokenLTE,omitempty"`
	RefreshTokenContains     *string  `json:"refreshTokenContains,omitempty"`
	RefreshTokenHasPrefix    *string  `json:"refreshTokenHasPrefix,omitempty"`
	RefreshTokenHasSuffix    *string  `json:"refreshTokenHasSuffix,omitempty"`
	RefreshTokenIsNil        bool     `json:"refreshTokenIsNil,omitempty"`
	RefreshTokenNotNil       bool     `json:"refreshTokenNotNil,omitempty"`
	RefreshTokenEqualFold    *string  `json:"refreshTokenEqualFold,omitempty"`
	RefreshTokenContainsFold *string  `json:"refreshTokenContainsFold,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt       *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ    *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn     []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn  []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT     *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE    *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT     *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE    *time.Time  `json:"expiresAtLTE,omitempty"`
	ExpiresAtIsNil  bool        `json:"expiresAtIsNil,omitempty"`
	ExpiresAtNotNil bool        `json:"expiresAtNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ApiAccessWhereInput) AddPredicates(predicates ...predicate.ApiAccess) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ApiAccessWhereInput filter on the ApiAccessQuery builder.
func (i *ApiAccessWhereInput) Filter(q *ApiAccessQuery) (*ApiAccessQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyApiAccessWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyApiAccessWhereInput is returned in case the ApiAccessWhereInput is empty.
var ErrEmptyApiAccessWhereInput = errors.New("ent: empty predicate ApiAccessWhereInput")

// P returns a predicate for filtering apiaccesses.
// An error is returned if the input is empty or invalid.
func (i *ApiAccessWhereInput) P() (predicate.ApiAccess, error) {
	var predicates []predicate.ApiAccess
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apiaccess.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ApiAccess, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apiaccess.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ApiAccess, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apiaccess.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apiaccess.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apiaccess.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apiaccess.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apiaccess.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apiaccess.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apiaccess.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apiaccess.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apiaccess.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, apiaccess.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, apiaccess.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apiaccess.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apiaccess.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apiaccess.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apiaccess.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apiaccess.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apiaccess.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apiaccess.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apiaccess.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, apiaccess.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, apiaccess.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, apiaccess.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, apiaccess.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, apiaccess.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, apiaccess.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, apiaccess.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, apiaccess.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.URL != nil {
		predicates = append(predicates, apiaccess.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, apiaccess.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, apiaccess.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, apiaccess.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, apiaccess.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, apiaccess.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, apiaccess.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, apiaccess.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, apiaccess.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, apiaccess.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, apiaccess.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, apiaccess.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, apiaccess.URLContainsFold(*i.URLContainsFold))
	}
	if i.Username != nil {
		predicates = append(predicates, apiaccess.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, apiaccess.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, apiaccess.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, apiaccess.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, apiaccess.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, apiaccess.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, apiaccess.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, apiaccess.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, apiaccess.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, apiaccess.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, apiaccess.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, apiaccess.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, apiaccess.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, apiaccess.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, apiaccess.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, apiaccess.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, apiaccess.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, apiaccess.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, apiaccess.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, apiaccess.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, apiaccess.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, apiaccess.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, apiaccess.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, apiaccess.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, apiaccess.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, apiaccess.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, apiaccess.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, apiaccess.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, apiaccess.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, apiaccess.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, apiaccess.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, apiaccess.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, apiaccess.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, apiaccess.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, apiaccess.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, apiaccess.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, apiaccess.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, apiaccess.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, apiaccess.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Secret != nil {
		predicates = append(predicates, apiaccess.SecretEQ(*i.Secret))
	}
	if i.SecretNEQ != nil {
		predicates = append(predicates, apiaccess.SecretNEQ(*i.SecretNEQ))
	}
	if len(i.SecretIn) > 0 {
		predicates = append(predicates, apiaccess.SecretIn(i.SecretIn...))
	}
	if len(i.SecretNotIn) > 0 {
		predicates = append(predicates, apiaccess.SecretNotIn(i.SecretNotIn...))
	}
	if i.SecretGT != nil {
		predicates = append(predicates, apiaccess.SecretGT(*i.SecretGT))
	}
	if i.SecretGTE != nil {
		predicates = append(predicates, apiaccess.SecretGTE(*i.SecretGTE))
	}
	if i.SecretLT != nil {
		predicates = append(predicates, apiaccess.SecretLT(*i.SecretLT))
	}
	if i.SecretLTE != nil {
		predicates = append(predicates, apiaccess.SecretLTE(*i.SecretLTE))
	}
	if i.SecretContains != nil {
		predicates = append(predicates, apiaccess.SecretContains(*i.SecretContains))
	}
	if i.SecretHasPrefix != nil {
		predicates = append(predicates, apiaccess.SecretHasPrefix(*i.SecretHasPrefix))
	}
	if i.SecretHasSuffix != nil {
		predicates = append(predicates, apiaccess.SecretHasSuffix(*i.SecretHasSuffix))
	}
	if i.SecretEqualFold != nil {
		predicates = append(predicates, apiaccess.SecretEqualFold(*i.SecretEqualFold))
	}
	if i.SecretContainsFold != nil {
		predicates = append(predicates, apiaccess.SecretContainsFold(*i.SecretContainsFold))
	}
	if i.AccessToken != nil {
		predicates = append(predicates, apiaccess.AccessTokenEQ(*i.AccessToken))
	}
	if i.AccessTokenNEQ != nil {
		predicates = append(predicates, apiaccess.AccessTokenNEQ(*i.AccessTokenNEQ))
	}
	if len(i.AccessTokenIn) > 0 {
		predicates = append(predicates, apiaccess.AccessTokenIn(i.AccessTokenIn...))
	}
	if len(i.AccessTokenNotIn) > 0 {
		predicates = append(predicates, apiaccess.AccessTokenNotIn(i.AccessTokenNotIn...))
	}
	if i.AccessTokenGT != nil {
		predicates = append(predicates, apiaccess.AccessTokenGT(*i.AccessTokenGT))
	}
	if i.AccessTokenGTE != nil {
		predicates = append(predicates, apiaccess.AccessTokenGTE(*i.AccessTokenGTE))
	}
	if i.AccessTokenLT != nil {
		predicates = append(predicates, apiaccess.AccessTokenLT(*i.AccessTokenLT))
	}
	if i.AccessTokenLTE != nil {
		predicates = append(predicates, apiaccess.AccessTokenLTE(*i.AccessTokenLTE))
	}
	if i.AccessTokenContains != nil {
		predicates = append(predicates, apiaccess.AccessTokenContains(*i.AccessTokenContains))
	}
	if i.AccessTokenHasPrefix != nil {
		predicates = append(predicates, apiaccess.AccessTokenHasPrefix(*i.AccessTokenHasPrefix))
	}
	if i.AccessTokenHasSuffix != nil {
		predicates = append(predicates, apiaccess.AccessTokenHasSuffix(*i.AccessTokenHasSuffix))
	}
	if i.AccessTokenIsNil {
		predicates = append(predicates, apiaccess.AccessTokenIsNil())
	}
	if i.AccessTokenNotNil {
		predicates = append(predicates, apiaccess.AccessTokenNotNil())
	}
	if i.AccessTokenEqualFold != nil {
		predicates = append(predicates, apiaccess.AccessTokenEqualFold(*i.AccessTokenEqualFold))
	}
	if i.AccessTokenContainsFold != nil {
		predicates = append(predicates, apiaccess.AccessTokenContainsFold(*i.AccessTokenContainsFold))
	}
	if i.RefreshToken != nil {
		predicates = append(predicates, apiaccess.RefreshTokenEQ(*i.RefreshToken))
	}
	if i.RefreshTokenNEQ != nil {
		predicates = append(predicates, apiaccess.RefreshTokenNEQ(*i.RefreshTokenNEQ))
	}
	if len(i.RefreshTokenIn) > 0 {
		predicates = append(predicates, apiaccess.RefreshTokenIn(i.RefreshTokenIn...))
	}
	if len(i.RefreshTokenNotIn) > 0 {
		predicates = append(predicates, apiaccess.RefreshTokenNotIn(i.RefreshTokenNotIn...))
	}
	if i.RefreshTokenGT != nil {
		predicates = append(predicates, apiaccess.RefreshTokenGT(*i.RefreshTokenGT))
	}
	if i.RefreshTokenGTE != nil {
		predicates = append(predicates, apiaccess.RefreshTokenGTE(*i.RefreshTokenGTE))
	}
	if i.RefreshTokenLT != nil {
		predicates = append(predicates, apiaccess.RefreshTokenLT(*i.RefreshTokenLT))
	}
	if i.RefreshTokenLTE != nil {
		predicates = append(predicates, apiaccess.RefreshTokenLTE(*i.RefreshTokenLTE))
	}
	if i.RefreshTokenContains != nil {
		predicates = append(predicates, apiaccess.RefreshTokenContains(*i.RefreshTokenContains))
	}
	if i.RefreshTokenHasPrefix != nil {
		predicates = append(predicates, apiaccess.RefreshTokenHasPrefix(*i.RefreshTokenHasPrefix))
	}
	if i.RefreshTokenHasSuffix != nil {
		predicates = append(predicates, apiaccess.RefreshTokenHasSuffix(*i.RefreshTokenHasSuffix))
	}
	if i.RefreshTokenIsNil {
		predicates = append(predicates, apiaccess.RefreshTokenIsNil())
	}
	if i.RefreshTokenNotNil {
		predicates = append(predicates, apiaccess.RefreshTokenNotNil())
	}
	if i.RefreshTokenEqualFold != nil {
		predicates = append(predicates, apiaccess.RefreshTokenEqualFold(*i.RefreshTokenEqualFold))
	}
	if i.RefreshTokenContainsFold != nil {
		predicates = append(predicates, apiaccess.RefreshTokenContainsFold(*i.RefreshTokenContainsFold))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, apiaccess.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, apiaccess.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, apiaccess.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, apiaccess.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, apiaccess.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, apiaccess.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, apiaccess.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, apiaccess.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.ExpiresAtIsNil {
		predicates = append(predicates, apiaccess.ExpiresAtIsNil())
	}
	if i.ExpiresAtNotNil {
		predicates = append(predicates, apiaccess.ExpiresAtNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyApiAccessWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apiaccess.And(predicates...), nil
	}
}

// ApiUserWhereInput represents a where input for filtering ApiUser queries.
type ApiUserWhereInput struct {
	Predicates []predicate.ApiUser  `json:"-"`
	Not        *ApiUserWhereInput   `json:"not,omitempty"`
	Or         []*ApiUserWhereInput `json:"or,omitempty"`
	And        []*ApiUserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "username" field predicates.
	Username             *string  `json:"username,omitempty"`
	UsernameNEQ          *string  `json:"usernameNEQ,omitempty"`
	UsernameIn           []string `json:"usernameIn,omitempty"`
	UsernameNotIn        []string `json:"usernameNotIn,omitempty"`
	UsernameGT           *string  `json:"usernameGT,omitempty"`
	UsernameGTE          *string  `json:"usernameGTE,omitempty"`
	UsernameLT           *string  `json:"usernameLT,omitempty"`
	UsernameLTE          *string  `json:"usernameLTE,omitempty"`
	UsernameContains     *string  `json:"usernameContains,omitempty"`
	UsernameHasPrefix    *string  `json:"usernameHasPrefix,omitempty"`
	UsernameHasSuffix    *string  `json:"usernameHasSuffix,omitempty"`
	UsernameEqualFold    *string  `json:"usernameEqualFold,omitempty"`
	UsernameContainsFold *string  `json:"usernameContainsFold,omitempty"`

	// "pwd_hash" field predicates.
	PwdHash             *string  `json:"pwdHash,omitempty"`
	PwdHashNEQ          *string  `json:"pwdHashNEQ,omitempty"`
	PwdHashIn           []string `json:"pwdHashIn,omitempty"`
	PwdHashNotIn        []string `json:"pwdHashNotIn,omitempty"`
	PwdHashGT           *string  `json:"pwdHashGT,omitempty"`
	PwdHashGTE          *string  `json:"pwdHashGTE,omitempty"`
	PwdHashLT           *string  `json:"pwdHashLT,omitempty"`
	PwdHashLTE          *string  `json:"pwdHashLTE,omitempty"`
	PwdHashContains     *string  `json:"pwdHashContains,omitempty"`
	PwdHashHasPrefix    *string  `json:"pwdHashHasPrefix,omitempty"`
	PwdHashHasSuffix    *string  `json:"pwdHashHasSuffix,omitempty"`
	PwdHashEqualFold    *string  `json:"pwdHashEqualFold,omitempty"`
	PwdHashContainsFold *string  `json:"pwdHashContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "cb_api_url" field predicates.
	CbAPIURL             *string  `json:"cbAPIURL,omitempty"`
	CbAPIURLNEQ          *string  `json:"cbAPIURLNEQ,omitempty"`
	CbAPIURLIn           []string `json:"cbAPIURLIn,omitempty"`
	CbAPIURLNotIn        []string `json:"cbAPIURLNotIn,omitempty"`
	CbAPIURLGT           *string  `json:"cbAPIURLGT,omitempty"`
	CbAPIURLGTE          *string  `json:"cbAPIURLGTE,omitempty"`
	CbAPIURLLT           *string  `json:"cbAPIURLLT,omitempty"`
	CbAPIURLLTE          *string  `json:"cbAPIURLLTE,omitempty"`
	CbAPIURLContains     *string  `json:"cbAPIURLContains,omitempty"`
	CbAPIURLHasPrefix    *string  `json:"cbAPIURLHasPrefix,omitempty"`
	CbAPIURLHasSuffix    *string  `json:"cbAPIURLHasSuffix,omitempty"`
	CbAPIURLIsNil        bool     `json:"cbAPIURLIsNil,omitempty"`
	CbAPIURLNotNil       bool     `json:"cbAPIURLNotNil,omitempty"`
	CbAPIURLEqualFold    *string  `json:"cbAPIURLEqualFold,omitempty"`
	CbAPIURLContainsFold *string  `json:"cbAPIURLContainsFold,omitempty"`

	// "cb_api_auth" field predicates.
	CbAPIAuth       *apiuser.CbAPIAuth  `json:"cbAPIAuth,omitempty"`
	CbAPIAuthNEQ    *apiuser.CbAPIAuth  `json:"cbAPIAuthNEQ,omitempty"`
	CbAPIAuthIn     []apiuser.CbAPIAuth `json:"cbAPIAuthIn,omitempty"`
	CbAPIAuthNotIn  []apiuser.CbAPIAuth `json:"cbAPIAuthNotIn,omitempty"`
	CbAPIAuthIsNil  bool                `json:"cbAPIAuthIsNil,omitempty"`
	CbAPIAuthNotNil bool                `json:"cbAPIAuthNotNil,omitempty"`

	// "cb_api_user" field predicates.
	CbAPIUser             *string  `json:"cbAPIUser,omitempty"`
	CbAPIUserNEQ          *string  `json:"cbAPIUserNEQ,omitempty"`
	CbAPIUserIn           []string `json:"cbAPIUserIn,omitempty"`
	CbAPIUserNotIn        []string `json:"cbAPIUserNotIn,omitempty"`
	CbAPIUserGT           *string  `json:"cbAPIUserGT,omitempty"`
	CbAPIUserGTE          *string  `json:"cbAPIUserGTE,omitempty"`
	CbAPIUserLT           *string  `json:"cbAPIUserLT,omitempty"`
	CbAPIUserLTE          *string  `json:"cbAPIUserLTE,omitempty"`
	CbAPIUserContains     *string  `json:"cbAPIUserContains,omitempty"`
	CbAPIUserHasPrefix    *string  `json:"cbAPIUserHasPrefix,omitempty"`
	CbAPIUserHasSuffix    *string  `json:"cbAPIUserHasSuffix,omitempty"`
	CbAPIUserIsNil        bool     `json:"cbAPIUserIsNil,omitempty"`
	CbAPIUserNotNil       bool     `json:"cbAPIUserNotNil,omitempty"`
	CbAPIUserEqualFold    *string  `json:"cbAPIUserEqualFold,omitempty"`
	CbAPIUserContainsFold *string  `json:"cbAPIUserContainsFold,omitempty"`

	// "cb_api_pwd" field predicates.
	CbAPIPwd             *string  `json:"cbAPIPwd,omitempty"`
	CbAPIPwdNEQ          *string  `json:"cbAPIPwdNEQ,omitempty"`
	CbAPIPwdIn           []string `json:"cbAPIPwdIn,omitempty"`
	CbAPIPwdNotIn        []string `json:"cbAPIPwdNotIn,omitempty"`
	CbAPIPwdGT           *string  `json:"cbAPIPwdGT,omitempty"`
	CbAPIPwdGTE          *string  `json:"cbAPIPwdGTE,omitempty"`
	CbAPIPwdLT           *string  `json:"cbAPIPwdLT,omitempty"`
	CbAPIPwdLTE          *string  `json:"cbAPIPwdLTE,omitempty"`
	CbAPIPwdContains     *string  `json:"cbAPIPwdContains,omitempty"`
	CbAPIPwdHasPrefix    *string  `json:"cbAPIPwdHasPrefix,omitempty"`
	CbAPIPwdHasSuffix    *string  `json:"cbAPIPwdHasSuffix,omitempty"`
	CbAPIPwdIsNil        bool     `json:"cbAPIPwdIsNil,omitempty"`
	CbAPIPwdNotNil       bool     `json:"cbAPIPwdNotNil,omitempty"`
	CbAPIPwdEqualFold    *string  `json:"cbAPIPwdEqualFold,omitempty"`
	CbAPIPwdContainsFold *string  `json:"cbAPIPwdContainsFold,omitempty"`

	// "cb_api_token" field predicates.
	CbAPIToken             *string  `json:"cbAPIToken,omitempty"`
	CbAPITokenNEQ          *string  `json:"cbAPITokenNEQ,omitempty"`
	CbAPITokenIn           []string `json:"cbAPITokenIn,omitempty"`
	CbAPITokenNotIn        []string `json:"cbAPITokenNotIn,omitempty"`
	CbAPITokenGT           *string  `json:"cbAPITokenGT,omitempty"`
	CbAPITokenGTE          *string  `json:"cbAPITokenGTE,omitempty"`
	CbAPITokenLT           *string  `json:"cbAPITokenLT,omitempty"`
	CbAPITokenLTE          *string  `json:"cbAPITokenLTE,omitempty"`
	CbAPITokenContains     *string  `json:"cbAPITokenContains,omitempty"`
	CbAPITokenHasPrefix    *string  `json:"cbAPITokenHasPrefix,omitempty"`
	CbAPITokenHasSuffix    *string  `json:"cbAPITokenHasSuffix,omitempty"`
	CbAPITokenIsNil        bool     `json:"cbAPITokenIsNil,omitempty"`
	CbAPITokenNotNil       bool     `json:"cbAPITokenNotNil,omitempty"`
	CbAPITokenEqualFold    *string  `json:"cbAPITokenEqualFold,omitempty"`
	CbAPITokenContainsFold *string  `json:"cbAPITokenContainsFold,omitempty"`

	// "tokens" edge predicates.
	HasTokens     *bool                     `json:"hasTokens,omitempty"`
	HasTokensWith []*ApiUserTokenWhereInput `json:"hasTokensWith,omitempty"`

	// "audit_logs" edge predicates.
	HasAuditLogs     *bool                 `json:"hasAuditLogs,omitempty"`
	HasAuditLogsWith []*AuditLogWhereInput `json:"hasAuditLogsWith,omitempty"`

	// "created_estimates" edge predicates.
	HasCreatedEstimates     *bool                 `json:"hasCreatedEstimates,omitempty"`
	HasCreatedEstimatesWith []*EstimateWhereInput `json:"hasCreatedEstimatesWith,omitempty"`

	// "created_jobs" edge predicates.
	HasCreatedJobs     *bool            `json:"hasCreatedJobs,omitempty"`
	HasCreatedJobsWith []*JobWhereInput `json:"hasCreatedJobsWith,omitempty"`

	// "created_partners" edge predicates.
	HasCreatedPartners     *bool                `json:"hasCreatedPartners,omitempty"`
	HasCreatedPartnersWith []*PartnerWhereInput `json:"hasCreatedPartnersWith,omitempty"`

	// "survey_progress" edge predicates.
	HasSurveyProgress     *bool                       `json:"hasSurveyProgress,omitempty"`
	HasSurveyProgressWith []*SurveyProgressWhereInput `json:"hasSurveyProgressWith,omitempty"`

	// "estimate_activities" edge predicates.
	HasEstimateActivities     *bool                         `json:"hasEstimateActivities,omitempty"`
	HasEstimateActivitiesWith []*EstimateActivityWhereInput `json:"hasEstimateActivitiesWith,omitempty"`

	// "user_activities" edge predicates.
	HasUserActivities     *bool                     `json:"hasUserActivities,omitempty"`
	HasUserActivitiesWith []*UserActivityWhereInput `json:"hasUserActivitiesWith,omitempty"`

	// "partner_activities" edge predicates.
	HasPartnerActivities     *bool                        `json:"hasPartnerActivities,omitempty"`
	HasPartnerActivitiesWith []*PartnerActivityWhereInput `json:"hasPartnerActivitiesWith,omitempty"`

	// "job_activities" edge predicates.
	HasJobActivities     *bool                    `json:"hasJobActivities,omitempty"`
	HasJobActivitiesWith []*JobActivityWhereInput `json:"hasJobActivitiesWith,omitempty"`

	// "notifications" edge predicates.
	HasNotifications     *bool                       `json:"hasNotifications,omitempty"`
	HasNotificationsWith []*ChannelMessageWhereInput `json:"hasNotificationsWith,omitempty"`

	// "job_progress_history" edge predicates.
	HasJobProgressHistory     *bool                           `json:"hasJobProgressHistory,omitempty"`
	HasJobProgressHistoryWith []*JobProgressHistoryWhereInput `json:"hasJobProgressHistoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ApiUserWhereInput) AddPredicates(predicates ...predicate.ApiUser) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ApiUserWhereInput filter on the ApiUserQuery builder.
func (i *ApiUserWhereInput) Filter(q *ApiUserQuery) (*ApiUserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyApiUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyApiUserWhereInput is returned in case the ApiUserWhereInput is empty.
var ErrEmptyApiUserWhereInput = errors.New("ent: empty predicate ApiUserWhereInput")

// P returns a predicate for filtering apiusers.
// An error is returned if the input is empty or invalid.
func (i *ApiUserWhereInput) P() (predicate.ApiUser, error) {
	var predicates []predicate.ApiUser
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apiuser.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ApiUser, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apiuser.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ApiUser, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apiuser.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apiuser.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apiuser.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apiuser.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apiuser.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apiuser.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apiuser.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apiuser.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apiuser.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, apiuser.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, apiuser.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apiuser.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apiuser.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apiuser.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apiuser.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apiuser.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apiuser.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apiuser.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apiuser.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Username != nil {
		predicates = append(predicates, apiuser.UsernameEQ(*i.Username))
	}
	if i.UsernameNEQ != nil {
		predicates = append(predicates, apiuser.UsernameNEQ(*i.UsernameNEQ))
	}
	if len(i.UsernameIn) > 0 {
		predicates = append(predicates, apiuser.UsernameIn(i.UsernameIn...))
	}
	if len(i.UsernameNotIn) > 0 {
		predicates = append(predicates, apiuser.UsernameNotIn(i.UsernameNotIn...))
	}
	if i.UsernameGT != nil {
		predicates = append(predicates, apiuser.UsernameGT(*i.UsernameGT))
	}
	if i.UsernameGTE != nil {
		predicates = append(predicates, apiuser.UsernameGTE(*i.UsernameGTE))
	}
	if i.UsernameLT != nil {
		predicates = append(predicates, apiuser.UsernameLT(*i.UsernameLT))
	}
	if i.UsernameLTE != nil {
		predicates = append(predicates, apiuser.UsernameLTE(*i.UsernameLTE))
	}
	if i.UsernameContains != nil {
		predicates = append(predicates, apiuser.UsernameContains(*i.UsernameContains))
	}
	if i.UsernameHasPrefix != nil {
		predicates = append(predicates, apiuser.UsernameHasPrefix(*i.UsernameHasPrefix))
	}
	if i.UsernameHasSuffix != nil {
		predicates = append(predicates, apiuser.UsernameHasSuffix(*i.UsernameHasSuffix))
	}
	if i.UsernameEqualFold != nil {
		predicates = append(predicates, apiuser.UsernameEqualFold(*i.UsernameEqualFold))
	}
	if i.UsernameContainsFold != nil {
		predicates = append(predicates, apiuser.UsernameContainsFold(*i.UsernameContainsFold))
	}
	if i.PwdHash != nil {
		predicates = append(predicates, apiuser.PwdHashEQ(*i.PwdHash))
	}
	if i.PwdHashNEQ != nil {
		predicates = append(predicates, apiuser.PwdHashNEQ(*i.PwdHashNEQ))
	}
	if len(i.PwdHashIn) > 0 {
		predicates = append(predicates, apiuser.PwdHashIn(i.PwdHashIn...))
	}
	if len(i.PwdHashNotIn) > 0 {
		predicates = append(predicates, apiuser.PwdHashNotIn(i.PwdHashNotIn...))
	}
	if i.PwdHashGT != nil {
		predicates = append(predicates, apiuser.PwdHashGT(*i.PwdHashGT))
	}
	if i.PwdHashGTE != nil {
		predicates = append(predicates, apiuser.PwdHashGTE(*i.PwdHashGTE))
	}
	if i.PwdHashLT != nil {
		predicates = append(predicates, apiuser.PwdHashLT(*i.PwdHashLT))
	}
	if i.PwdHashLTE != nil {
		predicates = append(predicates, apiuser.PwdHashLTE(*i.PwdHashLTE))
	}
	if i.PwdHashContains != nil {
		predicates = append(predicates, apiuser.PwdHashContains(*i.PwdHashContains))
	}
	if i.PwdHashHasPrefix != nil {
		predicates = append(predicates, apiuser.PwdHashHasPrefix(*i.PwdHashHasPrefix))
	}
	if i.PwdHashHasSuffix != nil {
		predicates = append(predicates, apiuser.PwdHashHasSuffix(*i.PwdHashHasSuffix))
	}
	if i.PwdHashEqualFold != nil {
		predicates = append(predicates, apiuser.PwdHashEqualFold(*i.PwdHashEqualFold))
	}
	if i.PwdHashContainsFold != nil {
		predicates = append(predicates, apiuser.PwdHashContainsFold(*i.PwdHashContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, apiuser.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, apiuser.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.CbAPIURL != nil {
		predicates = append(predicates, apiuser.CbAPIURLEQ(*i.CbAPIURL))
	}
	if i.CbAPIURLNEQ != nil {
		predicates = append(predicates, apiuser.CbAPIURLNEQ(*i.CbAPIURLNEQ))
	}
	if len(i.CbAPIURLIn) > 0 {
		predicates = append(predicates, apiuser.CbAPIURLIn(i.CbAPIURLIn...))
	}
	if len(i.CbAPIURLNotIn) > 0 {
		predicates = append(predicates, apiuser.CbAPIURLNotIn(i.CbAPIURLNotIn...))
	}
	if i.CbAPIURLGT != nil {
		predicates = append(predicates, apiuser.CbAPIURLGT(*i.CbAPIURLGT))
	}
	if i.CbAPIURLGTE != nil {
		predicates = append(predicates, apiuser.CbAPIURLGTE(*i.CbAPIURLGTE))
	}
	if i.CbAPIURLLT != nil {
		predicates = append(predicates, apiuser.CbAPIURLLT(*i.CbAPIURLLT))
	}
	if i.CbAPIURLLTE != nil {
		predicates = append(predicates, apiuser.CbAPIURLLTE(*i.CbAPIURLLTE))
	}
	if i.CbAPIURLContains != nil {
		predicates = append(predicates, apiuser.CbAPIURLContains(*i.CbAPIURLContains))
	}
	if i.CbAPIURLHasPrefix != nil {
		predicates = append(predicates, apiuser.CbAPIURLHasPrefix(*i.CbAPIURLHasPrefix))
	}
	if i.CbAPIURLHasSuffix != nil {
		predicates = append(predicates, apiuser.CbAPIURLHasSuffix(*i.CbAPIURLHasSuffix))
	}
	if i.CbAPIURLIsNil {
		predicates = append(predicates, apiuser.CbAPIURLIsNil())
	}
	if i.CbAPIURLNotNil {
		predicates = append(predicates, apiuser.CbAPIURLNotNil())
	}
	if i.CbAPIURLEqualFold != nil {
		predicates = append(predicates, apiuser.CbAPIURLEqualFold(*i.CbAPIURLEqualFold))
	}
	if i.CbAPIURLContainsFold != nil {
		predicates = append(predicates, apiuser.CbAPIURLContainsFold(*i.CbAPIURLContainsFold))
	}
	if i.CbAPIAuth != nil {
		predicates = append(predicates, apiuser.CbAPIAuthEQ(*i.CbAPIAuth))
	}
	if i.CbAPIAuthNEQ != nil {
		predicates = append(predicates, apiuser.CbAPIAuthNEQ(*i.CbAPIAuthNEQ))
	}
	if len(i.CbAPIAuthIn) > 0 {
		predicates = append(predicates, apiuser.CbAPIAuthIn(i.CbAPIAuthIn...))
	}
	if len(i.CbAPIAuthNotIn) > 0 {
		predicates = append(predicates, apiuser.CbAPIAuthNotIn(i.CbAPIAuthNotIn...))
	}
	if i.CbAPIAuthIsNil {
		predicates = append(predicates, apiuser.CbAPIAuthIsNil())
	}
	if i.CbAPIAuthNotNil {
		predicates = append(predicates, apiuser.CbAPIAuthNotNil())
	}
	if i.CbAPIUser != nil {
		predicates = append(predicates, apiuser.CbAPIUserEQ(*i.CbAPIUser))
	}
	if i.CbAPIUserNEQ != nil {
		predicates = append(predicates, apiuser.CbAPIUserNEQ(*i.CbAPIUserNEQ))
	}
	if len(i.CbAPIUserIn) > 0 {
		predicates = append(predicates, apiuser.CbAPIUserIn(i.CbAPIUserIn...))
	}
	if len(i.CbAPIUserNotIn) > 0 {
		predicates = append(predicates, apiuser.CbAPIUserNotIn(i.CbAPIUserNotIn...))
	}
	if i.CbAPIUserGT != nil {
		predicates = append(predicates, apiuser.CbAPIUserGT(*i.CbAPIUserGT))
	}
	if i.CbAPIUserGTE != nil {
		predicates = append(predicates, apiuser.CbAPIUserGTE(*i.CbAPIUserGTE))
	}
	if i.CbAPIUserLT != nil {
		predicates = append(predicates, apiuser.CbAPIUserLT(*i.CbAPIUserLT))
	}
	if i.CbAPIUserLTE != nil {
		predicates = append(predicates, apiuser.CbAPIUserLTE(*i.CbAPIUserLTE))
	}
	if i.CbAPIUserContains != nil {
		predicates = append(predicates, apiuser.CbAPIUserContains(*i.CbAPIUserContains))
	}
	if i.CbAPIUserHasPrefix != nil {
		predicates = append(predicates, apiuser.CbAPIUserHasPrefix(*i.CbAPIUserHasPrefix))
	}
	if i.CbAPIUserHasSuffix != nil {
		predicates = append(predicates, apiuser.CbAPIUserHasSuffix(*i.CbAPIUserHasSuffix))
	}
	if i.CbAPIUserIsNil {
		predicates = append(predicates, apiuser.CbAPIUserIsNil())
	}
	if i.CbAPIUserNotNil {
		predicates = append(predicates, apiuser.CbAPIUserNotNil())
	}
	if i.CbAPIUserEqualFold != nil {
		predicates = append(predicates, apiuser.CbAPIUserEqualFold(*i.CbAPIUserEqualFold))
	}
	if i.CbAPIUserContainsFold != nil {
		predicates = append(predicates, apiuser.CbAPIUserContainsFold(*i.CbAPIUserContainsFold))
	}
	if i.CbAPIPwd != nil {
		predicates = append(predicates, apiuser.CbAPIPwdEQ(*i.CbAPIPwd))
	}
	if i.CbAPIPwdNEQ != nil {
		predicates = append(predicates, apiuser.CbAPIPwdNEQ(*i.CbAPIPwdNEQ))
	}
	if len(i.CbAPIPwdIn) > 0 {
		predicates = append(predicates, apiuser.CbAPIPwdIn(i.CbAPIPwdIn...))
	}
	if len(i.CbAPIPwdNotIn) > 0 {
		predicates = append(predicates, apiuser.CbAPIPwdNotIn(i.CbAPIPwdNotIn...))
	}
	if i.CbAPIPwdGT != nil {
		predicates = append(predicates, apiuser.CbAPIPwdGT(*i.CbAPIPwdGT))
	}
	if i.CbAPIPwdGTE != nil {
		predicates = append(predicates, apiuser.CbAPIPwdGTE(*i.CbAPIPwdGTE))
	}
	if i.CbAPIPwdLT != nil {
		predicates = append(predicates, apiuser.CbAPIPwdLT(*i.CbAPIPwdLT))
	}
	if i.CbAPIPwdLTE != nil {
		predicates = append(predicates, apiuser.CbAPIPwdLTE(*i.CbAPIPwdLTE))
	}
	if i.CbAPIPwdContains != nil {
		predicates = append(predicates, apiuser.CbAPIPwdContains(*i.CbAPIPwdContains))
	}
	if i.CbAPIPwdHasPrefix != nil {
		predicates = append(predicates, apiuser.CbAPIPwdHasPrefix(*i.CbAPIPwdHasPrefix))
	}
	if i.CbAPIPwdHasSuffix != nil {
		predicates = append(predicates, apiuser.CbAPIPwdHasSuffix(*i.CbAPIPwdHasSuffix))
	}
	if i.CbAPIPwdIsNil {
		predicates = append(predicates, apiuser.CbAPIPwdIsNil())
	}
	if i.CbAPIPwdNotNil {
		predicates = append(predicates, apiuser.CbAPIPwdNotNil())
	}
	if i.CbAPIPwdEqualFold != nil {
		predicates = append(predicates, apiuser.CbAPIPwdEqualFold(*i.CbAPIPwdEqualFold))
	}
	if i.CbAPIPwdContainsFold != nil {
		predicates = append(predicates, apiuser.CbAPIPwdContainsFold(*i.CbAPIPwdContainsFold))
	}
	if i.CbAPIToken != nil {
		predicates = append(predicates, apiuser.CbAPITokenEQ(*i.CbAPIToken))
	}
	if i.CbAPITokenNEQ != nil {
		predicates = append(predicates, apiuser.CbAPITokenNEQ(*i.CbAPITokenNEQ))
	}
	if len(i.CbAPITokenIn) > 0 {
		predicates = append(predicates, apiuser.CbAPITokenIn(i.CbAPITokenIn...))
	}
	if len(i.CbAPITokenNotIn) > 0 {
		predicates = append(predicates, apiuser.CbAPITokenNotIn(i.CbAPITokenNotIn...))
	}
	if i.CbAPITokenGT != nil {
		predicates = append(predicates, apiuser.CbAPITokenGT(*i.CbAPITokenGT))
	}
	if i.CbAPITokenGTE != nil {
		predicates = append(predicates, apiuser.CbAPITokenGTE(*i.CbAPITokenGTE))
	}
	if i.CbAPITokenLT != nil {
		predicates = append(predicates, apiuser.CbAPITokenLT(*i.CbAPITokenLT))
	}
	if i.CbAPITokenLTE != nil {
		predicates = append(predicates, apiuser.CbAPITokenLTE(*i.CbAPITokenLTE))
	}
	if i.CbAPITokenContains != nil {
		predicates = append(predicates, apiuser.CbAPITokenContains(*i.CbAPITokenContains))
	}
	if i.CbAPITokenHasPrefix != nil {
		predicates = append(predicates, apiuser.CbAPITokenHasPrefix(*i.CbAPITokenHasPrefix))
	}
	if i.CbAPITokenHasSuffix != nil {
		predicates = append(predicates, apiuser.CbAPITokenHasSuffix(*i.CbAPITokenHasSuffix))
	}
	if i.CbAPITokenIsNil {
		predicates = append(predicates, apiuser.CbAPITokenIsNil())
	}
	if i.CbAPITokenNotNil {
		predicates = append(predicates, apiuser.CbAPITokenNotNil())
	}
	if i.CbAPITokenEqualFold != nil {
		predicates = append(predicates, apiuser.CbAPITokenEqualFold(*i.CbAPITokenEqualFold))
	}
	if i.CbAPITokenContainsFold != nil {
		predicates = append(predicates, apiuser.CbAPITokenContainsFold(*i.CbAPITokenContainsFold))
	}

	if i.HasTokens != nil {
		p := apiuser.HasTokens()
		if !*i.HasTokens {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTokensWith) > 0 {
		with := make([]predicate.ApiUserToken, 0, len(i.HasTokensWith))
		for _, w := range i.HasTokensWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTokensWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasTokensWith(with...))
	}
	if i.HasAuditLogs != nil {
		p := apiuser.HasAuditLogs()
		if !*i.HasAuditLogs {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuditLogsWith) > 0 {
		with := make([]predicate.AuditLog, 0, len(i.HasAuditLogsWith))
		for _, w := range i.HasAuditLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuditLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasAuditLogsWith(with...))
	}
	if i.HasCreatedEstimates != nil {
		p := apiuser.HasCreatedEstimates()
		if !*i.HasCreatedEstimates {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedEstimatesWith) > 0 {
		with := make([]predicate.Estimate, 0, len(i.HasCreatedEstimatesWith))
		for _, w := range i.HasCreatedEstimatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedEstimatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasCreatedEstimatesWith(with...))
	}
	if i.HasCreatedJobs != nil {
		p := apiuser.HasCreatedJobs()
		if !*i.HasCreatedJobs {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedJobsWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasCreatedJobsWith))
		for _, w := range i.HasCreatedJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasCreatedJobsWith(with...))
	}
	if i.HasCreatedPartners != nil {
		p := apiuser.HasCreatedPartners()
		if !*i.HasCreatedPartners {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedPartnersWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasCreatedPartnersWith))
		for _, w := range i.HasCreatedPartnersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedPartnersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasCreatedPartnersWith(with...))
	}
	if i.HasSurveyProgress != nil {
		p := apiuser.HasSurveyProgress()
		if !*i.HasSurveyProgress {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSurveyProgressWith) > 0 {
		with := make([]predicate.SurveyProgress, 0, len(i.HasSurveyProgressWith))
		for _, w := range i.HasSurveyProgressWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSurveyProgressWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasSurveyProgressWith(with...))
	}
	if i.HasEstimateActivities != nil {
		p := apiuser.HasEstimateActivities()
		if !*i.HasEstimateActivities {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEstimateActivitiesWith) > 0 {
		with := make([]predicate.EstimateActivity, 0, len(i.HasEstimateActivitiesWith))
		for _, w := range i.HasEstimateActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEstimateActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasEstimateActivitiesWith(with...))
	}
	if i.HasUserActivities != nil {
		p := apiuser.HasUserActivities()
		if !*i.HasUserActivities {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserActivitiesWith) > 0 {
		with := make([]predicate.UserActivity, 0, len(i.HasUserActivitiesWith))
		for _, w := range i.HasUserActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasUserActivitiesWith(with...))
	}
	if i.HasPartnerActivities != nil {
		p := apiuser.HasPartnerActivities()
		if !*i.HasPartnerActivities {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerActivitiesWith) > 0 {
		with := make([]predicate.PartnerActivity, 0, len(i.HasPartnerActivitiesWith))
		for _, w := range i.HasPartnerActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasPartnerActivitiesWith(with...))
	}
	if i.HasJobActivities != nil {
		p := apiuser.HasJobActivities()
		if !*i.HasJobActivities {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobActivitiesWith) > 0 {
		with := make([]predicate.JobActivity, 0, len(i.HasJobActivitiesWith))
		for _, w := range i.HasJobActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasJobActivitiesWith(with...))
	}
	if i.HasNotifications != nil {
		p := apiuser.HasNotifications()
		if !*i.HasNotifications {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotificationsWith) > 0 {
		with := make([]predicate.ChannelMessage, 0, len(i.HasNotificationsWith))
		for _, w := range i.HasNotificationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotificationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasNotificationsWith(with...))
	}
	if i.HasJobProgressHistory != nil {
		p := apiuser.HasJobProgressHistory()
		if !*i.HasJobProgressHistory {
			p = apiuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobProgressHistoryWith) > 0 {
		with := make([]predicate.JobProgressHistory, 0, len(i.HasJobProgressHistoryWith))
		for _, w := range i.HasJobProgressHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobProgressHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiuser.HasJobProgressHistoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyApiUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apiuser.And(predicates...), nil
	}
}

// ApiUserTokenWhereInput represents a where input for filtering ApiUserToken queries.
type ApiUserTokenWhereInput struct {
	Predicates []predicate.ApiUserToken  `json:"-"`
	Not        *ApiUserTokenWhereInput   `json:"not,omitempty"`
	Or         []*ApiUserTokenWhereInput `json:"or,omitempty"`
	And        []*ApiUserTokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "token_type" field predicates.
	TokenType             *string  `json:"tokenType,omitempty"`
	TokenTypeNEQ          *string  `json:"tokenTypeNEQ,omitempty"`
	TokenTypeIn           []string `json:"tokenTypeIn,omitempty"`
	TokenTypeNotIn        []string `json:"tokenTypeNotIn,omitempty"`
	TokenTypeGT           *string  `json:"tokenTypeGT,omitempty"`
	TokenTypeGTE          *string  `json:"tokenTypeGTE,omitempty"`
	TokenTypeLT           *string  `json:"tokenTypeLT,omitempty"`
	TokenTypeLTE          *string  `json:"tokenTypeLTE,omitempty"`
	TokenTypeContains     *string  `json:"tokenTypeContains,omitempty"`
	TokenTypeHasPrefix    *string  `json:"tokenTypeHasPrefix,omitempty"`
	TokenTypeHasSuffix    *string  `json:"tokenTypeHasSuffix,omitempty"`
	TokenTypeEqualFold    *string  `json:"tokenTypeEqualFold,omitempty"`
	TokenTypeContainsFold *string  `json:"tokenTypeContainsFold,omitempty"`

	// "token_id" field predicates.
	TokenID             *string  `json:"tokenID,omitempty"`
	TokenIDNEQ          *string  `json:"tokenIDNEQ,omitempty"`
	TokenIDIn           []string `json:"tokenIDIn,omitempty"`
	TokenIDNotIn        []string `json:"tokenIDNotIn,omitempty"`
	TokenIDGT           *string  `json:"tokenIDGT,omitempty"`
	TokenIDGTE          *string  `json:"tokenIDGTE,omitempty"`
	TokenIDLT           *string  `json:"tokenIDLT,omitempty"`
	TokenIDLTE          *string  `json:"tokenIDLTE,omitempty"`
	TokenIDContains     *string  `json:"tokenIDContains,omitempty"`
	TokenIDHasPrefix    *string  `json:"tokenIDHasPrefix,omitempty"`
	TokenIDHasSuffix    *string  `json:"tokenIDHasSuffix,omitempty"`
	TokenIDEqualFold    *string  `json:"tokenIDEqualFold,omitempty"`
	TokenIDContainsFold *string  `json:"tokenIDContainsFold,omitempty"`

	// "refresh_token_id" field predicates.
	RefreshTokenID             *string  `json:"refreshTokenID,omitempty"`
	RefreshTokenIDNEQ          *string  `json:"refreshTokenIDNEQ,omitempty"`
	RefreshTokenIDIn           []string `json:"refreshTokenIDIn,omitempty"`
	RefreshTokenIDNotIn        []string `json:"refreshTokenIDNotIn,omitempty"`
	RefreshTokenIDGT           *string  `json:"refreshTokenIDGT,omitempty"`
	RefreshTokenIDGTE          *string  `json:"refreshTokenIDGTE,omitempty"`
	RefreshTokenIDLT           *string  `json:"refreshTokenIDLT,omitempty"`
	RefreshTokenIDLTE          *string  `json:"refreshTokenIDLTE,omitempty"`
	RefreshTokenIDContains     *string  `json:"refreshTokenIDContains,omitempty"`
	RefreshTokenIDHasPrefix    *string  `json:"refreshTokenIDHasPrefix,omitempty"`
	RefreshTokenIDHasSuffix    *string  `json:"refreshTokenIDHasSuffix,omitempty"`
	RefreshTokenIDEqualFold    *string  `json:"refreshTokenIDEqualFold,omitempty"`
	RefreshTokenIDContainsFold *string  `json:"refreshTokenIDContainsFold,omitempty"`

	// "api_user" edge predicates.
	HasAPIUser     *bool                `json:"hasAPIUser,omitempty"`
	HasAPIUserWith []*ApiUserWhereInput `json:"hasAPIUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ApiUserTokenWhereInput) AddPredicates(predicates ...predicate.ApiUserToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ApiUserTokenWhereInput filter on the ApiUserTokenQuery builder.
func (i *ApiUserTokenWhereInput) Filter(q *ApiUserTokenQuery) (*ApiUserTokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyApiUserTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyApiUserTokenWhereInput is returned in case the ApiUserTokenWhereInput is empty.
var ErrEmptyApiUserTokenWhereInput = errors.New("ent: empty predicate ApiUserTokenWhereInput")

// P returns a predicate for filtering apiusertokens.
// An error is returned if the input is empty or invalid.
func (i *ApiUserTokenWhereInput) P() (predicate.ApiUserToken, error) {
	var predicates []predicate.ApiUserToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apiusertoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ApiUserToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apiusertoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ApiUserToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apiusertoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apiusertoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apiusertoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apiusertoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apiusertoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apiusertoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apiusertoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apiusertoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apiusertoken.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, apiusertoken.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, apiusertoken.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apiusertoken.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apiusertoken.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apiusertoken.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apiusertoken.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apiusertoken.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apiusertoken.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apiusertoken.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apiusertoken.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.TokenType != nil {
		predicates = append(predicates, apiusertoken.TokenTypeEQ(*i.TokenType))
	}
	if i.TokenTypeNEQ != nil {
		predicates = append(predicates, apiusertoken.TokenTypeNEQ(*i.TokenTypeNEQ))
	}
	if len(i.TokenTypeIn) > 0 {
		predicates = append(predicates, apiusertoken.TokenTypeIn(i.TokenTypeIn...))
	}
	if len(i.TokenTypeNotIn) > 0 {
		predicates = append(predicates, apiusertoken.TokenTypeNotIn(i.TokenTypeNotIn...))
	}
	if i.TokenTypeGT != nil {
		predicates = append(predicates, apiusertoken.TokenTypeGT(*i.TokenTypeGT))
	}
	if i.TokenTypeGTE != nil {
		predicates = append(predicates, apiusertoken.TokenTypeGTE(*i.TokenTypeGTE))
	}
	if i.TokenTypeLT != nil {
		predicates = append(predicates, apiusertoken.TokenTypeLT(*i.TokenTypeLT))
	}
	if i.TokenTypeLTE != nil {
		predicates = append(predicates, apiusertoken.TokenTypeLTE(*i.TokenTypeLTE))
	}
	if i.TokenTypeContains != nil {
		predicates = append(predicates, apiusertoken.TokenTypeContains(*i.TokenTypeContains))
	}
	if i.TokenTypeHasPrefix != nil {
		predicates = append(predicates, apiusertoken.TokenTypeHasPrefix(*i.TokenTypeHasPrefix))
	}
	if i.TokenTypeHasSuffix != nil {
		predicates = append(predicates, apiusertoken.TokenTypeHasSuffix(*i.TokenTypeHasSuffix))
	}
	if i.TokenTypeEqualFold != nil {
		predicates = append(predicates, apiusertoken.TokenTypeEqualFold(*i.TokenTypeEqualFold))
	}
	if i.TokenTypeContainsFold != nil {
		predicates = append(predicates, apiusertoken.TokenTypeContainsFold(*i.TokenTypeContainsFold))
	}
	if i.TokenID != nil {
		predicates = append(predicates, apiusertoken.TokenIDEQ(*i.TokenID))
	}
	if i.TokenIDNEQ != nil {
		predicates = append(predicates, apiusertoken.TokenIDNEQ(*i.TokenIDNEQ))
	}
	if len(i.TokenIDIn) > 0 {
		predicates = append(predicates, apiusertoken.TokenIDIn(i.TokenIDIn...))
	}
	if len(i.TokenIDNotIn) > 0 {
		predicates = append(predicates, apiusertoken.TokenIDNotIn(i.TokenIDNotIn...))
	}
	if i.TokenIDGT != nil {
		predicates = append(predicates, apiusertoken.TokenIDGT(*i.TokenIDGT))
	}
	if i.TokenIDGTE != nil {
		predicates = append(predicates, apiusertoken.TokenIDGTE(*i.TokenIDGTE))
	}
	if i.TokenIDLT != nil {
		predicates = append(predicates, apiusertoken.TokenIDLT(*i.TokenIDLT))
	}
	if i.TokenIDLTE != nil {
		predicates = append(predicates, apiusertoken.TokenIDLTE(*i.TokenIDLTE))
	}
	if i.TokenIDContains != nil {
		predicates = append(predicates, apiusertoken.TokenIDContains(*i.TokenIDContains))
	}
	if i.TokenIDHasPrefix != nil {
		predicates = append(predicates, apiusertoken.TokenIDHasPrefix(*i.TokenIDHasPrefix))
	}
	if i.TokenIDHasSuffix != nil {
		predicates = append(predicates, apiusertoken.TokenIDHasSuffix(*i.TokenIDHasSuffix))
	}
	if i.TokenIDEqualFold != nil {
		predicates = append(predicates, apiusertoken.TokenIDEqualFold(*i.TokenIDEqualFold))
	}
	if i.TokenIDContainsFold != nil {
		predicates = append(predicates, apiusertoken.TokenIDContainsFold(*i.TokenIDContainsFold))
	}
	if i.RefreshTokenID != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDEQ(*i.RefreshTokenID))
	}
	if i.RefreshTokenIDNEQ != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDNEQ(*i.RefreshTokenIDNEQ))
	}
	if len(i.RefreshTokenIDIn) > 0 {
		predicates = append(predicates, apiusertoken.RefreshTokenIDIn(i.RefreshTokenIDIn...))
	}
	if len(i.RefreshTokenIDNotIn) > 0 {
		predicates = append(predicates, apiusertoken.RefreshTokenIDNotIn(i.RefreshTokenIDNotIn...))
	}
	if i.RefreshTokenIDGT != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDGT(*i.RefreshTokenIDGT))
	}
	if i.RefreshTokenIDGTE != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDGTE(*i.RefreshTokenIDGTE))
	}
	if i.RefreshTokenIDLT != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDLT(*i.RefreshTokenIDLT))
	}
	if i.RefreshTokenIDLTE != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDLTE(*i.RefreshTokenIDLTE))
	}
	if i.RefreshTokenIDContains != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDContains(*i.RefreshTokenIDContains))
	}
	if i.RefreshTokenIDHasPrefix != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDHasPrefix(*i.RefreshTokenIDHasPrefix))
	}
	if i.RefreshTokenIDHasSuffix != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDHasSuffix(*i.RefreshTokenIDHasSuffix))
	}
	if i.RefreshTokenIDEqualFold != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDEqualFold(*i.RefreshTokenIDEqualFold))
	}
	if i.RefreshTokenIDContainsFold != nil {
		predicates = append(predicates, apiusertoken.RefreshTokenIDContainsFold(*i.RefreshTokenIDContainsFold))
	}

	if i.HasAPIUser != nil {
		p := apiusertoken.HasAPIUser()
		if !*i.HasAPIUser {
			p = apiusertoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIUserWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasAPIUserWith))
		for _, w := range i.HasAPIUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apiusertoken.HasAPIUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyApiUserTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apiusertoken.And(predicates...), nil
	}
}

// AuditLogWhereInput represents a where input for filtering AuditLog queries.
type AuditLogWhereInput struct {
	Predicates []predicate.AuditLog  `json:"-"`
	Not        *AuditLogWhereInput   `json:"not,omitempty"`
	Or         []*AuditLogWhereInput `json:"or,omitempty"`
	And        []*AuditLogWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "action" field predicates.
	Action             *string  `json:"action,omitempty"`
	ActionNEQ          *string  `json:"actionNEQ,omitempty"`
	ActionIn           []string `json:"actionIn,omitempty"`
	ActionNotIn        []string `json:"actionNotIn,omitempty"`
	ActionGT           *string  `json:"actionGT,omitempty"`
	ActionGTE          *string  `json:"actionGTE,omitempty"`
	ActionLT           *string  `json:"actionLT,omitempty"`
	ActionLTE          *string  `json:"actionLTE,omitempty"`
	ActionContains     *string  `json:"actionContains,omitempty"`
	ActionHasPrefix    *string  `json:"actionHasPrefix,omitempty"`
	ActionHasSuffix    *string  `json:"actionHasSuffix,omitempty"`
	ActionEqualFold    *string  `json:"actionEqualFold,omitempty"`
	ActionContainsFold *string  `json:"actionContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "ip" field predicates.
	IP             *string  `json:"ip,omitempty"`
	IPNEQ          *string  `json:"ipNEQ,omitempty"`
	IPIn           []string `json:"ipIn,omitempty"`
	IPNotIn        []string `json:"ipNotIn,omitempty"`
	IPGT           *string  `json:"ipGT,omitempty"`
	IPGTE          *string  `json:"ipGTE,omitempty"`
	IPLT           *string  `json:"ipLT,omitempty"`
	IPLTE          *string  `json:"ipLTE,omitempty"`
	IPContains     *string  `json:"ipContains,omitempty"`
	IPHasPrefix    *string  `json:"ipHasPrefix,omitempty"`
	IPHasSuffix    *string  `json:"ipHasSuffix,omitempty"`
	IPIsNil        bool     `json:"ipIsNil,omitempty"`
	IPNotNil       bool     `json:"ipNotNil,omitempty"`
	IPEqualFold    *string  `json:"ipEqualFold,omitempty"`
	IPContainsFold *string  `json:"ipContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "api_user" edge predicates.
	HasAPIUser     *bool                `json:"hasAPIUser,omitempty"`
	HasAPIUserWith []*ApiUserWhereInput `json:"hasAPIUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AuditLogWhereInput) AddPredicates(predicates ...predicate.AuditLog) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AuditLogWhereInput filter on the AuditLogQuery builder.
func (i *AuditLogWhereInput) Filter(q *AuditLogQuery) (*AuditLogQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAuditLogWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAuditLogWhereInput is returned in case the AuditLogWhereInput is empty.
var ErrEmptyAuditLogWhereInput = errors.New("ent: empty predicate AuditLogWhereInput")

// P returns a predicate for filtering auditlogs.
// An error is returned if the input is empty or invalid.
func (i *AuditLogWhereInput) P() (predicate.AuditLog, error) {
	var predicates []predicate.AuditLog
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, auditlog.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AuditLog, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, auditlog.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AuditLog, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, auditlog.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, auditlog.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, auditlog.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, auditlog.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, auditlog.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, auditlog.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, auditlog.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, auditlog.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, auditlog.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, auditlog.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, auditlog.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, auditlog.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, auditlog.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, auditlog.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, auditlog.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, auditlog.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, auditlog.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, auditlog.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, auditlog.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Action != nil {
		predicates = append(predicates, auditlog.ActionEQ(*i.Action))
	}
	if i.ActionNEQ != nil {
		predicates = append(predicates, auditlog.ActionNEQ(*i.ActionNEQ))
	}
	if len(i.ActionIn) > 0 {
		predicates = append(predicates, auditlog.ActionIn(i.ActionIn...))
	}
	if len(i.ActionNotIn) > 0 {
		predicates = append(predicates, auditlog.ActionNotIn(i.ActionNotIn...))
	}
	if i.ActionGT != nil {
		predicates = append(predicates, auditlog.ActionGT(*i.ActionGT))
	}
	if i.ActionGTE != nil {
		predicates = append(predicates, auditlog.ActionGTE(*i.ActionGTE))
	}
	if i.ActionLT != nil {
		predicates = append(predicates, auditlog.ActionLT(*i.ActionLT))
	}
	if i.ActionLTE != nil {
		predicates = append(predicates, auditlog.ActionLTE(*i.ActionLTE))
	}
	if i.ActionContains != nil {
		predicates = append(predicates, auditlog.ActionContains(*i.ActionContains))
	}
	if i.ActionHasPrefix != nil {
		predicates = append(predicates, auditlog.ActionHasPrefix(*i.ActionHasPrefix))
	}
	if i.ActionHasSuffix != nil {
		predicates = append(predicates, auditlog.ActionHasSuffix(*i.ActionHasSuffix))
	}
	if i.ActionEqualFold != nil {
		predicates = append(predicates, auditlog.ActionEqualFold(*i.ActionEqualFold))
	}
	if i.ActionContainsFold != nil {
		predicates = append(predicates, auditlog.ActionContainsFold(*i.ActionContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, auditlog.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, auditlog.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, auditlog.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, auditlog.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, auditlog.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, auditlog.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, auditlog.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, auditlog.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, auditlog.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, auditlog.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, auditlog.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, auditlog.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, auditlog.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, auditlog.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, auditlog.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.IP != nil {
		predicates = append(predicates, auditlog.IPEQ(*i.IP))
	}
	if i.IPNEQ != nil {
		predicates = append(predicates, auditlog.IPNEQ(*i.IPNEQ))
	}
	if len(i.IPIn) > 0 {
		predicates = append(predicates, auditlog.IPIn(i.IPIn...))
	}
	if len(i.IPNotIn) > 0 {
		predicates = append(predicates, auditlog.IPNotIn(i.IPNotIn...))
	}
	if i.IPGT != nil {
		predicates = append(predicates, auditlog.IPGT(*i.IPGT))
	}
	if i.IPGTE != nil {
		predicates = append(predicates, auditlog.IPGTE(*i.IPGTE))
	}
	if i.IPLT != nil {
		predicates = append(predicates, auditlog.IPLT(*i.IPLT))
	}
	if i.IPLTE != nil {
		predicates = append(predicates, auditlog.IPLTE(*i.IPLTE))
	}
	if i.IPContains != nil {
		predicates = append(predicates, auditlog.IPContains(*i.IPContains))
	}
	if i.IPHasPrefix != nil {
		predicates = append(predicates, auditlog.IPHasPrefix(*i.IPHasPrefix))
	}
	if i.IPHasSuffix != nil {
		predicates = append(predicates, auditlog.IPHasSuffix(*i.IPHasSuffix))
	}
	if i.IPIsNil {
		predicates = append(predicates, auditlog.IPIsNil())
	}
	if i.IPNotNil {
		predicates = append(predicates, auditlog.IPNotNil())
	}
	if i.IPEqualFold != nil {
		predicates = append(predicates, auditlog.IPEqualFold(*i.IPEqualFold))
	}
	if i.IPContainsFold != nil {
		predicates = append(predicates, auditlog.IPContainsFold(*i.IPContainsFold))
	}

	if i.HasUser != nil {
		p := auditlog.HasUser()
		if !*i.HasUser {
			p = auditlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, auditlog.HasUserWith(with...))
	}
	if i.HasAPIUser != nil {
		p := auditlog.HasAPIUser()
		if !*i.HasAPIUser {
			p = auditlog.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPIUserWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasAPIUserWith))
		for _, w := range i.HasAPIUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPIUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, auditlog.HasAPIUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAuditLogWhereInput
	case 1:
		return predicates[0], nil
	default:
		return auditlog.And(predicates...), nil
	}
}

// ChannelWhereInput represents a where input for filtering Channel queries.
type ChannelWhereInput struct {
	Predicates []predicate.Channel  `json:"-"`
	Not        *ChannelWhereInput   `json:"not,omitempty"`
	Or         []*ChannelWhereInput `json:"or,omitempty"`
	And        []*ChannelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name      *enum.Channel  `json:"name,omitempty"`
	NameNEQ   *enum.Channel  `json:"nameNEQ,omitempty"`
	NameIn    []enum.Channel `json:"nameIn,omitempty"`
	NameNotIn []enum.Channel `json:"nameNotIn,omitempty"`

	// "topic" field predicates.
	Topic      *enum.Topic  `json:"topic,omitempty"`
	TopicNEQ   *enum.Topic  `json:"topicNEQ,omitempty"`
	TopicIn    []enum.Topic `json:"topicIn,omitempty"`
	TopicNotIn []enum.Topic `json:"topicNotIn,omitempty"`

	// "ref_id" field predicates.
	RefID             *string  `json:"refID,omitempty"`
	RefIDNEQ          *string  `json:"refIDNEQ,omitempty"`
	RefIDIn           []string `json:"refIDIn,omitempty"`
	RefIDNotIn        []string `json:"refIDNotIn,omitempty"`
	RefIDGT           *string  `json:"refIDGT,omitempty"`
	RefIDGTE          *string  `json:"refIDGTE,omitempty"`
	RefIDLT           *string  `json:"refIDLT,omitempty"`
	RefIDLTE          *string  `json:"refIDLTE,omitempty"`
	RefIDContains     *string  `json:"refIDContains,omitempty"`
	RefIDHasPrefix    *string  `json:"refIDHasPrefix,omitempty"`
	RefIDHasSuffix    *string  `json:"refIDHasSuffix,omitempty"`
	RefIDIsNil        bool     `json:"refIDIsNil,omitempty"`
	RefIDNotNil       bool     `json:"refIDNotNil,omitempty"`
	RefIDEqualFold    *string  `json:"refIDEqualFold,omitempty"`
	RefIDContainsFold *string  `json:"refIDContainsFold,omitempty"`

	// "subscriptions" edge predicates.
	HasSubscriptions     *bool                   `json:"hasSubscriptions,omitempty"`
	HasSubscriptionsWith []*ChannelSubWhereInput `json:"hasSubscriptionsWith,omitempty"`

	// "messages" edge predicates.
	HasMessages     *bool                       `json:"hasMessages,omitempty"`
	HasMessagesWith []*ChannelMessageWhereInput `json:"hasMessagesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelWhereInput) AddPredicates(predicates ...predicate.Channel) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelWhereInput filter on the ChannelQuery builder.
func (i *ChannelWhereInput) Filter(q *ChannelQuery) (*ChannelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelWhereInput is returned in case the ChannelWhereInput is empty.
var ErrEmptyChannelWhereInput = errors.New("ent: empty predicate ChannelWhereInput")

// P returns a predicate for filtering channels.
// An error is returned if the input is empty or invalid.
func (i *ChannelWhereInput) P() (predicate.Channel, error) {
	var predicates []predicate.Channel
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channel.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Channel, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channel.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Channel, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channel.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channel.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channel.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channel.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channel.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channel.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channel.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channel.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channel.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, channel.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, channel.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channel.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channel.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channel.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channel.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channel.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channel.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channel.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channel.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channel.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channel.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channel.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channel.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channel.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channel.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channel.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channel.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, channel.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, channel.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, channel.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, channel.NameNotIn(i.NameNotIn...))
	}
	if i.Topic != nil {
		predicates = append(predicates, channel.TopicEQ(*i.Topic))
	}
	if i.TopicNEQ != nil {
		predicates = append(predicates, channel.TopicNEQ(*i.TopicNEQ))
	}
	if len(i.TopicIn) > 0 {
		predicates = append(predicates, channel.TopicIn(i.TopicIn...))
	}
	if len(i.TopicNotIn) > 0 {
		predicates = append(predicates, channel.TopicNotIn(i.TopicNotIn...))
	}
	if i.RefID != nil {
		predicates = append(predicates, channel.RefIDEQ(*i.RefID))
	}
	if i.RefIDNEQ != nil {
		predicates = append(predicates, channel.RefIDNEQ(*i.RefIDNEQ))
	}
	if len(i.RefIDIn) > 0 {
		predicates = append(predicates, channel.RefIDIn(i.RefIDIn...))
	}
	if len(i.RefIDNotIn) > 0 {
		predicates = append(predicates, channel.RefIDNotIn(i.RefIDNotIn...))
	}
	if i.RefIDGT != nil {
		predicates = append(predicates, channel.RefIDGT(*i.RefIDGT))
	}
	if i.RefIDGTE != nil {
		predicates = append(predicates, channel.RefIDGTE(*i.RefIDGTE))
	}
	if i.RefIDLT != nil {
		predicates = append(predicates, channel.RefIDLT(*i.RefIDLT))
	}
	if i.RefIDLTE != nil {
		predicates = append(predicates, channel.RefIDLTE(*i.RefIDLTE))
	}
	if i.RefIDContains != nil {
		predicates = append(predicates, channel.RefIDContains(*i.RefIDContains))
	}
	if i.RefIDHasPrefix != nil {
		predicates = append(predicates, channel.RefIDHasPrefix(*i.RefIDHasPrefix))
	}
	if i.RefIDHasSuffix != nil {
		predicates = append(predicates, channel.RefIDHasSuffix(*i.RefIDHasSuffix))
	}
	if i.RefIDIsNil {
		predicates = append(predicates, channel.RefIDIsNil())
	}
	if i.RefIDNotNil {
		predicates = append(predicates, channel.RefIDNotNil())
	}
	if i.RefIDEqualFold != nil {
		predicates = append(predicates, channel.RefIDEqualFold(*i.RefIDEqualFold))
	}
	if i.RefIDContainsFold != nil {
		predicates = append(predicates, channel.RefIDContainsFold(*i.RefIDContainsFold))
	}

	if i.HasSubscriptions != nil {
		p := channel.HasSubscriptions()
		if !*i.HasSubscriptions {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSubscriptionsWith) > 0 {
		with := make([]predicate.ChannelSub, 0, len(i.HasSubscriptionsWith))
		for _, w := range i.HasSubscriptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSubscriptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasSubscriptionsWith(with...))
	}
	if i.HasMessages != nil {
		p := channel.HasMessages()
		if !*i.HasMessages {
			p = channel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasMessagesWith) > 0 {
		with := make([]predicate.ChannelMessage, 0, len(i.HasMessagesWith))
		for _, w := range i.HasMessagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasMessagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channel.HasMessagesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channel.And(predicates...), nil
	}
}

// ChannelMessageWhereInput represents a where input for filtering ChannelMessage queries.
type ChannelMessageWhereInput struct {
	Predicates []predicate.ChannelMessage  `json:"-"`
	Not        *ChannelMessageWhereInput   `json:"not,omitempty"`
	Or         []*ChannelMessageWhereInput `json:"or,omitempty"`
	And        []*ChannelMessageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "message" field predicates.
	Message             *string  `json:"message,omitempty"`
	MessageNEQ          *string  `json:"messageNEQ,omitempty"`
	MessageIn           []string `json:"messageIn,omitempty"`
	MessageNotIn        []string `json:"messageNotIn,omitempty"`
	MessageGT           *string  `json:"messageGT,omitempty"`
	MessageGTE          *string  `json:"messageGTE,omitempty"`
	MessageLT           *string  `json:"messageLT,omitempty"`
	MessageLTE          *string  `json:"messageLTE,omitempty"`
	MessageContains     *string  `json:"messageContains,omitempty"`
	MessageHasPrefix    *string  `json:"messageHasPrefix,omitempty"`
	MessageHasSuffix    *string  `json:"messageHasSuffix,omitempty"`
	MessageEqualFold    *string  `json:"messageEqualFold,omitempty"`
	MessageContainsFold *string  `json:"messageContainsFold,omitempty"`

	// "from_name" field predicates.
	FromName             *string  `json:"fromName,omitempty"`
	FromNameNEQ          *string  `json:"fromNameNEQ,omitempty"`
	FromNameIn           []string `json:"fromNameIn,omitempty"`
	FromNameNotIn        []string `json:"fromNameNotIn,omitempty"`
	FromNameGT           *string  `json:"fromNameGT,omitempty"`
	FromNameGTE          *string  `json:"fromNameGTE,omitempty"`
	FromNameLT           *string  `json:"fromNameLT,omitempty"`
	FromNameLTE          *string  `json:"fromNameLTE,omitempty"`
	FromNameContains     *string  `json:"fromNameContains,omitempty"`
	FromNameHasPrefix    *string  `json:"fromNameHasPrefix,omitempty"`
	FromNameHasSuffix    *string  `json:"fromNameHasSuffix,omitempty"`
	FromNameEqualFold    *string  `json:"fromNameEqualFold,omitempty"`
	FromNameContainsFold *string  `json:"fromNameContainsFold,omitempty"`

	// "to_name" field predicates.
	ToName             *string  `json:"toName,omitempty"`
	ToNameNEQ          *string  `json:"toNameNEQ,omitempty"`
	ToNameIn           []string `json:"toNameIn,omitempty"`
	ToNameNotIn        []string `json:"toNameNotIn,omitempty"`
	ToNameGT           *string  `json:"toNameGT,omitempty"`
	ToNameGTE          *string  `json:"toNameGTE,omitempty"`
	ToNameLT           *string  `json:"toNameLT,omitempty"`
	ToNameLTE          *string  `json:"toNameLTE,omitempty"`
	ToNameContains     *string  `json:"toNameContains,omitempty"`
	ToNameHasPrefix    *string  `json:"toNameHasPrefix,omitempty"`
	ToNameHasSuffix    *string  `json:"toNameHasSuffix,omitempty"`
	ToNameIsNil        bool     `json:"toNameIsNil,omitempty"`
	ToNameNotNil       bool     `json:"toNameNotNil,omitempty"`
	ToNameEqualFold    *string  `json:"toNameEqualFold,omitempty"`
	ToNameContainsFold *string  `json:"toNameContainsFold,omitempty"`

	// "private" field predicates.
	Private    *bool `json:"private,omitempty"`
	PrivateNEQ *bool `json:"privateNEQ,omitempty"`

	// "unread" field predicates.
	Unread       *bool `json:"unread,omitempty"`
	UnreadNEQ    *bool `json:"unreadNEQ,omitempty"`
	UnreadIsNil  bool  `json:"unreadIsNil,omitempty"`
	UnreadNotNil bool  `json:"unreadNotNil,omitempty"`

	// "reads" edge predicates.
	HasReads     *bool                           `json:"hasReads,omitempty"`
	HasReadsWith []*ChannelMessageReadWhereInput `json:"hasReadsWith,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`

	// "from" edge predicates.
	HasFrom     *bool             `json:"hasFrom,omitempty"`
	HasFromWith []*UserWhereInput `json:"hasFromWith,omitempty"`

	// "from_api_user" edge predicates.
	HasFromAPIUser     *bool                `json:"hasFromAPIUser,omitempty"`
	HasFromAPIUserWith []*ApiUserWhereInput `json:"hasFromAPIUserWith,omitempty"`

	// "to" edge predicates.
	HasTo     *bool             `json:"hasTo,omitempty"`
	HasToWith []*UserWhereInput `json:"hasToWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelMessageWhereInput) AddPredicates(predicates ...predicate.ChannelMessage) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelMessageWhereInput filter on the ChannelMessageQuery builder.
func (i *ChannelMessageWhereInput) Filter(q *ChannelMessageQuery) (*ChannelMessageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelMessageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelMessageWhereInput is returned in case the ChannelMessageWhereInput is empty.
var ErrEmptyChannelMessageWhereInput = errors.New("ent: empty predicate ChannelMessageWhereInput")

// P returns a predicate for filtering channelmessages.
// An error is returned if the input is empty or invalid.
func (i *ChannelMessageWhereInput) P() (predicate.ChannelMessage, error) {
	var predicates []predicate.ChannelMessage
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channelmessage.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ChannelMessage, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channelmessage.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ChannelMessage, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channelmessage.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channelmessage.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channelmessage.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channelmessage.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channelmessage.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channelmessage.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channelmessage.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channelmessage.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channelmessage.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, channelmessage.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, channelmessage.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channelmessage.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channelmessage.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channelmessage.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channelmessage.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channelmessage.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channelmessage.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channelmessage.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channelmessage.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channelmessage.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channelmessage.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channelmessage.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channelmessage.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channelmessage.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channelmessage.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channelmessage.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channelmessage.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Title != nil {
		predicates = append(predicates, channelmessage.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, channelmessage.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, channelmessage.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, channelmessage.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, channelmessage.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, channelmessage.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, channelmessage.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, channelmessage.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, channelmessage.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, channelmessage.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, channelmessage.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, channelmessage.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, channelmessage.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, channelmessage.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, channelmessage.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Message != nil {
		predicates = append(predicates, channelmessage.MessageEQ(*i.Message))
	}
	if i.MessageNEQ != nil {
		predicates = append(predicates, channelmessage.MessageNEQ(*i.MessageNEQ))
	}
	if len(i.MessageIn) > 0 {
		predicates = append(predicates, channelmessage.MessageIn(i.MessageIn...))
	}
	if len(i.MessageNotIn) > 0 {
		predicates = append(predicates, channelmessage.MessageNotIn(i.MessageNotIn...))
	}
	if i.MessageGT != nil {
		predicates = append(predicates, channelmessage.MessageGT(*i.MessageGT))
	}
	if i.MessageGTE != nil {
		predicates = append(predicates, channelmessage.MessageGTE(*i.MessageGTE))
	}
	if i.MessageLT != nil {
		predicates = append(predicates, channelmessage.MessageLT(*i.MessageLT))
	}
	if i.MessageLTE != nil {
		predicates = append(predicates, channelmessage.MessageLTE(*i.MessageLTE))
	}
	if i.MessageContains != nil {
		predicates = append(predicates, channelmessage.MessageContains(*i.MessageContains))
	}
	if i.MessageHasPrefix != nil {
		predicates = append(predicates, channelmessage.MessageHasPrefix(*i.MessageHasPrefix))
	}
	if i.MessageHasSuffix != nil {
		predicates = append(predicates, channelmessage.MessageHasSuffix(*i.MessageHasSuffix))
	}
	if i.MessageEqualFold != nil {
		predicates = append(predicates, channelmessage.MessageEqualFold(*i.MessageEqualFold))
	}
	if i.MessageContainsFold != nil {
		predicates = append(predicates, channelmessage.MessageContainsFold(*i.MessageContainsFold))
	}
	if i.FromName != nil {
		predicates = append(predicates, channelmessage.FromNameEQ(*i.FromName))
	}
	if i.FromNameNEQ != nil {
		predicates = append(predicates, channelmessage.FromNameNEQ(*i.FromNameNEQ))
	}
	if len(i.FromNameIn) > 0 {
		predicates = append(predicates, channelmessage.FromNameIn(i.FromNameIn...))
	}
	if len(i.FromNameNotIn) > 0 {
		predicates = append(predicates, channelmessage.FromNameNotIn(i.FromNameNotIn...))
	}
	if i.FromNameGT != nil {
		predicates = append(predicates, channelmessage.FromNameGT(*i.FromNameGT))
	}
	if i.FromNameGTE != nil {
		predicates = append(predicates, channelmessage.FromNameGTE(*i.FromNameGTE))
	}
	if i.FromNameLT != nil {
		predicates = append(predicates, channelmessage.FromNameLT(*i.FromNameLT))
	}
	if i.FromNameLTE != nil {
		predicates = append(predicates, channelmessage.FromNameLTE(*i.FromNameLTE))
	}
	if i.FromNameContains != nil {
		predicates = append(predicates, channelmessage.FromNameContains(*i.FromNameContains))
	}
	if i.FromNameHasPrefix != nil {
		predicates = append(predicates, channelmessage.FromNameHasPrefix(*i.FromNameHasPrefix))
	}
	if i.FromNameHasSuffix != nil {
		predicates = append(predicates, channelmessage.FromNameHasSuffix(*i.FromNameHasSuffix))
	}
	if i.FromNameEqualFold != nil {
		predicates = append(predicates, channelmessage.FromNameEqualFold(*i.FromNameEqualFold))
	}
	if i.FromNameContainsFold != nil {
		predicates = append(predicates, channelmessage.FromNameContainsFold(*i.FromNameContainsFold))
	}
	if i.ToName != nil {
		predicates = append(predicates, channelmessage.ToNameEQ(*i.ToName))
	}
	if i.ToNameNEQ != nil {
		predicates = append(predicates, channelmessage.ToNameNEQ(*i.ToNameNEQ))
	}
	if len(i.ToNameIn) > 0 {
		predicates = append(predicates, channelmessage.ToNameIn(i.ToNameIn...))
	}
	if len(i.ToNameNotIn) > 0 {
		predicates = append(predicates, channelmessage.ToNameNotIn(i.ToNameNotIn...))
	}
	if i.ToNameGT != nil {
		predicates = append(predicates, channelmessage.ToNameGT(*i.ToNameGT))
	}
	if i.ToNameGTE != nil {
		predicates = append(predicates, channelmessage.ToNameGTE(*i.ToNameGTE))
	}
	if i.ToNameLT != nil {
		predicates = append(predicates, channelmessage.ToNameLT(*i.ToNameLT))
	}
	if i.ToNameLTE != nil {
		predicates = append(predicates, channelmessage.ToNameLTE(*i.ToNameLTE))
	}
	if i.ToNameContains != nil {
		predicates = append(predicates, channelmessage.ToNameContains(*i.ToNameContains))
	}
	if i.ToNameHasPrefix != nil {
		predicates = append(predicates, channelmessage.ToNameHasPrefix(*i.ToNameHasPrefix))
	}
	if i.ToNameHasSuffix != nil {
		predicates = append(predicates, channelmessage.ToNameHasSuffix(*i.ToNameHasSuffix))
	}
	if i.ToNameIsNil {
		predicates = append(predicates, channelmessage.ToNameIsNil())
	}
	if i.ToNameNotNil {
		predicates = append(predicates, channelmessage.ToNameNotNil())
	}
	if i.ToNameEqualFold != nil {
		predicates = append(predicates, channelmessage.ToNameEqualFold(*i.ToNameEqualFold))
	}
	if i.ToNameContainsFold != nil {
		predicates = append(predicates, channelmessage.ToNameContainsFold(*i.ToNameContainsFold))
	}
	if i.Private != nil {
		predicates = append(predicates, channelmessage.PrivateEQ(*i.Private))
	}
	if i.PrivateNEQ != nil {
		predicates = append(predicates, channelmessage.PrivateNEQ(*i.PrivateNEQ))
	}
	if i.Unread != nil {
		predicates = append(predicates, channelmessage.UnreadEQ(*i.Unread))
	}
	if i.UnreadNEQ != nil {
		predicates = append(predicates, channelmessage.UnreadNEQ(*i.UnreadNEQ))
	}
	if i.UnreadIsNil {
		predicates = append(predicates, channelmessage.UnreadIsNil())
	}
	if i.UnreadNotNil {
		predicates = append(predicates, channelmessage.UnreadNotNil())
	}

	if i.HasReads != nil {
		p := channelmessage.HasReads()
		if !*i.HasReads {
			p = channelmessage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReadsWith) > 0 {
		with := make([]predicate.ChannelMessageRead, 0, len(i.HasReadsWith))
		for _, w := range i.HasReadsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReadsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelmessage.HasReadsWith(with...))
	}
	if i.HasChannel != nil {
		p := channelmessage.HasChannel()
		if !*i.HasChannel {
			p = channelmessage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelmessage.HasChannelWith(with...))
	}
	if i.HasFrom != nil {
		p := channelmessage.HasFrom()
		if !*i.HasFrom {
			p = channelmessage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFromWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasFromWith))
		for _, w := range i.HasFromWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFromWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelmessage.HasFromWith(with...))
	}
	if i.HasFromAPIUser != nil {
		p := channelmessage.HasFromAPIUser()
		if !*i.HasFromAPIUser {
			p = channelmessage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFromAPIUserWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasFromAPIUserWith))
		for _, w := range i.HasFromAPIUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFromAPIUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelmessage.HasFromAPIUserWith(with...))
	}
	if i.HasTo != nil {
		p := channelmessage.HasTo()
		if !*i.HasTo {
			p = channelmessage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasToWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasToWith))
		for _, w := range i.HasToWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasToWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelmessage.HasToWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelMessageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channelmessage.And(predicates...), nil
	}
}

// ChannelMessageReadWhereInput represents a where input for filtering ChannelMessageRead queries.
type ChannelMessageReadWhereInput struct {
	Predicates []predicate.ChannelMessageRead  `json:"-"`
	Not        *ChannelMessageReadWhereInput   `json:"not,omitempty"`
	Or         []*ChannelMessageReadWhereInput `json:"or,omitempty"`
	And        []*ChannelMessageReadWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "read" field predicates.
	Read    *bool `json:"read,omitempty"`
	ReadNEQ *bool `json:"readNEQ,omitempty"`

	// "channel_message" edge predicates.
	HasChannelMessage     *bool                       `json:"hasChannelMessage,omitempty"`
	HasChannelMessageWith []*ChannelMessageWhereInput `json:"hasChannelMessageWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelMessageReadWhereInput) AddPredicates(predicates ...predicate.ChannelMessageRead) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelMessageReadWhereInput filter on the ChannelMessageReadQuery builder.
func (i *ChannelMessageReadWhereInput) Filter(q *ChannelMessageReadQuery) (*ChannelMessageReadQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelMessageReadWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelMessageReadWhereInput is returned in case the ChannelMessageReadWhereInput is empty.
var ErrEmptyChannelMessageReadWhereInput = errors.New("ent: empty predicate ChannelMessageReadWhereInput")

// P returns a predicate for filtering channelmessagereads.
// An error is returned if the input is empty or invalid.
func (i *ChannelMessageReadWhereInput) P() (predicate.ChannelMessageRead, error) {
	var predicates []predicate.ChannelMessageRead
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channelmessageread.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ChannelMessageRead, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channelmessageread.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ChannelMessageRead, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channelmessageread.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channelmessageread.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channelmessageread.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channelmessageread.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channelmessageread.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channelmessageread.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channelmessageread.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channelmessageread.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channelmessageread.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, channelmessageread.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, channelmessageread.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channelmessageread.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channelmessageread.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channelmessageread.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channelmessageread.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channelmessageread.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channelmessageread.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channelmessageread.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channelmessageread.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Read != nil {
		predicates = append(predicates, channelmessageread.ReadEQ(*i.Read))
	}
	if i.ReadNEQ != nil {
		predicates = append(predicates, channelmessageread.ReadNEQ(*i.ReadNEQ))
	}

	if i.HasChannelMessage != nil {
		p := channelmessageread.HasChannelMessage()
		if !*i.HasChannelMessage {
			p = channelmessageread.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelMessageWith) > 0 {
		with := make([]predicate.ChannelMessage, 0, len(i.HasChannelMessageWith))
		for _, w := range i.HasChannelMessageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelMessageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelmessageread.HasChannelMessageWith(with...))
	}
	if i.HasUser != nil {
		p := channelmessageread.HasUser()
		if !*i.HasUser {
			p = channelmessageread.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelmessageread.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelMessageReadWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channelmessageread.And(predicates...), nil
	}
}

// ChannelSubWhereInput represents a where input for filtering ChannelSub queries.
type ChannelSubWhereInput struct {
	Predicates []predicate.ChannelSub  `json:"-"`
	Not        *ChannelSubWhereInput   `json:"not,omitempty"`
	Or         []*ChannelSubWhereInput `json:"or,omitempty"`
	And        []*ChannelSubWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "role" field predicates.
	Role       *enum.Role  `json:"role,omitempty"`
	RoleNEQ    *enum.Role  `json:"roleNEQ,omitempty"`
	RoleIn     []enum.Role `json:"roleIn,omitempty"`
	RoleNotIn  []enum.Role `json:"roleNotIn,omitempty"`
	RoleIsNil  bool        `json:"roleIsNil,omitempty"`
	RoleNotNil bool        `json:"roleNotNil,omitempty"`

	// "channel" edge predicates.
	HasChannel     *bool                `json:"hasChannel,omitempty"`
	HasChannelWith []*ChannelWhereInput `json:"hasChannelWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChannelSubWhereInput) AddPredicates(predicates ...predicate.ChannelSub) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChannelSubWhereInput filter on the ChannelSubQuery builder.
func (i *ChannelSubWhereInput) Filter(q *ChannelSubQuery) (*ChannelSubQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChannelSubWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChannelSubWhereInput is returned in case the ChannelSubWhereInput is empty.
var ErrEmptyChannelSubWhereInput = errors.New("ent: empty predicate ChannelSubWhereInput")

// P returns a predicate for filtering channelsubs.
// An error is returned if the input is empty or invalid.
func (i *ChannelSubWhereInput) P() (predicate.ChannelSub, error) {
	var predicates []predicate.ChannelSub
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, channelsub.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ChannelSub, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, channelsub.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ChannelSub, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, channelsub.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, channelsub.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, channelsub.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, channelsub.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, channelsub.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, channelsub.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, channelsub.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, channelsub.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, channelsub.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, channelsub.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, channelsub.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, channelsub.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, channelsub.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, channelsub.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, channelsub.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, channelsub.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, channelsub.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, channelsub.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, channelsub.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, channelsub.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, channelsub.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, channelsub.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, channelsub.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, channelsub.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, channelsub.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, channelsub.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, channelsub.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Role != nil {
		predicates = append(predicates, channelsub.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, channelsub.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, channelsub.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, channelsub.RoleNotIn(i.RoleNotIn...))
	}
	if i.RoleIsNil {
		predicates = append(predicates, channelsub.RoleIsNil())
	}
	if i.RoleNotNil {
		predicates = append(predicates, channelsub.RoleNotNil())
	}

	if i.HasChannel != nil {
		p := channelsub.HasChannel()
		if !*i.HasChannel {
			p = channelsub.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelWith) > 0 {
		with := make([]predicate.Channel, 0, len(i.HasChannelWith))
		for _, w := range i.HasChannelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelsub.HasChannelWith(with...))
	}
	if i.HasUser != nil {
		p := channelsub.HasUser()
		if !*i.HasUser {
			p = channelsub.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelsub.HasUserWith(with...))
	}
	if i.HasPartner != nil {
		p := channelsub.HasPartner()
		if !*i.HasPartner {
			p = channelsub.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, channelsub.HasPartnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChannelSubWhereInput
	case 1:
		return predicates[0], nil
	default:
		return channelsub.And(predicates...), nil
	}
}

// ContactUsWhereInput represents a where input for filtering ContactUs queries.
type ContactUsWhereInput struct {
	Predicates []predicate.ContactUs  `json:"-"`
	Not        *ContactUsWhereInput   `json:"not,omitempty"`
	Or         []*ContactUsWhereInput `json:"or,omitempty"`
	And        []*ContactUsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "reason" field predicates.
	Reason             *string  `json:"reason,omitempty"`
	ReasonNEQ          *string  `json:"reasonNEQ,omitempty"`
	ReasonIn           []string `json:"reasonIn,omitempty"`
	ReasonNotIn        []string `json:"reasonNotIn,omitempty"`
	ReasonGT           *string  `json:"reasonGT,omitempty"`
	ReasonGTE          *string  `json:"reasonGTE,omitempty"`
	ReasonLT           *string  `json:"reasonLT,omitempty"`
	ReasonLTE          *string  `json:"reasonLTE,omitempty"`
	ReasonContains     *string  `json:"reasonContains,omitempty"`
	ReasonHasPrefix    *string  `json:"reasonHasPrefix,omitempty"`
	ReasonHasSuffix    *string  `json:"reasonHasSuffix,omitempty"`
	ReasonEqualFold    *string  `json:"reasonEqualFold,omitempty"`
	ReasonContainsFold *string  `json:"reasonContainsFold,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContactUsWhereInput) AddPredicates(predicates ...predicate.ContactUs) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContactUsWhereInput filter on the ContactUsQuery builder.
func (i *ContactUsWhereInput) Filter(q *ContactUsQuery) (*ContactUsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContactUsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContactUsWhereInput is returned in case the ContactUsWhereInput is empty.
var ErrEmptyContactUsWhereInput = errors.New("ent: empty predicate ContactUsWhereInput")

// P returns a predicate for filtering contactusslice.
// An error is returned if the input is empty or invalid.
func (i *ContactUsWhereInput) P() (predicate.ContactUs, error) {
	var predicates []predicate.ContactUs
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, contactus.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ContactUs, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, contactus.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ContactUs, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, contactus.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, contactus.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, contactus.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, contactus.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, contactus.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, contactus.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, contactus.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, contactus.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, contactus.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, contactus.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, contactus.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, contactus.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, contactus.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, contactus.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, contactus.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, contactus.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, contactus.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, contactus.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, contactus.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, contactus.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, contactus.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, contactus.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, contactus.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, contactus.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, contactus.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, contactus.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, contactus.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Reason != nil {
		predicates = append(predicates, contactus.ReasonEQ(*i.Reason))
	}
	if i.ReasonNEQ != nil {
		predicates = append(predicates, contactus.ReasonNEQ(*i.ReasonNEQ))
	}
	if len(i.ReasonIn) > 0 {
		predicates = append(predicates, contactus.ReasonIn(i.ReasonIn...))
	}
	if len(i.ReasonNotIn) > 0 {
		predicates = append(predicates, contactus.ReasonNotIn(i.ReasonNotIn...))
	}
	if i.ReasonGT != nil {
		predicates = append(predicates, contactus.ReasonGT(*i.ReasonGT))
	}
	if i.ReasonGTE != nil {
		predicates = append(predicates, contactus.ReasonGTE(*i.ReasonGTE))
	}
	if i.ReasonLT != nil {
		predicates = append(predicates, contactus.ReasonLT(*i.ReasonLT))
	}
	if i.ReasonLTE != nil {
		predicates = append(predicates, contactus.ReasonLTE(*i.ReasonLTE))
	}
	if i.ReasonContains != nil {
		predicates = append(predicates, contactus.ReasonContains(*i.ReasonContains))
	}
	if i.ReasonHasPrefix != nil {
		predicates = append(predicates, contactus.ReasonHasPrefix(*i.ReasonHasPrefix))
	}
	if i.ReasonHasSuffix != nil {
		predicates = append(predicates, contactus.ReasonHasSuffix(*i.ReasonHasSuffix))
	}
	if i.ReasonEqualFold != nil {
		predicates = append(predicates, contactus.ReasonEqualFold(*i.ReasonEqualFold))
	}
	if i.ReasonContainsFold != nil {
		predicates = append(predicates, contactus.ReasonContainsFold(*i.ReasonContainsFold))
	}

	if i.HasPartner != nil {
		p := contactus.HasPartner()
		if !*i.HasPartner {
			p = contactus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contactus.HasPartnerWith(with...))
	}
	if i.HasCreator != nil {
		p := contactus.HasCreator()
		if !*i.HasCreator {
			p = contactus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contactus.HasCreatorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContactUsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return contactus.And(predicates...), nil
	}
}

// DocumentWhereInput represents a where input for filtering Document queries.
type DocumentWhereInput struct {
	Predicates []predicate.Document  `json:"-"`
	Not        *DocumentWhereInput   `json:"not,omitempty"`
	Or         []*DocumentWhereInput `json:"or,omitempty"`
	And        []*DocumentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "bucket" field predicates.
	Bucket             *string  `json:"bucket,omitempty"`
	BucketNEQ          *string  `json:"bucketNEQ,omitempty"`
	BucketIn           []string `json:"bucketIn,omitempty"`
	BucketNotIn        []string `json:"bucketNotIn,omitempty"`
	BucketGT           *string  `json:"bucketGT,omitempty"`
	BucketGTE          *string  `json:"bucketGTE,omitempty"`
	BucketLT           *string  `json:"bucketLT,omitempty"`
	BucketLTE          *string  `json:"bucketLTE,omitempty"`
	BucketContains     *string  `json:"bucketContains,omitempty"`
	BucketHasPrefix    *string  `json:"bucketHasPrefix,omitempty"`
	BucketHasSuffix    *string  `json:"bucketHasSuffix,omitempty"`
	BucketEqualFold    *string  `json:"bucketEqualFold,omitempty"`
	BucketContainsFold *string  `json:"bucketContainsFold,omitempty"`

	// "key" field predicates.
	Key             *string  `json:"key,omitempty"`
	KeyNEQ          *string  `json:"keyNEQ,omitempty"`
	KeyIn           []string `json:"keyIn,omitempty"`
	KeyNotIn        []string `json:"keyNotIn,omitempty"`
	KeyGT           *string  `json:"keyGT,omitempty"`
	KeyGTE          *string  `json:"keyGTE,omitempty"`
	KeyLT           *string  `json:"keyLT,omitempty"`
	KeyLTE          *string  `json:"keyLTE,omitempty"`
	KeyContains     *string  `json:"keyContains,omitempty"`
	KeyHasPrefix    *string  `json:"keyHasPrefix,omitempty"`
	KeyHasSuffix    *string  `json:"keyHasSuffix,omitempty"`
	KeyEqualFold    *string  `json:"keyEqualFold,omitempty"`
	KeyContainsFold *string  `json:"keyContainsFold,omitempty"`

	// "folder" field predicates.
	Folder      *enum.DocFolder  `json:"folder,omitempty"`
	FolderNEQ   *enum.DocFolder  `json:"folderNEQ,omitempty"`
	FolderIn    []enum.DocFolder `json:"folderIn,omitempty"`
	FolderNotIn []enum.DocFolder `json:"folderNotIn,omitempty"`

	// "dir" field predicates.
	Dir             *string  `json:"dir,omitempty"`
	DirNEQ          *string  `json:"dirNEQ,omitempty"`
	DirIn           []string `json:"dirIn,omitempty"`
	DirNotIn        []string `json:"dirNotIn,omitempty"`
	DirGT           *string  `json:"dirGT,omitempty"`
	DirGTE          *string  `json:"dirGTE,omitempty"`
	DirLT           *string  `json:"dirLT,omitempty"`
	DirLTE          *string  `json:"dirLTE,omitempty"`
	DirContains     *string  `json:"dirContains,omitempty"`
	DirHasPrefix    *string  `json:"dirHasPrefix,omitempty"`
	DirHasSuffix    *string  `json:"dirHasSuffix,omitempty"`
	DirIsNil        bool     `json:"dirIsNil,omitempty"`
	DirNotNil       bool     `json:"dirNotNil,omitempty"`
	DirEqualFold    *string  `json:"dirEqualFold,omitempty"`
	DirContainsFold *string  `json:"dirContainsFold,omitempty"`

	// "section" field predicates.
	Section      *enum.DocSection  `json:"section,omitempty"`
	SectionNEQ   *enum.DocSection  `json:"sectionNEQ,omitempty"`
	SectionIn    []enum.DocSection `json:"sectionIn,omitempty"`
	SectionNotIn []enum.DocSection `json:"sectionNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "filename" field predicates.
	Filename             *string  `json:"filename,omitempty"`
	FilenameNEQ          *string  `json:"filenameNEQ,omitempty"`
	FilenameIn           []string `json:"filenameIn,omitempty"`
	FilenameNotIn        []string `json:"filenameNotIn,omitempty"`
	FilenameGT           *string  `json:"filenameGT,omitempty"`
	FilenameGTE          *string  `json:"filenameGTE,omitempty"`
	FilenameLT           *string  `json:"filenameLT,omitempty"`
	FilenameLTE          *string  `json:"filenameLTE,omitempty"`
	FilenameContains     *string  `json:"filenameContains,omitempty"`
	FilenameHasPrefix    *string  `json:"filenameHasPrefix,omitempty"`
	FilenameHasSuffix    *string  `json:"filenameHasSuffix,omitempty"`
	FilenameEqualFold    *string  `json:"filenameEqualFold,omitempty"`
	FilenameContainsFold *string  `json:"filenameContainsFold,omitempty"`

	// "content_type" field predicates.
	ContentType             *string  `json:"contentType,omitempty"`
	ContentTypeNEQ          *string  `json:"contentTypeNEQ,omitempty"`
	ContentTypeIn           []string `json:"contentTypeIn,omitempty"`
	ContentTypeNotIn        []string `json:"contentTypeNotIn,omitempty"`
	ContentTypeGT           *string  `json:"contentTypeGT,omitempty"`
	ContentTypeGTE          *string  `json:"contentTypeGTE,omitempty"`
	ContentTypeLT           *string  `json:"contentTypeLT,omitempty"`
	ContentTypeLTE          *string  `json:"contentTypeLTE,omitempty"`
	ContentTypeContains     *string  `json:"contentTypeContains,omitempty"`
	ContentTypeHasPrefix    *string  `json:"contentTypeHasPrefix,omitempty"`
	ContentTypeHasSuffix    *string  `json:"contentTypeHasSuffix,omitempty"`
	ContentTypeIsNil        bool     `json:"contentTypeIsNil,omitempty"`
	ContentTypeNotNil       bool     `json:"contentTypeNotNil,omitempty"`
	ContentTypeEqualFold    *string  `json:"contentTypeEqualFold,omitempty"`
	ContentTypeContainsFold *string  `json:"contentTypeContainsFold,omitempty"`

	// "content_size" field predicates.
	ContentSize      *int64  `json:"contentSize,omitempty"`
	ContentSizeNEQ   *int64  `json:"contentSizeNEQ,omitempty"`
	ContentSizeIn    []int64 `json:"contentSizeIn,omitempty"`
	ContentSizeNotIn []int64 `json:"contentSizeNotIn,omitempty"`
	ContentSizeGT    *int64  `json:"contentSizeGT,omitempty"`
	ContentSizeGTE   *int64  `json:"contentSizeGTE,omitempty"`
	ContentSizeLT    *int64  `json:"contentSizeLT,omitempty"`
	ContentSizeLTE   *int64  `json:"contentSizeLTE,omitempty"`

	// "ready" field predicates.
	Ready    *bool `json:"ready,omitempty"`
	ReadyNEQ *bool `json:"readyNEQ,omitempty"`

	// "creator_id" field predicates.
	CreatorID             *string  `json:"creatorID,omitempty"`
	CreatorIDNEQ          *string  `json:"creatorIDNEQ,omitempty"`
	CreatorIDIn           []string `json:"creatorIDIn,omitempty"`
	CreatorIDNotIn        []string `json:"creatorIDNotIn,omitempty"`
	CreatorIDGT           *string  `json:"creatorIDGT,omitempty"`
	CreatorIDGTE          *string  `json:"creatorIDGTE,omitempty"`
	CreatorIDLT           *string  `json:"creatorIDLT,omitempty"`
	CreatorIDLTE          *string  `json:"creatorIDLTE,omitempty"`
	CreatorIDContains     *string  `json:"creatorIDContains,omitempty"`
	CreatorIDHasPrefix    *string  `json:"creatorIDHasPrefix,omitempty"`
	CreatorIDHasSuffix    *string  `json:"creatorIDHasSuffix,omitempty"`
	CreatorIDEqualFold    *string  `json:"creatorIDEqualFold,omitempty"`
	CreatorIDContainsFold *string  `json:"creatorIDContainsFold,omitempty"`

	// "updater_id" field predicates.
	UpdaterID             *string  `json:"updaterID,omitempty"`
	UpdaterIDNEQ          *string  `json:"updaterIDNEQ,omitempty"`
	UpdaterIDIn           []string `json:"updaterIDIn,omitempty"`
	UpdaterIDNotIn        []string `json:"updaterIDNotIn,omitempty"`
	UpdaterIDGT           *string  `json:"updaterIDGT,omitempty"`
	UpdaterIDGTE          *string  `json:"updaterIDGTE,omitempty"`
	UpdaterIDLT           *string  `json:"updaterIDLT,omitempty"`
	UpdaterIDLTE          *string  `json:"updaterIDLTE,omitempty"`
	UpdaterIDContains     *string  `json:"updaterIDContains,omitempty"`
	UpdaterIDHasPrefix    *string  `json:"updaterIDHasPrefix,omitempty"`
	UpdaterIDHasSuffix    *string  `json:"updaterIDHasSuffix,omitempty"`
	UpdaterIDIsNil        bool     `json:"updaterIDIsNil,omitempty"`
	UpdaterIDNotNil       bool     `json:"updaterIDNotNil,omitempty"`
	UpdaterIDEqualFold    *string  `json:"updaterIDEqualFold,omitempty"`
	UpdaterIDContainsFold *string  `json:"updaterIDContainsFold,omitempty"`

	// "training_video" edge predicates.
	HasTrainingVideo     *bool                      `json:"hasTrainingVideo,omitempty"`
	HasTrainingVideoWith []*TrainingVideoWhereInput `json:"hasTrainingVideoWith,omitempty"`

	// "training_video_poster" edge predicates.
	HasTrainingVideoPoster     *bool                      `json:"hasTrainingVideoPoster,omitempty"`
	HasTrainingVideoPosterWith []*TrainingVideoWhereInput `json:"hasTrainingVideoPosterWith,omitempty"`

	// "products_image" edge predicates.
	HasProductsImage     *bool                `json:"hasProductsImage,omitempty"`
	HasProductsImageWith []*ProductWhereInput `json:"hasProductsImageWith,omitempty"`

	// "installation_job_item_image" edge predicates.
	HasInstallationJobItemImage     *bool                            `json:"hasInstallationJobItemImage,omitempty"`
	HasInstallationJobItemImageWith []*InstallationJobItemWhereInput `json:"hasInstallationJobItemImageWith,omitempty"`

	// "estimate_pdf" edge predicates.
	HasEstimatePdf     *bool                 `json:"hasEstimatePdf,omitempty"`
	HasEstimatePdfWith []*EstimateWhereInput `json:"hasEstimatePdfWith,omitempty"`

	// "job_estimate_pdf" edge predicates.
	HasJobEstimatePdf     *bool            `json:"hasJobEstimatePdf,omitempty"`
	HasJobEstimatePdfWith []*JobWhereInput `json:"hasJobEstimatePdfWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DocumentWhereInput) AddPredicates(predicates ...predicate.Document) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DocumentWhereInput filter on the DocumentQuery builder.
func (i *DocumentWhereInput) Filter(q *DocumentQuery) (*DocumentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDocumentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDocumentWhereInput is returned in case the DocumentWhereInput is empty.
var ErrEmptyDocumentWhereInput = errors.New("ent: empty predicate DocumentWhereInput")

// P returns a predicate for filtering documents.
// An error is returned if the input is empty or invalid.
func (i *DocumentWhereInput) P() (predicate.Document, error) {
	var predicates []predicate.Document
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, document.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Document, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, document.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Document, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, document.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, document.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, document.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, document.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, document.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, document.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, document.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, document.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, document.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, document.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, document.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, document.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, document.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, document.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, document.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, document.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, document.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, document.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, document.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, document.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, document.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, document.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, document.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, document.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, document.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, document.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, document.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Bucket != nil {
		predicates = append(predicates, document.BucketEQ(*i.Bucket))
	}
	if i.BucketNEQ != nil {
		predicates = append(predicates, document.BucketNEQ(*i.BucketNEQ))
	}
	if len(i.BucketIn) > 0 {
		predicates = append(predicates, document.BucketIn(i.BucketIn...))
	}
	if len(i.BucketNotIn) > 0 {
		predicates = append(predicates, document.BucketNotIn(i.BucketNotIn...))
	}
	if i.BucketGT != nil {
		predicates = append(predicates, document.BucketGT(*i.BucketGT))
	}
	if i.BucketGTE != nil {
		predicates = append(predicates, document.BucketGTE(*i.BucketGTE))
	}
	if i.BucketLT != nil {
		predicates = append(predicates, document.BucketLT(*i.BucketLT))
	}
	if i.BucketLTE != nil {
		predicates = append(predicates, document.BucketLTE(*i.BucketLTE))
	}
	if i.BucketContains != nil {
		predicates = append(predicates, document.BucketContains(*i.BucketContains))
	}
	if i.BucketHasPrefix != nil {
		predicates = append(predicates, document.BucketHasPrefix(*i.BucketHasPrefix))
	}
	if i.BucketHasSuffix != nil {
		predicates = append(predicates, document.BucketHasSuffix(*i.BucketHasSuffix))
	}
	if i.BucketEqualFold != nil {
		predicates = append(predicates, document.BucketEqualFold(*i.BucketEqualFold))
	}
	if i.BucketContainsFold != nil {
		predicates = append(predicates, document.BucketContainsFold(*i.BucketContainsFold))
	}
	if i.Key != nil {
		predicates = append(predicates, document.KeyEQ(*i.Key))
	}
	if i.KeyNEQ != nil {
		predicates = append(predicates, document.KeyNEQ(*i.KeyNEQ))
	}
	if len(i.KeyIn) > 0 {
		predicates = append(predicates, document.KeyIn(i.KeyIn...))
	}
	if len(i.KeyNotIn) > 0 {
		predicates = append(predicates, document.KeyNotIn(i.KeyNotIn...))
	}
	if i.KeyGT != nil {
		predicates = append(predicates, document.KeyGT(*i.KeyGT))
	}
	if i.KeyGTE != nil {
		predicates = append(predicates, document.KeyGTE(*i.KeyGTE))
	}
	if i.KeyLT != nil {
		predicates = append(predicates, document.KeyLT(*i.KeyLT))
	}
	if i.KeyLTE != nil {
		predicates = append(predicates, document.KeyLTE(*i.KeyLTE))
	}
	if i.KeyContains != nil {
		predicates = append(predicates, document.KeyContains(*i.KeyContains))
	}
	if i.KeyHasPrefix != nil {
		predicates = append(predicates, document.KeyHasPrefix(*i.KeyHasPrefix))
	}
	if i.KeyHasSuffix != nil {
		predicates = append(predicates, document.KeyHasSuffix(*i.KeyHasSuffix))
	}
	if i.KeyEqualFold != nil {
		predicates = append(predicates, document.KeyEqualFold(*i.KeyEqualFold))
	}
	if i.KeyContainsFold != nil {
		predicates = append(predicates, document.KeyContainsFold(*i.KeyContainsFold))
	}
	if i.Folder != nil {
		predicates = append(predicates, document.FolderEQ(*i.Folder))
	}
	if i.FolderNEQ != nil {
		predicates = append(predicates, document.FolderNEQ(*i.FolderNEQ))
	}
	if len(i.FolderIn) > 0 {
		predicates = append(predicates, document.FolderIn(i.FolderIn...))
	}
	if len(i.FolderNotIn) > 0 {
		predicates = append(predicates, document.FolderNotIn(i.FolderNotIn...))
	}
	if i.Dir != nil {
		predicates = append(predicates, document.DirEQ(*i.Dir))
	}
	if i.DirNEQ != nil {
		predicates = append(predicates, document.DirNEQ(*i.DirNEQ))
	}
	if len(i.DirIn) > 0 {
		predicates = append(predicates, document.DirIn(i.DirIn...))
	}
	if len(i.DirNotIn) > 0 {
		predicates = append(predicates, document.DirNotIn(i.DirNotIn...))
	}
	if i.DirGT != nil {
		predicates = append(predicates, document.DirGT(*i.DirGT))
	}
	if i.DirGTE != nil {
		predicates = append(predicates, document.DirGTE(*i.DirGTE))
	}
	if i.DirLT != nil {
		predicates = append(predicates, document.DirLT(*i.DirLT))
	}
	if i.DirLTE != nil {
		predicates = append(predicates, document.DirLTE(*i.DirLTE))
	}
	if i.DirContains != nil {
		predicates = append(predicates, document.DirContains(*i.DirContains))
	}
	if i.DirHasPrefix != nil {
		predicates = append(predicates, document.DirHasPrefix(*i.DirHasPrefix))
	}
	if i.DirHasSuffix != nil {
		predicates = append(predicates, document.DirHasSuffix(*i.DirHasSuffix))
	}
	if i.DirIsNil {
		predicates = append(predicates, document.DirIsNil())
	}
	if i.DirNotNil {
		predicates = append(predicates, document.DirNotNil())
	}
	if i.DirEqualFold != nil {
		predicates = append(predicates, document.DirEqualFold(*i.DirEqualFold))
	}
	if i.DirContainsFold != nil {
		predicates = append(predicates, document.DirContainsFold(*i.DirContainsFold))
	}
	if i.Section != nil {
		predicates = append(predicates, document.SectionEQ(*i.Section))
	}
	if i.SectionNEQ != nil {
		predicates = append(predicates, document.SectionNEQ(*i.SectionNEQ))
	}
	if len(i.SectionIn) > 0 {
		predicates = append(predicates, document.SectionIn(i.SectionIn...))
	}
	if len(i.SectionNotIn) > 0 {
		predicates = append(predicates, document.SectionNotIn(i.SectionNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, document.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, document.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, document.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, document.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, document.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, document.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, document.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, document.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, document.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, document.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, document.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, document.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, document.NameContainsFold(*i.NameContainsFold))
	}
	if i.Filename != nil {
		predicates = append(predicates, document.FilenameEQ(*i.Filename))
	}
	if i.FilenameNEQ != nil {
		predicates = append(predicates, document.FilenameNEQ(*i.FilenameNEQ))
	}
	if len(i.FilenameIn) > 0 {
		predicates = append(predicates, document.FilenameIn(i.FilenameIn...))
	}
	if len(i.FilenameNotIn) > 0 {
		predicates = append(predicates, document.FilenameNotIn(i.FilenameNotIn...))
	}
	if i.FilenameGT != nil {
		predicates = append(predicates, document.FilenameGT(*i.FilenameGT))
	}
	if i.FilenameGTE != nil {
		predicates = append(predicates, document.FilenameGTE(*i.FilenameGTE))
	}
	if i.FilenameLT != nil {
		predicates = append(predicates, document.FilenameLT(*i.FilenameLT))
	}
	if i.FilenameLTE != nil {
		predicates = append(predicates, document.FilenameLTE(*i.FilenameLTE))
	}
	if i.FilenameContains != nil {
		predicates = append(predicates, document.FilenameContains(*i.FilenameContains))
	}
	if i.FilenameHasPrefix != nil {
		predicates = append(predicates, document.FilenameHasPrefix(*i.FilenameHasPrefix))
	}
	if i.FilenameHasSuffix != nil {
		predicates = append(predicates, document.FilenameHasSuffix(*i.FilenameHasSuffix))
	}
	if i.FilenameEqualFold != nil {
		predicates = append(predicates, document.FilenameEqualFold(*i.FilenameEqualFold))
	}
	if i.FilenameContainsFold != nil {
		predicates = append(predicates, document.FilenameContainsFold(*i.FilenameContainsFold))
	}
	if i.ContentType != nil {
		predicates = append(predicates, document.ContentTypeEQ(*i.ContentType))
	}
	if i.ContentTypeNEQ != nil {
		predicates = append(predicates, document.ContentTypeNEQ(*i.ContentTypeNEQ))
	}
	if len(i.ContentTypeIn) > 0 {
		predicates = append(predicates, document.ContentTypeIn(i.ContentTypeIn...))
	}
	if len(i.ContentTypeNotIn) > 0 {
		predicates = append(predicates, document.ContentTypeNotIn(i.ContentTypeNotIn...))
	}
	if i.ContentTypeGT != nil {
		predicates = append(predicates, document.ContentTypeGT(*i.ContentTypeGT))
	}
	if i.ContentTypeGTE != nil {
		predicates = append(predicates, document.ContentTypeGTE(*i.ContentTypeGTE))
	}
	if i.ContentTypeLT != nil {
		predicates = append(predicates, document.ContentTypeLT(*i.ContentTypeLT))
	}
	if i.ContentTypeLTE != nil {
		predicates = append(predicates, document.ContentTypeLTE(*i.ContentTypeLTE))
	}
	if i.ContentTypeContains != nil {
		predicates = append(predicates, document.ContentTypeContains(*i.ContentTypeContains))
	}
	if i.ContentTypeHasPrefix != nil {
		predicates = append(predicates, document.ContentTypeHasPrefix(*i.ContentTypeHasPrefix))
	}
	if i.ContentTypeHasSuffix != nil {
		predicates = append(predicates, document.ContentTypeHasSuffix(*i.ContentTypeHasSuffix))
	}
	if i.ContentTypeIsNil {
		predicates = append(predicates, document.ContentTypeIsNil())
	}
	if i.ContentTypeNotNil {
		predicates = append(predicates, document.ContentTypeNotNil())
	}
	if i.ContentTypeEqualFold != nil {
		predicates = append(predicates, document.ContentTypeEqualFold(*i.ContentTypeEqualFold))
	}
	if i.ContentTypeContainsFold != nil {
		predicates = append(predicates, document.ContentTypeContainsFold(*i.ContentTypeContainsFold))
	}
	if i.ContentSize != nil {
		predicates = append(predicates, document.ContentSizeEQ(*i.ContentSize))
	}
	if i.ContentSizeNEQ != nil {
		predicates = append(predicates, document.ContentSizeNEQ(*i.ContentSizeNEQ))
	}
	if len(i.ContentSizeIn) > 0 {
		predicates = append(predicates, document.ContentSizeIn(i.ContentSizeIn...))
	}
	if len(i.ContentSizeNotIn) > 0 {
		predicates = append(predicates, document.ContentSizeNotIn(i.ContentSizeNotIn...))
	}
	if i.ContentSizeGT != nil {
		predicates = append(predicates, document.ContentSizeGT(*i.ContentSizeGT))
	}
	if i.ContentSizeGTE != nil {
		predicates = append(predicates, document.ContentSizeGTE(*i.ContentSizeGTE))
	}
	if i.ContentSizeLT != nil {
		predicates = append(predicates, document.ContentSizeLT(*i.ContentSizeLT))
	}
	if i.ContentSizeLTE != nil {
		predicates = append(predicates, document.ContentSizeLTE(*i.ContentSizeLTE))
	}
	if i.Ready != nil {
		predicates = append(predicates, document.ReadyEQ(*i.Ready))
	}
	if i.ReadyNEQ != nil {
		predicates = append(predicates, document.ReadyNEQ(*i.ReadyNEQ))
	}
	if i.CreatorID != nil {
		predicates = append(predicates, document.CreatorIDEQ(*i.CreatorID))
	}
	if i.CreatorIDNEQ != nil {
		predicates = append(predicates, document.CreatorIDNEQ(*i.CreatorIDNEQ))
	}
	if len(i.CreatorIDIn) > 0 {
		predicates = append(predicates, document.CreatorIDIn(i.CreatorIDIn...))
	}
	if len(i.CreatorIDNotIn) > 0 {
		predicates = append(predicates, document.CreatorIDNotIn(i.CreatorIDNotIn...))
	}
	if i.CreatorIDGT != nil {
		predicates = append(predicates, document.CreatorIDGT(*i.CreatorIDGT))
	}
	if i.CreatorIDGTE != nil {
		predicates = append(predicates, document.CreatorIDGTE(*i.CreatorIDGTE))
	}
	if i.CreatorIDLT != nil {
		predicates = append(predicates, document.CreatorIDLT(*i.CreatorIDLT))
	}
	if i.CreatorIDLTE != nil {
		predicates = append(predicates, document.CreatorIDLTE(*i.CreatorIDLTE))
	}
	if i.CreatorIDContains != nil {
		predicates = append(predicates, document.CreatorIDContains(*i.CreatorIDContains))
	}
	if i.CreatorIDHasPrefix != nil {
		predicates = append(predicates, document.CreatorIDHasPrefix(*i.CreatorIDHasPrefix))
	}
	if i.CreatorIDHasSuffix != nil {
		predicates = append(predicates, document.CreatorIDHasSuffix(*i.CreatorIDHasSuffix))
	}
	if i.CreatorIDEqualFold != nil {
		predicates = append(predicates, document.CreatorIDEqualFold(*i.CreatorIDEqualFold))
	}
	if i.CreatorIDContainsFold != nil {
		predicates = append(predicates, document.CreatorIDContainsFold(*i.CreatorIDContainsFold))
	}
	if i.UpdaterID != nil {
		predicates = append(predicates, document.UpdaterIDEQ(*i.UpdaterID))
	}
	if i.UpdaterIDNEQ != nil {
		predicates = append(predicates, document.UpdaterIDNEQ(*i.UpdaterIDNEQ))
	}
	if len(i.UpdaterIDIn) > 0 {
		predicates = append(predicates, document.UpdaterIDIn(i.UpdaterIDIn...))
	}
	if len(i.UpdaterIDNotIn) > 0 {
		predicates = append(predicates, document.UpdaterIDNotIn(i.UpdaterIDNotIn...))
	}
	if i.UpdaterIDGT != nil {
		predicates = append(predicates, document.UpdaterIDGT(*i.UpdaterIDGT))
	}
	if i.UpdaterIDGTE != nil {
		predicates = append(predicates, document.UpdaterIDGTE(*i.UpdaterIDGTE))
	}
	if i.UpdaterIDLT != nil {
		predicates = append(predicates, document.UpdaterIDLT(*i.UpdaterIDLT))
	}
	if i.UpdaterIDLTE != nil {
		predicates = append(predicates, document.UpdaterIDLTE(*i.UpdaterIDLTE))
	}
	if i.UpdaterIDContains != nil {
		predicates = append(predicates, document.UpdaterIDContains(*i.UpdaterIDContains))
	}
	if i.UpdaterIDHasPrefix != nil {
		predicates = append(predicates, document.UpdaterIDHasPrefix(*i.UpdaterIDHasPrefix))
	}
	if i.UpdaterIDHasSuffix != nil {
		predicates = append(predicates, document.UpdaterIDHasSuffix(*i.UpdaterIDHasSuffix))
	}
	if i.UpdaterIDIsNil {
		predicates = append(predicates, document.UpdaterIDIsNil())
	}
	if i.UpdaterIDNotNil {
		predicates = append(predicates, document.UpdaterIDNotNil())
	}
	if i.UpdaterIDEqualFold != nil {
		predicates = append(predicates, document.UpdaterIDEqualFold(*i.UpdaterIDEqualFold))
	}
	if i.UpdaterIDContainsFold != nil {
		predicates = append(predicates, document.UpdaterIDContainsFold(*i.UpdaterIDContainsFold))
	}

	if i.HasTrainingVideo != nil {
		p := document.HasTrainingVideo()
		if !*i.HasTrainingVideo {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTrainingVideoWith) > 0 {
		with := make([]predicate.TrainingVideo, 0, len(i.HasTrainingVideoWith))
		for _, w := range i.HasTrainingVideoWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTrainingVideoWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasTrainingVideoWith(with...))
	}
	if i.HasTrainingVideoPoster != nil {
		p := document.HasTrainingVideoPoster()
		if !*i.HasTrainingVideoPoster {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTrainingVideoPosterWith) > 0 {
		with := make([]predicate.TrainingVideo, 0, len(i.HasTrainingVideoPosterWith))
		for _, w := range i.HasTrainingVideoPosterWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTrainingVideoPosterWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasTrainingVideoPosterWith(with...))
	}
	if i.HasProductsImage != nil {
		p := document.HasProductsImage()
		if !*i.HasProductsImage {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsImageWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsImageWith))
		for _, w := range i.HasProductsImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasProductsImageWith(with...))
	}
	if i.HasInstallationJobItemImage != nil {
		p := document.HasInstallationJobItemImage()
		if !*i.HasInstallationJobItemImage {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstallationJobItemImageWith) > 0 {
		with := make([]predicate.InstallationJobItem, 0, len(i.HasInstallationJobItemImageWith))
		for _, w := range i.HasInstallationJobItemImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInstallationJobItemImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasInstallationJobItemImageWith(with...))
	}
	if i.HasEstimatePdf != nil {
		p := document.HasEstimatePdf()
		if !*i.HasEstimatePdf {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEstimatePdfWith) > 0 {
		with := make([]predicate.Estimate, 0, len(i.HasEstimatePdfWith))
		for _, w := range i.HasEstimatePdfWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEstimatePdfWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasEstimatePdfWith(with...))
	}
	if i.HasJobEstimatePdf != nil {
		p := document.HasJobEstimatePdf()
		if !*i.HasJobEstimatePdf {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobEstimatePdfWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobEstimatePdfWith))
		for _, w := range i.HasJobEstimatePdfWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobEstimatePdfWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasJobEstimatePdfWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDocumentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return document.And(predicates...), nil
	}
}

// EstimateWhereInput represents a where input for filtering Estimate queries.
type EstimateWhereInput struct {
	Predicates []predicate.Estimate  `json:"-"`
	Not        *EstimateWhereInput   `json:"not,omitempty"`
	Or         []*EstimateWhereInput `json:"or,omitempty"`
	And        []*EstimateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "region_id" field predicates.
	RegionID      *uint8  `json:"regionID,omitempty"`
	RegionIDNEQ   *uint8  `json:"regionIDNEQ,omitempty"`
	RegionIDIn    []uint8 `json:"regionIDIn,omitempty"`
	RegionIDNotIn []uint8 `json:"regionIDNotIn,omitempty"`
	RegionIDGT    *uint8  `json:"regionIDGT,omitempty"`
	RegionIDGTE   *uint8  `json:"regionIDGTE,omitempty"`
	RegionIDLT    *uint8  `json:"regionIDLT,omitempty"`
	RegionIDLTE   *uint8  `json:"regionIDLTE,omitempty"`

	// "status" field predicates.
	Status      *enum.EstimateStatus  `json:"status,omitempty"`
	StatusNEQ   *enum.EstimateStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enum.EstimateStatus `json:"statusIn,omitempty"`
	StatusNotIn []enum.EstimateStatus `json:"statusNotIn,omitempty"`

	// "current_material" field predicates.
	CurrentMaterial             *string  `json:"currentMaterial,omitempty"`
	CurrentMaterialNEQ          *string  `json:"currentMaterialNEQ,omitempty"`
	CurrentMaterialIn           []string `json:"currentMaterialIn,omitempty"`
	CurrentMaterialNotIn        []string `json:"currentMaterialNotIn,omitempty"`
	CurrentMaterialGT           *string  `json:"currentMaterialGT,omitempty"`
	CurrentMaterialGTE          *string  `json:"currentMaterialGTE,omitempty"`
	CurrentMaterialLT           *string  `json:"currentMaterialLT,omitempty"`
	CurrentMaterialLTE          *string  `json:"currentMaterialLTE,omitempty"`
	CurrentMaterialContains     *string  `json:"currentMaterialContains,omitempty"`
	CurrentMaterialHasPrefix    *string  `json:"currentMaterialHasPrefix,omitempty"`
	CurrentMaterialHasSuffix    *string  `json:"currentMaterialHasSuffix,omitempty"`
	CurrentMaterialIsNil        bool     `json:"currentMaterialIsNil,omitempty"`
	CurrentMaterialNotNil       bool     `json:"currentMaterialNotNil,omitempty"`
	CurrentMaterialEqualFold    *string  `json:"currentMaterialEqualFold,omitempty"`
	CurrentMaterialContainsFold *string  `json:"currentMaterialContainsFold,omitempty"`

	// "new_roofing_material" field predicates.
	NewRoofingMaterial             *string  `json:"newRoofingMaterial,omitempty"`
	NewRoofingMaterialNEQ          *string  `json:"newRoofingMaterialNEQ,omitempty"`
	NewRoofingMaterialIn           []string `json:"newRoofingMaterialIn,omitempty"`
	NewRoofingMaterialNotIn        []string `json:"newRoofingMaterialNotIn,omitempty"`
	NewRoofingMaterialGT           *string  `json:"newRoofingMaterialGT,omitempty"`
	NewRoofingMaterialGTE          *string  `json:"newRoofingMaterialGTE,omitempty"`
	NewRoofingMaterialLT           *string  `json:"newRoofingMaterialLT,omitempty"`
	NewRoofingMaterialLTE          *string  `json:"newRoofingMaterialLTE,omitempty"`
	NewRoofingMaterialContains     *string  `json:"newRoofingMaterialContains,omitempty"`
	NewRoofingMaterialHasPrefix    *string  `json:"newRoofingMaterialHasPrefix,omitempty"`
	NewRoofingMaterialHasSuffix    *string  `json:"newRoofingMaterialHasSuffix,omitempty"`
	NewRoofingMaterialIsNil        bool     `json:"newRoofingMaterialIsNil,omitempty"`
	NewRoofingMaterialNotNil       bool     `json:"newRoofingMaterialNotNil,omitempty"`
	NewRoofingMaterialEqualFold    *string  `json:"newRoofingMaterialEqualFold,omitempty"`
	NewRoofingMaterialContainsFold *string  `json:"newRoofingMaterialContainsFold,omitempty"`

	// "lowSlope" field predicates.
	LowSlope    *bool `json:"lowslope,omitempty"`
	LowSlopeNEQ *bool `json:"lowslopeNEQ,omitempty"`

	// "current_material_low_slope" field predicates.
	CurrentMaterialLowSlope             *string  `json:"currentMaterialLowSlope,omitempty"`
	CurrentMaterialLowSlopeNEQ          *string  `json:"currentMaterialLowSlopeNEQ,omitempty"`
	CurrentMaterialLowSlopeIn           []string `json:"currentMaterialLowSlopeIn,omitempty"`
	CurrentMaterialLowSlopeNotIn        []string `json:"currentMaterialLowSlopeNotIn,omitempty"`
	CurrentMaterialLowSlopeGT           *string  `json:"currentMaterialLowSlopeGT,omitempty"`
	CurrentMaterialLowSlopeGTE          *string  `json:"currentMaterialLowSlopeGTE,omitempty"`
	CurrentMaterialLowSlopeLT           *string  `json:"currentMaterialLowSlopeLT,omitempty"`
	CurrentMaterialLowSlopeLTE          *string  `json:"currentMaterialLowSlopeLTE,omitempty"`
	CurrentMaterialLowSlopeContains     *string  `json:"currentMaterialLowSlopeContains,omitempty"`
	CurrentMaterialLowSlopeHasPrefix    *string  `json:"currentMaterialLowSlopeHasPrefix,omitempty"`
	CurrentMaterialLowSlopeHasSuffix    *string  `json:"currentMaterialLowSlopeHasSuffix,omitempty"`
	CurrentMaterialLowSlopeIsNil        bool     `json:"currentMaterialLowSlopeIsNil,omitempty"`
	CurrentMaterialLowSlopeNotNil       bool     `json:"currentMaterialLowSlopeNotNil,omitempty"`
	CurrentMaterialLowSlopeEqualFold    *string  `json:"currentMaterialLowSlopeEqualFold,omitempty"`
	CurrentMaterialLowSlopeContainsFold *string  `json:"currentMaterialLowSlopeContainsFold,omitempty"`

	// "new_roofing_material_low_slope" field predicates.
	NewRoofingMaterialLowSlope             *string  `json:"newRoofingMaterialLowSlope,omitempty"`
	NewRoofingMaterialLowSlopeNEQ          *string  `json:"newRoofingMaterialLowSlopeNEQ,omitempty"`
	NewRoofingMaterialLowSlopeIn           []string `json:"newRoofingMaterialLowSlopeIn,omitempty"`
	NewRoofingMaterialLowSlopeNotIn        []string `json:"newRoofingMaterialLowSlopeNotIn,omitempty"`
	NewRoofingMaterialLowSlopeGT           *string  `json:"newRoofingMaterialLowSlopeGT,omitempty"`
	NewRoofingMaterialLowSlopeGTE          *string  `json:"newRoofingMaterialLowSlopeGTE,omitempty"`
	NewRoofingMaterialLowSlopeLT           *string  `json:"newRoofingMaterialLowSlopeLT,omitempty"`
	NewRoofingMaterialLowSlopeLTE          *string  `json:"newRoofingMaterialLowSlopeLTE,omitempty"`
	NewRoofingMaterialLowSlopeContains     *string  `json:"newRoofingMaterialLowSlopeContains,omitempty"`
	NewRoofingMaterialLowSlopeHasPrefix    *string  `json:"newRoofingMaterialLowSlopeHasPrefix,omitempty"`
	NewRoofingMaterialLowSlopeHasSuffix    *string  `json:"newRoofingMaterialLowSlopeHasSuffix,omitempty"`
	NewRoofingMaterialLowSlopeIsNil        bool     `json:"newRoofingMaterialLowSlopeIsNil,omitempty"`
	NewRoofingMaterialLowSlopeNotNil       bool     `json:"newRoofingMaterialLowSlopeNotNil,omitempty"`
	NewRoofingMaterialLowSlopeEqualFold    *string  `json:"newRoofingMaterialLowSlopeEqualFold,omitempty"`
	NewRoofingMaterialLowSlopeContainsFold *string  `json:"newRoofingMaterialLowSlopeContainsFold,omitempty"`

	// "redeck" field predicates.
	Redeck    *bool `json:"redeck,omitempty"`
	RedeckNEQ *bool `json:"redeckNEQ,omitempty"`

	// "layers" field predicates.
	Layers      *uint8  `json:"layers,omitempty"`
	LayersNEQ   *uint8  `json:"layersNEQ,omitempty"`
	LayersIn    []uint8 `json:"layersIn,omitempty"`
	LayersNotIn []uint8 `json:"layersNotIn,omitempty"`
	LayersGT    *uint8  `json:"layersGT,omitempty"`
	LayersGTE   *uint8  `json:"layersGTE,omitempty"`
	LayersLT    *uint8  `json:"layersLT,omitempty"`
	LayersLTE   *uint8  `json:"layersLTE,omitempty"`

	// "layer2_material" field predicates.
	Layer2Material             *string  `json:"layer2Material,omitempty"`
	Layer2MaterialNEQ          *string  `json:"layer2MaterialNEQ,omitempty"`
	Layer2MaterialIn           []string `json:"layer2MaterialIn,omitempty"`
	Layer2MaterialNotIn        []string `json:"layer2MaterialNotIn,omitempty"`
	Layer2MaterialGT           *string  `json:"layer2MaterialGT,omitempty"`
	Layer2MaterialGTE          *string  `json:"layer2MaterialGTE,omitempty"`
	Layer2MaterialLT           *string  `json:"layer2MaterialLT,omitempty"`
	Layer2MaterialLTE          *string  `json:"layer2MaterialLTE,omitempty"`
	Layer2MaterialContains     *string  `json:"layer2MaterialContains,omitempty"`
	Layer2MaterialHasPrefix    *string  `json:"layer2MaterialHasPrefix,omitempty"`
	Layer2MaterialHasSuffix    *string  `json:"layer2MaterialHasSuffix,omitempty"`
	Layer2MaterialIsNil        bool     `json:"layer2MaterialIsNil,omitempty"`
	Layer2MaterialNotNil       bool     `json:"layer2MaterialNotNil,omitempty"`
	Layer2MaterialEqualFold    *string  `json:"layer2MaterialEqualFold,omitempty"`
	Layer2MaterialContainsFold *string  `json:"layer2MaterialContainsFold,omitempty"`

	// "layer3_material" field predicates.
	Layer3Material             *string  `json:"layer3Material,omitempty"`
	Layer3MaterialNEQ          *string  `json:"layer3MaterialNEQ,omitempty"`
	Layer3MaterialIn           []string `json:"layer3MaterialIn,omitempty"`
	Layer3MaterialNotIn        []string `json:"layer3MaterialNotIn,omitempty"`
	Layer3MaterialGT           *string  `json:"layer3MaterialGT,omitempty"`
	Layer3MaterialGTE          *string  `json:"layer3MaterialGTE,omitempty"`
	Layer3MaterialLT           *string  `json:"layer3MaterialLT,omitempty"`
	Layer3MaterialLTE          *string  `json:"layer3MaterialLTE,omitempty"`
	Layer3MaterialContains     *string  `json:"layer3MaterialContains,omitempty"`
	Layer3MaterialHasPrefix    *string  `json:"layer3MaterialHasPrefix,omitempty"`
	Layer3MaterialHasSuffix    *string  `json:"layer3MaterialHasSuffix,omitempty"`
	Layer3MaterialIsNil        bool     `json:"layer3MaterialIsNil,omitempty"`
	Layer3MaterialNotNil       bool     `json:"layer3MaterialNotNil,omitempty"`
	Layer3MaterialEqualFold    *string  `json:"layer3MaterialEqualFold,omitempty"`
	Layer3MaterialContainsFold *string  `json:"layer3MaterialContainsFold,omitempty"`

	// "partial_percentage" field predicates.
	PartialPercentage       *float64  `json:"partialPercentage,omitempty"`
	PartialPercentageNEQ    *float64  `json:"partialPercentageNEQ,omitempty"`
	PartialPercentageIn     []float64 `json:"partialPercentageIn,omitempty"`
	PartialPercentageNotIn  []float64 `json:"partialPercentageNotIn,omitempty"`
	PartialPercentageGT     *float64  `json:"partialPercentageGT,omitempty"`
	PartialPercentageGTE    *float64  `json:"partialPercentageGTE,omitempty"`
	PartialPercentageLT     *float64  `json:"partialPercentageLT,omitempty"`
	PartialPercentageLTE    *float64  `json:"partialPercentageLTE,omitempty"`
	PartialPercentageIsNil  bool      `json:"partialPercentageIsNil,omitempty"`
	PartialPercentageNotNil bool      `json:"partialPercentageNotNil,omitempty"`

	// "material_mapping_note" field predicates.
	MaterialMappingNote             *string  `json:"materialMappingNote,omitempty"`
	MaterialMappingNoteNEQ          *string  `json:"materialMappingNoteNEQ,omitempty"`
	MaterialMappingNoteIn           []string `json:"materialMappingNoteIn,omitempty"`
	MaterialMappingNoteNotIn        []string `json:"materialMappingNoteNotIn,omitempty"`
	MaterialMappingNoteGT           *string  `json:"materialMappingNoteGT,omitempty"`
	MaterialMappingNoteGTE          *string  `json:"materialMappingNoteGTE,omitempty"`
	MaterialMappingNoteLT           *string  `json:"materialMappingNoteLT,omitempty"`
	MaterialMappingNoteLTE          *string  `json:"materialMappingNoteLTE,omitempty"`
	MaterialMappingNoteContains     *string  `json:"materialMappingNoteContains,omitempty"`
	MaterialMappingNoteHasPrefix    *string  `json:"materialMappingNoteHasPrefix,omitempty"`
	MaterialMappingNoteHasSuffix    *string  `json:"materialMappingNoteHasSuffix,omitempty"`
	MaterialMappingNoteIsNil        bool     `json:"materialMappingNoteIsNil,omitempty"`
	MaterialMappingNoteNotNil       bool     `json:"materialMappingNoteNotNil,omitempty"`
	MaterialMappingNoteEqualFold    *string  `json:"materialMappingNoteEqualFold,omitempty"`
	MaterialMappingNoteContainsFold *string  `json:"materialMappingNoteContainsFold,omitempty"`

	// "measure_type" field predicates.
	MeasureType      *enum.Measure  `json:"measureType,omitempty"`
	MeasureTypeNEQ   *enum.Measure  `json:"measureTypeNEQ,omitempty"`
	MeasureTypeIn    []enum.Measure `json:"measureTypeIn,omitempty"`
	MeasureTypeNotIn []enum.Measure `json:"measureTypeNotIn,omitempty"`

	// "extra_charge_type" field predicates.
	ExtraChargeType       *enum.ExtraCharge  `json:"extraChargeType,omitempty"`
	ExtraChargeTypeNEQ    *enum.ExtraCharge  `json:"extraChargeTypeNEQ,omitempty"`
	ExtraChargeTypeIn     []enum.ExtraCharge `json:"extraChargeTypeIn,omitempty"`
	ExtraChargeTypeNotIn  []enum.ExtraCharge `json:"extraChargeTypeNotIn,omitempty"`
	ExtraChargeTypeIsNil  bool               `json:"extraChargeTypeIsNil,omitempty"`
	ExtraChargeTypeNotNil bool               `json:"extraChargeTypeNotNil,omitempty"`

	// "extra_charges" field predicates.
	ExtraCharges       *float64  `json:"extraCharges,omitempty"`
	ExtraChargesNEQ    *float64  `json:"extraChargesNEQ,omitempty"`
	ExtraChargesIn     []float64 `json:"extraChargesIn,omitempty"`
	ExtraChargesNotIn  []float64 `json:"extraChargesNotIn,omitempty"`
	ExtraChargesGT     *float64  `json:"extraChargesGT,omitempty"`
	ExtraChargesGTE    *float64  `json:"extraChargesGTE,omitempty"`
	ExtraChargesLT     *float64  `json:"extraChargesLT,omitempty"`
	ExtraChargesLTE    *float64  `json:"extraChargesLTE,omitempty"`
	ExtraChargesIsNil  bool      `json:"extraChargesIsNil,omitempty"`
	ExtraChargesNotNil bool      `json:"extraChargesNotNil,omitempty"`

	// "extra_charge_note" field predicates.
	ExtraChargeNote             *string  `json:"extraChargeNote,omitempty"`
	ExtraChargeNoteNEQ          *string  `json:"extraChargeNoteNEQ,omitempty"`
	ExtraChargeNoteIn           []string `json:"extraChargeNoteIn,omitempty"`
	ExtraChargeNoteNotIn        []string `json:"extraChargeNoteNotIn,omitempty"`
	ExtraChargeNoteGT           *string  `json:"extraChargeNoteGT,omitempty"`
	ExtraChargeNoteGTE          *string  `json:"extraChargeNoteGTE,omitempty"`
	ExtraChargeNoteLT           *string  `json:"extraChargeNoteLT,omitempty"`
	ExtraChargeNoteLTE          *string  `json:"extraChargeNoteLTE,omitempty"`
	ExtraChargeNoteContains     *string  `json:"extraChargeNoteContains,omitempty"`
	ExtraChargeNoteHasPrefix    *string  `json:"extraChargeNoteHasPrefix,omitempty"`
	ExtraChargeNoteHasSuffix    *string  `json:"extraChargeNoteHasSuffix,omitempty"`
	ExtraChargeNoteIsNil        bool     `json:"extraChargeNoteIsNil,omitempty"`
	ExtraChargeNoteNotNil       bool     `json:"extraChargeNoteNotNil,omitempty"`
	ExtraChargeNoteEqualFold    *string  `json:"extraChargeNoteEqualFold,omitempty"`
	ExtraChargeNoteContainsFold *string  `json:"extraChargeNoteContainsFold,omitempty"`

	// "estimator" field predicates.
	Estimator             *string  `json:"estimator,omitempty"`
	EstimatorNEQ          *string  `json:"estimatorNEQ,omitempty"`
	EstimatorIn           []string `json:"estimatorIn,omitempty"`
	EstimatorNotIn        []string `json:"estimatorNotIn,omitempty"`
	EstimatorGT           *string  `json:"estimatorGT,omitempty"`
	EstimatorGTE          *string  `json:"estimatorGTE,omitempty"`
	EstimatorLT           *string  `json:"estimatorLT,omitempty"`
	EstimatorLTE          *string  `json:"estimatorLTE,omitempty"`
	EstimatorContains     *string  `json:"estimatorContains,omitempty"`
	EstimatorHasPrefix    *string  `json:"estimatorHasPrefix,omitempty"`
	EstimatorHasSuffix    *string  `json:"estimatorHasSuffix,omitempty"`
	EstimatorIsNil        bool     `json:"estimatorIsNil,omitempty"`
	EstimatorNotNil       bool     `json:"estimatorNotNil,omitempty"`
	EstimatorEqualFold    *string  `json:"estimatorEqualFold,omitempty"`
	EstimatorContainsFold *string  `json:"estimatorContainsFold,omitempty"`

	// "estimator_order_id" field predicates.
	EstimatorOrderID       *uint  `json:"estimatorOrderID,omitempty"`
	EstimatorOrderIDNEQ    *uint  `json:"estimatorOrderIDNEQ,omitempty"`
	EstimatorOrderIDIn     []uint `json:"estimatorOrderIDIn,omitempty"`
	EstimatorOrderIDNotIn  []uint `json:"estimatorOrderIDNotIn,omitempty"`
	EstimatorOrderIDGT     *uint  `json:"estimatorOrderIDGT,omitempty"`
	EstimatorOrderIDGTE    *uint  `json:"estimatorOrderIDGTE,omitempty"`
	EstimatorOrderIDLT     *uint  `json:"estimatorOrderIDLT,omitempty"`
	EstimatorOrderIDLTE    *uint  `json:"estimatorOrderIDLTE,omitempty"`
	EstimatorOrderIDIsNil  bool   `json:"estimatorOrderIDIsNil,omitempty"`
	EstimatorOrderIDNotNil bool   `json:"estimatorOrderIDNotNil,omitempty"`

	// "estimator_report_id" field predicates.
	EstimatorReportID       *uint  `json:"estimatorReportID,omitempty"`
	EstimatorReportIDNEQ    *uint  `json:"estimatorReportIDNEQ,omitempty"`
	EstimatorReportIDIn     []uint `json:"estimatorReportIDIn,omitempty"`
	EstimatorReportIDNotIn  []uint `json:"estimatorReportIDNotIn,omitempty"`
	EstimatorReportIDGT     *uint  `json:"estimatorReportIDGT,omitempty"`
	EstimatorReportIDGTE    *uint  `json:"estimatorReportIDGTE,omitempty"`
	EstimatorReportIDLT     *uint  `json:"estimatorReportIDLT,omitempty"`
	EstimatorReportIDLTE    *uint  `json:"estimatorReportIDLTE,omitempty"`
	EstimatorReportIDIsNil  bool   `json:"estimatorReportIDIsNil,omitempty"`
	EstimatorReportIDNotNil bool   `json:"estimatorReportIDNotNil,omitempty"`

	// "total_squares" field predicates.
	TotalSquares      *float64  `json:"totalSquares,omitempty"`
	TotalSquaresNEQ   *float64  `json:"totalSquaresNEQ,omitempty"`
	TotalSquaresIn    []float64 `json:"totalSquaresIn,omitempty"`
	TotalSquaresNotIn []float64 `json:"totalSquaresNotIn,omitempty"`
	TotalSquaresGT    *float64  `json:"totalSquaresGT,omitempty"`
	TotalSquaresGTE   *float64  `json:"totalSquaresGTE,omitempty"`
	TotalSquaresLT    *float64  `json:"totalSquaresLT,omitempty"`
	TotalSquaresLTE   *float64  `json:"totalSquaresLTE,omitempty"`

	// "primary_pitch" field predicates.
	PrimaryPitch      *float64  `json:"primaryPitch,omitempty"`
	PrimaryPitchNEQ   *float64  `json:"primaryPitchNEQ,omitempty"`
	PrimaryPitchIn    []float64 `json:"primaryPitchIn,omitempty"`
	PrimaryPitchNotIn []float64 `json:"primaryPitchNotIn,omitempty"`
	PrimaryPitchGT    *float64  `json:"primaryPitchGT,omitempty"`
	PrimaryPitchGTE   *float64  `json:"primaryPitchGTE,omitempty"`
	PrimaryPitchLT    *float64  `json:"primaryPitchLT,omitempty"`
	PrimaryPitchLTE   *float64  `json:"primaryPitchLTE,omitempty"`

	// "price" field predicates.
	Price      *float64  `json:"price,omitempty"`
	PriceNEQ   *float64  `json:"priceNEQ,omitempty"`
	PriceIn    []float64 `json:"priceIn,omitempty"`
	PriceNotIn []float64 `json:"priceNotIn,omitempty"`
	PriceGT    *float64  `json:"priceGT,omitempty"`
	PriceGTE   *float64  `json:"priceGTE,omitempty"`
	PriceLT    *float64  `json:"priceLT,omitempty"`
	PriceLTE   *float64  `json:"priceLTE,omitempty"`

	// "price_summary" field predicates.
	PriceSummary             *string  `json:"priceSummary,omitempty"`
	PriceSummaryNEQ          *string  `json:"priceSummaryNEQ,omitempty"`
	PriceSummaryIn           []string `json:"priceSummaryIn,omitempty"`
	PriceSummaryNotIn        []string `json:"priceSummaryNotIn,omitempty"`
	PriceSummaryGT           *string  `json:"priceSummaryGT,omitempty"`
	PriceSummaryGTE          *string  `json:"priceSummaryGTE,omitempty"`
	PriceSummaryLT           *string  `json:"priceSummaryLT,omitempty"`
	PriceSummaryLTE          *string  `json:"priceSummaryLTE,omitempty"`
	PriceSummaryContains     *string  `json:"priceSummaryContains,omitempty"`
	PriceSummaryHasPrefix    *string  `json:"priceSummaryHasPrefix,omitempty"`
	PriceSummaryHasSuffix    *string  `json:"priceSummaryHasSuffix,omitempty"`
	PriceSummaryIsNil        bool     `json:"priceSummaryIsNil,omitempty"`
	PriceSummaryNotNil       bool     `json:"priceSummaryNotNil,omitempty"`
	PriceSummaryEqualFold    *string  `json:"priceSummaryEqualFold,omitempty"`
	PriceSummaryContainsFold *string  `json:"priceSummaryContainsFold,omitempty"`

	// "override" field predicates.
	Override       *bool `json:"override,omitempty"`
	OverrideNEQ    *bool `json:"overrideNEQ,omitempty"`
	OverrideIsNil  bool  `json:"overrideIsNil,omitempty"`
	OverrideNotNil bool  `json:"overrideNotNil,omitempty"`

	// "override_total_squares" field predicates.
	OverrideTotalSquares      *float64  `json:"overrideTotalSquares,omitempty"`
	OverrideTotalSquaresNEQ   *float64  `json:"overrideTotalSquaresNEQ,omitempty"`
	OverrideTotalSquaresIn    []float64 `json:"overrideTotalSquaresIn,omitempty"`
	OverrideTotalSquaresNotIn []float64 `json:"overrideTotalSquaresNotIn,omitempty"`
	OverrideTotalSquaresGT    *float64  `json:"overrideTotalSquaresGT,omitempty"`
	OverrideTotalSquaresGTE   *float64  `json:"overrideTotalSquaresGTE,omitempty"`
	OverrideTotalSquaresLT    *float64  `json:"overrideTotalSquaresLT,omitempty"`
	OverrideTotalSquaresLTE   *float64  `json:"overrideTotalSquaresLTE,omitempty"`

	// "override_primary_pitch" field predicates.
	OverridePrimaryPitch      *float64  `json:"overridePrimaryPitch,omitempty"`
	OverridePrimaryPitchNEQ   *float64  `json:"overridePrimaryPitchNEQ,omitempty"`
	OverridePrimaryPitchIn    []float64 `json:"overridePrimaryPitchIn,omitempty"`
	OverridePrimaryPitchNotIn []float64 `json:"overridePrimaryPitchNotIn,omitempty"`
	OverridePrimaryPitchGT    *float64  `json:"overridePrimaryPitchGT,omitempty"`
	OverridePrimaryPitchGTE   *float64  `json:"overridePrimaryPitchGTE,omitempty"`
	OverridePrimaryPitchLT    *float64  `json:"overridePrimaryPitchLT,omitempty"`
	OverridePrimaryPitchLTE   *float64  `json:"overridePrimaryPitchLTE,omitempty"`

	// "override_price" field predicates.
	OverridePrice      *float64  `json:"overridePrice,omitempty"`
	OverridePriceNEQ   *float64  `json:"overridePriceNEQ,omitempty"`
	OverridePriceIn    []float64 `json:"overridePriceIn,omitempty"`
	OverridePriceNotIn []float64 `json:"overridePriceNotIn,omitempty"`
	OverridePriceGT    *float64  `json:"overridePriceGT,omitempty"`
	OverridePriceGTE   *float64  `json:"overridePriceGTE,omitempty"`
	OverridePriceLT    *float64  `json:"overridePriceLT,omitempty"`
	OverridePriceLTE   *float64  `json:"overridePriceLTE,omitempty"`

	// "override_price_summary" field predicates.
	OverridePriceSummary             *string  `json:"overridePriceSummary,omitempty"`
	OverridePriceSummaryNEQ          *string  `json:"overridePriceSummaryNEQ,omitempty"`
	OverridePriceSummaryIn           []string `json:"overridePriceSummaryIn,omitempty"`
	OverridePriceSummaryNotIn        []string `json:"overridePriceSummaryNotIn,omitempty"`
	OverridePriceSummaryGT           *string  `json:"overridePriceSummaryGT,omitempty"`
	OverridePriceSummaryGTE          *string  `json:"overridePriceSummaryGTE,omitempty"`
	OverridePriceSummaryLT           *string  `json:"overridePriceSummaryLT,omitempty"`
	OverridePriceSummaryLTE          *string  `json:"overridePriceSummaryLTE,omitempty"`
	OverridePriceSummaryContains     *string  `json:"overridePriceSummaryContains,omitempty"`
	OverridePriceSummaryHasPrefix    *string  `json:"overridePriceSummaryHasPrefix,omitempty"`
	OverridePriceSummaryHasSuffix    *string  `json:"overridePriceSummaryHasSuffix,omitempty"`
	OverridePriceSummaryIsNil        bool     `json:"overridePriceSummaryIsNil,omitempty"`
	OverridePriceSummaryNotNil       bool     `json:"overridePriceSummaryNotNil,omitempty"`
	OverridePriceSummaryEqualFold    *string  `json:"overridePriceSummaryEqualFold,omitempty"`
	OverridePriceSummaryContainsFold *string  `json:"overridePriceSummaryContainsFold,omitempty"`

	// "company_ref_id" field predicates.
	CompanyRefID             *string  `json:"companyRefID,omitempty"`
	CompanyRefIDNEQ          *string  `json:"companyRefIDNEQ,omitempty"`
	CompanyRefIDIn           []string `json:"companyRefIDIn,omitempty"`
	CompanyRefIDNotIn        []string `json:"companyRefIDNotIn,omitempty"`
	CompanyRefIDGT           *string  `json:"companyRefIDGT,omitempty"`
	CompanyRefIDGTE          *string  `json:"companyRefIDGTE,omitempty"`
	CompanyRefIDLT           *string  `json:"companyRefIDLT,omitempty"`
	CompanyRefIDLTE          *string  `json:"companyRefIDLTE,omitempty"`
	CompanyRefIDContains     *string  `json:"companyRefIDContains,omitempty"`
	CompanyRefIDHasPrefix    *string  `json:"companyRefIDHasPrefix,omitempty"`
	CompanyRefIDHasSuffix    *string  `json:"companyRefIDHasSuffix,omitempty"`
	CompanyRefIDIsNil        bool     `json:"companyRefIDIsNil,omitempty"`
	CompanyRefIDNotNil       bool     `json:"companyRefIDNotNil,omitempty"`
	CompanyRefIDEqualFold    *string  `json:"companyRefIDEqualFold,omitempty"`
	CompanyRefIDContainsFold *string  `json:"companyRefIDContainsFold,omitempty"`

	// "company_ref_name" field predicates.
	CompanyRefName             *string  `json:"companyRefName,omitempty"`
	CompanyRefNameNEQ          *string  `json:"companyRefNameNEQ,omitempty"`
	CompanyRefNameIn           []string `json:"companyRefNameIn,omitempty"`
	CompanyRefNameNotIn        []string `json:"companyRefNameNotIn,omitempty"`
	CompanyRefNameGT           *string  `json:"companyRefNameGT,omitempty"`
	CompanyRefNameGTE          *string  `json:"companyRefNameGTE,omitempty"`
	CompanyRefNameLT           *string  `json:"companyRefNameLT,omitempty"`
	CompanyRefNameLTE          *string  `json:"companyRefNameLTE,omitempty"`
	CompanyRefNameContains     *string  `json:"companyRefNameContains,omitempty"`
	CompanyRefNameHasPrefix    *string  `json:"companyRefNameHasPrefix,omitempty"`
	CompanyRefNameHasSuffix    *string  `json:"companyRefNameHasSuffix,omitempty"`
	CompanyRefNameIsNil        bool     `json:"companyRefNameIsNil,omitempty"`
	CompanyRefNameNotNil       bool     `json:"companyRefNameNotNil,omitempty"`
	CompanyRefNameEqualFold    *string  `json:"companyRefNameEqualFold,omitempty"`
	CompanyRefNameContainsFold *string  `json:"companyRefNameContainsFold,omitempty"`

	// "failure_reason" field predicates.
	FailureReason             *string  `json:"failureReason,omitempty"`
	FailureReasonNEQ          *string  `json:"failureReasonNEQ,omitempty"`
	FailureReasonIn           []string `json:"failureReasonIn,omitempty"`
	FailureReasonNotIn        []string `json:"failureReasonNotIn,omitempty"`
	FailureReasonGT           *string  `json:"failureReasonGT,omitempty"`
	FailureReasonGTE          *string  `json:"failureReasonGTE,omitempty"`
	FailureReasonLT           *string  `json:"failureReasonLT,omitempty"`
	FailureReasonLTE          *string  `json:"failureReasonLTE,omitempty"`
	FailureReasonContains     *string  `json:"failureReasonContains,omitempty"`
	FailureReasonHasPrefix    *string  `json:"failureReasonHasPrefix,omitempty"`
	FailureReasonHasSuffix    *string  `json:"failureReasonHasSuffix,omitempty"`
	FailureReasonIsNil        bool     `json:"failureReasonIsNil,omitempty"`
	FailureReasonNotNil       bool     `json:"failureReasonNotNil,omitempty"`
	FailureReasonEqualFold    *string  `json:"failureReasonEqualFold,omitempty"`
	FailureReasonContainsFold *string  `json:"failureReasonContainsFold,omitempty"`

	// "activities" edge predicates.
	HasActivities     *bool                         `json:"hasActivities,omitempty"`
	HasActivitiesWith []*EstimateActivityWhereInput `json:"hasActivitiesWith,omitempty"`

	// "job_info" edge predicates.
	HasJobInfo     *bool            `json:"hasJobInfo,omitempty"`
	HasJobInfoWith []*JobWhereInput `json:"hasJobInfoWith,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`

	// "home_owner" edge predicates.
	HasHomeOwner     *bool                  `json:"hasHomeOwner,omitempty"`
	HasHomeOwnerWith []*HomeOwnerWhereInput `json:"hasHomeOwnerWith,omitempty"`

	// "sales_rep" edge predicates.
	HasSalesRep     *bool             `json:"hasSalesRep,omitempty"`
	HasSalesRepWith []*UserWhereInput `json:"hasSalesRepWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "creator_api" edge predicates.
	HasCreatorAPI     *bool                `json:"hasCreatorAPI,omitempty"`
	HasCreatorAPIWith []*ApiUserWhereInput `json:"hasCreatorAPIWith,omitempty"`

	// "pdf" edge predicates.
	HasPdf     *bool                 `json:"hasPdf,omitempty"`
	HasPdfWith []*DocumentWhereInput `json:"hasPdfWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EstimateWhereInput) AddPredicates(predicates ...predicate.Estimate) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EstimateWhereInput filter on the EstimateQuery builder.
func (i *EstimateWhereInput) Filter(q *EstimateQuery) (*EstimateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEstimateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEstimateWhereInput is returned in case the EstimateWhereInput is empty.
var ErrEmptyEstimateWhereInput = errors.New("ent: empty predicate EstimateWhereInput")

// P returns a predicate for filtering estimates.
// An error is returned if the input is empty or invalid.
func (i *EstimateWhereInput) P() (predicate.Estimate, error) {
	var predicates []predicate.Estimate
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, estimate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Estimate, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, estimate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Estimate, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, estimate.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, estimate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, estimate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, estimate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, estimate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, estimate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, estimate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, estimate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, estimate.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, estimate.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, estimate.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, estimate.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, estimate.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, estimate.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, estimate.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, estimate.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, estimate.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, estimate.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, estimate.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, estimate.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, estimate.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, estimate.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, estimate.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, estimate.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, estimate.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, estimate.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, estimate.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.RegionID != nil {
		predicates = append(predicates, estimate.RegionIDEQ(*i.RegionID))
	}
	if i.RegionIDNEQ != nil {
		predicates = append(predicates, estimate.RegionIDNEQ(*i.RegionIDNEQ))
	}
	if len(i.RegionIDIn) > 0 {
		predicates = append(predicates, estimate.RegionIDIn(i.RegionIDIn...))
	}
	if len(i.RegionIDNotIn) > 0 {
		predicates = append(predicates, estimate.RegionIDNotIn(i.RegionIDNotIn...))
	}
	if i.RegionIDGT != nil {
		predicates = append(predicates, estimate.RegionIDGT(*i.RegionIDGT))
	}
	if i.RegionIDGTE != nil {
		predicates = append(predicates, estimate.RegionIDGTE(*i.RegionIDGTE))
	}
	if i.RegionIDLT != nil {
		predicates = append(predicates, estimate.RegionIDLT(*i.RegionIDLT))
	}
	if i.RegionIDLTE != nil {
		predicates = append(predicates, estimate.RegionIDLTE(*i.RegionIDLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, estimate.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, estimate.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, estimate.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, estimate.StatusNotIn(i.StatusNotIn...))
	}
	if i.CurrentMaterial != nil {
		predicates = append(predicates, estimate.CurrentMaterialEQ(*i.CurrentMaterial))
	}
	if i.CurrentMaterialNEQ != nil {
		predicates = append(predicates, estimate.CurrentMaterialNEQ(*i.CurrentMaterialNEQ))
	}
	if len(i.CurrentMaterialIn) > 0 {
		predicates = append(predicates, estimate.CurrentMaterialIn(i.CurrentMaterialIn...))
	}
	if len(i.CurrentMaterialNotIn) > 0 {
		predicates = append(predicates, estimate.CurrentMaterialNotIn(i.CurrentMaterialNotIn...))
	}
	if i.CurrentMaterialGT != nil {
		predicates = append(predicates, estimate.CurrentMaterialGT(*i.CurrentMaterialGT))
	}
	if i.CurrentMaterialGTE != nil {
		predicates = append(predicates, estimate.CurrentMaterialGTE(*i.CurrentMaterialGTE))
	}
	if i.CurrentMaterialLT != nil {
		predicates = append(predicates, estimate.CurrentMaterialLT(*i.CurrentMaterialLT))
	}
	if i.CurrentMaterialLTE != nil {
		predicates = append(predicates, estimate.CurrentMaterialLTE(*i.CurrentMaterialLTE))
	}
	if i.CurrentMaterialContains != nil {
		predicates = append(predicates, estimate.CurrentMaterialContains(*i.CurrentMaterialContains))
	}
	if i.CurrentMaterialHasPrefix != nil {
		predicates = append(predicates, estimate.CurrentMaterialHasPrefix(*i.CurrentMaterialHasPrefix))
	}
	if i.CurrentMaterialHasSuffix != nil {
		predicates = append(predicates, estimate.CurrentMaterialHasSuffix(*i.CurrentMaterialHasSuffix))
	}
	if i.CurrentMaterialIsNil {
		predicates = append(predicates, estimate.CurrentMaterialIsNil())
	}
	if i.CurrentMaterialNotNil {
		predicates = append(predicates, estimate.CurrentMaterialNotNil())
	}
	if i.CurrentMaterialEqualFold != nil {
		predicates = append(predicates, estimate.CurrentMaterialEqualFold(*i.CurrentMaterialEqualFold))
	}
	if i.CurrentMaterialContainsFold != nil {
		predicates = append(predicates, estimate.CurrentMaterialContainsFold(*i.CurrentMaterialContainsFold))
	}
	if i.NewRoofingMaterial != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialEQ(*i.NewRoofingMaterial))
	}
	if i.NewRoofingMaterialNEQ != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialNEQ(*i.NewRoofingMaterialNEQ))
	}
	if len(i.NewRoofingMaterialIn) > 0 {
		predicates = append(predicates, estimate.NewRoofingMaterialIn(i.NewRoofingMaterialIn...))
	}
	if len(i.NewRoofingMaterialNotIn) > 0 {
		predicates = append(predicates, estimate.NewRoofingMaterialNotIn(i.NewRoofingMaterialNotIn...))
	}
	if i.NewRoofingMaterialGT != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialGT(*i.NewRoofingMaterialGT))
	}
	if i.NewRoofingMaterialGTE != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialGTE(*i.NewRoofingMaterialGTE))
	}
	if i.NewRoofingMaterialLT != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLT(*i.NewRoofingMaterialLT))
	}
	if i.NewRoofingMaterialLTE != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLTE(*i.NewRoofingMaterialLTE))
	}
	if i.NewRoofingMaterialContains != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialContains(*i.NewRoofingMaterialContains))
	}
	if i.NewRoofingMaterialHasPrefix != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialHasPrefix(*i.NewRoofingMaterialHasPrefix))
	}
	if i.NewRoofingMaterialHasSuffix != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialHasSuffix(*i.NewRoofingMaterialHasSuffix))
	}
	if i.NewRoofingMaterialIsNil {
		predicates = append(predicates, estimate.NewRoofingMaterialIsNil())
	}
	if i.NewRoofingMaterialNotNil {
		predicates = append(predicates, estimate.NewRoofingMaterialNotNil())
	}
	if i.NewRoofingMaterialEqualFold != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialEqualFold(*i.NewRoofingMaterialEqualFold))
	}
	if i.NewRoofingMaterialContainsFold != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialContainsFold(*i.NewRoofingMaterialContainsFold))
	}
	if i.LowSlope != nil {
		predicates = append(predicates, estimate.LowSlopeEQ(*i.LowSlope))
	}
	if i.LowSlopeNEQ != nil {
		predicates = append(predicates, estimate.LowSlopeNEQ(*i.LowSlopeNEQ))
	}
	if i.CurrentMaterialLowSlope != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeEQ(*i.CurrentMaterialLowSlope))
	}
	if i.CurrentMaterialLowSlopeNEQ != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeNEQ(*i.CurrentMaterialLowSlopeNEQ))
	}
	if len(i.CurrentMaterialLowSlopeIn) > 0 {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeIn(i.CurrentMaterialLowSlopeIn...))
	}
	if len(i.CurrentMaterialLowSlopeNotIn) > 0 {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeNotIn(i.CurrentMaterialLowSlopeNotIn...))
	}
	if i.CurrentMaterialLowSlopeGT != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeGT(*i.CurrentMaterialLowSlopeGT))
	}
	if i.CurrentMaterialLowSlopeGTE != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeGTE(*i.CurrentMaterialLowSlopeGTE))
	}
	if i.CurrentMaterialLowSlopeLT != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeLT(*i.CurrentMaterialLowSlopeLT))
	}
	if i.CurrentMaterialLowSlopeLTE != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeLTE(*i.CurrentMaterialLowSlopeLTE))
	}
	if i.CurrentMaterialLowSlopeContains != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeContains(*i.CurrentMaterialLowSlopeContains))
	}
	if i.CurrentMaterialLowSlopeHasPrefix != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeHasPrefix(*i.CurrentMaterialLowSlopeHasPrefix))
	}
	if i.CurrentMaterialLowSlopeHasSuffix != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeHasSuffix(*i.CurrentMaterialLowSlopeHasSuffix))
	}
	if i.CurrentMaterialLowSlopeIsNil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeIsNil())
	}
	if i.CurrentMaterialLowSlopeNotNil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeNotNil())
	}
	if i.CurrentMaterialLowSlopeEqualFold != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeEqualFold(*i.CurrentMaterialLowSlopeEqualFold))
	}
	if i.CurrentMaterialLowSlopeContainsFold != nil {
		predicates = append(predicates, estimate.CurrentMaterialLowSlopeContainsFold(*i.CurrentMaterialLowSlopeContainsFold))
	}
	if i.NewRoofingMaterialLowSlope != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeEQ(*i.NewRoofingMaterialLowSlope))
	}
	if i.NewRoofingMaterialLowSlopeNEQ != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeNEQ(*i.NewRoofingMaterialLowSlopeNEQ))
	}
	if len(i.NewRoofingMaterialLowSlopeIn) > 0 {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeIn(i.NewRoofingMaterialLowSlopeIn...))
	}
	if len(i.NewRoofingMaterialLowSlopeNotIn) > 0 {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeNotIn(i.NewRoofingMaterialLowSlopeNotIn...))
	}
	if i.NewRoofingMaterialLowSlopeGT != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeGT(*i.NewRoofingMaterialLowSlopeGT))
	}
	if i.NewRoofingMaterialLowSlopeGTE != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeGTE(*i.NewRoofingMaterialLowSlopeGTE))
	}
	if i.NewRoofingMaterialLowSlopeLT != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeLT(*i.NewRoofingMaterialLowSlopeLT))
	}
	if i.NewRoofingMaterialLowSlopeLTE != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeLTE(*i.NewRoofingMaterialLowSlopeLTE))
	}
	if i.NewRoofingMaterialLowSlopeContains != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeContains(*i.NewRoofingMaterialLowSlopeContains))
	}
	if i.NewRoofingMaterialLowSlopeHasPrefix != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeHasPrefix(*i.NewRoofingMaterialLowSlopeHasPrefix))
	}
	if i.NewRoofingMaterialLowSlopeHasSuffix != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeHasSuffix(*i.NewRoofingMaterialLowSlopeHasSuffix))
	}
	if i.NewRoofingMaterialLowSlopeIsNil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeIsNil())
	}
	if i.NewRoofingMaterialLowSlopeNotNil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeNotNil())
	}
	if i.NewRoofingMaterialLowSlopeEqualFold != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeEqualFold(*i.NewRoofingMaterialLowSlopeEqualFold))
	}
	if i.NewRoofingMaterialLowSlopeContainsFold != nil {
		predicates = append(predicates, estimate.NewRoofingMaterialLowSlopeContainsFold(*i.NewRoofingMaterialLowSlopeContainsFold))
	}
	if i.Redeck != nil {
		predicates = append(predicates, estimate.RedeckEQ(*i.Redeck))
	}
	if i.RedeckNEQ != nil {
		predicates = append(predicates, estimate.RedeckNEQ(*i.RedeckNEQ))
	}
	if i.Layers != nil {
		predicates = append(predicates, estimate.LayersEQ(*i.Layers))
	}
	if i.LayersNEQ != nil {
		predicates = append(predicates, estimate.LayersNEQ(*i.LayersNEQ))
	}
	if len(i.LayersIn) > 0 {
		predicates = append(predicates, estimate.LayersIn(i.LayersIn...))
	}
	if len(i.LayersNotIn) > 0 {
		predicates = append(predicates, estimate.LayersNotIn(i.LayersNotIn...))
	}
	if i.LayersGT != nil {
		predicates = append(predicates, estimate.LayersGT(*i.LayersGT))
	}
	if i.LayersGTE != nil {
		predicates = append(predicates, estimate.LayersGTE(*i.LayersGTE))
	}
	if i.LayersLT != nil {
		predicates = append(predicates, estimate.LayersLT(*i.LayersLT))
	}
	if i.LayersLTE != nil {
		predicates = append(predicates, estimate.LayersLTE(*i.LayersLTE))
	}
	if i.Layer2Material != nil {
		predicates = append(predicates, estimate.Layer2MaterialEQ(*i.Layer2Material))
	}
	if i.Layer2MaterialNEQ != nil {
		predicates = append(predicates, estimate.Layer2MaterialNEQ(*i.Layer2MaterialNEQ))
	}
	if len(i.Layer2MaterialIn) > 0 {
		predicates = append(predicates, estimate.Layer2MaterialIn(i.Layer2MaterialIn...))
	}
	if len(i.Layer2MaterialNotIn) > 0 {
		predicates = append(predicates, estimate.Layer2MaterialNotIn(i.Layer2MaterialNotIn...))
	}
	if i.Layer2MaterialGT != nil {
		predicates = append(predicates, estimate.Layer2MaterialGT(*i.Layer2MaterialGT))
	}
	if i.Layer2MaterialGTE != nil {
		predicates = append(predicates, estimate.Layer2MaterialGTE(*i.Layer2MaterialGTE))
	}
	if i.Layer2MaterialLT != nil {
		predicates = append(predicates, estimate.Layer2MaterialLT(*i.Layer2MaterialLT))
	}
	if i.Layer2MaterialLTE != nil {
		predicates = append(predicates, estimate.Layer2MaterialLTE(*i.Layer2MaterialLTE))
	}
	if i.Layer2MaterialContains != nil {
		predicates = append(predicates, estimate.Layer2MaterialContains(*i.Layer2MaterialContains))
	}
	if i.Layer2MaterialHasPrefix != nil {
		predicates = append(predicates, estimate.Layer2MaterialHasPrefix(*i.Layer2MaterialHasPrefix))
	}
	if i.Layer2MaterialHasSuffix != nil {
		predicates = append(predicates, estimate.Layer2MaterialHasSuffix(*i.Layer2MaterialHasSuffix))
	}
	if i.Layer2MaterialIsNil {
		predicates = append(predicates, estimate.Layer2MaterialIsNil())
	}
	if i.Layer2MaterialNotNil {
		predicates = append(predicates, estimate.Layer2MaterialNotNil())
	}
	if i.Layer2MaterialEqualFold != nil {
		predicates = append(predicates, estimate.Layer2MaterialEqualFold(*i.Layer2MaterialEqualFold))
	}
	if i.Layer2MaterialContainsFold != nil {
		predicates = append(predicates, estimate.Layer2MaterialContainsFold(*i.Layer2MaterialContainsFold))
	}
	if i.Layer3Material != nil {
		predicates = append(predicates, estimate.Layer3MaterialEQ(*i.Layer3Material))
	}
	if i.Layer3MaterialNEQ != nil {
		predicates = append(predicates, estimate.Layer3MaterialNEQ(*i.Layer3MaterialNEQ))
	}
	if len(i.Layer3MaterialIn) > 0 {
		predicates = append(predicates, estimate.Layer3MaterialIn(i.Layer3MaterialIn...))
	}
	if len(i.Layer3MaterialNotIn) > 0 {
		predicates = append(predicates, estimate.Layer3MaterialNotIn(i.Layer3MaterialNotIn...))
	}
	if i.Layer3MaterialGT != nil {
		predicates = append(predicates, estimate.Layer3MaterialGT(*i.Layer3MaterialGT))
	}
	if i.Layer3MaterialGTE != nil {
		predicates = append(predicates, estimate.Layer3MaterialGTE(*i.Layer3MaterialGTE))
	}
	if i.Layer3MaterialLT != nil {
		predicates = append(predicates, estimate.Layer3MaterialLT(*i.Layer3MaterialLT))
	}
	if i.Layer3MaterialLTE != nil {
		predicates = append(predicates, estimate.Layer3MaterialLTE(*i.Layer3MaterialLTE))
	}
	if i.Layer3MaterialContains != nil {
		predicates = append(predicates, estimate.Layer3MaterialContains(*i.Layer3MaterialContains))
	}
	if i.Layer3MaterialHasPrefix != nil {
		predicates = append(predicates, estimate.Layer3MaterialHasPrefix(*i.Layer3MaterialHasPrefix))
	}
	if i.Layer3MaterialHasSuffix != nil {
		predicates = append(predicates, estimate.Layer3MaterialHasSuffix(*i.Layer3MaterialHasSuffix))
	}
	if i.Layer3MaterialIsNil {
		predicates = append(predicates, estimate.Layer3MaterialIsNil())
	}
	if i.Layer3MaterialNotNil {
		predicates = append(predicates, estimate.Layer3MaterialNotNil())
	}
	if i.Layer3MaterialEqualFold != nil {
		predicates = append(predicates, estimate.Layer3MaterialEqualFold(*i.Layer3MaterialEqualFold))
	}
	if i.Layer3MaterialContainsFold != nil {
		predicates = append(predicates, estimate.Layer3MaterialContainsFold(*i.Layer3MaterialContainsFold))
	}
	if i.PartialPercentage != nil {
		predicates = append(predicates, estimate.PartialPercentageEQ(*i.PartialPercentage))
	}
	if i.PartialPercentageNEQ != nil {
		predicates = append(predicates, estimate.PartialPercentageNEQ(*i.PartialPercentageNEQ))
	}
	if len(i.PartialPercentageIn) > 0 {
		predicates = append(predicates, estimate.PartialPercentageIn(i.PartialPercentageIn...))
	}
	if len(i.PartialPercentageNotIn) > 0 {
		predicates = append(predicates, estimate.PartialPercentageNotIn(i.PartialPercentageNotIn...))
	}
	if i.PartialPercentageGT != nil {
		predicates = append(predicates, estimate.PartialPercentageGT(*i.PartialPercentageGT))
	}
	if i.PartialPercentageGTE != nil {
		predicates = append(predicates, estimate.PartialPercentageGTE(*i.PartialPercentageGTE))
	}
	if i.PartialPercentageLT != nil {
		predicates = append(predicates, estimate.PartialPercentageLT(*i.PartialPercentageLT))
	}
	if i.PartialPercentageLTE != nil {
		predicates = append(predicates, estimate.PartialPercentageLTE(*i.PartialPercentageLTE))
	}
	if i.PartialPercentageIsNil {
		predicates = append(predicates, estimate.PartialPercentageIsNil())
	}
	if i.PartialPercentageNotNil {
		predicates = append(predicates, estimate.PartialPercentageNotNil())
	}
	if i.MaterialMappingNote != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteEQ(*i.MaterialMappingNote))
	}
	if i.MaterialMappingNoteNEQ != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteNEQ(*i.MaterialMappingNoteNEQ))
	}
	if len(i.MaterialMappingNoteIn) > 0 {
		predicates = append(predicates, estimate.MaterialMappingNoteIn(i.MaterialMappingNoteIn...))
	}
	if len(i.MaterialMappingNoteNotIn) > 0 {
		predicates = append(predicates, estimate.MaterialMappingNoteNotIn(i.MaterialMappingNoteNotIn...))
	}
	if i.MaterialMappingNoteGT != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteGT(*i.MaterialMappingNoteGT))
	}
	if i.MaterialMappingNoteGTE != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteGTE(*i.MaterialMappingNoteGTE))
	}
	if i.MaterialMappingNoteLT != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteLT(*i.MaterialMappingNoteLT))
	}
	if i.MaterialMappingNoteLTE != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteLTE(*i.MaterialMappingNoteLTE))
	}
	if i.MaterialMappingNoteContains != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteContains(*i.MaterialMappingNoteContains))
	}
	if i.MaterialMappingNoteHasPrefix != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteHasPrefix(*i.MaterialMappingNoteHasPrefix))
	}
	if i.MaterialMappingNoteHasSuffix != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteHasSuffix(*i.MaterialMappingNoteHasSuffix))
	}
	if i.MaterialMappingNoteIsNil {
		predicates = append(predicates, estimate.MaterialMappingNoteIsNil())
	}
	if i.MaterialMappingNoteNotNil {
		predicates = append(predicates, estimate.MaterialMappingNoteNotNil())
	}
	if i.MaterialMappingNoteEqualFold != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteEqualFold(*i.MaterialMappingNoteEqualFold))
	}
	if i.MaterialMappingNoteContainsFold != nil {
		predicates = append(predicates, estimate.MaterialMappingNoteContainsFold(*i.MaterialMappingNoteContainsFold))
	}
	if i.MeasureType != nil {
		predicates = append(predicates, estimate.MeasureTypeEQ(*i.MeasureType))
	}
	if i.MeasureTypeNEQ != nil {
		predicates = append(predicates, estimate.MeasureTypeNEQ(*i.MeasureTypeNEQ))
	}
	if len(i.MeasureTypeIn) > 0 {
		predicates = append(predicates, estimate.MeasureTypeIn(i.MeasureTypeIn...))
	}
	if len(i.MeasureTypeNotIn) > 0 {
		predicates = append(predicates, estimate.MeasureTypeNotIn(i.MeasureTypeNotIn...))
	}
	if i.ExtraChargeType != nil {
		predicates = append(predicates, estimate.ExtraChargeTypeEQ(*i.ExtraChargeType))
	}
	if i.ExtraChargeTypeNEQ != nil {
		predicates = append(predicates, estimate.ExtraChargeTypeNEQ(*i.ExtraChargeTypeNEQ))
	}
	if len(i.ExtraChargeTypeIn) > 0 {
		predicates = append(predicates, estimate.ExtraChargeTypeIn(i.ExtraChargeTypeIn...))
	}
	if len(i.ExtraChargeTypeNotIn) > 0 {
		predicates = append(predicates, estimate.ExtraChargeTypeNotIn(i.ExtraChargeTypeNotIn...))
	}
	if i.ExtraChargeTypeIsNil {
		predicates = append(predicates, estimate.ExtraChargeTypeIsNil())
	}
	if i.ExtraChargeTypeNotNil {
		predicates = append(predicates, estimate.ExtraChargeTypeNotNil())
	}
	if i.ExtraCharges != nil {
		predicates = append(predicates, estimate.ExtraChargesEQ(*i.ExtraCharges))
	}
	if i.ExtraChargesNEQ != nil {
		predicates = append(predicates, estimate.ExtraChargesNEQ(*i.ExtraChargesNEQ))
	}
	if len(i.ExtraChargesIn) > 0 {
		predicates = append(predicates, estimate.ExtraChargesIn(i.ExtraChargesIn...))
	}
	if len(i.ExtraChargesNotIn) > 0 {
		predicates = append(predicates, estimate.ExtraChargesNotIn(i.ExtraChargesNotIn...))
	}
	if i.ExtraChargesGT != nil {
		predicates = append(predicates, estimate.ExtraChargesGT(*i.ExtraChargesGT))
	}
	if i.ExtraChargesGTE != nil {
		predicates = append(predicates, estimate.ExtraChargesGTE(*i.ExtraChargesGTE))
	}
	if i.ExtraChargesLT != nil {
		predicates = append(predicates, estimate.ExtraChargesLT(*i.ExtraChargesLT))
	}
	if i.ExtraChargesLTE != nil {
		predicates = append(predicates, estimate.ExtraChargesLTE(*i.ExtraChargesLTE))
	}
	if i.ExtraChargesIsNil {
		predicates = append(predicates, estimate.ExtraChargesIsNil())
	}
	if i.ExtraChargesNotNil {
		predicates = append(predicates, estimate.ExtraChargesNotNil())
	}
	if i.ExtraChargeNote != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteEQ(*i.ExtraChargeNote))
	}
	if i.ExtraChargeNoteNEQ != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteNEQ(*i.ExtraChargeNoteNEQ))
	}
	if len(i.ExtraChargeNoteIn) > 0 {
		predicates = append(predicates, estimate.ExtraChargeNoteIn(i.ExtraChargeNoteIn...))
	}
	if len(i.ExtraChargeNoteNotIn) > 0 {
		predicates = append(predicates, estimate.ExtraChargeNoteNotIn(i.ExtraChargeNoteNotIn...))
	}
	if i.ExtraChargeNoteGT != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteGT(*i.ExtraChargeNoteGT))
	}
	if i.ExtraChargeNoteGTE != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteGTE(*i.ExtraChargeNoteGTE))
	}
	if i.ExtraChargeNoteLT != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteLT(*i.ExtraChargeNoteLT))
	}
	if i.ExtraChargeNoteLTE != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteLTE(*i.ExtraChargeNoteLTE))
	}
	if i.ExtraChargeNoteContains != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteContains(*i.ExtraChargeNoteContains))
	}
	if i.ExtraChargeNoteHasPrefix != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteHasPrefix(*i.ExtraChargeNoteHasPrefix))
	}
	if i.ExtraChargeNoteHasSuffix != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteHasSuffix(*i.ExtraChargeNoteHasSuffix))
	}
	if i.ExtraChargeNoteIsNil {
		predicates = append(predicates, estimate.ExtraChargeNoteIsNil())
	}
	if i.ExtraChargeNoteNotNil {
		predicates = append(predicates, estimate.ExtraChargeNoteNotNil())
	}
	if i.ExtraChargeNoteEqualFold != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteEqualFold(*i.ExtraChargeNoteEqualFold))
	}
	if i.ExtraChargeNoteContainsFold != nil {
		predicates = append(predicates, estimate.ExtraChargeNoteContainsFold(*i.ExtraChargeNoteContainsFold))
	}
	if i.Estimator != nil {
		predicates = append(predicates, estimate.EstimatorEQ(*i.Estimator))
	}
	if i.EstimatorNEQ != nil {
		predicates = append(predicates, estimate.EstimatorNEQ(*i.EstimatorNEQ))
	}
	if len(i.EstimatorIn) > 0 {
		predicates = append(predicates, estimate.EstimatorIn(i.EstimatorIn...))
	}
	if len(i.EstimatorNotIn) > 0 {
		predicates = append(predicates, estimate.EstimatorNotIn(i.EstimatorNotIn...))
	}
	if i.EstimatorGT != nil {
		predicates = append(predicates, estimate.EstimatorGT(*i.EstimatorGT))
	}
	if i.EstimatorGTE != nil {
		predicates = append(predicates, estimate.EstimatorGTE(*i.EstimatorGTE))
	}
	if i.EstimatorLT != nil {
		predicates = append(predicates, estimate.EstimatorLT(*i.EstimatorLT))
	}
	if i.EstimatorLTE != nil {
		predicates = append(predicates, estimate.EstimatorLTE(*i.EstimatorLTE))
	}
	if i.EstimatorContains != nil {
		predicates = append(predicates, estimate.EstimatorContains(*i.EstimatorContains))
	}
	if i.EstimatorHasPrefix != nil {
		predicates = append(predicates, estimate.EstimatorHasPrefix(*i.EstimatorHasPrefix))
	}
	if i.EstimatorHasSuffix != nil {
		predicates = append(predicates, estimate.EstimatorHasSuffix(*i.EstimatorHasSuffix))
	}
	if i.EstimatorIsNil {
		predicates = append(predicates, estimate.EstimatorIsNil())
	}
	if i.EstimatorNotNil {
		predicates = append(predicates, estimate.EstimatorNotNil())
	}
	if i.EstimatorEqualFold != nil {
		predicates = append(predicates, estimate.EstimatorEqualFold(*i.EstimatorEqualFold))
	}
	if i.EstimatorContainsFold != nil {
		predicates = append(predicates, estimate.EstimatorContainsFold(*i.EstimatorContainsFold))
	}
	if i.EstimatorOrderID != nil {
		predicates = append(predicates, estimate.EstimatorOrderIDEQ(*i.EstimatorOrderID))
	}
	if i.EstimatorOrderIDNEQ != nil {
		predicates = append(predicates, estimate.EstimatorOrderIDNEQ(*i.EstimatorOrderIDNEQ))
	}
	if len(i.EstimatorOrderIDIn) > 0 {
		predicates = append(predicates, estimate.EstimatorOrderIDIn(i.EstimatorOrderIDIn...))
	}
	if len(i.EstimatorOrderIDNotIn) > 0 {
		predicates = append(predicates, estimate.EstimatorOrderIDNotIn(i.EstimatorOrderIDNotIn...))
	}
	if i.EstimatorOrderIDGT != nil {
		predicates = append(predicates, estimate.EstimatorOrderIDGT(*i.EstimatorOrderIDGT))
	}
	if i.EstimatorOrderIDGTE != nil {
		predicates = append(predicates, estimate.EstimatorOrderIDGTE(*i.EstimatorOrderIDGTE))
	}
	if i.EstimatorOrderIDLT != nil {
		predicates = append(predicates, estimate.EstimatorOrderIDLT(*i.EstimatorOrderIDLT))
	}
	if i.EstimatorOrderIDLTE != nil {
		predicates = append(predicates, estimate.EstimatorOrderIDLTE(*i.EstimatorOrderIDLTE))
	}
	if i.EstimatorOrderIDIsNil {
		predicates = append(predicates, estimate.EstimatorOrderIDIsNil())
	}
	if i.EstimatorOrderIDNotNil {
		predicates = append(predicates, estimate.EstimatorOrderIDNotNil())
	}
	if i.EstimatorReportID != nil {
		predicates = append(predicates, estimate.EstimatorReportIDEQ(*i.EstimatorReportID))
	}
	if i.EstimatorReportIDNEQ != nil {
		predicates = append(predicates, estimate.EstimatorReportIDNEQ(*i.EstimatorReportIDNEQ))
	}
	if len(i.EstimatorReportIDIn) > 0 {
		predicates = append(predicates, estimate.EstimatorReportIDIn(i.EstimatorReportIDIn...))
	}
	if len(i.EstimatorReportIDNotIn) > 0 {
		predicates = append(predicates, estimate.EstimatorReportIDNotIn(i.EstimatorReportIDNotIn...))
	}
	if i.EstimatorReportIDGT != nil {
		predicates = append(predicates, estimate.EstimatorReportIDGT(*i.EstimatorReportIDGT))
	}
	if i.EstimatorReportIDGTE != nil {
		predicates = append(predicates, estimate.EstimatorReportIDGTE(*i.EstimatorReportIDGTE))
	}
	if i.EstimatorReportIDLT != nil {
		predicates = append(predicates, estimate.EstimatorReportIDLT(*i.EstimatorReportIDLT))
	}
	if i.EstimatorReportIDLTE != nil {
		predicates = append(predicates, estimate.EstimatorReportIDLTE(*i.EstimatorReportIDLTE))
	}
	if i.EstimatorReportIDIsNil {
		predicates = append(predicates, estimate.EstimatorReportIDIsNil())
	}
	if i.EstimatorReportIDNotNil {
		predicates = append(predicates, estimate.EstimatorReportIDNotNil())
	}
	if i.TotalSquares != nil {
		predicates = append(predicates, estimate.TotalSquaresEQ(*i.TotalSquares))
	}
	if i.TotalSquaresNEQ != nil {
		predicates = append(predicates, estimate.TotalSquaresNEQ(*i.TotalSquaresNEQ))
	}
	if len(i.TotalSquaresIn) > 0 {
		predicates = append(predicates, estimate.TotalSquaresIn(i.TotalSquaresIn...))
	}
	if len(i.TotalSquaresNotIn) > 0 {
		predicates = append(predicates, estimate.TotalSquaresNotIn(i.TotalSquaresNotIn...))
	}
	if i.TotalSquaresGT != nil {
		predicates = append(predicates, estimate.TotalSquaresGT(*i.TotalSquaresGT))
	}
	if i.TotalSquaresGTE != nil {
		predicates = append(predicates, estimate.TotalSquaresGTE(*i.TotalSquaresGTE))
	}
	if i.TotalSquaresLT != nil {
		predicates = append(predicates, estimate.TotalSquaresLT(*i.TotalSquaresLT))
	}
	if i.TotalSquaresLTE != nil {
		predicates = append(predicates, estimate.TotalSquaresLTE(*i.TotalSquaresLTE))
	}
	if i.PrimaryPitch != nil {
		predicates = append(predicates, estimate.PrimaryPitchEQ(*i.PrimaryPitch))
	}
	if i.PrimaryPitchNEQ != nil {
		predicates = append(predicates, estimate.PrimaryPitchNEQ(*i.PrimaryPitchNEQ))
	}
	if len(i.PrimaryPitchIn) > 0 {
		predicates = append(predicates, estimate.PrimaryPitchIn(i.PrimaryPitchIn...))
	}
	if len(i.PrimaryPitchNotIn) > 0 {
		predicates = append(predicates, estimate.PrimaryPitchNotIn(i.PrimaryPitchNotIn...))
	}
	if i.PrimaryPitchGT != nil {
		predicates = append(predicates, estimate.PrimaryPitchGT(*i.PrimaryPitchGT))
	}
	if i.PrimaryPitchGTE != nil {
		predicates = append(predicates, estimate.PrimaryPitchGTE(*i.PrimaryPitchGTE))
	}
	if i.PrimaryPitchLT != nil {
		predicates = append(predicates, estimate.PrimaryPitchLT(*i.PrimaryPitchLT))
	}
	if i.PrimaryPitchLTE != nil {
		predicates = append(predicates, estimate.PrimaryPitchLTE(*i.PrimaryPitchLTE))
	}
	if i.Price != nil {
		predicates = append(predicates, estimate.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, estimate.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, estimate.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, estimate.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, estimate.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, estimate.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, estimate.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, estimate.PriceLTE(*i.PriceLTE))
	}
	if i.PriceSummary != nil {
		predicates = append(predicates, estimate.PriceSummaryEQ(*i.PriceSummary))
	}
	if i.PriceSummaryNEQ != nil {
		predicates = append(predicates, estimate.PriceSummaryNEQ(*i.PriceSummaryNEQ))
	}
	if len(i.PriceSummaryIn) > 0 {
		predicates = append(predicates, estimate.PriceSummaryIn(i.PriceSummaryIn...))
	}
	if len(i.PriceSummaryNotIn) > 0 {
		predicates = append(predicates, estimate.PriceSummaryNotIn(i.PriceSummaryNotIn...))
	}
	if i.PriceSummaryGT != nil {
		predicates = append(predicates, estimate.PriceSummaryGT(*i.PriceSummaryGT))
	}
	if i.PriceSummaryGTE != nil {
		predicates = append(predicates, estimate.PriceSummaryGTE(*i.PriceSummaryGTE))
	}
	if i.PriceSummaryLT != nil {
		predicates = append(predicates, estimate.PriceSummaryLT(*i.PriceSummaryLT))
	}
	if i.PriceSummaryLTE != nil {
		predicates = append(predicates, estimate.PriceSummaryLTE(*i.PriceSummaryLTE))
	}
	if i.PriceSummaryContains != nil {
		predicates = append(predicates, estimate.PriceSummaryContains(*i.PriceSummaryContains))
	}
	if i.PriceSummaryHasPrefix != nil {
		predicates = append(predicates, estimate.PriceSummaryHasPrefix(*i.PriceSummaryHasPrefix))
	}
	if i.PriceSummaryHasSuffix != nil {
		predicates = append(predicates, estimate.PriceSummaryHasSuffix(*i.PriceSummaryHasSuffix))
	}
	if i.PriceSummaryIsNil {
		predicates = append(predicates, estimate.PriceSummaryIsNil())
	}
	if i.PriceSummaryNotNil {
		predicates = append(predicates, estimate.PriceSummaryNotNil())
	}
	if i.PriceSummaryEqualFold != nil {
		predicates = append(predicates, estimate.PriceSummaryEqualFold(*i.PriceSummaryEqualFold))
	}
	if i.PriceSummaryContainsFold != nil {
		predicates = append(predicates, estimate.PriceSummaryContainsFold(*i.PriceSummaryContainsFold))
	}
	if i.Override != nil {
		predicates = append(predicates, estimate.OverrideEQ(*i.Override))
	}
	if i.OverrideNEQ != nil {
		predicates = append(predicates, estimate.OverrideNEQ(*i.OverrideNEQ))
	}
	if i.OverrideIsNil {
		predicates = append(predicates, estimate.OverrideIsNil())
	}
	if i.OverrideNotNil {
		predicates = append(predicates, estimate.OverrideNotNil())
	}
	if i.OverrideTotalSquares != nil {
		predicates = append(predicates, estimate.OverrideTotalSquaresEQ(*i.OverrideTotalSquares))
	}
	if i.OverrideTotalSquaresNEQ != nil {
		predicates = append(predicates, estimate.OverrideTotalSquaresNEQ(*i.OverrideTotalSquaresNEQ))
	}
	if len(i.OverrideTotalSquaresIn) > 0 {
		predicates = append(predicates, estimate.OverrideTotalSquaresIn(i.OverrideTotalSquaresIn...))
	}
	if len(i.OverrideTotalSquaresNotIn) > 0 {
		predicates = append(predicates, estimate.OverrideTotalSquaresNotIn(i.OverrideTotalSquaresNotIn...))
	}
	if i.OverrideTotalSquaresGT != nil {
		predicates = append(predicates, estimate.OverrideTotalSquaresGT(*i.OverrideTotalSquaresGT))
	}
	if i.OverrideTotalSquaresGTE != nil {
		predicates = append(predicates, estimate.OverrideTotalSquaresGTE(*i.OverrideTotalSquaresGTE))
	}
	if i.OverrideTotalSquaresLT != nil {
		predicates = append(predicates, estimate.OverrideTotalSquaresLT(*i.OverrideTotalSquaresLT))
	}
	if i.OverrideTotalSquaresLTE != nil {
		predicates = append(predicates, estimate.OverrideTotalSquaresLTE(*i.OverrideTotalSquaresLTE))
	}
	if i.OverridePrimaryPitch != nil {
		predicates = append(predicates, estimate.OverridePrimaryPitchEQ(*i.OverridePrimaryPitch))
	}
	if i.OverridePrimaryPitchNEQ != nil {
		predicates = append(predicates, estimate.OverridePrimaryPitchNEQ(*i.OverridePrimaryPitchNEQ))
	}
	if len(i.OverridePrimaryPitchIn) > 0 {
		predicates = append(predicates, estimate.OverridePrimaryPitchIn(i.OverridePrimaryPitchIn...))
	}
	if len(i.OverridePrimaryPitchNotIn) > 0 {
		predicates = append(predicates, estimate.OverridePrimaryPitchNotIn(i.OverridePrimaryPitchNotIn...))
	}
	if i.OverridePrimaryPitchGT != nil {
		predicates = append(predicates, estimate.OverridePrimaryPitchGT(*i.OverridePrimaryPitchGT))
	}
	if i.OverridePrimaryPitchGTE != nil {
		predicates = append(predicates, estimate.OverridePrimaryPitchGTE(*i.OverridePrimaryPitchGTE))
	}
	if i.OverridePrimaryPitchLT != nil {
		predicates = append(predicates, estimate.OverridePrimaryPitchLT(*i.OverridePrimaryPitchLT))
	}
	if i.OverridePrimaryPitchLTE != nil {
		predicates = append(predicates, estimate.OverridePrimaryPitchLTE(*i.OverridePrimaryPitchLTE))
	}
	if i.OverridePrice != nil {
		predicates = append(predicates, estimate.OverridePriceEQ(*i.OverridePrice))
	}
	if i.OverridePriceNEQ != nil {
		predicates = append(predicates, estimate.OverridePriceNEQ(*i.OverridePriceNEQ))
	}
	if len(i.OverridePriceIn) > 0 {
		predicates = append(predicates, estimate.OverridePriceIn(i.OverridePriceIn...))
	}
	if len(i.OverridePriceNotIn) > 0 {
		predicates = append(predicates, estimate.OverridePriceNotIn(i.OverridePriceNotIn...))
	}
	if i.OverridePriceGT != nil {
		predicates = append(predicates, estimate.OverridePriceGT(*i.OverridePriceGT))
	}
	if i.OverridePriceGTE != nil {
		predicates = append(predicates, estimate.OverridePriceGTE(*i.OverridePriceGTE))
	}
	if i.OverridePriceLT != nil {
		predicates = append(predicates, estimate.OverridePriceLT(*i.OverridePriceLT))
	}
	if i.OverridePriceLTE != nil {
		predicates = append(predicates, estimate.OverridePriceLTE(*i.OverridePriceLTE))
	}
	if i.OverridePriceSummary != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryEQ(*i.OverridePriceSummary))
	}
	if i.OverridePriceSummaryNEQ != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryNEQ(*i.OverridePriceSummaryNEQ))
	}
	if len(i.OverridePriceSummaryIn) > 0 {
		predicates = append(predicates, estimate.OverridePriceSummaryIn(i.OverridePriceSummaryIn...))
	}
	if len(i.OverridePriceSummaryNotIn) > 0 {
		predicates = append(predicates, estimate.OverridePriceSummaryNotIn(i.OverridePriceSummaryNotIn...))
	}
	if i.OverridePriceSummaryGT != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryGT(*i.OverridePriceSummaryGT))
	}
	if i.OverridePriceSummaryGTE != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryGTE(*i.OverridePriceSummaryGTE))
	}
	if i.OverridePriceSummaryLT != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryLT(*i.OverridePriceSummaryLT))
	}
	if i.OverridePriceSummaryLTE != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryLTE(*i.OverridePriceSummaryLTE))
	}
	if i.OverridePriceSummaryContains != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryContains(*i.OverridePriceSummaryContains))
	}
	if i.OverridePriceSummaryHasPrefix != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryHasPrefix(*i.OverridePriceSummaryHasPrefix))
	}
	if i.OverridePriceSummaryHasSuffix != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryHasSuffix(*i.OverridePriceSummaryHasSuffix))
	}
	if i.OverridePriceSummaryIsNil {
		predicates = append(predicates, estimate.OverridePriceSummaryIsNil())
	}
	if i.OverridePriceSummaryNotNil {
		predicates = append(predicates, estimate.OverridePriceSummaryNotNil())
	}
	if i.OverridePriceSummaryEqualFold != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryEqualFold(*i.OverridePriceSummaryEqualFold))
	}
	if i.OverridePriceSummaryContainsFold != nil {
		predicates = append(predicates, estimate.OverridePriceSummaryContainsFold(*i.OverridePriceSummaryContainsFold))
	}
	if i.CompanyRefID != nil {
		predicates = append(predicates, estimate.CompanyRefIDEQ(*i.CompanyRefID))
	}
	if i.CompanyRefIDNEQ != nil {
		predicates = append(predicates, estimate.CompanyRefIDNEQ(*i.CompanyRefIDNEQ))
	}
	if len(i.CompanyRefIDIn) > 0 {
		predicates = append(predicates, estimate.CompanyRefIDIn(i.CompanyRefIDIn...))
	}
	if len(i.CompanyRefIDNotIn) > 0 {
		predicates = append(predicates, estimate.CompanyRefIDNotIn(i.CompanyRefIDNotIn...))
	}
	if i.CompanyRefIDGT != nil {
		predicates = append(predicates, estimate.CompanyRefIDGT(*i.CompanyRefIDGT))
	}
	if i.CompanyRefIDGTE != nil {
		predicates = append(predicates, estimate.CompanyRefIDGTE(*i.CompanyRefIDGTE))
	}
	if i.CompanyRefIDLT != nil {
		predicates = append(predicates, estimate.CompanyRefIDLT(*i.CompanyRefIDLT))
	}
	if i.CompanyRefIDLTE != nil {
		predicates = append(predicates, estimate.CompanyRefIDLTE(*i.CompanyRefIDLTE))
	}
	if i.CompanyRefIDContains != nil {
		predicates = append(predicates, estimate.CompanyRefIDContains(*i.CompanyRefIDContains))
	}
	if i.CompanyRefIDHasPrefix != nil {
		predicates = append(predicates, estimate.CompanyRefIDHasPrefix(*i.CompanyRefIDHasPrefix))
	}
	if i.CompanyRefIDHasSuffix != nil {
		predicates = append(predicates, estimate.CompanyRefIDHasSuffix(*i.CompanyRefIDHasSuffix))
	}
	if i.CompanyRefIDIsNil {
		predicates = append(predicates, estimate.CompanyRefIDIsNil())
	}
	if i.CompanyRefIDNotNil {
		predicates = append(predicates, estimate.CompanyRefIDNotNil())
	}
	if i.CompanyRefIDEqualFold != nil {
		predicates = append(predicates, estimate.CompanyRefIDEqualFold(*i.CompanyRefIDEqualFold))
	}
	if i.CompanyRefIDContainsFold != nil {
		predicates = append(predicates, estimate.CompanyRefIDContainsFold(*i.CompanyRefIDContainsFold))
	}
	if i.CompanyRefName != nil {
		predicates = append(predicates, estimate.CompanyRefNameEQ(*i.CompanyRefName))
	}
	if i.CompanyRefNameNEQ != nil {
		predicates = append(predicates, estimate.CompanyRefNameNEQ(*i.CompanyRefNameNEQ))
	}
	if len(i.CompanyRefNameIn) > 0 {
		predicates = append(predicates, estimate.CompanyRefNameIn(i.CompanyRefNameIn...))
	}
	if len(i.CompanyRefNameNotIn) > 0 {
		predicates = append(predicates, estimate.CompanyRefNameNotIn(i.CompanyRefNameNotIn...))
	}
	if i.CompanyRefNameGT != nil {
		predicates = append(predicates, estimate.CompanyRefNameGT(*i.CompanyRefNameGT))
	}
	if i.CompanyRefNameGTE != nil {
		predicates = append(predicates, estimate.CompanyRefNameGTE(*i.CompanyRefNameGTE))
	}
	if i.CompanyRefNameLT != nil {
		predicates = append(predicates, estimate.CompanyRefNameLT(*i.CompanyRefNameLT))
	}
	if i.CompanyRefNameLTE != nil {
		predicates = append(predicates, estimate.CompanyRefNameLTE(*i.CompanyRefNameLTE))
	}
	if i.CompanyRefNameContains != nil {
		predicates = append(predicates, estimate.CompanyRefNameContains(*i.CompanyRefNameContains))
	}
	if i.CompanyRefNameHasPrefix != nil {
		predicates = append(predicates, estimate.CompanyRefNameHasPrefix(*i.CompanyRefNameHasPrefix))
	}
	if i.CompanyRefNameHasSuffix != nil {
		predicates = append(predicates, estimate.CompanyRefNameHasSuffix(*i.CompanyRefNameHasSuffix))
	}
	if i.CompanyRefNameIsNil {
		predicates = append(predicates, estimate.CompanyRefNameIsNil())
	}
	if i.CompanyRefNameNotNil {
		predicates = append(predicates, estimate.CompanyRefNameNotNil())
	}
	if i.CompanyRefNameEqualFold != nil {
		predicates = append(predicates, estimate.CompanyRefNameEqualFold(*i.CompanyRefNameEqualFold))
	}
	if i.CompanyRefNameContainsFold != nil {
		predicates = append(predicates, estimate.CompanyRefNameContainsFold(*i.CompanyRefNameContainsFold))
	}
	if i.FailureReason != nil {
		predicates = append(predicates, estimate.FailureReasonEQ(*i.FailureReason))
	}
	if i.FailureReasonNEQ != nil {
		predicates = append(predicates, estimate.FailureReasonNEQ(*i.FailureReasonNEQ))
	}
	if len(i.FailureReasonIn) > 0 {
		predicates = append(predicates, estimate.FailureReasonIn(i.FailureReasonIn...))
	}
	if len(i.FailureReasonNotIn) > 0 {
		predicates = append(predicates, estimate.FailureReasonNotIn(i.FailureReasonNotIn...))
	}
	if i.FailureReasonGT != nil {
		predicates = append(predicates, estimate.FailureReasonGT(*i.FailureReasonGT))
	}
	if i.FailureReasonGTE != nil {
		predicates = append(predicates, estimate.FailureReasonGTE(*i.FailureReasonGTE))
	}
	if i.FailureReasonLT != nil {
		predicates = append(predicates, estimate.FailureReasonLT(*i.FailureReasonLT))
	}
	if i.FailureReasonLTE != nil {
		predicates = append(predicates, estimate.FailureReasonLTE(*i.FailureReasonLTE))
	}
	if i.FailureReasonContains != nil {
		predicates = append(predicates, estimate.FailureReasonContains(*i.FailureReasonContains))
	}
	if i.FailureReasonHasPrefix != nil {
		predicates = append(predicates, estimate.FailureReasonHasPrefix(*i.FailureReasonHasPrefix))
	}
	if i.FailureReasonHasSuffix != nil {
		predicates = append(predicates, estimate.FailureReasonHasSuffix(*i.FailureReasonHasSuffix))
	}
	if i.FailureReasonIsNil {
		predicates = append(predicates, estimate.FailureReasonIsNil())
	}
	if i.FailureReasonNotNil {
		predicates = append(predicates, estimate.FailureReasonNotNil())
	}
	if i.FailureReasonEqualFold != nil {
		predicates = append(predicates, estimate.FailureReasonEqualFold(*i.FailureReasonEqualFold))
	}
	if i.FailureReasonContainsFold != nil {
		predicates = append(predicates, estimate.FailureReasonContainsFold(*i.FailureReasonContainsFold))
	}

	if i.HasActivities != nil {
		p := estimate.HasActivities()
		if !*i.HasActivities {
			p = estimate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActivitiesWith) > 0 {
		with := make([]predicate.EstimateActivity, 0, len(i.HasActivitiesWith))
		for _, w := range i.HasActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimate.HasActivitiesWith(with...))
	}
	if i.HasJobInfo != nil {
		p := estimate.HasJobInfo()
		if !*i.HasJobInfo {
			p = estimate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobInfoWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobInfoWith))
		for _, w := range i.HasJobInfoWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobInfoWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimate.HasJobInfoWith(with...))
	}
	if i.HasPartner != nil {
		p := estimate.HasPartner()
		if !*i.HasPartner {
			p = estimate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimate.HasPartnerWith(with...))
	}
	if i.HasHomeOwner != nil {
		p := estimate.HasHomeOwner()
		if !*i.HasHomeOwner {
			p = estimate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHomeOwnerWith) > 0 {
		with := make([]predicate.HomeOwner, 0, len(i.HasHomeOwnerWith))
		for _, w := range i.HasHomeOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHomeOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimate.HasHomeOwnerWith(with...))
	}
	if i.HasSalesRep != nil {
		p := estimate.HasSalesRep()
		if !*i.HasSalesRep {
			p = estimate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSalesRepWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasSalesRepWith))
		for _, w := range i.HasSalesRepWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSalesRepWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimate.HasSalesRepWith(with...))
	}
	if i.HasCreator != nil {
		p := estimate.HasCreator()
		if !*i.HasCreator {
			p = estimate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimate.HasCreatorWith(with...))
	}
	if i.HasCreatorAPI != nil {
		p := estimate.HasCreatorAPI()
		if !*i.HasCreatorAPI {
			p = estimate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorAPIWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasCreatorAPIWith))
		for _, w := range i.HasCreatorAPIWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorAPIWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimate.HasCreatorAPIWith(with...))
	}
	if i.HasPdf != nil {
		p := estimate.HasPdf()
		if !*i.HasPdf {
			p = estimate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPdfWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasPdfWith))
		for _, w := range i.HasPdfWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPdfWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimate.HasPdfWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEstimateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return estimate.And(predicates...), nil
	}
}

// EstimateActivityWhereInput represents a where input for filtering EstimateActivity queries.
type EstimateActivityWhereInput struct {
	Predicates []predicate.EstimateActivity  `json:"-"`
	Not        *EstimateActivityWhereInput   `json:"not,omitempty"`
	Or         []*EstimateActivityWhereInput `json:"or,omitempty"`
	And        []*EstimateActivityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "estimate" edge predicates.
	HasEstimate     *bool                 `json:"hasEstimate,omitempty"`
	HasEstimateWith []*EstimateWhereInput `json:"hasEstimateWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "creator_api" edge predicates.
	HasCreatorAPI     *bool                `json:"hasCreatorAPI,omitempty"`
	HasCreatorAPIWith []*ApiUserWhereInput `json:"hasCreatorAPIWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EstimateActivityWhereInput) AddPredicates(predicates ...predicate.EstimateActivity) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EstimateActivityWhereInput filter on the EstimateActivityQuery builder.
func (i *EstimateActivityWhereInput) Filter(q *EstimateActivityQuery) (*EstimateActivityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEstimateActivityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEstimateActivityWhereInput is returned in case the EstimateActivityWhereInput is empty.
var ErrEmptyEstimateActivityWhereInput = errors.New("ent: empty predicate EstimateActivityWhereInput")

// P returns a predicate for filtering estimateactivities.
// An error is returned if the input is empty or invalid.
func (i *EstimateActivityWhereInput) P() (predicate.EstimateActivity, error) {
	var predicates []predicate.EstimateActivity
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, estimateactivity.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EstimateActivity, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, estimateactivity.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EstimateActivity, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, estimateactivity.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, estimateactivity.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, estimateactivity.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, estimateactivity.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, estimateactivity.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, estimateactivity.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, estimateactivity.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, estimateactivity.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, estimateactivity.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, estimateactivity.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, estimateactivity.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, estimateactivity.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, estimateactivity.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, estimateactivity.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, estimateactivity.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, estimateactivity.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, estimateactivity.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, estimateactivity.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, estimateactivity.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, estimateactivity.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, estimateactivity.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, estimateactivity.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, estimateactivity.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, estimateactivity.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, estimateactivity.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, estimateactivity.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, estimateactivity.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, estimateactivity.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, estimateactivity.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, estimateactivity.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, estimateactivity.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, estimateactivity.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasEstimate != nil {
		p := estimateactivity.HasEstimate()
		if !*i.HasEstimate {
			p = estimateactivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEstimateWith) > 0 {
		with := make([]predicate.Estimate, 0, len(i.HasEstimateWith))
		for _, w := range i.HasEstimateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEstimateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimateactivity.HasEstimateWith(with...))
	}
	if i.HasCreator != nil {
		p := estimateactivity.HasCreator()
		if !*i.HasCreator {
			p = estimateactivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimateactivity.HasCreatorWith(with...))
	}
	if i.HasCreatorAPI != nil {
		p := estimateactivity.HasCreatorAPI()
		if !*i.HasCreatorAPI {
			p = estimateactivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorAPIWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasCreatorAPIWith))
		for _, w := range i.HasCreatorAPIWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorAPIWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, estimateactivity.HasCreatorAPIWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEstimateActivityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return estimateactivity.And(predicates...), nil
	}
}

// HomeOwnerWhereInput represents a where input for filtering HomeOwner queries.
type HomeOwnerWhereInput struct {
	Predicates []predicate.HomeOwner  `json:"-"`
	Not        *HomeOwnerWhereInput   `json:"not,omitempty"`
	Or         []*HomeOwnerWhereInput `json:"or,omitempty"`
	And        []*HomeOwnerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "street_number" field predicates.
	StreetNumber             *string  `json:"streetNumber,omitempty"`
	StreetNumberNEQ          *string  `json:"streetNumberNEQ,omitempty"`
	StreetNumberIn           []string `json:"streetNumberIn,omitempty"`
	StreetNumberNotIn        []string `json:"streetNumberNotIn,omitempty"`
	StreetNumberGT           *string  `json:"streetNumberGT,omitempty"`
	StreetNumberGTE          *string  `json:"streetNumberGTE,omitempty"`
	StreetNumberLT           *string  `json:"streetNumberLT,omitempty"`
	StreetNumberLTE          *string  `json:"streetNumberLTE,omitempty"`
	StreetNumberContains     *string  `json:"streetNumberContains,omitempty"`
	StreetNumberHasPrefix    *string  `json:"streetNumberHasPrefix,omitempty"`
	StreetNumberHasSuffix    *string  `json:"streetNumberHasSuffix,omitempty"`
	StreetNumberEqualFold    *string  `json:"streetNumberEqualFold,omitempty"`
	StreetNumberContainsFold *string  `json:"streetNumberContainsFold,omitempty"`

	// "street_name" field predicates.
	StreetName             *string  `json:"streetName,omitempty"`
	StreetNameNEQ          *string  `json:"streetNameNEQ,omitempty"`
	StreetNameIn           []string `json:"streetNameIn,omitempty"`
	StreetNameNotIn        []string `json:"streetNameNotIn,omitempty"`
	StreetNameGT           *string  `json:"streetNameGT,omitempty"`
	StreetNameGTE          *string  `json:"streetNameGTE,omitempty"`
	StreetNameLT           *string  `json:"streetNameLT,omitempty"`
	StreetNameLTE          *string  `json:"streetNameLTE,omitempty"`
	StreetNameContains     *string  `json:"streetNameContains,omitempty"`
	StreetNameHasPrefix    *string  `json:"streetNameHasPrefix,omitempty"`
	StreetNameHasSuffix    *string  `json:"streetNameHasSuffix,omitempty"`
	StreetNameEqualFold    *string  `json:"streetNameEqualFold,omitempty"`
	StreetNameContainsFold *string  `json:"streetNameContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "state" field predicates.
	State             *string  `json:"state,omitempty"`
	StateNEQ          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGT           *string  `json:"stateGT,omitempty"`
	StateGTE          *string  `json:"stateGTE,omitempty"`
	StateLT           *string  `json:"stateLT,omitempty"`
	StateLTE          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`

	// "state_abbr" field predicates.
	StateAbbr             *string  `json:"stateAbbr,omitempty"`
	StateAbbrNEQ          *string  `json:"stateAbbrNEQ,omitempty"`
	StateAbbrIn           []string `json:"stateAbbrIn,omitempty"`
	StateAbbrNotIn        []string `json:"stateAbbrNotIn,omitempty"`
	StateAbbrGT           *string  `json:"stateAbbrGT,omitempty"`
	StateAbbrGTE          *string  `json:"stateAbbrGTE,omitempty"`
	StateAbbrLT           *string  `json:"stateAbbrLT,omitempty"`
	StateAbbrLTE          *string  `json:"stateAbbrLTE,omitempty"`
	StateAbbrContains     *string  `json:"stateAbbrContains,omitempty"`
	StateAbbrHasPrefix    *string  `json:"stateAbbrHasPrefix,omitempty"`
	StateAbbrHasSuffix    *string  `json:"stateAbbrHasSuffix,omitempty"`
	StateAbbrIsNil        bool     `json:"stateAbbrIsNil,omitempty"`
	StateAbbrNotNil       bool     `json:"stateAbbrNotNil,omitempty"`
	StateAbbrEqualFold    *string  `json:"stateAbbrEqualFold,omitempty"`
	StateAbbrContainsFold *string  `json:"stateAbbrContainsFold,omitempty"`

	// "zip" field predicates.
	Zip             *string  `json:"zip,omitempty"`
	ZipNEQ          *string  `json:"zipNEQ,omitempty"`
	ZipIn           []string `json:"zipIn,omitempty"`
	ZipNotIn        []string `json:"zipNotIn,omitempty"`
	ZipGT           *string  `json:"zipGT,omitempty"`
	ZipGTE          *string  `json:"zipGTE,omitempty"`
	ZipLT           *string  `json:"zipLT,omitempty"`
	ZipLTE          *string  `json:"zipLTE,omitempty"`
	ZipContains     *string  `json:"zipContains,omitempty"`
	ZipHasPrefix    *string  `json:"zipHasPrefix,omitempty"`
	ZipHasSuffix    *string  `json:"zipHasSuffix,omitempty"`
	ZipEqualFold    *string  `json:"zipEqualFold,omitempty"`
	ZipContainsFold *string  `json:"zipContainsFold,omitempty"`

	// "formatted_address" field predicates.
	FormattedAddress             *string  `json:"formattedAddress,omitempty"`
	FormattedAddressNEQ          *string  `json:"formattedAddressNEQ,omitempty"`
	FormattedAddressIn           []string `json:"formattedAddressIn,omitempty"`
	FormattedAddressNotIn        []string `json:"formattedAddressNotIn,omitempty"`
	FormattedAddressGT           *string  `json:"formattedAddressGT,omitempty"`
	FormattedAddressGTE          *string  `json:"formattedAddressGTE,omitempty"`
	FormattedAddressLT           *string  `json:"formattedAddressLT,omitempty"`
	FormattedAddressLTE          *string  `json:"formattedAddressLTE,omitempty"`
	FormattedAddressContains     *string  `json:"formattedAddressContains,omitempty"`
	FormattedAddressHasPrefix    *string  `json:"formattedAddressHasPrefix,omitempty"`
	FormattedAddressHasSuffix    *string  `json:"formattedAddressHasSuffix,omitempty"`
	FormattedAddressIsNil        bool     `json:"formattedAddressIsNil,omitempty"`
	FormattedAddressNotNil       bool     `json:"formattedAddressNotNil,omitempty"`
	FormattedAddressEqualFold    *string  `json:"formattedAddressEqualFold,omitempty"`
	FormattedAddressContainsFold *string  `json:"formattedAddressContainsFold,omitempty"`

	// "latitude" field predicates.
	Latitude       *float64  `json:"latitude,omitempty"`
	LatitudeNEQ    *float64  `json:"latitudeNEQ,omitempty"`
	LatitudeIn     []float64 `json:"latitudeIn,omitempty"`
	LatitudeNotIn  []float64 `json:"latitudeNotIn,omitempty"`
	LatitudeGT     *float64  `json:"latitudeGT,omitempty"`
	LatitudeGTE    *float64  `json:"latitudeGTE,omitempty"`
	LatitudeLT     *float64  `json:"latitudeLT,omitempty"`
	LatitudeLTE    *float64  `json:"latitudeLTE,omitempty"`
	LatitudeIsNil  bool      `json:"latitudeIsNil,omitempty"`
	LatitudeNotNil bool      `json:"latitudeNotNil,omitempty"`

	// "longitude" field predicates.
	Longitude       *float64  `json:"longitude,omitempty"`
	LongitudeNEQ    *float64  `json:"longitudeNEQ,omitempty"`
	LongitudeIn     []float64 `json:"longitudeIn,omitempty"`
	LongitudeNotIn  []float64 `json:"longitudeNotIn,omitempty"`
	LongitudeGT     *float64  `json:"longitudeGT,omitempty"`
	LongitudeGTE    *float64  `json:"longitudeGTE,omitempty"`
	LongitudeLT     *float64  `json:"longitudeLT,omitempty"`
	LongitudeLTE    *float64  `json:"longitudeLTE,omitempty"`
	LongitudeIsNil  bool      `json:"longitudeIsNil,omitempty"`
	LongitudeNotNil bool      `json:"longitudeNotNil,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashIsNil        bool     `json:"hashIsNil,omitempty"`
	HashNotNil       bool     `json:"hashNotNil,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "estimates" edge predicates.
	HasEstimates     *bool                 `json:"hasEstimates,omitempty"`
	HasEstimatesWith []*EstimateWhereInput `json:"hasEstimatesWith,omitempty"`

	// "jobs" edge predicates.
	HasJobs     *bool            `json:"hasJobs,omitempty"`
	HasJobsWith []*JobWhereInput `json:"hasJobsWith,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HomeOwnerWhereInput) AddPredicates(predicates ...predicate.HomeOwner) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HomeOwnerWhereInput filter on the HomeOwnerQuery builder.
func (i *HomeOwnerWhereInput) Filter(q *HomeOwnerQuery) (*HomeOwnerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHomeOwnerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHomeOwnerWhereInput is returned in case the HomeOwnerWhereInput is empty.
var ErrEmptyHomeOwnerWhereInput = errors.New("ent: empty predicate HomeOwnerWhereInput")

// P returns a predicate for filtering homeowners.
// An error is returned if the input is empty or invalid.
func (i *HomeOwnerWhereInput) P() (predicate.HomeOwner, error) {
	var predicates []predicate.HomeOwner
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, homeowner.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HomeOwner, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, homeowner.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HomeOwner, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, homeowner.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, homeowner.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, homeowner.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, homeowner.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, homeowner.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, homeowner.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, homeowner.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, homeowner.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, homeowner.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, homeowner.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, homeowner.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, homeowner.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, homeowner.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, homeowner.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, homeowner.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, homeowner.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, homeowner.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, homeowner.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, homeowner.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, homeowner.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, homeowner.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, homeowner.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, homeowner.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, homeowner.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, homeowner.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, homeowner.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, homeowner.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.FirstName != nil {
		predicates = append(predicates, homeowner.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, homeowner.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, homeowner.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, homeowner.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, homeowner.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, homeowner.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, homeowner.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, homeowner.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, homeowner.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, homeowner.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, homeowner.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, homeowner.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, homeowner.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, homeowner.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, homeowner.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, homeowner.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, homeowner.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, homeowner.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, homeowner.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, homeowner.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, homeowner.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, homeowner.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, homeowner.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, homeowner.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, homeowner.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, homeowner.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, homeowner.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, homeowner.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, homeowner.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, homeowner.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, homeowner.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, homeowner.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, homeowner.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, homeowner.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, homeowner.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, homeowner.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, homeowner.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, homeowner.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, homeowner.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, homeowner.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, homeowner.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, homeowner.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, homeowner.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, homeowner.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, homeowner.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, homeowner.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, homeowner.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, homeowner.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, homeowner.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, homeowner.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, homeowner.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, homeowner.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, homeowner.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, homeowner.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, homeowner.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, homeowner.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.StreetNumber != nil {
		predicates = append(predicates, homeowner.StreetNumberEQ(*i.StreetNumber))
	}
	if i.StreetNumberNEQ != nil {
		predicates = append(predicates, homeowner.StreetNumberNEQ(*i.StreetNumberNEQ))
	}
	if len(i.StreetNumberIn) > 0 {
		predicates = append(predicates, homeowner.StreetNumberIn(i.StreetNumberIn...))
	}
	if len(i.StreetNumberNotIn) > 0 {
		predicates = append(predicates, homeowner.StreetNumberNotIn(i.StreetNumberNotIn...))
	}
	if i.StreetNumberGT != nil {
		predicates = append(predicates, homeowner.StreetNumberGT(*i.StreetNumberGT))
	}
	if i.StreetNumberGTE != nil {
		predicates = append(predicates, homeowner.StreetNumberGTE(*i.StreetNumberGTE))
	}
	if i.StreetNumberLT != nil {
		predicates = append(predicates, homeowner.StreetNumberLT(*i.StreetNumberLT))
	}
	if i.StreetNumberLTE != nil {
		predicates = append(predicates, homeowner.StreetNumberLTE(*i.StreetNumberLTE))
	}
	if i.StreetNumberContains != nil {
		predicates = append(predicates, homeowner.StreetNumberContains(*i.StreetNumberContains))
	}
	if i.StreetNumberHasPrefix != nil {
		predicates = append(predicates, homeowner.StreetNumberHasPrefix(*i.StreetNumberHasPrefix))
	}
	if i.StreetNumberHasSuffix != nil {
		predicates = append(predicates, homeowner.StreetNumberHasSuffix(*i.StreetNumberHasSuffix))
	}
	if i.StreetNumberEqualFold != nil {
		predicates = append(predicates, homeowner.StreetNumberEqualFold(*i.StreetNumberEqualFold))
	}
	if i.StreetNumberContainsFold != nil {
		predicates = append(predicates, homeowner.StreetNumberContainsFold(*i.StreetNumberContainsFold))
	}
	if i.StreetName != nil {
		predicates = append(predicates, homeowner.StreetNameEQ(*i.StreetName))
	}
	if i.StreetNameNEQ != nil {
		predicates = append(predicates, homeowner.StreetNameNEQ(*i.StreetNameNEQ))
	}
	if len(i.StreetNameIn) > 0 {
		predicates = append(predicates, homeowner.StreetNameIn(i.StreetNameIn...))
	}
	if len(i.StreetNameNotIn) > 0 {
		predicates = append(predicates, homeowner.StreetNameNotIn(i.StreetNameNotIn...))
	}
	if i.StreetNameGT != nil {
		predicates = append(predicates, homeowner.StreetNameGT(*i.StreetNameGT))
	}
	if i.StreetNameGTE != nil {
		predicates = append(predicates, homeowner.StreetNameGTE(*i.StreetNameGTE))
	}
	if i.StreetNameLT != nil {
		predicates = append(predicates, homeowner.StreetNameLT(*i.StreetNameLT))
	}
	if i.StreetNameLTE != nil {
		predicates = append(predicates, homeowner.StreetNameLTE(*i.StreetNameLTE))
	}
	if i.StreetNameContains != nil {
		predicates = append(predicates, homeowner.StreetNameContains(*i.StreetNameContains))
	}
	if i.StreetNameHasPrefix != nil {
		predicates = append(predicates, homeowner.StreetNameHasPrefix(*i.StreetNameHasPrefix))
	}
	if i.StreetNameHasSuffix != nil {
		predicates = append(predicates, homeowner.StreetNameHasSuffix(*i.StreetNameHasSuffix))
	}
	if i.StreetNameEqualFold != nil {
		predicates = append(predicates, homeowner.StreetNameEqualFold(*i.StreetNameEqualFold))
	}
	if i.StreetNameContainsFold != nil {
		predicates = append(predicates, homeowner.StreetNameContainsFold(*i.StreetNameContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, homeowner.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, homeowner.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, homeowner.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, homeowner.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, homeowner.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, homeowner.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, homeowner.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, homeowner.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, homeowner.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, homeowner.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, homeowner.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, homeowner.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, homeowner.CityContainsFold(*i.CityContainsFold))
	}
	if i.State != nil {
		predicates = append(predicates, homeowner.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, homeowner.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, homeowner.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, homeowner.StateNotIn(i.StateNotIn...))
	}
	if i.StateGT != nil {
		predicates = append(predicates, homeowner.StateGT(*i.StateGT))
	}
	if i.StateGTE != nil {
		predicates = append(predicates, homeowner.StateGTE(*i.StateGTE))
	}
	if i.StateLT != nil {
		predicates = append(predicates, homeowner.StateLT(*i.StateLT))
	}
	if i.StateLTE != nil {
		predicates = append(predicates, homeowner.StateLTE(*i.StateLTE))
	}
	if i.StateContains != nil {
		predicates = append(predicates, homeowner.StateContains(*i.StateContains))
	}
	if i.StateHasPrefix != nil {
		predicates = append(predicates, homeowner.StateHasPrefix(*i.StateHasPrefix))
	}
	if i.StateHasSuffix != nil {
		predicates = append(predicates, homeowner.StateHasSuffix(*i.StateHasSuffix))
	}
	if i.StateEqualFold != nil {
		predicates = append(predicates, homeowner.StateEqualFold(*i.StateEqualFold))
	}
	if i.StateContainsFold != nil {
		predicates = append(predicates, homeowner.StateContainsFold(*i.StateContainsFold))
	}
	if i.StateAbbr != nil {
		predicates = append(predicates, homeowner.StateAbbrEQ(*i.StateAbbr))
	}
	if i.StateAbbrNEQ != nil {
		predicates = append(predicates, homeowner.StateAbbrNEQ(*i.StateAbbrNEQ))
	}
	if len(i.StateAbbrIn) > 0 {
		predicates = append(predicates, homeowner.StateAbbrIn(i.StateAbbrIn...))
	}
	if len(i.StateAbbrNotIn) > 0 {
		predicates = append(predicates, homeowner.StateAbbrNotIn(i.StateAbbrNotIn...))
	}
	if i.StateAbbrGT != nil {
		predicates = append(predicates, homeowner.StateAbbrGT(*i.StateAbbrGT))
	}
	if i.StateAbbrGTE != nil {
		predicates = append(predicates, homeowner.StateAbbrGTE(*i.StateAbbrGTE))
	}
	if i.StateAbbrLT != nil {
		predicates = append(predicates, homeowner.StateAbbrLT(*i.StateAbbrLT))
	}
	if i.StateAbbrLTE != nil {
		predicates = append(predicates, homeowner.StateAbbrLTE(*i.StateAbbrLTE))
	}
	if i.StateAbbrContains != nil {
		predicates = append(predicates, homeowner.StateAbbrContains(*i.StateAbbrContains))
	}
	if i.StateAbbrHasPrefix != nil {
		predicates = append(predicates, homeowner.StateAbbrHasPrefix(*i.StateAbbrHasPrefix))
	}
	if i.StateAbbrHasSuffix != nil {
		predicates = append(predicates, homeowner.StateAbbrHasSuffix(*i.StateAbbrHasSuffix))
	}
	if i.StateAbbrIsNil {
		predicates = append(predicates, homeowner.StateAbbrIsNil())
	}
	if i.StateAbbrNotNil {
		predicates = append(predicates, homeowner.StateAbbrNotNil())
	}
	if i.StateAbbrEqualFold != nil {
		predicates = append(predicates, homeowner.StateAbbrEqualFold(*i.StateAbbrEqualFold))
	}
	if i.StateAbbrContainsFold != nil {
		predicates = append(predicates, homeowner.StateAbbrContainsFold(*i.StateAbbrContainsFold))
	}
	if i.Zip != nil {
		predicates = append(predicates, homeowner.ZipEQ(*i.Zip))
	}
	if i.ZipNEQ != nil {
		predicates = append(predicates, homeowner.ZipNEQ(*i.ZipNEQ))
	}
	if len(i.ZipIn) > 0 {
		predicates = append(predicates, homeowner.ZipIn(i.ZipIn...))
	}
	if len(i.ZipNotIn) > 0 {
		predicates = append(predicates, homeowner.ZipNotIn(i.ZipNotIn...))
	}
	if i.ZipGT != nil {
		predicates = append(predicates, homeowner.ZipGT(*i.ZipGT))
	}
	if i.ZipGTE != nil {
		predicates = append(predicates, homeowner.ZipGTE(*i.ZipGTE))
	}
	if i.ZipLT != nil {
		predicates = append(predicates, homeowner.ZipLT(*i.ZipLT))
	}
	if i.ZipLTE != nil {
		predicates = append(predicates, homeowner.ZipLTE(*i.ZipLTE))
	}
	if i.ZipContains != nil {
		predicates = append(predicates, homeowner.ZipContains(*i.ZipContains))
	}
	if i.ZipHasPrefix != nil {
		predicates = append(predicates, homeowner.ZipHasPrefix(*i.ZipHasPrefix))
	}
	if i.ZipHasSuffix != nil {
		predicates = append(predicates, homeowner.ZipHasSuffix(*i.ZipHasSuffix))
	}
	if i.ZipEqualFold != nil {
		predicates = append(predicates, homeowner.ZipEqualFold(*i.ZipEqualFold))
	}
	if i.ZipContainsFold != nil {
		predicates = append(predicates, homeowner.ZipContainsFold(*i.ZipContainsFold))
	}
	if i.FormattedAddress != nil {
		predicates = append(predicates, homeowner.FormattedAddressEQ(*i.FormattedAddress))
	}
	if i.FormattedAddressNEQ != nil {
		predicates = append(predicates, homeowner.FormattedAddressNEQ(*i.FormattedAddressNEQ))
	}
	if len(i.FormattedAddressIn) > 0 {
		predicates = append(predicates, homeowner.FormattedAddressIn(i.FormattedAddressIn...))
	}
	if len(i.FormattedAddressNotIn) > 0 {
		predicates = append(predicates, homeowner.FormattedAddressNotIn(i.FormattedAddressNotIn...))
	}
	if i.FormattedAddressGT != nil {
		predicates = append(predicates, homeowner.FormattedAddressGT(*i.FormattedAddressGT))
	}
	if i.FormattedAddressGTE != nil {
		predicates = append(predicates, homeowner.FormattedAddressGTE(*i.FormattedAddressGTE))
	}
	if i.FormattedAddressLT != nil {
		predicates = append(predicates, homeowner.FormattedAddressLT(*i.FormattedAddressLT))
	}
	if i.FormattedAddressLTE != nil {
		predicates = append(predicates, homeowner.FormattedAddressLTE(*i.FormattedAddressLTE))
	}
	if i.FormattedAddressContains != nil {
		predicates = append(predicates, homeowner.FormattedAddressContains(*i.FormattedAddressContains))
	}
	if i.FormattedAddressHasPrefix != nil {
		predicates = append(predicates, homeowner.FormattedAddressHasPrefix(*i.FormattedAddressHasPrefix))
	}
	if i.FormattedAddressHasSuffix != nil {
		predicates = append(predicates, homeowner.FormattedAddressHasSuffix(*i.FormattedAddressHasSuffix))
	}
	if i.FormattedAddressIsNil {
		predicates = append(predicates, homeowner.FormattedAddressIsNil())
	}
	if i.FormattedAddressNotNil {
		predicates = append(predicates, homeowner.FormattedAddressNotNil())
	}
	if i.FormattedAddressEqualFold != nil {
		predicates = append(predicates, homeowner.FormattedAddressEqualFold(*i.FormattedAddressEqualFold))
	}
	if i.FormattedAddressContainsFold != nil {
		predicates = append(predicates, homeowner.FormattedAddressContainsFold(*i.FormattedAddressContainsFold))
	}
	if i.Latitude != nil {
		predicates = append(predicates, homeowner.LatitudeEQ(*i.Latitude))
	}
	if i.LatitudeNEQ != nil {
		predicates = append(predicates, homeowner.LatitudeNEQ(*i.LatitudeNEQ))
	}
	if len(i.LatitudeIn) > 0 {
		predicates = append(predicates, homeowner.LatitudeIn(i.LatitudeIn...))
	}
	if len(i.LatitudeNotIn) > 0 {
		predicates = append(predicates, homeowner.LatitudeNotIn(i.LatitudeNotIn...))
	}
	if i.LatitudeGT != nil {
		predicates = append(predicates, homeowner.LatitudeGT(*i.LatitudeGT))
	}
	if i.LatitudeGTE != nil {
		predicates = append(predicates, homeowner.LatitudeGTE(*i.LatitudeGTE))
	}
	if i.LatitudeLT != nil {
		predicates = append(predicates, homeowner.LatitudeLT(*i.LatitudeLT))
	}
	if i.LatitudeLTE != nil {
		predicates = append(predicates, homeowner.LatitudeLTE(*i.LatitudeLTE))
	}
	if i.LatitudeIsNil {
		predicates = append(predicates, homeowner.LatitudeIsNil())
	}
	if i.LatitudeNotNil {
		predicates = append(predicates, homeowner.LatitudeNotNil())
	}
	if i.Longitude != nil {
		predicates = append(predicates, homeowner.LongitudeEQ(*i.Longitude))
	}
	if i.LongitudeNEQ != nil {
		predicates = append(predicates, homeowner.LongitudeNEQ(*i.LongitudeNEQ))
	}
	if len(i.LongitudeIn) > 0 {
		predicates = append(predicates, homeowner.LongitudeIn(i.LongitudeIn...))
	}
	if len(i.LongitudeNotIn) > 0 {
		predicates = append(predicates, homeowner.LongitudeNotIn(i.LongitudeNotIn...))
	}
	if i.LongitudeGT != nil {
		predicates = append(predicates, homeowner.LongitudeGT(*i.LongitudeGT))
	}
	if i.LongitudeGTE != nil {
		predicates = append(predicates, homeowner.LongitudeGTE(*i.LongitudeGTE))
	}
	if i.LongitudeLT != nil {
		predicates = append(predicates, homeowner.LongitudeLT(*i.LongitudeLT))
	}
	if i.LongitudeLTE != nil {
		predicates = append(predicates, homeowner.LongitudeLTE(*i.LongitudeLTE))
	}
	if i.LongitudeIsNil {
		predicates = append(predicates, homeowner.LongitudeIsNil())
	}
	if i.LongitudeNotNil {
		predicates = append(predicates, homeowner.LongitudeNotNil())
	}
	if i.Hash != nil {
		predicates = append(predicates, homeowner.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, homeowner.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, homeowner.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, homeowner.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, homeowner.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, homeowner.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, homeowner.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, homeowner.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, homeowner.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, homeowner.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, homeowner.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashIsNil {
		predicates = append(predicates, homeowner.HashIsNil())
	}
	if i.HashNotNil {
		predicates = append(predicates, homeowner.HashNotNil())
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, homeowner.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, homeowner.HashContainsFold(*i.HashContainsFold))
	}

	if i.HasEstimates != nil {
		p := homeowner.HasEstimates()
		if !*i.HasEstimates {
			p = homeowner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEstimatesWith) > 0 {
		with := make([]predicate.Estimate, 0, len(i.HasEstimatesWith))
		for _, w := range i.HasEstimatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEstimatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, homeowner.HasEstimatesWith(with...))
	}
	if i.HasJobs != nil {
		p := homeowner.HasJobs()
		if !*i.HasJobs {
			p = homeowner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobsWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobsWith))
		for _, w := range i.HasJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, homeowner.HasJobsWith(with...))
	}
	if i.HasPartner != nil {
		p := homeowner.HasPartner()
		if !*i.HasPartner {
			p = homeowner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, homeowner.HasPartnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHomeOwnerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return homeowner.And(predicates...), nil
	}
}

// InstallationJobWhereInput represents a where input for filtering InstallationJob queries.
type InstallationJobWhereInput struct {
	Predicates []predicate.InstallationJob  `json:"-"`
	Not        *InstallationJobWhereInput   `json:"not,omitempty"`
	Or         []*InstallationJobWhereInput `json:"or,omitempty"`
	And        []*InstallationJobWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "type" field predicates.
	Type      *enum.InstallationType  `json:"type,omitempty"`
	TypeNEQ   *enum.InstallationType  `json:"typeNEQ,omitempty"`
	TypeIn    []enum.InstallationType `json:"typeIn,omitempty"`
	TypeNotIn []enum.InstallationType `json:"typeNotIn,omitempty"`

	// "owner_name" field predicates.
	OwnerName             *string  `json:"ownerName,omitempty"`
	OwnerNameNEQ          *string  `json:"ownerNameNEQ,omitempty"`
	OwnerNameIn           []string `json:"ownerNameIn,omitempty"`
	OwnerNameNotIn        []string `json:"ownerNameNotIn,omitempty"`
	OwnerNameGT           *string  `json:"ownerNameGT,omitempty"`
	OwnerNameGTE          *string  `json:"ownerNameGTE,omitempty"`
	OwnerNameLT           *string  `json:"ownerNameLT,omitempty"`
	OwnerNameLTE          *string  `json:"ownerNameLTE,omitempty"`
	OwnerNameContains     *string  `json:"ownerNameContains,omitempty"`
	OwnerNameHasPrefix    *string  `json:"ownerNameHasPrefix,omitempty"`
	OwnerNameHasSuffix    *string  `json:"ownerNameHasSuffix,omitempty"`
	OwnerNameEqualFold    *string  `json:"ownerNameEqualFold,omitempty"`
	OwnerNameContainsFold *string  `json:"ownerNameContainsFold,omitempty"`

	// "owner_phone" field predicates.
	OwnerPhone             *string  `json:"ownerPhone,omitempty"`
	OwnerPhoneNEQ          *string  `json:"ownerPhoneNEQ,omitempty"`
	OwnerPhoneIn           []string `json:"ownerPhoneIn,omitempty"`
	OwnerPhoneNotIn        []string `json:"ownerPhoneNotIn,omitempty"`
	OwnerPhoneGT           *string  `json:"ownerPhoneGT,omitempty"`
	OwnerPhoneGTE          *string  `json:"ownerPhoneGTE,omitempty"`
	OwnerPhoneLT           *string  `json:"ownerPhoneLT,omitempty"`
	OwnerPhoneLTE          *string  `json:"ownerPhoneLTE,omitempty"`
	OwnerPhoneContains     *string  `json:"ownerPhoneContains,omitempty"`
	OwnerPhoneHasPrefix    *string  `json:"ownerPhoneHasPrefix,omitempty"`
	OwnerPhoneHasSuffix    *string  `json:"ownerPhoneHasSuffix,omitempty"`
	OwnerPhoneEqualFold    *string  `json:"ownerPhoneEqualFold,omitempty"`
	OwnerPhoneContainsFold *string  `json:"ownerPhoneContainsFold,omitempty"`

	// "owner_email" field predicates.
	OwnerEmail             *string  `json:"ownerEmail,omitempty"`
	OwnerEmailNEQ          *string  `json:"ownerEmailNEQ,omitempty"`
	OwnerEmailIn           []string `json:"ownerEmailIn,omitempty"`
	OwnerEmailNotIn        []string `json:"ownerEmailNotIn,omitempty"`
	OwnerEmailGT           *string  `json:"ownerEmailGT,omitempty"`
	OwnerEmailGTE          *string  `json:"ownerEmailGTE,omitempty"`
	OwnerEmailLT           *string  `json:"ownerEmailLT,omitempty"`
	OwnerEmailLTE          *string  `json:"ownerEmailLTE,omitempty"`
	OwnerEmailContains     *string  `json:"ownerEmailContains,omitempty"`
	OwnerEmailHasPrefix    *string  `json:"ownerEmailHasPrefix,omitempty"`
	OwnerEmailHasSuffix    *string  `json:"ownerEmailHasSuffix,omitempty"`
	OwnerEmailIsNil        bool     `json:"ownerEmailIsNil,omitempty"`
	OwnerEmailNotNil       bool     `json:"ownerEmailNotNil,omitempty"`
	OwnerEmailEqualFold    *string  `json:"ownerEmailEqualFold,omitempty"`
	OwnerEmailContainsFold *string  `json:"ownerEmailContainsFold,omitempty"`

	// "owner_address" field predicates.
	OwnerAddress             *string  `json:"ownerAddress,omitempty"`
	OwnerAddressNEQ          *string  `json:"ownerAddressNEQ,omitempty"`
	OwnerAddressIn           []string `json:"ownerAddressIn,omitempty"`
	OwnerAddressNotIn        []string `json:"ownerAddressNotIn,omitempty"`
	OwnerAddressGT           *string  `json:"ownerAddressGT,omitempty"`
	OwnerAddressGTE          *string  `json:"ownerAddressGTE,omitempty"`
	OwnerAddressLT           *string  `json:"ownerAddressLT,omitempty"`
	OwnerAddressLTE          *string  `json:"ownerAddressLTE,omitempty"`
	OwnerAddressContains     *string  `json:"ownerAddressContains,omitempty"`
	OwnerAddressHasPrefix    *string  `json:"ownerAddressHasPrefix,omitempty"`
	OwnerAddressHasSuffix    *string  `json:"ownerAddressHasSuffix,omitempty"`
	OwnerAddressEqualFold    *string  `json:"ownerAddressEqualFold,omitempty"`
	OwnerAddressContainsFold *string  `json:"ownerAddressContainsFold,omitempty"`

	// "owner_address_lat" field predicates.
	OwnerAddressLat       *float64  `json:"ownerAddressLat,omitempty"`
	OwnerAddressLatNEQ    *float64  `json:"ownerAddressLatNEQ,omitempty"`
	OwnerAddressLatIn     []float64 `json:"ownerAddressLatIn,omitempty"`
	OwnerAddressLatNotIn  []float64 `json:"ownerAddressLatNotIn,omitempty"`
	OwnerAddressLatGT     *float64  `json:"ownerAddressLatGT,omitempty"`
	OwnerAddressLatGTE    *float64  `json:"ownerAddressLatGTE,omitempty"`
	OwnerAddressLatLT     *float64  `json:"ownerAddressLatLT,omitempty"`
	OwnerAddressLatLTE    *float64  `json:"ownerAddressLatLTE,omitempty"`
	OwnerAddressLatIsNil  bool      `json:"ownerAddressLatIsNil,omitempty"`
	OwnerAddressLatNotNil bool      `json:"ownerAddressLatNotNil,omitempty"`

	// "owner_address_lng" field predicates.
	OwnerAddressLng       *float64  `json:"ownerAddressLng,omitempty"`
	OwnerAddressLngNEQ    *float64  `json:"ownerAddressLngNEQ,omitempty"`
	OwnerAddressLngIn     []float64 `json:"ownerAddressLngIn,omitempty"`
	OwnerAddressLngNotIn  []float64 `json:"ownerAddressLngNotIn,omitempty"`
	OwnerAddressLngGT     *float64  `json:"ownerAddressLngGT,omitempty"`
	OwnerAddressLngGTE    *float64  `json:"ownerAddressLngGTE,omitempty"`
	OwnerAddressLngLT     *float64  `json:"ownerAddressLngLT,omitempty"`
	OwnerAddressLngLTE    *float64  `json:"ownerAddressLngLTE,omitempty"`
	OwnerAddressLngIsNil  bool      `json:"ownerAddressLngIsNil,omitempty"`
	OwnerAddressLngNotNil bool      `json:"ownerAddressLngNotNil,omitempty"`

	// "special_note" field predicates.
	SpecialNote             *string  `json:"specialNote,omitempty"`
	SpecialNoteNEQ          *string  `json:"specialNoteNEQ,omitempty"`
	SpecialNoteIn           []string `json:"specialNoteIn,omitempty"`
	SpecialNoteNotIn        []string `json:"specialNoteNotIn,omitempty"`
	SpecialNoteGT           *string  `json:"specialNoteGT,omitempty"`
	SpecialNoteGTE          *string  `json:"specialNoteGTE,omitempty"`
	SpecialNoteLT           *string  `json:"specialNoteLT,omitempty"`
	SpecialNoteLTE          *string  `json:"specialNoteLTE,omitempty"`
	SpecialNoteContains     *string  `json:"specialNoteContains,omitempty"`
	SpecialNoteHasPrefix    *string  `json:"specialNoteHasPrefix,omitempty"`
	SpecialNoteHasSuffix    *string  `json:"specialNoteHasSuffix,omitempty"`
	SpecialNoteIsNil        bool     `json:"specialNoteIsNil,omitempty"`
	SpecialNoteNotNil       bool     `json:"specialNoteNotNil,omitempty"`
	SpecialNoteEqualFold    *string  `json:"specialNoteEqualFold,omitempty"`
	SpecialNoteContainsFold *string  `json:"specialNoteContainsFold,omitempty"`

	// "pkg" field predicates.
	Pkg             *string  `json:"pkg,omitempty"`
	PkgNEQ          *string  `json:"pkgNEQ,omitempty"`
	PkgIn           []string `json:"pkgIn,omitempty"`
	PkgNotIn        []string `json:"pkgNotIn,omitempty"`
	PkgGT           *string  `json:"pkgGT,omitempty"`
	PkgGTE          *string  `json:"pkgGTE,omitempty"`
	PkgLT           *string  `json:"pkgLT,omitempty"`
	PkgLTE          *string  `json:"pkgLTE,omitempty"`
	PkgContains     *string  `json:"pkgContains,omitempty"`
	PkgHasPrefix    *string  `json:"pkgHasPrefix,omitempty"`
	PkgHasSuffix    *string  `json:"pkgHasSuffix,omitempty"`
	PkgEqualFold    *string  `json:"pkgEqualFold,omitempty"`
	PkgContainsFold *string  `json:"pkgContainsFold,omitempty"`

	// "pkg_description" field predicates.
	PkgDescription             *string  `json:"pkgDescription,omitempty"`
	PkgDescriptionNEQ          *string  `json:"pkgDescriptionNEQ,omitempty"`
	PkgDescriptionIn           []string `json:"pkgDescriptionIn,omitempty"`
	PkgDescriptionNotIn        []string `json:"pkgDescriptionNotIn,omitempty"`
	PkgDescriptionGT           *string  `json:"pkgDescriptionGT,omitempty"`
	PkgDescriptionGTE          *string  `json:"pkgDescriptionGTE,omitempty"`
	PkgDescriptionLT           *string  `json:"pkgDescriptionLT,omitempty"`
	PkgDescriptionLTE          *string  `json:"pkgDescriptionLTE,omitempty"`
	PkgDescriptionContains     *string  `json:"pkgDescriptionContains,omitempty"`
	PkgDescriptionHasPrefix    *string  `json:"pkgDescriptionHasPrefix,omitempty"`
	PkgDescriptionHasSuffix    *string  `json:"pkgDescriptionHasSuffix,omitempty"`
	PkgDescriptionIsNil        bool     `json:"pkgDescriptionIsNil,omitempty"`
	PkgDescriptionNotNil       bool     `json:"pkgDescriptionNotNil,omitempty"`
	PkgDescriptionEqualFold    *string  `json:"pkgDescriptionEqualFold,omitempty"`
	PkgDescriptionContainsFold *string  `json:"pkgDescriptionContainsFold,omitempty"`

	// "price" field predicates.
	Price      *float64  `json:"price,omitempty"`
	PriceNEQ   *float64  `json:"priceNEQ,omitempty"`
	PriceIn    []float64 `json:"priceIn,omitempty"`
	PriceNotIn []float64 `json:"priceNotIn,omitempty"`
	PriceGT    *float64  `json:"priceGT,omitempty"`
	PriceGTE   *float64  `json:"priceGTE,omitempty"`
	PriceLT    *float64  `json:"priceLT,omitempty"`
	PriceLTE   *float64  `json:"priceLTE,omitempty"`

	// "approval" field predicates.
	Approval      *enum.Approval  `json:"approval,omitempty"`
	ApprovalNEQ   *enum.Approval  `json:"approvalNEQ,omitempty"`
	ApprovalIn    []enum.Approval `json:"approvalIn,omitempty"`
	ApprovalNotIn []enum.Approval `json:"approvalNotIn,omitempty"`

	// "approval_at" field predicates.
	ApprovalAt      *time.Time  `json:"approvalAt,omitempty"`
	ApprovalAtNEQ   *time.Time  `json:"approvalAtNEQ,omitempty"`
	ApprovalAtIn    []time.Time `json:"approvalAtIn,omitempty"`
	ApprovalAtNotIn []time.Time `json:"approvalAtNotIn,omitempty"`
	ApprovalAtGT    *time.Time  `json:"approvalAtGT,omitempty"`
	ApprovalAtGTE   *time.Time  `json:"approvalAtGTE,omitempty"`
	ApprovalAtLT    *time.Time  `json:"approvalAtLT,omitempty"`
	ApprovalAtLTE   *time.Time  `json:"approvalAtLTE,omitempty"`

	// "deny_reason" field predicates.
	DenyReason             *string  `json:"denyReason,omitempty"`
	DenyReasonNEQ          *string  `json:"denyReasonNEQ,omitempty"`
	DenyReasonIn           []string `json:"denyReasonIn,omitempty"`
	DenyReasonNotIn        []string `json:"denyReasonNotIn,omitempty"`
	DenyReasonGT           *string  `json:"denyReasonGT,omitempty"`
	DenyReasonGTE          *string  `json:"denyReasonGTE,omitempty"`
	DenyReasonLT           *string  `json:"denyReasonLT,omitempty"`
	DenyReasonLTE          *string  `json:"denyReasonLTE,omitempty"`
	DenyReasonContains     *string  `json:"denyReasonContains,omitempty"`
	DenyReasonHasPrefix    *string  `json:"denyReasonHasPrefix,omitempty"`
	DenyReasonHasSuffix    *string  `json:"denyReasonHasSuffix,omitempty"`
	DenyReasonIsNil        bool     `json:"denyReasonIsNil,omitempty"`
	DenyReasonNotNil       bool     `json:"denyReasonNotNil,omitempty"`
	DenyReasonEqualFold    *string  `json:"denyReasonEqualFold,omitempty"`
	DenyReasonContainsFold *string  `json:"denyReasonContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enum.InstallationStatus  `json:"status,omitempty"`
	StatusNEQ   *enum.InstallationStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enum.InstallationStatus `json:"statusIn,omitempty"`
	StatusNotIn []enum.InstallationStatus `json:"statusNotIn,omitempty"`

	// "status_at" field predicates.
	StatusAt      *time.Time  `json:"statusAt,omitempty"`
	StatusAtNEQ   *time.Time  `json:"statusAtNEQ,omitempty"`
	StatusAtIn    []time.Time `json:"statusAtIn,omitempty"`
	StatusAtNotIn []time.Time `json:"statusAtNotIn,omitempty"`
	StatusAtGT    *time.Time  `json:"statusAtGT,omitempty"`
	StatusAtGTE   *time.Time  `json:"statusAtGTE,omitempty"`
	StatusAtLT    *time.Time  `json:"statusAtLT,omitempty"`
	StatusAtLTE   *time.Time  `json:"statusAtLTE,omitempty"`

	// "items" edge predicates.
	HasItems     *bool                            `json:"hasItems,omitempty"`
	HasItemsWith []*InstallationJobItemWhereInput `json:"hasItemsWith,omitempty"`

	// "progress_history" edge predicates.
	HasProgressHistory     *bool                                `json:"hasProgressHistory,omitempty"`
	HasProgressHistoryWith []*InstallationJobProgressWhereInput `json:"hasProgressHistoryWith,omitempty"`

	// "requesting_partner" edge predicates.
	HasRequestingPartner     *bool                `json:"hasRequestingPartner,omitempty"`
	HasRequestingPartnerWith []*PartnerWhereInput `json:"hasRequestingPartnerWith,omitempty"`

	// "assigned_partner" edge predicates.
	HasAssignedPartner     *bool                `json:"hasAssignedPartner,omitempty"`
	HasAssignedPartnerWith []*PartnerWhereInput `json:"hasAssignedPartnerWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "sales_rep" edge predicates.
	HasSalesRep     *bool             `json:"hasSalesRep,omitempty"`
	HasSalesRepWith []*UserWhereInput `json:"hasSalesRepWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InstallationJobWhereInput) AddPredicates(predicates ...predicate.InstallationJob) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InstallationJobWhereInput filter on the InstallationJobQuery builder.
func (i *InstallationJobWhereInput) Filter(q *InstallationJobQuery) (*InstallationJobQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInstallationJobWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInstallationJobWhereInput is returned in case the InstallationJobWhereInput is empty.
var ErrEmptyInstallationJobWhereInput = errors.New("ent: empty predicate InstallationJobWhereInput")

// P returns a predicate for filtering installationjobs.
// An error is returned if the input is empty or invalid.
func (i *InstallationJobWhereInput) P() (predicate.InstallationJob, error) {
	var predicates []predicate.InstallationJob
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, installationjob.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.InstallationJob, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, installationjob.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.InstallationJob, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, installationjob.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, installationjob.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, installationjob.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, installationjob.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, installationjob.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, installationjob.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, installationjob.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, installationjob.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, installationjob.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, installationjob.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, installationjob.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, installationjob.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, installationjob.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, installationjob.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, installationjob.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, installationjob.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, installationjob.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, installationjob.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, installationjob.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, installationjob.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, installationjob.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, installationjob.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, installationjob.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, installationjob.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, installationjob.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, installationjob.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, installationjob.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, installationjob.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, installationjob.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, installationjob.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, installationjob.TypeNotIn(i.TypeNotIn...))
	}
	if i.OwnerName != nil {
		predicates = append(predicates, installationjob.OwnerNameEQ(*i.OwnerName))
	}
	if i.OwnerNameNEQ != nil {
		predicates = append(predicates, installationjob.OwnerNameNEQ(*i.OwnerNameNEQ))
	}
	if len(i.OwnerNameIn) > 0 {
		predicates = append(predicates, installationjob.OwnerNameIn(i.OwnerNameIn...))
	}
	if len(i.OwnerNameNotIn) > 0 {
		predicates = append(predicates, installationjob.OwnerNameNotIn(i.OwnerNameNotIn...))
	}
	if i.OwnerNameGT != nil {
		predicates = append(predicates, installationjob.OwnerNameGT(*i.OwnerNameGT))
	}
	if i.OwnerNameGTE != nil {
		predicates = append(predicates, installationjob.OwnerNameGTE(*i.OwnerNameGTE))
	}
	if i.OwnerNameLT != nil {
		predicates = append(predicates, installationjob.OwnerNameLT(*i.OwnerNameLT))
	}
	if i.OwnerNameLTE != nil {
		predicates = append(predicates, installationjob.OwnerNameLTE(*i.OwnerNameLTE))
	}
	if i.OwnerNameContains != nil {
		predicates = append(predicates, installationjob.OwnerNameContains(*i.OwnerNameContains))
	}
	if i.OwnerNameHasPrefix != nil {
		predicates = append(predicates, installationjob.OwnerNameHasPrefix(*i.OwnerNameHasPrefix))
	}
	if i.OwnerNameHasSuffix != nil {
		predicates = append(predicates, installationjob.OwnerNameHasSuffix(*i.OwnerNameHasSuffix))
	}
	if i.OwnerNameEqualFold != nil {
		predicates = append(predicates, installationjob.OwnerNameEqualFold(*i.OwnerNameEqualFold))
	}
	if i.OwnerNameContainsFold != nil {
		predicates = append(predicates, installationjob.OwnerNameContainsFold(*i.OwnerNameContainsFold))
	}
	if i.OwnerPhone != nil {
		predicates = append(predicates, installationjob.OwnerPhoneEQ(*i.OwnerPhone))
	}
	if i.OwnerPhoneNEQ != nil {
		predicates = append(predicates, installationjob.OwnerPhoneNEQ(*i.OwnerPhoneNEQ))
	}
	if len(i.OwnerPhoneIn) > 0 {
		predicates = append(predicates, installationjob.OwnerPhoneIn(i.OwnerPhoneIn...))
	}
	if len(i.OwnerPhoneNotIn) > 0 {
		predicates = append(predicates, installationjob.OwnerPhoneNotIn(i.OwnerPhoneNotIn...))
	}
	if i.OwnerPhoneGT != nil {
		predicates = append(predicates, installationjob.OwnerPhoneGT(*i.OwnerPhoneGT))
	}
	if i.OwnerPhoneGTE != nil {
		predicates = append(predicates, installationjob.OwnerPhoneGTE(*i.OwnerPhoneGTE))
	}
	if i.OwnerPhoneLT != nil {
		predicates = append(predicates, installationjob.OwnerPhoneLT(*i.OwnerPhoneLT))
	}
	if i.OwnerPhoneLTE != nil {
		predicates = append(predicates, installationjob.OwnerPhoneLTE(*i.OwnerPhoneLTE))
	}
	if i.OwnerPhoneContains != nil {
		predicates = append(predicates, installationjob.OwnerPhoneContains(*i.OwnerPhoneContains))
	}
	if i.OwnerPhoneHasPrefix != nil {
		predicates = append(predicates, installationjob.OwnerPhoneHasPrefix(*i.OwnerPhoneHasPrefix))
	}
	if i.OwnerPhoneHasSuffix != nil {
		predicates = append(predicates, installationjob.OwnerPhoneHasSuffix(*i.OwnerPhoneHasSuffix))
	}
	if i.OwnerPhoneEqualFold != nil {
		predicates = append(predicates, installationjob.OwnerPhoneEqualFold(*i.OwnerPhoneEqualFold))
	}
	if i.OwnerPhoneContainsFold != nil {
		predicates = append(predicates, installationjob.OwnerPhoneContainsFold(*i.OwnerPhoneContainsFold))
	}
	if i.OwnerEmail != nil {
		predicates = append(predicates, installationjob.OwnerEmailEQ(*i.OwnerEmail))
	}
	if i.OwnerEmailNEQ != nil {
		predicates = append(predicates, installationjob.OwnerEmailNEQ(*i.OwnerEmailNEQ))
	}
	if len(i.OwnerEmailIn) > 0 {
		predicates = append(predicates, installationjob.OwnerEmailIn(i.OwnerEmailIn...))
	}
	if len(i.OwnerEmailNotIn) > 0 {
		predicates = append(predicates, installationjob.OwnerEmailNotIn(i.OwnerEmailNotIn...))
	}
	if i.OwnerEmailGT != nil {
		predicates = append(predicates, installationjob.OwnerEmailGT(*i.OwnerEmailGT))
	}
	if i.OwnerEmailGTE != nil {
		predicates = append(predicates, installationjob.OwnerEmailGTE(*i.OwnerEmailGTE))
	}
	if i.OwnerEmailLT != nil {
		predicates = append(predicates, installationjob.OwnerEmailLT(*i.OwnerEmailLT))
	}
	if i.OwnerEmailLTE != nil {
		predicates = append(predicates, installationjob.OwnerEmailLTE(*i.OwnerEmailLTE))
	}
	if i.OwnerEmailContains != nil {
		predicates = append(predicates, installationjob.OwnerEmailContains(*i.OwnerEmailContains))
	}
	if i.OwnerEmailHasPrefix != nil {
		predicates = append(predicates, installationjob.OwnerEmailHasPrefix(*i.OwnerEmailHasPrefix))
	}
	if i.OwnerEmailHasSuffix != nil {
		predicates = append(predicates, installationjob.OwnerEmailHasSuffix(*i.OwnerEmailHasSuffix))
	}
	if i.OwnerEmailIsNil {
		predicates = append(predicates, installationjob.OwnerEmailIsNil())
	}
	if i.OwnerEmailNotNil {
		predicates = append(predicates, installationjob.OwnerEmailNotNil())
	}
	if i.OwnerEmailEqualFold != nil {
		predicates = append(predicates, installationjob.OwnerEmailEqualFold(*i.OwnerEmailEqualFold))
	}
	if i.OwnerEmailContainsFold != nil {
		predicates = append(predicates, installationjob.OwnerEmailContainsFold(*i.OwnerEmailContainsFold))
	}
	if i.OwnerAddress != nil {
		predicates = append(predicates, installationjob.OwnerAddressEQ(*i.OwnerAddress))
	}
	if i.OwnerAddressNEQ != nil {
		predicates = append(predicates, installationjob.OwnerAddressNEQ(*i.OwnerAddressNEQ))
	}
	if len(i.OwnerAddressIn) > 0 {
		predicates = append(predicates, installationjob.OwnerAddressIn(i.OwnerAddressIn...))
	}
	if len(i.OwnerAddressNotIn) > 0 {
		predicates = append(predicates, installationjob.OwnerAddressNotIn(i.OwnerAddressNotIn...))
	}
	if i.OwnerAddressGT != nil {
		predicates = append(predicates, installationjob.OwnerAddressGT(*i.OwnerAddressGT))
	}
	if i.OwnerAddressGTE != nil {
		predicates = append(predicates, installationjob.OwnerAddressGTE(*i.OwnerAddressGTE))
	}
	if i.OwnerAddressLT != nil {
		predicates = append(predicates, installationjob.OwnerAddressLT(*i.OwnerAddressLT))
	}
	if i.OwnerAddressLTE != nil {
		predicates = append(predicates, installationjob.OwnerAddressLTE(*i.OwnerAddressLTE))
	}
	if i.OwnerAddressContains != nil {
		predicates = append(predicates, installationjob.OwnerAddressContains(*i.OwnerAddressContains))
	}
	if i.OwnerAddressHasPrefix != nil {
		predicates = append(predicates, installationjob.OwnerAddressHasPrefix(*i.OwnerAddressHasPrefix))
	}
	if i.OwnerAddressHasSuffix != nil {
		predicates = append(predicates, installationjob.OwnerAddressHasSuffix(*i.OwnerAddressHasSuffix))
	}
	if i.OwnerAddressEqualFold != nil {
		predicates = append(predicates, installationjob.OwnerAddressEqualFold(*i.OwnerAddressEqualFold))
	}
	if i.OwnerAddressContainsFold != nil {
		predicates = append(predicates, installationjob.OwnerAddressContainsFold(*i.OwnerAddressContainsFold))
	}
	if i.OwnerAddressLat != nil {
		predicates = append(predicates, installationjob.OwnerAddressLatEQ(*i.OwnerAddressLat))
	}
	if i.OwnerAddressLatNEQ != nil {
		predicates = append(predicates, installationjob.OwnerAddressLatNEQ(*i.OwnerAddressLatNEQ))
	}
	if len(i.OwnerAddressLatIn) > 0 {
		predicates = append(predicates, installationjob.OwnerAddressLatIn(i.OwnerAddressLatIn...))
	}
	if len(i.OwnerAddressLatNotIn) > 0 {
		predicates = append(predicates, installationjob.OwnerAddressLatNotIn(i.OwnerAddressLatNotIn...))
	}
	if i.OwnerAddressLatGT != nil {
		predicates = append(predicates, installationjob.OwnerAddressLatGT(*i.OwnerAddressLatGT))
	}
	if i.OwnerAddressLatGTE != nil {
		predicates = append(predicates, installationjob.OwnerAddressLatGTE(*i.OwnerAddressLatGTE))
	}
	if i.OwnerAddressLatLT != nil {
		predicates = append(predicates, installationjob.OwnerAddressLatLT(*i.OwnerAddressLatLT))
	}
	if i.OwnerAddressLatLTE != nil {
		predicates = append(predicates, installationjob.OwnerAddressLatLTE(*i.OwnerAddressLatLTE))
	}
	if i.OwnerAddressLatIsNil {
		predicates = append(predicates, installationjob.OwnerAddressLatIsNil())
	}
	if i.OwnerAddressLatNotNil {
		predicates = append(predicates, installationjob.OwnerAddressLatNotNil())
	}
	if i.OwnerAddressLng != nil {
		predicates = append(predicates, installationjob.OwnerAddressLngEQ(*i.OwnerAddressLng))
	}
	if i.OwnerAddressLngNEQ != nil {
		predicates = append(predicates, installationjob.OwnerAddressLngNEQ(*i.OwnerAddressLngNEQ))
	}
	if len(i.OwnerAddressLngIn) > 0 {
		predicates = append(predicates, installationjob.OwnerAddressLngIn(i.OwnerAddressLngIn...))
	}
	if len(i.OwnerAddressLngNotIn) > 0 {
		predicates = append(predicates, installationjob.OwnerAddressLngNotIn(i.OwnerAddressLngNotIn...))
	}
	if i.OwnerAddressLngGT != nil {
		predicates = append(predicates, installationjob.OwnerAddressLngGT(*i.OwnerAddressLngGT))
	}
	if i.OwnerAddressLngGTE != nil {
		predicates = append(predicates, installationjob.OwnerAddressLngGTE(*i.OwnerAddressLngGTE))
	}
	if i.OwnerAddressLngLT != nil {
		predicates = append(predicates, installationjob.OwnerAddressLngLT(*i.OwnerAddressLngLT))
	}
	if i.OwnerAddressLngLTE != nil {
		predicates = append(predicates, installationjob.OwnerAddressLngLTE(*i.OwnerAddressLngLTE))
	}
	if i.OwnerAddressLngIsNil {
		predicates = append(predicates, installationjob.OwnerAddressLngIsNil())
	}
	if i.OwnerAddressLngNotNil {
		predicates = append(predicates, installationjob.OwnerAddressLngNotNil())
	}
	if i.SpecialNote != nil {
		predicates = append(predicates, installationjob.SpecialNoteEQ(*i.SpecialNote))
	}
	if i.SpecialNoteNEQ != nil {
		predicates = append(predicates, installationjob.SpecialNoteNEQ(*i.SpecialNoteNEQ))
	}
	if len(i.SpecialNoteIn) > 0 {
		predicates = append(predicates, installationjob.SpecialNoteIn(i.SpecialNoteIn...))
	}
	if len(i.SpecialNoteNotIn) > 0 {
		predicates = append(predicates, installationjob.SpecialNoteNotIn(i.SpecialNoteNotIn...))
	}
	if i.SpecialNoteGT != nil {
		predicates = append(predicates, installationjob.SpecialNoteGT(*i.SpecialNoteGT))
	}
	if i.SpecialNoteGTE != nil {
		predicates = append(predicates, installationjob.SpecialNoteGTE(*i.SpecialNoteGTE))
	}
	if i.SpecialNoteLT != nil {
		predicates = append(predicates, installationjob.SpecialNoteLT(*i.SpecialNoteLT))
	}
	if i.SpecialNoteLTE != nil {
		predicates = append(predicates, installationjob.SpecialNoteLTE(*i.SpecialNoteLTE))
	}
	if i.SpecialNoteContains != nil {
		predicates = append(predicates, installationjob.SpecialNoteContains(*i.SpecialNoteContains))
	}
	if i.SpecialNoteHasPrefix != nil {
		predicates = append(predicates, installationjob.SpecialNoteHasPrefix(*i.SpecialNoteHasPrefix))
	}
	if i.SpecialNoteHasSuffix != nil {
		predicates = append(predicates, installationjob.SpecialNoteHasSuffix(*i.SpecialNoteHasSuffix))
	}
	if i.SpecialNoteIsNil {
		predicates = append(predicates, installationjob.SpecialNoteIsNil())
	}
	if i.SpecialNoteNotNil {
		predicates = append(predicates, installationjob.SpecialNoteNotNil())
	}
	if i.SpecialNoteEqualFold != nil {
		predicates = append(predicates, installationjob.SpecialNoteEqualFold(*i.SpecialNoteEqualFold))
	}
	if i.SpecialNoteContainsFold != nil {
		predicates = append(predicates, installationjob.SpecialNoteContainsFold(*i.SpecialNoteContainsFold))
	}
	if i.Pkg != nil {
		predicates = append(predicates, installationjob.PkgEQ(*i.Pkg))
	}
	if i.PkgNEQ != nil {
		predicates = append(predicates, installationjob.PkgNEQ(*i.PkgNEQ))
	}
	if len(i.PkgIn) > 0 {
		predicates = append(predicates, installationjob.PkgIn(i.PkgIn...))
	}
	if len(i.PkgNotIn) > 0 {
		predicates = append(predicates, installationjob.PkgNotIn(i.PkgNotIn...))
	}
	if i.PkgGT != nil {
		predicates = append(predicates, installationjob.PkgGT(*i.PkgGT))
	}
	if i.PkgGTE != nil {
		predicates = append(predicates, installationjob.PkgGTE(*i.PkgGTE))
	}
	if i.PkgLT != nil {
		predicates = append(predicates, installationjob.PkgLT(*i.PkgLT))
	}
	if i.PkgLTE != nil {
		predicates = append(predicates, installationjob.PkgLTE(*i.PkgLTE))
	}
	if i.PkgContains != nil {
		predicates = append(predicates, installationjob.PkgContains(*i.PkgContains))
	}
	if i.PkgHasPrefix != nil {
		predicates = append(predicates, installationjob.PkgHasPrefix(*i.PkgHasPrefix))
	}
	if i.PkgHasSuffix != nil {
		predicates = append(predicates, installationjob.PkgHasSuffix(*i.PkgHasSuffix))
	}
	if i.PkgEqualFold != nil {
		predicates = append(predicates, installationjob.PkgEqualFold(*i.PkgEqualFold))
	}
	if i.PkgContainsFold != nil {
		predicates = append(predicates, installationjob.PkgContainsFold(*i.PkgContainsFold))
	}
	if i.PkgDescription != nil {
		predicates = append(predicates, installationjob.PkgDescriptionEQ(*i.PkgDescription))
	}
	if i.PkgDescriptionNEQ != nil {
		predicates = append(predicates, installationjob.PkgDescriptionNEQ(*i.PkgDescriptionNEQ))
	}
	if len(i.PkgDescriptionIn) > 0 {
		predicates = append(predicates, installationjob.PkgDescriptionIn(i.PkgDescriptionIn...))
	}
	if len(i.PkgDescriptionNotIn) > 0 {
		predicates = append(predicates, installationjob.PkgDescriptionNotIn(i.PkgDescriptionNotIn...))
	}
	if i.PkgDescriptionGT != nil {
		predicates = append(predicates, installationjob.PkgDescriptionGT(*i.PkgDescriptionGT))
	}
	if i.PkgDescriptionGTE != nil {
		predicates = append(predicates, installationjob.PkgDescriptionGTE(*i.PkgDescriptionGTE))
	}
	if i.PkgDescriptionLT != nil {
		predicates = append(predicates, installationjob.PkgDescriptionLT(*i.PkgDescriptionLT))
	}
	if i.PkgDescriptionLTE != nil {
		predicates = append(predicates, installationjob.PkgDescriptionLTE(*i.PkgDescriptionLTE))
	}
	if i.PkgDescriptionContains != nil {
		predicates = append(predicates, installationjob.PkgDescriptionContains(*i.PkgDescriptionContains))
	}
	if i.PkgDescriptionHasPrefix != nil {
		predicates = append(predicates, installationjob.PkgDescriptionHasPrefix(*i.PkgDescriptionHasPrefix))
	}
	if i.PkgDescriptionHasSuffix != nil {
		predicates = append(predicates, installationjob.PkgDescriptionHasSuffix(*i.PkgDescriptionHasSuffix))
	}
	if i.PkgDescriptionIsNil {
		predicates = append(predicates, installationjob.PkgDescriptionIsNil())
	}
	if i.PkgDescriptionNotNil {
		predicates = append(predicates, installationjob.PkgDescriptionNotNil())
	}
	if i.PkgDescriptionEqualFold != nil {
		predicates = append(predicates, installationjob.PkgDescriptionEqualFold(*i.PkgDescriptionEqualFold))
	}
	if i.PkgDescriptionContainsFold != nil {
		predicates = append(predicates, installationjob.PkgDescriptionContainsFold(*i.PkgDescriptionContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, installationjob.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, installationjob.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, installationjob.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, installationjob.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, installationjob.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, installationjob.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, installationjob.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, installationjob.PriceLTE(*i.PriceLTE))
	}
	if i.Approval != nil {
		predicates = append(predicates, installationjob.ApprovalEQ(*i.Approval))
	}
	if i.ApprovalNEQ != nil {
		predicates = append(predicates, installationjob.ApprovalNEQ(*i.ApprovalNEQ))
	}
	if len(i.ApprovalIn) > 0 {
		predicates = append(predicates, installationjob.ApprovalIn(i.ApprovalIn...))
	}
	if len(i.ApprovalNotIn) > 0 {
		predicates = append(predicates, installationjob.ApprovalNotIn(i.ApprovalNotIn...))
	}
	if i.ApprovalAt != nil {
		predicates = append(predicates, installationjob.ApprovalAtEQ(*i.ApprovalAt))
	}
	if i.ApprovalAtNEQ != nil {
		predicates = append(predicates, installationjob.ApprovalAtNEQ(*i.ApprovalAtNEQ))
	}
	if len(i.ApprovalAtIn) > 0 {
		predicates = append(predicates, installationjob.ApprovalAtIn(i.ApprovalAtIn...))
	}
	if len(i.ApprovalAtNotIn) > 0 {
		predicates = append(predicates, installationjob.ApprovalAtNotIn(i.ApprovalAtNotIn...))
	}
	if i.ApprovalAtGT != nil {
		predicates = append(predicates, installationjob.ApprovalAtGT(*i.ApprovalAtGT))
	}
	if i.ApprovalAtGTE != nil {
		predicates = append(predicates, installationjob.ApprovalAtGTE(*i.ApprovalAtGTE))
	}
	if i.ApprovalAtLT != nil {
		predicates = append(predicates, installationjob.ApprovalAtLT(*i.ApprovalAtLT))
	}
	if i.ApprovalAtLTE != nil {
		predicates = append(predicates, installationjob.ApprovalAtLTE(*i.ApprovalAtLTE))
	}
	if i.DenyReason != nil {
		predicates = append(predicates, installationjob.DenyReasonEQ(*i.DenyReason))
	}
	if i.DenyReasonNEQ != nil {
		predicates = append(predicates, installationjob.DenyReasonNEQ(*i.DenyReasonNEQ))
	}
	if len(i.DenyReasonIn) > 0 {
		predicates = append(predicates, installationjob.DenyReasonIn(i.DenyReasonIn...))
	}
	if len(i.DenyReasonNotIn) > 0 {
		predicates = append(predicates, installationjob.DenyReasonNotIn(i.DenyReasonNotIn...))
	}
	if i.DenyReasonGT != nil {
		predicates = append(predicates, installationjob.DenyReasonGT(*i.DenyReasonGT))
	}
	if i.DenyReasonGTE != nil {
		predicates = append(predicates, installationjob.DenyReasonGTE(*i.DenyReasonGTE))
	}
	if i.DenyReasonLT != nil {
		predicates = append(predicates, installationjob.DenyReasonLT(*i.DenyReasonLT))
	}
	if i.DenyReasonLTE != nil {
		predicates = append(predicates, installationjob.DenyReasonLTE(*i.DenyReasonLTE))
	}
	if i.DenyReasonContains != nil {
		predicates = append(predicates, installationjob.DenyReasonContains(*i.DenyReasonContains))
	}
	if i.DenyReasonHasPrefix != nil {
		predicates = append(predicates, installationjob.DenyReasonHasPrefix(*i.DenyReasonHasPrefix))
	}
	if i.DenyReasonHasSuffix != nil {
		predicates = append(predicates, installationjob.DenyReasonHasSuffix(*i.DenyReasonHasSuffix))
	}
	if i.DenyReasonIsNil {
		predicates = append(predicates, installationjob.DenyReasonIsNil())
	}
	if i.DenyReasonNotNil {
		predicates = append(predicates, installationjob.DenyReasonNotNil())
	}
	if i.DenyReasonEqualFold != nil {
		predicates = append(predicates, installationjob.DenyReasonEqualFold(*i.DenyReasonEqualFold))
	}
	if i.DenyReasonContainsFold != nil {
		predicates = append(predicates, installationjob.DenyReasonContainsFold(*i.DenyReasonContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, installationjob.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, installationjob.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, installationjob.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, installationjob.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusAt != nil {
		predicates = append(predicates, installationjob.StatusAtEQ(*i.StatusAt))
	}
	if i.StatusAtNEQ != nil {
		predicates = append(predicates, installationjob.StatusAtNEQ(*i.StatusAtNEQ))
	}
	if len(i.StatusAtIn) > 0 {
		predicates = append(predicates, installationjob.StatusAtIn(i.StatusAtIn...))
	}
	if len(i.StatusAtNotIn) > 0 {
		predicates = append(predicates, installationjob.StatusAtNotIn(i.StatusAtNotIn...))
	}
	if i.StatusAtGT != nil {
		predicates = append(predicates, installationjob.StatusAtGT(*i.StatusAtGT))
	}
	if i.StatusAtGTE != nil {
		predicates = append(predicates, installationjob.StatusAtGTE(*i.StatusAtGTE))
	}
	if i.StatusAtLT != nil {
		predicates = append(predicates, installationjob.StatusAtLT(*i.StatusAtLT))
	}
	if i.StatusAtLTE != nil {
		predicates = append(predicates, installationjob.StatusAtLTE(*i.StatusAtLTE))
	}

	if i.HasItems != nil {
		p := installationjob.HasItems()
		if !*i.HasItems {
			p = installationjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.InstallationJobItem, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, installationjob.HasItemsWith(with...))
	}
	if i.HasProgressHistory != nil {
		p := installationjob.HasProgressHistory()
		if !*i.HasProgressHistory {
			p = installationjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgressHistoryWith) > 0 {
		with := make([]predicate.InstallationJobProgress, 0, len(i.HasProgressHistoryWith))
		for _, w := range i.HasProgressHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgressHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, installationjob.HasProgressHistoryWith(with...))
	}
	if i.HasRequestingPartner != nil {
		p := installationjob.HasRequestingPartner()
		if !*i.HasRequestingPartner {
			p = installationjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestingPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasRequestingPartnerWith))
		for _, w := range i.HasRequestingPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestingPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, installationjob.HasRequestingPartnerWith(with...))
	}
	if i.HasAssignedPartner != nil {
		p := installationjob.HasAssignedPartner()
		if !*i.HasAssignedPartner {
			p = installationjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasAssignedPartnerWith))
		for _, w := range i.HasAssignedPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, installationjob.HasAssignedPartnerWith(with...))
	}
	if i.HasCreator != nil {
		p := installationjob.HasCreator()
		if !*i.HasCreator {
			p = installationjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, installationjob.HasCreatorWith(with...))
	}
	if i.HasSalesRep != nil {
		p := installationjob.HasSalesRep()
		if !*i.HasSalesRep {
			p = installationjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSalesRepWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasSalesRepWith))
		for _, w := range i.HasSalesRepWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSalesRepWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, installationjob.HasSalesRepWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInstallationJobWhereInput
	case 1:
		return predicates[0], nil
	default:
		return installationjob.And(predicates...), nil
	}
}

// InstallationJobItemWhereInput represents a where input for filtering InstallationJobItem queries.
type InstallationJobItemWhereInput struct {
	Predicates []predicate.InstallationJobItem  `json:"-"`
	Not        *InstallationJobItemWhereInput   `json:"not,omitempty"`
	Or         []*InstallationJobItemWhereInput `json:"or,omitempty"`
	And        []*InstallationJobItemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "price" field predicates.
	Price      *float64  `json:"price,omitempty"`
	PriceNEQ   *float64  `json:"priceNEQ,omitempty"`
	PriceIn    []float64 `json:"priceIn,omitempty"`
	PriceNotIn []float64 `json:"priceNotIn,omitempty"`
	PriceGT    *float64  `json:"priceGT,omitempty"`
	PriceGTE   *float64  `json:"priceGTE,omitempty"`
	PriceLT    *float64  `json:"priceLT,omitempty"`
	PriceLTE   *float64  `json:"priceLTE,omitempty"`

	// "img_key" field predicates.
	ImgKey             *string  `json:"imgKey,omitempty"`
	ImgKeyNEQ          *string  `json:"imgKeyNEQ,omitempty"`
	ImgKeyIn           []string `json:"imgKeyIn,omitempty"`
	ImgKeyNotIn        []string `json:"imgKeyNotIn,omitempty"`
	ImgKeyGT           *string  `json:"imgKeyGT,omitempty"`
	ImgKeyGTE          *string  `json:"imgKeyGTE,omitempty"`
	ImgKeyLT           *string  `json:"imgKeyLT,omitempty"`
	ImgKeyLTE          *string  `json:"imgKeyLTE,omitempty"`
	ImgKeyContains     *string  `json:"imgKeyContains,omitempty"`
	ImgKeyHasPrefix    *string  `json:"imgKeyHasPrefix,omitempty"`
	ImgKeyHasSuffix    *string  `json:"imgKeyHasSuffix,omitempty"`
	ImgKeyEqualFold    *string  `json:"imgKeyEqualFold,omitempty"`
	ImgKeyContainsFold *string  `json:"imgKeyContainsFold,omitempty"`

	// "special_note" field predicates.
	SpecialNote             *string  `json:"specialNote,omitempty"`
	SpecialNoteNEQ          *string  `json:"specialNoteNEQ,omitempty"`
	SpecialNoteIn           []string `json:"specialNoteIn,omitempty"`
	SpecialNoteNotIn        []string `json:"specialNoteNotIn,omitempty"`
	SpecialNoteGT           *string  `json:"specialNoteGT,omitempty"`
	SpecialNoteGTE          *string  `json:"specialNoteGTE,omitempty"`
	SpecialNoteLT           *string  `json:"specialNoteLT,omitempty"`
	SpecialNoteLTE          *string  `json:"specialNoteLTE,omitempty"`
	SpecialNoteContains     *string  `json:"specialNoteContains,omitempty"`
	SpecialNoteHasPrefix    *string  `json:"specialNoteHasPrefix,omitempty"`
	SpecialNoteHasSuffix    *string  `json:"specialNoteHasSuffix,omitempty"`
	SpecialNoteIsNil        bool     `json:"specialNoteIsNil,omitempty"`
	SpecialNoteNotNil       bool     `json:"specialNoteNotNil,omitempty"`
	SpecialNoteEqualFold    *string  `json:"specialNoteEqualFold,omitempty"`
	SpecialNoteContainsFold *string  `json:"specialNoteContainsFold,omitempty"`

	// "job" edge predicates.
	HasJob     *bool                        `json:"hasJob,omitempty"`
	HasJobWith []*InstallationJobWhereInput `json:"hasJobWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InstallationJobItemWhereInput) AddPredicates(predicates ...predicate.InstallationJobItem) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InstallationJobItemWhereInput filter on the InstallationJobItemQuery builder.
func (i *InstallationJobItemWhereInput) Filter(q *InstallationJobItemQuery) (*InstallationJobItemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInstallationJobItemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInstallationJobItemWhereInput is returned in case the InstallationJobItemWhereInput is empty.
var ErrEmptyInstallationJobItemWhereInput = errors.New("ent: empty predicate InstallationJobItemWhereInput")

// P returns a predicate for filtering installationjobitems.
// An error is returned if the input is empty or invalid.
func (i *InstallationJobItemWhereInput) P() (predicate.InstallationJobItem, error) {
	var predicates []predicate.InstallationJobItem
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, installationjobitem.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.InstallationJobItem, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, installationjobitem.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.InstallationJobItem, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, installationjobitem.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, installationjobitem.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, installationjobitem.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, installationjobitem.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, installationjobitem.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, installationjobitem.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, installationjobitem.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, installationjobitem.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, installationjobitem.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, installationjobitem.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, installationjobitem.IDContainsFold(*i.IDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, installationjobitem.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, installationjobitem.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, installationjobitem.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, installationjobitem.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, installationjobitem.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, installationjobitem.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, installationjobitem.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, installationjobitem.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, installationjobitem.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, installationjobitem.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, installationjobitem.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, installationjobitem.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, installationjobitem.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, installationjobitem.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, installationjobitem.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, installationjobitem.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, installationjobitem.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, installationjobitem.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, installationjobitem.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, installationjobitem.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, installationjobitem.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, installationjobitem.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, installationjobitem.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, installationjobitem.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, installationjobitem.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, installationjobitem.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, installationjobitem.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, installationjobitem.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, installationjobitem.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, installationjobitem.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, installationjobitem.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, installationjobitem.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, installationjobitem.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, installationjobitem.PriceLTE(*i.PriceLTE))
	}
	if i.ImgKey != nil {
		predicates = append(predicates, installationjobitem.ImgKeyEQ(*i.ImgKey))
	}
	if i.ImgKeyNEQ != nil {
		predicates = append(predicates, installationjobitem.ImgKeyNEQ(*i.ImgKeyNEQ))
	}
	if len(i.ImgKeyIn) > 0 {
		predicates = append(predicates, installationjobitem.ImgKeyIn(i.ImgKeyIn...))
	}
	if len(i.ImgKeyNotIn) > 0 {
		predicates = append(predicates, installationjobitem.ImgKeyNotIn(i.ImgKeyNotIn...))
	}
	if i.ImgKeyGT != nil {
		predicates = append(predicates, installationjobitem.ImgKeyGT(*i.ImgKeyGT))
	}
	if i.ImgKeyGTE != nil {
		predicates = append(predicates, installationjobitem.ImgKeyGTE(*i.ImgKeyGTE))
	}
	if i.ImgKeyLT != nil {
		predicates = append(predicates, installationjobitem.ImgKeyLT(*i.ImgKeyLT))
	}
	if i.ImgKeyLTE != nil {
		predicates = append(predicates, installationjobitem.ImgKeyLTE(*i.ImgKeyLTE))
	}
	if i.ImgKeyContains != nil {
		predicates = append(predicates, installationjobitem.ImgKeyContains(*i.ImgKeyContains))
	}
	if i.ImgKeyHasPrefix != nil {
		predicates = append(predicates, installationjobitem.ImgKeyHasPrefix(*i.ImgKeyHasPrefix))
	}
	if i.ImgKeyHasSuffix != nil {
		predicates = append(predicates, installationjobitem.ImgKeyHasSuffix(*i.ImgKeyHasSuffix))
	}
	if i.ImgKeyEqualFold != nil {
		predicates = append(predicates, installationjobitem.ImgKeyEqualFold(*i.ImgKeyEqualFold))
	}
	if i.ImgKeyContainsFold != nil {
		predicates = append(predicates, installationjobitem.ImgKeyContainsFold(*i.ImgKeyContainsFold))
	}
	if i.SpecialNote != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteEQ(*i.SpecialNote))
	}
	if i.SpecialNoteNEQ != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteNEQ(*i.SpecialNoteNEQ))
	}
	if len(i.SpecialNoteIn) > 0 {
		predicates = append(predicates, installationjobitem.SpecialNoteIn(i.SpecialNoteIn...))
	}
	if len(i.SpecialNoteNotIn) > 0 {
		predicates = append(predicates, installationjobitem.SpecialNoteNotIn(i.SpecialNoteNotIn...))
	}
	if i.SpecialNoteGT != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteGT(*i.SpecialNoteGT))
	}
	if i.SpecialNoteGTE != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteGTE(*i.SpecialNoteGTE))
	}
	if i.SpecialNoteLT != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteLT(*i.SpecialNoteLT))
	}
	if i.SpecialNoteLTE != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteLTE(*i.SpecialNoteLTE))
	}
	if i.SpecialNoteContains != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteContains(*i.SpecialNoteContains))
	}
	if i.SpecialNoteHasPrefix != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteHasPrefix(*i.SpecialNoteHasPrefix))
	}
	if i.SpecialNoteHasSuffix != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteHasSuffix(*i.SpecialNoteHasSuffix))
	}
	if i.SpecialNoteIsNil {
		predicates = append(predicates, installationjobitem.SpecialNoteIsNil())
	}
	if i.SpecialNoteNotNil {
		predicates = append(predicates, installationjobitem.SpecialNoteNotNil())
	}
	if i.SpecialNoteEqualFold != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteEqualFold(*i.SpecialNoteEqualFold))
	}
	if i.SpecialNoteContainsFold != nil {
		predicates = append(predicates, installationjobitem.SpecialNoteContainsFold(*i.SpecialNoteContainsFold))
	}

	if i.HasJob != nil {
		p := installationjobitem.HasJob()
		if !*i.HasJob {
			p = installationjobitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobWith) > 0 {
		with := make([]predicate.InstallationJob, 0, len(i.HasJobWith))
		for _, w := range i.HasJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, installationjobitem.HasJobWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInstallationJobItemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return installationjobitem.And(predicates...), nil
	}
}

// InstallationJobProgressWhereInput represents a where input for filtering InstallationJobProgress queries.
type InstallationJobProgressWhereInput struct {
	Predicates []predicate.InstallationJobProgress  `json:"-"`
	Not        *InstallationJobProgressWhereInput   `json:"not,omitempty"`
	Or         []*InstallationJobProgressWhereInput `json:"or,omitempty"`
	And        []*InstallationJobProgressWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "status" field predicates.
	Status      *enum.InstallationStatus  `json:"status,omitempty"`
	StatusNEQ   *enum.InstallationStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enum.InstallationStatus `json:"statusIn,omitempty"`
	StatusNotIn []enum.InstallationStatus `json:"statusNotIn,omitempty"`

	// "complete" field predicates.
	Complete       *bool `json:"complete,omitempty"`
	CompleteNEQ    *bool `json:"completeNEQ,omitempty"`
	CompleteIsNil  bool  `json:"completeIsNil,omitempty"`
	CompleteNotNil bool  `json:"completeNotNil,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "job" edge predicates.
	HasJob     *bool                        `json:"hasJob,omitempty"`
	HasJobWith []*InstallationJobWhereInput `json:"hasJobWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InstallationJobProgressWhereInput) AddPredicates(predicates ...predicate.InstallationJobProgress) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InstallationJobProgressWhereInput filter on the InstallationJobProgressQuery builder.
func (i *InstallationJobProgressWhereInput) Filter(q *InstallationJobProgressQuery) (*InstallationJobProgressQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInstallationJobProgressWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInstallationJobProgressWhereInput is returned in case the InstallationJobProgressWhereInput is empty.
var ErrEmptyInstallationJobProgressWhereInput = errors.New("ent: empty predicate InstallationJobProgressWhereInput")

// P returns a predicate for filtering installationjobprogresses.
// An error is returned if the input is empty or invalid.
func (i *InstallationJobProgressWhereInput) P() (predicate.InstallationJobProgress, error) {
	var predicates []predicate.InstallationJobProgress
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, installationjobprogress.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.InstallationJobProgress, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, installationjobprogress.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.InstallationJobProgress, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, installationjobprogress.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, installationjobprogress.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, installationjobprogress.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, installationjobprogress.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, installationjobprogress.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, installationjobprogress.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, installationjobprogress.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, installationjobprogress.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, installationjobprogress.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, installationjobprogress.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, installationjobprogress.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, installationjobprogress.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, installationjobprogress.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, installationjobprogress.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, installationjobprogress.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, installationjobprogress.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, installationjobprogress.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, installationjobprogress.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, installationjobprogress.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, installationjobprogress.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, installationjobprogress.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, installationjobprogress.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, installationjobprogress.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, installationjobprogress.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, installationjobprogress.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, installationjobprogress.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, installationjobprogress.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, installationjobprogress.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, installationjobprogress.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, installationjobprogress.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, installationjobprogress.StatusNotIn(i.StatusNotIn...))
	}
	if i.Complete != nil {
		predicates = append(predicates, installationjobprogress.CompleteEQ(*i.Complete))
	}
	if i.CompleteNEQ != nil {
		predicates = append(predicates, installationjobprogress.CompleteNEQ(*i.CompleteNEQ))
	}
	if i.CompleteIsNil {
		predicates = append(predicates, installationjobprogress.CompleteIsNil())
	}
	if i.CompleteNotNil {
		predicates = append(predicates, installationjobprogress.CompleteNotNil())
	}
	if i.Note != nil {
		predicates = append(predicates, installationjobprogress.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, installationjobprogress.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, installationjobprogress.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, installationjobprogress.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, installationjobprogress.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, installationjobprogress.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, installationjobprogress.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, installationjobprogress.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, installationjobprogress.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, installationjobprogress.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, installationjobprogress.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, installationjobprogress.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, installationjobprogress.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, installationjobprogress.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, installationjobprogress.NoteContainsFold(*i.NoteContainsFold))
	}

	if i.HasJob != nil {
		p := installationjobprogress.HasJob()
		if !*i.HasJob {
			p = installationjobprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobWith) > 0 {
		with := make([]predicate.InstallationJob, 0, len(i.HasJobWith))
		for _, w := range i.HasJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, installationjobprogress.HasJobWith(with...))
	}
	if i.HasCreator != nil {
		p := installationjobprogress.HasCreator()
		if !*i.HasCreator {
			p = installationjobprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, installationjobprogress.HasCreatorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInstallationJobProgressWhereInput
	case 1:
		return predicates[0], nil
	default:
		return installationjobprogress.And(predicates...), nil
	}
}

// JobWhereInput represents a where input for filtering Job queries.
type JobWhereInput struct {
	Predicates []predicate.Job  `json:"-"`
	Not        *JobWhereInput   `json:"not,omitempty"`
	Or         []*JobWhereInput `json:"or,omitempty"`
	And        []*JobWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "progress" field predicates.
	Progress       *enum.JobProgress  `json:"progress,omitempty"`
	ProgressNEQ    *enum.JobProgress  `json:"progressNEQ,omitempty"`
	ProgressIn     []enum.JobProgress `json:"progressIn,omitempty"`
	ProgressNotIn  []enum.JobProgress `json:"progressNotIn,omitempty"`
	ProgressIsNil  bool               `json:"progressIsNil,omitempty"`
	ProgressNotNil bool               `json:"progressNotNil,omitempty"`

	// "progress_at" field predicates.
	ProgressAt       *time.Time  `json:"progressAt,omitempty"`
	ProgressAtNEQ    *time.Time  `json:"progressAtNEQ,omitempty"`
	ProgressAtIn     []time.Time `json:"progressAtIn,omitempty"`
	ProgressAtNotIn  []time.Time `json:"progressAtNotIn,omitempty"`
	ProgressAtGT     *time.Time  `json:"progressAtGT,omitempty"`
	ProgressAtGTE    *time.Time  `json:"progressAtGTE,omitempty"`
	ProgressAtLT     *time.Time  `json:"progressAtLT,omitempty"`
	ProgressAtLTE    *time.Time  `json:"progressAtLTE,omitempty"`
	ProgressAtIsNil  bool        `json:"progressAtIsNil,omitempty"`
	ProgressAtNotNil bool        `json:"progressAtNotNil,omitempty"`

	// "progress_flag_at" field predicates.
	ProgressFlagAt       *time.Time  `json:"progressFlagAt,omitempty"`
	ProgressFlagAtNEQ    *time.Time  `json:"progressFlagAtNEQ,omitempty"`
	ProgressFlagAtIn     []time.Time `json:"progressFlagAtIn,omitempty"`
	ProgressFlagAtNotIn  []time.Time `json:"progressFlagAtNotIn,omitempty"`
	ProgressFlagAtGT     *time.Time  `json:"progressFlagAtGT,omitempty"`
	ProgressFlagAtGTE    *time.Time  `json:"progressFlagAtGTE,omitempty"`
	ProgressFlagAtLT     *time.Time  `json:"progressFlagAtLT,omitempty"`
	ProgressFlagAtLTE    *time.Time  `json:"progressFlagAtLTE,omitempty"`
	ProgressFlagAtIsNil  bool        `json:"progressFlagAtIsNil,omitempty"`
	ProgressFlagAtNotNil bool        `json:"progressFlagAtNotNil,omitempty"`

	// "region_id" field predicates.
	RegionID       *uint8  `json:"regionID,omitempty"`
	RegionIDNEQ    *uint8  `json:"regionIDNEQ,omitempty"`
	RegionIDIn     []uint8 `json:"regionIDIn,omitempty"`
	RegionIDNotIn  []uint8 `json:"regionIDNotIn,omitempty"`
	RegionIDGT     *uint8  `json:"regionIDGT,omitempty"`
	RegionIDGTE    *uint8  `json:"regionIDGTE,omitempty"`
	RegionIDLT     *uint8  `json:"regionIDLT,omitempty"`
	RegionIDLTE    *uint8  `json:"regionIDLTE,omitempty"`
	RegionIDIsNil  bool    `json:"regionIDIsNil,omitempty"`
	RegionIDNotNil bool    `json:"regionIDNotNil,omitempty"`

	// "company_ref_id" field predicates.
	CompanyRefID             *string  `json:"companyRefID,omitempty"`
	CompanyRefIDNEQ          *string  `json:"companyRefIDNEQ,omitempty"`
	CompanyRefIDIn           []string `json:"companyRefIDIn,omitempty"`
	CompanyRefIDNotIn        []string `json:"companyRefIDNotIn,omitempty"`
	CompanyRefIDGT           *string  `json:"companyRefIDGT,omitempty"`
	CompanyRefIDGTE          *string  `json:"companyRefIDGTE,omitempty"`
	CompanyRefIDLT           *string  `json:"companyRefIDLT,omitempty"`
	CompanyRefIDLTE          *string  `json:"companyRefIDLTE,omitempty"`
	CompanyRefIDContains     *string  `json:"companyRefIDContains,omitempty"`
	CompanyRefIDHasPrefix    *string  `json:"companyRefIDHasPrefix,omitempty"`
	CompanyRefIDHasSuffix    *string  `json:"companyRefIDHasSuffix,omitempty"`
	CompanyRefIDIsNil        bool     `json:"companyRefIDIsNil,omitempty"`
	CompanyRefIDNotNil       bool     `json:"companyRefIDNotNil,omitempty"`
	CompanyRefIDEqualFold    *string  `json:"companyRefIDEqualFold,omitempty"`
	CompanyRefIDContainsFold *string  `json:"companyRefIDContainsFold,omitempty"`

	// "company_name" field predicates.
	CompanyName             *string  `json:"companyName,omitempty"`
	CompanyNameNEQ          *string  `json:"companyNameNEQ,omitempty"`
	CompanyNameIn           []string `json:"companyNameIn,omitempty"`
	CompanyNameNotIn        []string `json:"companyNameNotIn,omitempty"`
	CompanyNameGT           *string  `json:"companyNameGT,omitempty"`
	CompanyNameGTE          *string  `json:"companyNameGTE,omitempty"`
	CompanyNameLT           *string  `json:"companyNameLT,omitempty"`
	CompanyNameLTE          *string  `json:"companyNameLTE,omitempty"`
	CompanyNameContains     *string  `json:"companyNameContains,omitempty"`
	CompanyNameHasPrefix    *string  `json:"companyNameHasPrefix,omitempty"`
	CompanyNameHasSuffix    *string  `json:"companyNameHasSuffix,omitempty"`
	CompanyNameIsNil        bool     `json:"companyNameIsNil,omitempty"`
	CompanyNameNotNil       bool     `json:"companyNameNotNil,omitempty"`
	CompanyNameEqualFold    *string  `json:"companyNameEqualFold,omitempty"`
	CompanyNameContainsFold *string  `json:"companyNameContainsFold,omitempty"`

	// "price" field predicates.
	Price      *float64  `json:"price,omitempty"`
	PriceNEQ   *float64  `json:"priceNEQ,omitempty"`
	PriceIn    []float64 `json:"priceIn,omitempty"`
	PriceNotIn []float64 `json:"priceNotIn,omitempty"`
	PriceGT    *float64  `json:"priceGT,omitempty"`
	PriceGTE   *float64  `json:"priceGTE,omitempty"`
	PriceLT    *float64  `json:"priceLT,omitempty"`
	PriceLTE   *float64  `json:"priceLTE,omitempty"`

	// "work_order_price" field predicates.
	WorkOrderPrice      *float64  `json:"workOrderPrice,omitempty"`
	WorkOrderPriceNEQ   *float64  `json:"workOrderPriceNEQ,omitempty"`
	WorkOrderPriceIn    []float64 `json:"workOrderPriceIn,omitempty"`
	WorkOrderPriceNotIn []float64 `json:"workOrderPriceNotIn,omitempty"`
	WorkOrderPriceGT    *float64  `json:"workOrderPriceGT,omitempty"`
	WorkOrderPriceGTE   *float64  `json:"workOrderPriceGTE,omitempty"`
	WorkOrderPriceLT    *float64  `json:"workOrderPriceLT,omitempty"`
	WorkOrderPriceLTE   *float64  `json:"workOrderPriceLTE,omitempty"`

	// "contract_price" field predicates.
	ContractPrice       *float64  `json:"contractPrice,omitempty"`
	ContractPriceNEQ    *float64  `json:"contractPriceNEQ,omitempty"`
	ContractPriceIn     []float64 `json:"contractPriceIn,omitempty"`
	ContractPriceNotIn  []float64 `json:"contractPriceNotIn,omitempty"`
	ContractPriceGT     *float64  `json:"contractPriceGT,omitempty"`
	ContractPriceGTE    *float64  `json:"contractPriceGTE,omitempty"`
	ContractPriceLT     *float64  `json:"contractPriceLT,omitempty"`
	ContractPriceLTE    *float64  `json:"contractPriceLTE,omitempty"`
	ContractPriceIsNil  bool      `json:"contractPriceIsNil,omitempty"`
	ContractPriceNotNil bool      `json:"contractPriceNotNil,omitempty"`

	// "change_order_price" field predicates.
	ChangeOrderPrice       *float64  `json:"changeOrderPrice,omitempty"`
	ChangeOrderPriceNEQ    *float64  `json:"changeOrderPriceNEQ,omitempty"`
	ChangeOrderPriceIn     []float64 `json:"changeOrderPriceIn,omitempty"`
	ChangeOrderPriceNotIn  []float64 `json:"changeOrderPriceNotIn,omitempty"`
	ChangeOrderPriceGT     *float64  `json:"changeOrderPriceGT,omitempty"`
	ChangeOrderPriceGTE    *float64  `json:"changeOrderPriceGTE,omitempty"`
	ChangeOrderPriceLT     *float64  `json:"changeOrderPriceLT,omitempty"`
	ChangeOrderPriceLTE    *float64  `json:"changeOrderPriceLTE,omitempty"`
	ChangeOrderPriceIsNil  bool      `json:"changeOrderPriceIsNil,omitempty"`
	ChangeOrderPriceNotNil bool      `json:"changeOrderPriceNotNil,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "shingle_color" field predicates.
	ShingleColor             *string  `json:"shingleColor,omitempty"`
	ShingleColorNEQ          *string  `json:"shingleColorNEQ,omitempty"`
	ShingleColorIn           []string `json:"shingleColorIn,omitempty"`
	ShingleColorNotIn        []string `json:"shingleColorNotIn,omitempty"`
	ShingleColorGT           *string  `json:"shingleColorGT,omitempty"`
	ShingleColorGTE          *string  `json:"shingleColorGTE,omitempty"`
	ShingleColorLT           *string  `json:"shingleColorLT,omitempty"`
	ShingleColorLTE          *string  `json:"shingleColorLTE,omitempty"`
	ShingleColorContains     *string  `json:"shingleColorContains,omitempty"`
	ShingleColorHasPrefix    *string  `json:"shingleColorHasPrefix,omitempty"`
	ShingleColorHasSuffix    *string  `json:"shingleColorHasSuffix,omitempty"`
	ShingleColorIsNil        bool     `json:"shingleColorIsNil,omitempty"`
	ShingleColorNotNil       bool     `json:"shingleColorNotNil,omitempty"`
	ShingleColorEqualFold    *string  `json:"shingleColorEqualFold,omitempty"`
	ShingleColorContainsFold *string  `json:"shingleColorContainsFold,omitempty"`

	// "permit_required" field predicates.
	PermitRequired       *bool `json:"permitRequired,omitempty"`
	PermitRequiredNEQ    *bool `json:"permitRequiredNEQ,omitempty"`
	PermitRequiredIsNil  bool  `json:"permitRequiredIsNil,omitempty"`
	PermitRequiredNotNil bool  `json:"permitRequiredNotNil,omitempty"`

	// "inspection_required" field predicates.
	InspectionRequired       *bool `json:"inspectionRequired,omitempty"`
	InspectionRequiredNEQ    *bool `json:"inspectionRequiredNEQ,omitempty"`
	InspectionRequiredIsNil  bool  `json:"inspectionRequiredIsNil,omitempty"`
	InspectionRequiredNotNil bool  `json:"inspectionRequiredNotNil,omitempty"`

	// "inspection_date" field predicates.
	InspectionDate       *time.Time  `json:"inspectionDate,omitempty"`
	InspectionDateNEQ    *time.Time  `json:"inspectionDateNEQ,omitempty"`
	InspectionDateIn     []time.Time `json:"inspectionDateIn,omitempty"`
	InspectionDateNotIn  []time.Time `json:"inspectionDateNotIn,omitempty"`
	InspectionDateGT     *time.Time  `json:"inspectionDateGT,omitempty"`
	InspectionDateGTE    *time.Time  `json:"inspectionDateGTE,omitempty"`
	InspectionDateLT     *time.Time  `json:"inspectionDateLT,omitempty"`
	InspectionDateLTE    *time.Time  `json:"inspectionDateLTE,omitempty"`
	InspectionDateIsNil  bool        `json:"inspectionDateIsNil,omitempty"`
	InspectionDateNotNil bool        `json:"inspectionDateNotNil,omitempty"`

	// "progress_inspection_date" field predicates.
	ProgressInspectionDate       *time.Time  `json:"progressInspectionDate,omitempty"`
	ProgressInspectionDateNEQ    *time.Time  `json:"progressInspectionDateNEQ,omitempty"`
	ProgressInspectionDateIn     []time.Time `json:"progressInspectionDateIn,omitempty"`
	ProgressInspectionDateNotIn  []time.Time `json:"progressInspectionDateNotIn,omitempty"`
	ProgressInspectionDateGT     *time.Time  `json:"progressInspectionDateGT,omitempty"`
	ProgressInspectionDateGTE    *time.Time  `json:"progressInspectionDateGTE,omitempty"`
	ProgressInspectionDateLT     *time.Time  `json:"progressInspectionDateLT,omitempty"`
	ProgressInspectionDateLTE    *time.Time  `json:"progressInspectionDateLTE,omitempty"`
	ProgressInspectionDateIsNil  bool        `json:"progressInspectionDateIsNil,omitempty"`
	ProgressInspectionDateNotNil bool        `json:"progressInspectionDateNotNil,omitempty"`

	// "install_date" field predicates.
	InstallDate       *time.Time  `json:"installDate,omitempty"`
	InstallDateNEQ    *time.Time  `json:"installDateNEQ,omitempty"`
	InstallDateIn     []time.Time `json:"installDateIn,omitempty"`
	InstallDateNotIn  []time.Time `json:"installDateNotIn,omitempty"`
	InstallDateGT     *time.Time  `json:"installDateGT,omitempty"`
	InstallDateGTE    *time.Time  `json:"installDateGTE,omitempty"`
	InstallDateLT     *time.Time  `json:"installDateLT,omitempty"`
	InstallDateLTE    *time.Time  `json:"installDateLTE,omitempty"`
	InstallDateIsNil  bool        `json:"installDateIsNil,omitempty"`
	InstallDateNotNil bool        `json:"installDateNotNil,omitempty"`

	// "completion_date" field predicates.
	CompletionDate       *time.Time  `json:"completionDate,omitempty"`
	CompletionDateNEQ    *time.Time  `json:"completionDateNEQ,omitempty"`
	CompletionDateIn     []time.Time `json:"completionDateIn,omitempty"`
	CompletionDateNotIn  []time.Time `json:"completionDateNotIn,omitempty"`
	CompletionDateGT     *time.Time  `json:"completionDateGT,omitempty"`
	CompletionDateGTE    *time.Time  `json:"completionDateGTE,omitempty"`
	CompletionDateLT     *time.Time  `json:"completionDateLT,omitempty"`
	CompletionDateLTE    *time.Time  `json:"completionDateLTE,omitempty"`
	CompletionDateIsNil  bool        `json:"completionDateIsNil,omitempty"`
	CompletionDateNotNil bool        `json:"completionDateNotNil,omitempty"`

	// "material_delivery_date" field predicates.
	MaterialDeliveryDate       *time.Time  `json:"materialDeliveryDate,omitempty"`
	MaterialDeliveryDateNEQ    *time.Time  `json:"materialDeliveryDateNEQ,omitempty"`
	MaterialDeliveryDateIn     []time.Time `json:"materialDeliveryDateIn,omitempty"`
	MaterialDeliveryDateNotIn  []time.Time `json:"materialDeliveryDateNotIn,omitempty"`
	MaterialDeliveryDateGT     *time.Time  `json:"materialDeliveryDateGT,omitempty"`
	MaterialDeliveryDateGTE    *time.Time  `json:"materialDeliveryDateGTE,omitempty"`
	MaterialDeliveryDateLT     *time.Time  `json:"materialDeliveryDateLT,omitempty"`
	MaterialDeliveryDateLTE    *time.Time  `json:"materialDeliveryDateLTE,omitempty"`
	MaterialDeliveryDateIsNil  bool        `json:"materialDeliveryDateIsNil,omitempty"`
	MaterialDeliveryDateNotNil bool        `json:"materialDeliveryDateNotNil,omitempty"`

	// "agree" field predicates.
	Agree       *bool `json:"agree,omitempty"`
	AgreeNEQ    *bool `json:"agreeNEQ,omitempty"`
	AgreeIsNil  bool  `json:"agreeIsNil,omitempty"`
	AgreeNotNil bool  `json:"agreeNotNil,omitempty"`

	// "agree_at" field predicates.
	AgreeAt       *time.Time  `json:"agreeAt,omitempty"`
	AgreeAtNEQ    *time.Time  `json:"agreeAtNEQ,omitempty"`
	AgreeAtIn     []time.Time `json:"agreeAtIn,omitempty"`
	AgreeAtNotIn  []time.Time `json:"agreeAtNotIn,omitempty"`
	AgreeAtGT     *time.Time  `json:"agreeAtGT,omitempty"`
	AgreeAtGTE    *time.Time  `json:"agreeAtGTE,omitempty"`
	AgreeAtLT     *time.Time  `json:"agreeAtLT,omitempty"`
	AgreeAtLTE    *time.Time  `json:"agreeAtLTE,omitempty"`
	AgreeAtIsNil  bool        `json:"agreeAtIsNil,omitempty"`
	AgreeAtNotNil bool        `json:"agreeAtNotNil,omitempty"`

	// "po_number" field predicates.
	PoNumber             *string  `json:"poNumber,omitempty"`
	PoNumberNEQ          *string  `json:"poNumberNEQ,omitempty"`
	PoNumberIn           []string `json:"poNumberIn,omitempty"`
	PoNumberNotIn        []string `json:"poNumberNotIn,omitempty"`
	PoNumberGT           *string  `json:"poNumberGT,omitempty"`
	PoNumberGTE          *string  `json:"poNumberGTE,omitempty"`
	PoNumberLT           *string  `json:"poNumberLT,omitempty"`
	PoNumberLTE          *string  `json:"poNumberLTE,omitempty"`
	PoNumberContains     *string  `json:"poNumberContains,omitempty"`
	PoNumberHasPrefix    *string  `json:"poNumberHasPrefix,omitempty"`
	PoNumberHasSuffix    *string  `json:"poNumberHasSuffix,omitempty"`
	PoNumberIsNil        bool     `json:"poNumberIsNil,omitempty"`
	PoNumberNotNil       bool     `json:"poNumberNotNil,omitempty"`
	PoNumberEqualFold    *string  `json:"poNumberEqualFold,omitempty"`
	PoNumberContainsFold *string  `json:"poNumberContainsFold,omitempty"`

	// "roofing_partner_assigned_at" field predicates.
	RoofingPartnerAssignedAt       *time.Time  `json:"roofingPartnerAssignedAt,omitempty"`
	RoofingPartnerAssignedAtNEQ    *time.Time  `json:"roofingPartnerAssignedAtNEQ,omitempty"`
	RoofingPartnerAssignedAtIn     []time.Time `json:"roofingPartnerAssignedAtIn,omitempty"`
	RoofingPartnerAssignedAtNotIn  []time.Time `json:"roofingPartnerAssignedAtNotIn,omitempty"`
	RoofingPartnerAssignedAtGT     *time.Time  `json:"roofingPartnerAssignedAtGT,omitempty"`
	RoofingPartnerAssignedAtGTE    *time.Time  `json:"roofingPartnerAssignedAtGTE,omitempty"`
	RoofingPartnerAssignedAtLT     *time.Time  `json:"roofingPartnerAssignedAtLT,omitempty"`
	RoofingPartnerAssignedAtLTE    *time.Time  `json:"roofingPartnerAssignedAtLTE,omitempty"`
	RoofingPartnerAssignedAtIsNil  bool        `json:"roofingPartnerAssignedAtIsNil,omitempty"`
	RoofingPartnerAssignedAtNotNil bool        `json:"roofingPartnerAssignedAtNotNil,omitempty"`

	// "roofing_partner_flag_at" field predicates.
	RoofingPartnerFlagAt       *time.Time  `json:"roofingPartnerFlagAt,omitempty"`
	RoofingPartnerFlagAtNEQ    *time.Time  `json:"roofingPartnerFlagAtNEQ,omitempty"`
	RoofingPartnerFlagAtIn     []time.Time `json:"roofingPartnerFlagAtIn,omitempty"`
	RoofingPartnerFlagAtNotIn  []time.Time `json:"roofingPartnerFlagAtNotIn,omitempty"`
	RoofingPartnerFlagAtGT     *time.Time  `json:"roofingPartnerFlagAtGT,omitempty"`
	RoofingPartnerFlagAtGTE    *time.Time  `json:"roofingPartnerFlagAtGTE,omitempty"`
	RoofingPartnerFlagAtLT     *time.Time  `json:"roofingPartnerFlagAtLT,omitempty"`
	RoofingPartnerFlagAtLTE    *time.Time  `json:"roofingPartnerFlagAtLTE,omitempty"`
	RoofingPartnerFlagAtIsNil  bool        `json:"roofingPartnerFlagAtIsNil,omitempty"`
	RoofingPartnerFlagAtNotNil bool        `json:"roofingPartnerFlagAtNotNil,omitempty"`

	// "payments" edge predicates.
	HasPayments     *bool                `json:"hasPayments,omitempty"`
	HasPaymentsWith []*PaymentWhereInput `json:"hasPaymentsWith,omitempty"`

	// "activities" edge predicates.
	HasActivities     *bool                    `json:"hasActivities,omitempty"`
	HasActivitiesWith []*JobActivityWhereInput `json:"hasActivitiesWith,omitempty"`

	// "assignment_history" edge predicates.
	HasAssignmentHistory     *bool                             `json:"hasAssignmentHistory,omitempty"`
	HasAssignmentHistoryWith []*JobAssignmentHistoryWhereInput `json:"hasAssignmentHistoryWith,omitempty"`

	// "progress_history" edge predicates.
	HasProgressHistory     *bool                           `json:"hasProgressHistory,omitempty"`
	HasProgressHistoryWith []*JobProgressHistoryWhereInput `json:"hasProgressHistoryWith,omitempty"`

	// "notes" edge predicates.
	HasNotes     *bool                `json:"hasNotes,omitempty"`
	HasNotesWith []*JobNoteWhereInput `json:"hasNotesWith,omitempty"`

	// "doc_urls" edge predicates.
	HasDocUrls     *bool                  `json:"hasDocUrls,omitempty"`
	HasDocUrlsWith []*JobDocURLWhereInput `json:"hasDocUrlsWith,omitempty"`

	// "estimate" edge predicates.
	HasEstimate     *bool                 `json:"hasEstimate,omitempty"`
	HasEstimateWith []*EstimateWhereInput `json:"hasEstimateWith,omitempty"`

	// "creator_api" edge predicates.
	HasCreatorAPI     *bool                `json:"hasCreatorAPI,omitempty"`
	HasCreatorAPIWith []*ApiUserWhereInput `json:"hasCreatorAPIWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "home_owner" edge predicates.
	HasHomeOwner     *bool                  `json:"hasHomeOwner,omitempty"`
	HasHomeOwnerWith []*HomeOwnerWhereInput `json:"hasHomeOwnerWith,omitempty"`

	// "sales_rep" edge predicates.
	HasSalesRep     *bool             `json:"hasSalesRep,omitempty"`
	HasSalesRepWith []*UserWhereInput `json:"hasSalesRepWith,omitempty"`

	// "requester" edge predicates.
	HasRequester     *bool                `json:"hasRequester,omitempty"`
	HasRequesterWith []*PartnerWhereInput `json:"hasRequesterWith,omitempty"`

	// "roofing_partner" edge predicates.
	HasRoofingPartner     *bool                `json:"hasRoofingPartner,omitempty"`
	HasRoofingPartnerWith []*PartnerWhereInput `json:"hasRoofingPartnerWith,omitempty"`

	// "integration_partner" edge predicates.
	HasIntegrationPartner     *bool                `json:"hasIntegrationPartner,omitempty"`
	HasIntegrationPartnerWith []*PartnerWhereInput `json:"hasIntegrationPartnerWith,omitempty"`

	// "epc_partner" edge predicates.
	HasEpcPartner     *bool                `json:"hasEpcPartner,omitempty"`
	HasEpcPartnerWith []*PartnerWhereInput `json:"hasEpcPartnerWith,omitempty"`

	// "epc" edge predicates.
	HasEpc     *bool                   `json:"hasEpc,omitempty"`
	HasEpcWith []*OptionListWhereInput `json:"hasEpcWith,omitempty"`

	// "estimate_pdf" edge predicates.
	HasEstimatePdf     *bool                 `json:"hasEstimatePdf,omitempty"`
	HasEstimatePdfWith []*DocumentWhereInput `json:"hasEstimatePdfWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobWhereInput) AddPredicates(predicates ...predicate.Job) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobWhereInput filter on the JobQuery builder.
func (i *JobWhereInput) Filter(q *JobQuery) (*JobQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobWhereInput is returned in case the JobWhereInput is empty.
var ErrEmptyJobWhereInput = errors.New("ent: empty predicate JobWhereInput")

// P returns a predicate for filtering jobs.
// An error is returned if the input is empty or invalid.
func (i *JobWhereInput) P() (predicate.Job, error) {
	var predicates []predicate.Job
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, job.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Job, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, job.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Job, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, job.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, job.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, job.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, job.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, job.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, job.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, job.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, job.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, job.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, job.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, job.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, job.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, job.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, job.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, job.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, job.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, job.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, job.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, job.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, job.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, job.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, job.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, job.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, job.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, job.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, job.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, job.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Progress != nil {
		predicates = append(predicates, job.ProgressEQ(*i.Progress))
	}
	if i.ProgressNEQ != nil {
		predicates = append(predicates, job.ProgressNEQ(*i.ProgressNEQ))
	}
	if len(i.ProgressIn) > 0 {
		predicates = append(predicates, job.ProgressIn(i.ProgressIn...))
	}
	if len(i.ProgressNotIn) > 0 {
		predicates = append(predicates, job.ProgressNotIn(i.ProgressNotIn...))
	}
	if i.ProgressIsNil {
		predicates = append(predicates, job.ProgressIsNil())
	}
	if i.ProgressNotNil {
		predicates = append(predicates, job.ProgressNotNil())
	}
	if i.ProgressAt != nil {
		predicates = append(predicates, job.ProgressAtEQ(*i.ProgressAt))
	}
	if i.ProgressAtNEQ != nil {
		predicates = append(predicates, job.ProgressAtNEQ(*i.ProgressAtNEQ))
	}
	if len(i.ProgressAtIn) > 0 {
		predicates = append(predicates, job.ProgressAtIn(i.ProgressAtIn...))
	}
	if len(i.ProgressAtNotIn) > 0 {
		predicates = append(predicates, job.ProgressAtNotIn(i.ProgressAtNotIn...))
	}
	if i.ProgressAtGT != nil {
		predicates = append(predicates, job.ProgressAtGT(*i.ProgressAtGT))
	}
	if i.ProgressAtGTE != nil {
		predicates = append(predicates, job.ProgressAtGTE(*i.ProgressAtGTE))
	}
	if i.ProgressAtLT != nil {
		predicates = append(predicates, job.ProgressAtLT(*i.ProgressAtLT))
	}
	if i.ProgressAtLTE != nil {
		predicates = append(predicates, job.ProgressAtLTE(*i.ProgressAtLTE))
	}
	if i.ProgressAtIsNil {
		predicates = append(predicates, job.ProgressAtIsNil())
	}
	if i.ProgressAtNotNil {
		predicates = append(predicates, job.ProgressAtNotNil())
	}
	if i.ProgressFlagAt != nil {
		predicates = append(predicates, job.ProgressFlagAtEQ(*i.ProgressFlagAt))
	}
	if i.ProgressFlagAtNEQ != nil {
		predicates = append(predicates, job.ProgressFlagAtNEQ(*i.ProgressFlagAtNEQ))
	}
	if len(i.ProgressFlagAtIn) > 0 {
		predicates = append(predicates, job.ProgressFlagAtIn(i.ProgressFlagAtIn...))
	}
	if len(i.ProgressFlagAtNotIn) > 0 {
		predicates = append(predicates, job.ProgressFlagAtNotIn(i.ProgressFlagAtNotIn...))
	}
	if i.ProgressFlagAtGT != nil {
		predicates = append(predicates, job.ProgressFlagAtGT(*i.ProgressFlagAtGT))
	}
	if i.ProgressFlagAtGTE != nil {
		predicates = append(predicates, job.ProgressFlagAtGTE(*i.ProgressFlagAtGTE))
	}
	if i.ProgressFlagAtLT != nil {
		predicates = append(predicates, job.ProgressFlagAtLT(*i.ProgressFlagAtLT))
	}
	if i.ProgressFlagAtLTE != nil {
		predicates = append(predicates, job.ProgressFlagAtLTE(*i.ProgressFlagAtLTE))
	}
	if i.ProgressFlagAtIsNil {
		predicates = append(predicates, job.ProgressFlagAtIsNil())
	}
	if i.ProgressFlagAtNotNil {
		predicates = append(predicates, job.ProgressFlagAtNotNil())
	}
	if i.RegionID != nil {
		predicates = append(predicates, job.RegionIDEQ(*i.RegionID))
	}
	if i.RegionIDNEQ != nil {
		predicates = append(predicates, job.RegionIDNEQ(*i.RegionIDNEQ))
	}
	if len(i.RegionIDIn) > 0 {
		predicates = append(predicates, job.RegionIDIn(i.RegionIDIn...))
	}
	if len(i.RegionIDNotIn) > 0 {
		predicates = append(predicates, job.RegionIDNotIn(i.RegionIDNotIn...))
	}
	if i.RegionIDGT != nil {
		predicates = append(predicates, job.RegionIDGT(*i.RegionIDGT))
	}
	if i.RegionIDGTE != nil {
		predicates = append(predicates, job.RegionIDGTE(*i.RegionIDGTE))
	}
	if i.RegionIDLT != nil {
		predicates = append(predicates, job.RegionIDLT(*i.RegionIDLT))
	}
	if i.RegionIDLTE != nil {
		predicates = append(predicates, job.RegionIDLTE(*i.RegionIDLTE))
	}
	if i.RegionIDIsNil {
		predicates = append(predicates, job.RegionIDIsNil())
	}
	if i.RegionIDNotNil {
		predicates = append(predicates, job.RegionIDNotNil())
	}
	if i.CompanyRefID != nil {
		predicates = append(predicates, job.CompanyRefIDEQ(*i.CompanyRefID))
	}
	if i.CompanyRefIDNEQ != nil {
		predicates = append(predicates, job.CompanyRefIDNEQ(*i.CompanyRefIDNEQ))
	}
	if len(i.CompanyRefIDIn) > 0 {
		predicates = append(predicates, job.CompanyRefIDIn(i.CompanyRefIDIn...))
	}
	if len(i.CompanyRefIDNotIn) > 0 {
		predicates = append(predicates, job.CompanyRefIDNotIn(i.CompanyRefIDNotIn...))
	}
	if i.CompanyRefIDGT != nil {
		predicates = append(predicates, job.CompanyRefIDGT(*i.CompanyRefIDGT))
	}
	if i.CompanyRefIDGTE != nil {
		predicates = append(predicates, job.CompanyRefIDGTE(*i.CompanyRefIDGTE))
	}
	if i.CompanyRefIDLT != nil {
		predicates = append(predicates, job.CompanyRefIDLT(*i.CompanyRefIDLT))
	}
	if i.CompanyRefIDLTE != nil {
		predicates = append(predicates, job.CompanyRefIDLTE(*i.CompanyRefIDLTE))
	}
	if i.CompanyRefIDContains != nil {
		predicates = append(predicates, job.CompanyRefIDContains(*i.CompanyRefIDContains))
	}
	if i.CompanyRefIDHasPrefix != nil {
		predicates = append(predicates, job.CompanyRefIDHasPrefix(*i.CompanyRefIDHasPrefix))
	}
	if i.CompanyRefIDHasSuffix != nil {
		predicates = append(predicates, job.CompanyRefIDHasSuffix(*i.CompanyRefIDHasSuffix))
	}
	if i.CompanyRefIDIsNil {
		predicates = append(predicates, job.CompanyRefIDIsNil())
	}
	if i.CompanyRefIDNotNil {
		predicates = append(predicates, job.CompanyRefIDNotNil())
	}
	if i.CompanyRefIDEqualFold != nil {
		predicates = append(predicates, job.CompanyRefIDEqualFold(*i.CompanyRefIDEqualFold))
	}
	if i.CompanyRefIDContainsFold != nil {
		predicates = append(predicates, job.CompanyRefIDContainsFold(*i.CompanyRefIDContainsFold))
	}
	if i.CompanyName != nil {
		predicates = append(predicates, job.CompanyNameEQ(*i.CompanyName))
	}
	if i.CompanyNameNEQ != nil {
		predicates = append(predicates, job.CompanyNameNEQ(*i.CompanyNameNEQ))
	}
	if len(i.CompanyNameIn) > 0 {
		predicates = append(predicates, job.CompanyNameIn(i.CompanyNameIn...))
	}
	if len(i.CompanyNameNotIn) > 0 {
		predicates = append(predicates, job.CompanyNameNotIn(i.CompanyNameNotIn...))
	}
	if i.CompanyNameGT != nil {
		predicates = append(predicates, job.CompanyNameGT(*i.CompanyNameGT))
	}
	if i.CompanyNameGTE != nil {
		predicates = append(predicates, job.CompanyNameGTE(*i.CompanyNameGTE))
	}
	if i.CompanyNameLT != nil {
		predicates = append(predicates, job.CompanyNameLT(*i.CompanyNameLT))
	}
	if i.CompanyNameLTE != nil {
		predicates = append(predicates, job.CompanyNameLTE(*i.CompanyNameLTE))
	}
	if i.CompanyNameContains != nil {
		predicates = append(predicates, job.CompanyNameContains(*i.CompanyNameContains))
	}
	if i.CompanyNameHasPrefix != nil {
		predicates = append(predicates, job.CompanyNameHasPrefix(*i.CompanyNameHasPrefix))
	}
	if i.CompanyNameHasSuffix != nil {
		predicates = append(predicates, job.CompanyNameHasSuffix(*i.CompanyNameHasSuffix))
	}
	if i.CompanyNameIsNil {
		predicates = append(predicates, job.CompanyNameIsNil())
	}
	if i.CompanyNameNotNil {
		predicates = append(predicates, job.CompanyNameNotNil())
	}
	if i.CompanyNameEqualFold != nil {
		predicates = append(predicates, job.CompanyNameEqualFold(*i.CompanyNameEqualFold))
	}
	if i.CompanyNameContainsFold != nil {
		predicates = append(predicates, job.CompanyNameContainsFold(*i.CompanyNameContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, job.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, job.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, job.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, job.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, job.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, job.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, job.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, job.PriceLTE(*i.PriceLTE))
	}
	if i.WorkOrderPrice != nil {
		predicates = append(predicates, job.WorkOrderPriceEQ(*i.WorkOrderPrice))
	}
	if i.WorkOrderPriceNEQ != nil {
		predicates = append(predicates, job.WorkOrderPriceNEQ(*i.WorkOrderPriceNEQ))
	}
	if len(i.WorkOrderPriceIn) > 0 {
		predicates = append(predicates, job.WorkOrderPriceIn(i.WorkOrderPriceIn...))
	}
	if len(i.WorkOrderPriceNotIn) > 0 {
		predicates = append(predicates, job.WorkOrderPriceNotIn(i.WorkOrderPriceNotIn...))
	}
	if i.WorkOrderPriceGT != nil {
		predicates = append(predicates, job.WorkOrderPriceGT(*i.WorkOrderPriceGT))
	}
	if i.WorkOrderPriceGTE != nil {
		predicates = append(predicates, job.WorkOrderPriceGTE(*i.WorkOrderPriceGTE))
	}
	if i.WorkOrderPriceLT != nil {
		predicates = append(predicates, job.WorkOrderPriceLT(*i.WorkOrderPriceLT))
	}
	if i.WorkOrderPriceLTE != nil {
		predicates = append(predicates, job.WorkOrderPriceLTE(*i.WorkOrderPriceLTE))
	}
	if i.ContractPrice != nil {
		predicates = append(predicates, job.ContractPriceEQ(*i.ContractPrice))
	}
	if i.ContractPriceNEQ != nil {
		predicates = append(predicates, job.ContractPriceNEQ(*i.ContractPriceNEQ))
	}
	if len(i.ContractPriceIn) > 0 {
		predicates = append(predicates, job.ContractPriceIn(i.ContractPriceIn...))
	}
	if len(i.ContractPriceNotIn) > 0 {
		predicates = append(predicates, job.ContractPriceNotIn(i.ContractPriceNotIn...))
	}
	if i.ContractPriceGT != nil {
		predicates = append(predicates, job.ContractPriceGT(*i.ContractPriceGT))
	}
	if i.ContractPriceGTE != nil {
		predicates = append(predicates, job.ContractPriceGTE(*i.ContractPriceGTE))
	}
	if i.ContractPriceLT != nil {
		predicates = append(predicates, job.ContractPriceLT(*i.ContractPriceLT))
	}
	if i.ContractPriceLTE != nil {
		predicates = append(predicates, job.ContractPriceLTE(*i.ContractPriceLTE))
	}
	if i.ContractPriceIsNil {
		predicates = append(predicates, job.ContractPriceIsNil())
	}
	if i.ContractPriceNotNil {
		predicates = append(predicates, job.ContractPriceNotNil())
	}
	if i.ChangeOrderPrice != nil {
		predicates = append(predicates, job.ChangeOrderPriceEQ(*i.ChangeOrderPrice))
	}
	if i.ChangeOrderPriceNEQ != nil {
		predicates = append(predicates, job.ChangeOrderPriceNEQ(*i.ChangeOrderPriceNEQ))
	}
	if len(i.ChangeOrderPriceIn) > 0 {
		predicates = append(predicates, job.ChangeOrderPriceIn(i.ChangeOrderPriceIn...))
	}
	if len(i.ChangeOrderPriceNotIn) > 0 {
		predicates = append(predicates, job.ChangeOrderPriceNotIn(i.ChangeOrderPriceNotIn...))
	}
	if i.ChangeOrderPriceGT != nil {
		predicates = append(predicates, job.ChangeOrderPriceGT(*i.ChangeOrderPriceGT))
	}
	if i.ChangeOrderPriceGTE != nil {
		predicates = append(predicates, job.ChangeOrderPriceGTE(*i.ChangeOrderPriceGTE))
	}
	if i.ChangeOrderPriceLT != nil {
		predicates = append(predicates, job.ChangeOrderPriceLT(*i.ChangeOrderPriceLT))
	}
	if i.ChangeOrderPriceLTE != nil {
		predicates = append(predicates, job.ChangeOrderPriceLTE(*i.ChangeOrderPriceLTE))
	}
	if i.ChangeOrderPriceIsNil {
		predicates = append(predicates, job.ChangeOrderPriceIsNil())
	}
	if i.ChangeOrderPriceNotNil {
		predicates = append(predicates, job.ChangeOrderPriceNotNil())
	}
	if i.Note != nil {
		predicates = append(predicates, job.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, job.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, job.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, job.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, job.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, job.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, job.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, job.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, job.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, job.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, job.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, job.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, job.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, job.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, job.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.ShingleColor != nil {
		predicates = append(predicates, job.ShingleColorEQ(*i.ShingleColor))
	}
	if i.ShingleColorNEQ != nil {
		predicates = append(predicates, job.ShingleColorNEQ(*i.ShingleColorNEQ))
	}
	if len(i.ShingleColorIn) > 0 {
		predicates = append(predicates, job.ShingleColorIn(i.ShingleColorIn...))
	}
	if len(i.ShingleColorNotIn) > 0 {
		predicates = append(predicates, job.ShingleColorNotIn(i.ShingleColorNotIn...))
	}
	if i.ShingleColorGT != nil {
		predicates = append(predicates, job.ShingleColorGT(*i.ShingleColorGT))
	}
	if i.ShingleColorGTE != nil {
		predicates = append(predicates, job.ShingleColorGTE(*i.ShingleColorGTE))
	}
	if i.ShingleColorLT != nil {
		predicates = append(predicates, job.ShingleColorLT(*i.ShingleColorLT))
	}
	if i.ShingleColorLTE != nil {
		predicates = append(predicates, job.ShingleColorLTE(*i.ShingleColorLTE))
	}
	if i.ShingleColorContains != nil {
		predicates = append(predicates, job.ShingleColorContains(*i.ShingleColorContains))
	}
	if i.ShingleColorHasPrefix != nil {
		predicates = append(predicates, job.ShingleColorHasPrefix(*i.ShingleColorHasPrefix))
	}
	if i.ShingleColorHasSuffix != nil {
		predicates = append(predicates, job.ShingleColorHasSuffix(*i.ShingleColorHasSuffix))
	}
	if i.ShingleColorIsNil {
		predicates = append(predicates, job.ShingleColorIsNil())
	}
	if i.ShingleColorNotNil {
		predicates = append(predicates, job.ShingleColorNotNil())
	}
	if i.ShingleColorEqualFold != nil {
		predicates = append(predicates, job.ShingleColorEqualFold(*i.ShingleColorEqualFold))
	}
	if i.ShingleColorContainsFold != nil {
		predicates = append(predicates, job.ShingleColorContainsFold(*i.ShingleColorContainsFold))
	}
	if i.PermitRequired != nil {
		predicates = append(predicates, job.PermitRequiredEQ(*i.PermitRequired))
	}
	if i.PermitRequiredNEQ != nil {
		predicates = append(predicates, job.PermitRequiredNEQ(*i.PermitRequiredNEQ))
	}
	if i.PermitRequiredIsNil {
		predicates = append(predicates, job.PermitRequiredIsNil())
	}
	if i.PermitRequiredNotNil {
		predicates = append(predicates, job.PermitRequiredNotNil())
	}
	if i.InspectionRequired != nil {
		predicates = append(predicates, job.InspectionRequiredEQ(*i.InspectionRequired))
	}
	if i.InspectionRequiredNEQ != nil {
		predicates = append(predicates, job.InspectionRequiredNEQ(*i.InspectionRequiredNEQ))
	}
	if i.InspectionRequiredIsNil {
		predicates = append(predicates, job.InspectionRequiredIsNil())
	}
	if i.InspectionRequiredNotNil {
		predicates = append(predicates, job.InspectionRequiredNotNil())
	}
	if i.InspectionDate != nil {
		predicates = append(predicates, job.InspectionDateEQ(*i.InspectionDate))
	}
	if i.InspectionDateNEQ != nil {
		predicates = append(predicates, job.InspectionDateNEQ(*i.InspectionDateNEQ))
	}
	if len(i.InspectionDateIn) > 0 {
		predicates = append(predicates, job.InspectionDateIn(i.InspectionDateIn...))
	}
	if len(i.InspectionDateNotIn) > 0 {
		predicates = append(predicates, job.InspectionDateNotIn(i.InspectionDateNotIn...))
	}
	if i.InspectionDateGT != nil {
		predicates = append(predicates, job.InspectionDateGT(*i.InspectionDateGT))
	}
	if i.InspectionDateGTE != nil {
		predicates = append(predicates, job.InspectionDateGTE(*i.InspectionDateGTE))
	}
	if i.InspectionDateLT != nil {
		predicates = append(predicates, job.InspectionDateLT(*i.InspectionDateLT))
	}
	if i.InspectionDateLTE != nil {
		predicates = append(predicates, job.InspectionDateLTE(*i.InspectionDateLTE))
	}
	if i.InspectionDateIsNil {
		predicates = append(predicates, job.InspectionDateIsNil())
	}
	if i.InspectionDateNotNil {
		predicates = append(predicates, job.InspectionDateNotNil())
	}
	if i.ProgressInspectionDate != nil {
		predicates = append(predicates, job.ProgressInspectionDateEQ(*i.ProgressInspectionDate))
	}
	if i.ProgressInspectionDateNEQ != nil {
		predicates = append(predicates, job.ProgressInspectionDateNEQ(*i.ProgressInspectionDateNEQ))
	}
	if len(i.ProgressInspectionDateIn) > 0 {
		predicates = append(predicates, job.ProgressInspectionDateIn(i.ProgressInspectionDateIn...))
	}
	if len(i.ProgressInspectionDateNotIn) > 0 {
		predicates = append(predicates, job.ProgressInspectionDateNotIn(i.ProgressInspectionDateNotIn...))
	}
	if i.ProgressInspectionDateGT != nil {
		predicates = append(predicates, job.ProgressInspectionDateGT(*i.ProgressInspectionDateGT))
	}
	if i.ProgressInspectionDateGTE != nil {
		predicates = append(predicates, job.ProgressInspectionDateGTE(*i.ProgressInspectionDateGTE))
	}
	if i.ProgressInspectionDateLT != nil {
		predicates = append(predicates, job.ProgressInspectionDateLT(*i.ProgressInspectionDateLT))
	}
	if i.ProgressInspectionDateLTE != nil {
		predicates = append(predicates, job.ProgressInspectionDateLTE(*i.ProgressInspectionDateLTE))
	}
	if i.ProgressInspectionDateIsNil {
		predicates = append(predicates, job.ProgressInspectionDateIsNil())
	}
	if i.ProgressInspectionDateNotNil {
		predicates = append(predicates, job.ProgressInspectionDateNotNil())
	}
	if i.InstallDate != nil {
		predicates = append(predicates, job.InstallDateEQ(*i.InstallDate))
	}
	if i.InstallDateNEQ != nil {
		predicates = append(predicates, job.InstallDateNEQ(*i.InstallDateNEQ))
	}
	if len(i.InstallDateIn) > 0 {
		predicates = append(predicates, job.InstallDateIn(i.InstallDateIn...))
	}
	if len(i.InstallDateNotIn) > 0 {
		predicates = append(predicates, job.InstallDateNotIn(i.InstallDateNotIn...))
	}
	if i.InstallDateGT != nil {
		predicates = append(predicates, job.InstallDateGT(*i.InstallDateGT))
	}
	if i.InstallDateGTE != nil {
		predicates = append(predicates, job.InstallDateGTE(*i.InstallDateGTE))
	}
	if i.InstallDateLT != nil {
		predicates = append(predicates, job.InstallDateLT(*i.InstallDateLT))
	}
	if i.InstallDateLTE != nil {
		predicates = append(predicates, job.InstallDateLTE(*i.InstallDateLTE))
	}
	if i.InstallDateIsNil {
		predicates = append(predicates, job.InstallDateIsNil())
	}
	if i.InstallDateNotNil {
		predicates = append(predicates, job.InstallDateNotNil())
	}
	if i.CompletionDate != nil {
		predicates = append(predicates, job.CompletionDateEQ(*i.CompletionDate))
	}
	if i.CompletionDateNEQ != nil {
		predicates = append(predicates, job.CompletionDateNEQ(*i.CompletionDateNEQ))
	}
	if len(i.CompletionDateIn) > 0 {
		predicates = append(predicates, job.CompletionDateIn(i.CompletionDateIn...))
	}
	if len(i.CompletionDateNotIn) > 0 {
		predicates = append(predicates, job.CompletionDateNotIn(i.CompletionDateNotIn...))
	}
	if i.CompletionDateGT != nil {
		predicates = append(predicates, job.CompletionDateGT(*i.CompletionDateGT))
	}
	if i.CompletionDateGTE != nil {
		predicates = append(predicates, job.CompletionDateGTE(*i.CompletionDateGTE))
	}
	if i.CompletionDateLT != nil {
		predicates = append(predicates, job.CompletionDateLT(*i.CompletionDateLT))
	}
	if i.CompletionDateLTE != nil {
		predicates = append(predicates, job.CompletionDateLTE(*i.CompletionDateLTE))
	}
	if i.CompletionDateIsNil {
		predicates = append(predicates, job.CompletionDateIsNil())
	}
	if i.CompletionDateNotNil {
		predicates = append(predicates, job.CompletionDateNotNil())
	}
	if i.MaterialDeliveryDate != nil {
		predicates = append(predicates, job.MaterialDeliveryDateEQ(*i.MaterialDeliveryDate))
	}
	if i.MaterialDeliveryDateNEQ != nil {
		predicates = append(predicates, job.MaterialDeliveryDateNEQ(*i.MaterialDeliveryDateNEQ))
	}
	if len(i.MaterialDeliveryDateIn) > 0 {
		predicates = append(predicates, job.MaterialDeliveryDateIn(i.MaterialDeliveryDateIn...))
	}
	if len(i.MaterialDeliveryDateNotIn) > 0 {
		predicates = append(predicates, job.MaterialDeliveryDateNotIn(i.MaterialDeliveryDateNotIn...))
	}
	if i.MaterialDeliveryDateGT != nil {
		predicates = append(predicates, job.MaterialDeliveryDateGT(*i.MaterialDeliveryDateGT))
	}
	if i.MaterialDeliveryDateGTE != nil {
		predicates = append(predicates, job.MaterialDeliveryDateGTE(*i.MaterialDeliveryDateGTE))
	}
	if i.MaterialDeliveryDateLT != nil {
		predicates = append(predicates, job.MaterialDeliveryDateLT(*i.MaterialDeliveryDateLT))
	}
	if i.MaterialDeliveryDateLTE != nil {
		predicates = append(predicates, job.MaterialDeliveryDateLTE(*i.MaterialDeliveryDateLTE))
	}
	if i.MaterialDeliveryDateIsNil {
		predicates = append(predicates, job.MaterialDeliveryDateIsNil())
	}
	if i.MaterialDeliveryDateNotNil {
		predicates = append(predicates, job.MaterialDeliveryDateNotNil())
	}
	if i.Agree != nil {
		predicates = append(predicates, job.AgreeEQ(*i.Agree))
	}
	if i.AgreeNEQ != nil {
		predicates = append(predicates, job.AgreeNEQ(*i.AgreeNEQ))
	}
	if i.AgreeIsNil {
		predicates = append(predicates, job.AgreeIsNil())
	}
	if i.AgreeNotNil {
		predicates = append(predicates, job.AgreeNotNil())
	}
	if i.AgreeAt != nil {
		predicates = append(predicates, job.AgreeAtEQ(*i.AgreeAt))
	}
	if i.AgreeAtNEQ != nil {
		predicates = append(predicates, job.AgreeAtNEQ(*i.AgreeAtNEQ))
	}
	if len(i.AgreeAtIn) > 0 {
		predicates = append(predicates, job.AgreeAtIn(i.AgreeAtIn...))
	}
	if len(i.AgreeAtNotIn) > 0 {
		predicates = append(predicates, job.AgreeAtNotIn(i.AgreeAtNotIn...))
	}
	if i.AgreeAtGT != nil {
		predicates = append(predicates, job.AgreeAtGT(*i.AgreeAtGT))
	}
	if i.AgreeAtGTE != nil {
		predicates = append(predicates, job.AgreeAtGTE(*i.AgreeAtGTE))
	}
	if i.AgreeAtLT != nil {
		predicates = append(predicates, job.AgreeAtLT(*i.AgreeAtLT))
	}
	if i.AgreeAtLTE != nil {
		predicates = append(predicates, job.AgreeAtLTE(*i.AgreeAtLTE))
	}
	if i.AgreeAtIsNil {
		predicates = append(predicates, job.AgreeAtIsNil())
	}
	if i.AgreeAtNotNil {
		predicates = append(predicates, job.AgreeAtNotNil())
	}
	if i.PoNumber != nil {
		predicates = append(predicates, job.PoNumberEQ(*i.PoNumber))
	}
	if i.PoNumberNEQ != nil {
		predicates = append(predicates, job.PoNumberNEQ(*i.PoNumberNEQ))
	}
	if len(i.PoNumberIn) > 0 {
		predicates = append(predicates, job.PoNumberIn(i.PoNumberIn...))
	}
	if len(i.PoNumberNotIn) > 0 {
		predicates = append(predicates, job.PoNumberNotIn(i.PoNumberNotIn...))
	}
	if i.PoNumberGT != nil {
		predicates = append(predicates, job.PoNumberGT(*i.PoNumberGT))
	}
	if i.PoNumberGTE != nil {
		predicates = append(predicates, job.PoNumberGTE(*i.PoNumberGTE))
	}
	if i.PoNumberLT != nil {
		predicates = append(predicates, job.PoNumberLT(*i.PoNumberLT))
	}
	if i.PoNumberLTE != nil {
		predicates = append(predicates, job.PoNumberLTE(*i.PoNumberLTE))
	}
	if i.PoNumberContains != nil {
		predicates = append(predicates, job.PoNumberContains(*i.PoNumberContains))
	}
	if i.PoNumberHasPrefix != nil {
		predicates = append(predicates, job.PoNumberHasPrefix(*i.PoNumberHasPrefix))
	}
	if i.PoNumberHasSuffix != nil {
		predicates = append(predicates, job.PoNumberHasSuffix(*i.PoNumberHasSuffix))
	}
	if i.PoNumberIsNil {
		predicates = append(predicates, job.PoNumberIsNil())
	}
	if i.PoNumberNotNil {
		predicates = append(predicates, job.PoNumberNotNil())
	}
	if i.PoNumberEqualFold != nil {
		predicates = append(predicates, job.PoNumberEqualFold(*i.PoNumberEqualFold))
	}
	if i.PoNumberContainsFold != nil {
		predicates = append(predicates, job.PoNumberContainsFold(*i.PoNumberContainsFold))
	}
	if i.RoofingPartnerAssignedAt != nil {
		predicates = append(predicates, job.RoofingPartnerAssignedAtEQ(*i.RoofingPartnerAssignedAt))
	}
	if i.RoofingPartnerAssignedAtNEQ != nil {
		predicates = append(predicates, job.RoofingPartnerAssignedAtNEQ(*i.RoofingPartnerAssignedAtNEQ))
	}
	if len(i.RoofingPartnerAssignedAtIn) > 0 {
		predicates = append(predicates, job.RoofingPartnerAssignedAtIn(i.RoofingPartnerAssignedAtIn...))
	}
	if len(i.RoofingPartnerAssignedAtNotIn) > 0 {
		predicates = append(predicates, job.RoofingPartnerAssignedAtNotIn(i.RoofingPartnerAssignedAtNotIn...))
	}
	if i.RoofingPartnerAssignedAtGT != nil {
		predicates = append(predicates, job.RoofingPartnerAssignedAtGT(*i.RoofingPartnerAssignedAtGT))
	}
	if i.RoofingPartnerAssignedAtGTE != nil {
		predicates = append(predicates, job.RoofingPartnerAssignedAtGTE(*i.RoofingPartnerAssignedAtGTE))
	}
	if i.RoofingPartnerAssignedAtLT != nil {
		predicates = append(predicates, job.RoofingPartnerAssignedAtLT(*i.RoofingPartnerAssignedAtLT))
	}
	if i.RoofingPartnerAssignedAtLTE != nil {
		predicates = append(predicates, job.RoofingPartnerAssignedAtLTE(*i.RoofingPartnerAssignedAtLTE))
	}
	if i.RoofingPartnerAssignedAtIsNil {
		predicates = append(predicates, job.RoofingPartnerAssignedAtIsNil())
	}
	if i.RoofingPartnerAssignedAtNotNil {
		predicates = append(predicates, job.RoofingPartnerAssignedAtNotNil())
	}
	if i.RoofingPartnerFlagAt != nil {
		predicates = append(predicates, job.RoofingPartnerFlagAtEQ(*i.RoofingPartnerFlagAt))
	}
	if i.RoofingPartnerFlagAtNEQ != nil {
		predicates = append(predicates, job.RoofingPartnerFlagAtNEQ(*i.RoofingPartnerFlagAtNEQ))
	}
	if len(i.RoofingPartnerFlagAtIn) > 0 {
		predicates = append(predicates, job.RoofingPartnerFlagAtIn(i.RoofingPartnerFlagAtIn...))
	}
	if len(i.RoofingPartnerFlagAtNotIn) > 0 {
		predicates = append(predicates, job.RoofingPartnerFlagAtNotIn(i.RoofingPartnerFlagAtNotIn...))
	}
	if i.RoofingPartnerFlagAtGT != nil {
		predicates = append(predicates, job.RoofingPartnerFlagAtGT(*i.RoofingPartnerFlagAtGT))
	}
	if i.RoofingPartnerFlagAtGTE != nil {
		predicates = append(predicates, job.RoofingPartnerFlagAtGTE(*i.RoofingPartnerFlagAtGTE))
	}
	if i.RoofingPartnerFlagAtLT != nil {
		predicates = append(predicates, job.RoofingPartnerFlagAtLT(*i.RoofingPartnerFlagAtLT))
	}
	if i.RoofingPartnerFlagAtLTE != nil {
		predicates = append(predicates, job.RoofingPartnerFlagAtLTE(*i.RoofingPartnerFlagAtLTE))
	}
	if i.RoofingPartnerFlagAtIsNil {
		predicates = append(predicates, job.RoofingPartnerFlagAtIsNil())
	}
	if i.RoofingPartnerFlagAtNotNil {
		predicates = append(predicates, job.RoofingPartnerFlagAtNotNil())
	}

	if i.HasPayments != nil {
		p := job.HasPayments()
		if !*i.HasPayments {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPaymentsWith) > 0 {
		with := make([]predicate.Payment, 0, len(i.HasPaymentsWith))
		for _, w := range i.HasPaymentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPaymentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasPaymentsWith(with...))
	}
	if i.HasActivities != nil {
		p := job.HasActivities()
		if !*i.HasActivities {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActivitiesWith) > 0 {
		with := make([]predicate.JobActivity, 0, len(i.HasActivitiesWith))
		for _, w := range i.HasActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasActivitiesWith(with...))
	}
	if i.HasAssignmentHistory != nil {
		p := job.HasAssignmentHistory()
		if !*i.HasAssignmentHistory {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignmentHistoryWith) > 0 {
		with := make([]predicate.JobAssignmentHistory, 0, len(i.HasAssignmentHistoryWith))
		for _, w := range i.HasAssignmentHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignmentHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasAssignmentHistoryWith(with...))
	}
	if i.HasProgressHistory != nil {
		p := job.HasProgressHistory()
		if !*i.HasProgressHistory {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgressHistoryWith) > 0 {
		with := make([]predicate.JobProgressHistory, 0, len(i.HasProgressHistoryWith))
		for _, w := range i.HasProgressHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgressHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasProgressHistoryWith(with...))
	}
	if i.HasNotes != nil {
		p := job.HasNotes()
		if !*i.HasNotes {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotesWith) > 0 {
		with := make([]predicate.JobNote, 0, len(i.HasNotesWith))
		for _, w := range i.HasNotesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasNotesWith(with...))
	}
	if i.HasDocUrls != nil {
		p := job.HasDocUrls()
		if !*i.HasDocUrls {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocUrlsWith) > 0 {
		with := make([]predicate.JobDocURL, 0, len(i.HasDocUrlsWith))
		for _, w := range i.HasDocUrlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocUrlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasDocUrlsWith(with...))
	}
	if i.HasEstimate != nil {
		p := job.HasEstimate()
		if !*i.HasEstimate {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEstimateWith) > 0 {
		with := make([]predicate.Estimate, 0, len(i.HasEstimateWith))
		for _, w := range i.HasEstimateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEstimateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasEstimateWith(with...))
	}
	if i.HasCreatorAPI != nil {
		p := job.HasCreatorAPI()
		if !*i.HasCreatorAPI {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorAPIWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasCreatorAPIWith))
		for _, w := range i.HasCreatorAPIWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorAPIWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasCreatorAPIWith(with...))
	}
	if i.HasCreator != nil {
		p := job.HasCreator()
		if !*i.HasCreator {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasCreatorWith(with...))
	}
	if i.HasHomeOwner != nil {
		p := job.HasHomeOwner()
		if !*i.HasHomeOwner {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHomeOwnerWith) > 0 {
		with := make([]predicate.HomeOwner, 0, len(i.HasHomeOwnerWith))
		for _, w := range i.HasHomeOwnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHomeOwnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasHomeOwnerWith(with...))
	}
	if i.HasSalesRep != nil {
		p := job.HasSalesRep()
		if !*i.HasSalesRep {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSalesRepWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasSalesRepWith))
		for _, w := range i.HasSalesRepWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSalesRepWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasSalesRepWith(with...))
	}
	if i.HasRequester != nil {
		p := job.HasRequester()
		if !*i.HasRequester {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequesterWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasRequesterWith))
		for _, w := range i.HasRequesterWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequesterWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasRequesterWith(with...))
	}
	if i.HasRoofingPartner != nil {
		p := job.HasRoofingPartner()
		if !*i.HasRoofingPartner {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoofingPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasRoofingPartnerWith))
		for _, w := range i.HasRoofingPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoofingPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasRoofingPartnerWith(with...))
	}
	if i.HasIntegrationPartner != nil {
		p := job.HasIntegrationPartner()
		if !*i.HasIntegrationPartner {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIntegrationPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasIntegrationPartnerWith))
		for _, w := range i.HasIntegrationPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIntegrationPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasIntegrationPartnerWith(with...))
	}
	if i.HasEpcPartner != nil {
		p := job.HasEpcPartner()
		if !*i.HasEpcPartner {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpcPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasEpcPartnerWith))
		for _, w := range i.HasEpcPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpcPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasEpcPartnerWith(with...))
	}
	if i.HasEpc != nil {
		p := job.HasEpc()
		if !*i.HasEpc {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpcWith) > 0 {
		with := make([]predicate.OptionList, 0, len(i.HasEpcWith))
		for _, w := range i.HasEpcWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpcWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasEpcWith(with...))
	}
	if i.HasEstimatePdf != nil {
		p := job.HasEstimatePdf()
		if !*i.HasEstimatePdf {
			p = job.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEstimatePdfWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasEstimatePdfWith))
		for _, w := range i.HasEstimatePdfWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEstimatePdfWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, job.HasEstimatePdfWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobWhereInput
	case 1:
		return predicates[0], nil
	default:
		return job.And(predicates...), nil
	}
}

// JobActivityWhereInput represents a where input for filtering JobActivity queries.
type JobActivityWhereInput struct {
	Predicates []predicate.JobActivity  `json:"-"`
	Not        *JobActivityWhereInput   `json:"not,omitempty"`
	Or         []*JobActivityWhereInput `json:"or,omitempty"`
	And        []*JobActivityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "job" edge predicates.
	HasJob     *bool            `json:"hasJob,omitempty"`
	HasJobWith []*JobWhereInput `json:"hasJobWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "creator_api" edge predicates.
	HasCreatorAPI     *bool                `json:"hasCreatorAPI,omitempty"`
	HasCreatorAPIWith []*ApiUserWhereInput `json:"hasCreatorAPIWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobActivityWhereInput) AddPredicates(predicates ...predicate.JobActivity) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobActivityWhereInput filter on the JobActivityQuery builder.
func (i *JobActivityWhereInput) Filter(q *JobActivityQuery) (*JobActivityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobActivityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobActivityWhereInput is returned in case the JobActivityWhereInput is empty.
var ErrEmptyJobActivityWhereInput = errors.New("ent: empty predicate JobActivityWhereInput")

// P returns a predicate for filtering jobactivities.
// An error is returned if the input is empty or invalid.
func (i *JobActivityWhereInput) P() (predicate.JobActivity, error) {
	var predicates []predicate.JobActivity
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, jobactivity.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobActivity, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobactivity.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobActivity, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobactivity.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, jobactivity.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobactivity.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobactivity.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobactivity.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobactivity.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobactivity.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobactivity.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobactivity.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, jobactivity.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, jobactivity.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, jobactivity.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, jobactivity.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, jobactivity.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, jobactivity.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, jobactivity.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, jobactivity.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, jobactivity.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, jobactivity.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, jobactivity.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, jobactivity.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, jobactivity.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, jobactivity.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, jobactivity.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, jobactivity.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, jobactivity.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, jobactivity.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, jobactivity.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, jobactivity.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, jobactivity.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, jobactivity.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, jobactivity.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasJob != nil {
		p := jobactivity.HasJob()
		if !*i.HasJob {
			p = jobactivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobWith))
		for _, w := range i.HasJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobactivity.HasJobWith(with...))
	}
	if i.HasCreator != nil {
		p := jobactivity.HasCreator()
		if !*i.HasCreator {
			p = jobactivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobactivity.HasCreatorWith(with...))
	}
	if i.HasCreatorAPI != nil {
		p := jobactivity.HasCreatorAPI()
		if !*i.HasCreatorAPI {
			p = jobactivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorAPIWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasCreatorAPIWith))
		for _, w := range i.HasCreatorAPIWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorAPIWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobactivity.HasCreatorAPIWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobActivityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return jobactivity.And(predicates...), nil
	}
}

// JobAssignmentHistoryWhereInput represents a where input for filtering JobAssignmentHistory queries.
type JobAssignmentHistoryWhereInput struct {
	Predicates []predicate.JobAssignmentHistory  `json:"-"`
	Not        *JobAssignmentHistoryWhereInput   `json:"not,omitempty"`
	Or         []*JobAssignmentHistoryWhereInput `json:"or,omitempty"`
	And        []*JobAssignmentHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "status" field predicates.
	Status      *enum.JobAssignmentStatus  `json:"status,omitempty"`
	StatusNEQ   *enum.JobAssignmentStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enum.JobAssignmentStatus `json:"statusIn,omitempty"`
	StatusNotIn []enum.JobAssignmentStatus `json:"statusNotIn,omitempty"`

	// "Note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "job" edge predicates.
	HasJob     *bool            `json:"hasJob,omitempty"`
	HasJobWith []*JobWhereInput `json:"hasJobWith,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobAssignmentHistoryWhereInput) AddPredicates(predicates ...predicate.JobAssignmentHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobAssignmentHistoryWhereInput filter on the JobAssignmentHistoryQuery builder.
func (i *JobAssignmentHistoryWhereInput) Filter(q *JobAssignmentHistoryQuery) (*JobAssignmentHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobAssignmentHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobAssignmentHistoryWhereInput is returned in case the JobAssignmentHistoryWhereInput is empty.
var ErrEmptyJobAssignmentHistoryWhereInput = errors.New("ent: empty predicate JobAssignmentHistoryWhereInput")

// P returns a predicate for filtering jobassignmenthistories.
// An error is returned if the input is empty or invalid.
func (i *JobAssignmentHistoryWhereInput) P() (predicate.JobAssignmentHistory, error) {
	var predicates []predicate.JobAssignmentHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, jobassignmenthistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobAssignmentHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobassignmenthistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobAssignmentHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobassignmenthistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, jobassignmenthistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobassignmenthistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobassignmenthistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobassignmenthistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobassignmenthistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobassignmenthistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobassignmenthistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobassignmenthistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, jobassignmenthistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, jobassignmenthistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, jobassignmenthistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, jobassignmenthistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, jobassignmenthistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, jobassignmenthistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, jobassignmenthistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, jobassignmenthistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, jobassignmenthistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, jobassignmenthistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, jobassignmenthistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, jobassignmenthistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, jobassignmenthistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, jobassignmenthistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.Note != nil {
		predicates = append(predicates, jobassignmenthistory.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, jobassignmenthistory.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, jobassignmenthistory.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, jobassignmenthistory.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, jobassignmenthistory.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, jobassignmenthistory.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, jobassignmenthistory.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, jobassignmenthistory.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, jobassignmenthistory.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, jobassignmenthistory.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, jobassignmenthistory.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, jobassignmenthistory.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, jobassignmenthistory.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, jobassignmenthistory.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, jobassignmenthistory.NoteContainsFold(*i.NoteContainsFold))
	}

	if i.HasJob != nil {
		p := jobassignmenthistory.HasJob()
		if !*i.HasJob {
			p = jobassignmenthistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobWith))
		for _, w := range i.HasJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobassignmenthistory.HasJobWith(with...))
	}
	if i.HasPartner != nil {
		p := jobassignmenthistory.HasPartner()
		if !*i.HasPartner {
			p = jobassignmenthistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobassignmenthistory.HasPartnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobAssignmentHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return jobassignmenthistory.And(predicates...), nil
	}
}

// JobDocURLWhereInput represents a where input for filtering JobDocURL queries.
type JobDocURLWhereInput struct {
	Predicates []predicate.JobDocURL  `json:"-"`
	Not        *JobDocURLWhereInput   `json:"not,omitempty"`
	Or         []*JobDocURLWhereInput `json:"or,omitempty"`
	And        []*JobDocURLWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "type" field predicates.
	Type      *enum.JobDocUrlType  `json:"type,omitempty"`
	TypeNEQ   *enum.JobDocUrlType  `json:"typeNEQ,omitempty"`
	TypeIn    []enum.JobDocUrlType `json:"typeIn,omitempty"`
	TypeNotIn []enum.JobDocUrlType `json:"typeNotIn,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "job" edge predicates.
	HasJob     *bool            `json:"hasJob,omitempty"`
	HasJobWith []*JobWhereInput `json:"hasJobWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobDocURLWhereInput) AddPredicates(predicates ...predicate.JobDocURL) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobDocURLWhereInput filter on the JobDocURLQuery builder.
func (i *JobDocURLWhereInput) Filter(q *JobDocURLQuery) (*JobDocURLQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobDocURLWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobDocURLWhereInput is returned in case the JobDocURLWhereInput is empty.
var ErrEmptyJobDocURLWhereInput = errors.New("ent: empty predicate JobDocURLWhereInput")

// P returns a predicate for filtering jobdocurls.
// An error is returned if the input is empty or invalid.
func (i *JobDocURLWhereInput) P() (predicate.JobDocURL, error) {
	var predicates []predicate.JobDocURL
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, jobdocurl.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobDocURL, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobdocurl.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobDocURL, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobdocurl.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, jobdocurl.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobdocurl.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobdocurl.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobdocurl.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobdocurl.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobdocurl.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobdocurl.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobdocurl.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, jobdocurl.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, jobdocurl.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, jobdocurl.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, jobdocurl.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, jobdocurl.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, jobdocurl.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, jobdocurl.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, jobdocurl.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, jobdocurl.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, jobdocurl.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, jobdocurl.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, jobdocurl.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, jobdocurl.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, jobdocurl.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, jobdocurl.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, jobdocurl.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, jobdocurl.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, jobdocurl.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, jobdocurl.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, jobdocurl.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, jobdocurl.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, jobdocurl.TypeNotIn(i.TypeNotIn...))
	}
	if i.URL != nil {
		predicates = append(predicates, jobdocurl.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, jobdocurl.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, jobdocurl.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, jobdocurl.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, jobdocurl.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, jobdocurl.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, jobdocurl.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, jobdocurl.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, jobdocurl.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, jobdocurl.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, jobdocurl.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, jobdocurl.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, jobdocurl.URLContainsFold(*i.URLContainsFold))
	}

	if i.HasJob != nil {
		p := jobdocurl.HasJob()
		if !*i.HasJob {
			p = jobdocurl.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobWith))
		for _, w := range i.HasJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobdocurl.HasJobWith(with...))
	}
	if i.HasCreator != nil {
		p := jobdocurl.HasCreator()
		if !*i.HasCreator {
			p = jobdocurl.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobdocurl.HasCreatorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobDocURLWhereInput
	case 1:
		return predicates[0], nil
	default:
		return jobdocurl.And(predicates...), nil
	}
}

// JobNoteWhereInput represents a where input for filtering JobNote queries.
type JobNoteWhereInput struct {
	Predicates []predicate.JobNote  `json:"-"`
	Not        *JobNoteWhereInput   `json:"not,omitempty"`
	Or         []*JobNoteWhereInput `json:"or,omitempty"`
	And        []*JobNoteWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "job" edge predicates.
	HasJob     *bool            `json:"hasJob,omitempty"`
	HasJobWith []*JobWhereInput `json:"hasJobWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobNoteWhereInput) AddPredicates(predicates ...predicate.JobNote) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobNoteWhereInput filter on the JobNoteQuery builder.
func (i *JobNoteWhereInput) Filter(q *JobNoteQuery) (*JobNoteQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobNoteWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobNoteWhereInput is returned in case the JobNoteWhereInput is empty.
var ErrEmptyJobNoteWhereInput = errors.New("ent: empty predicate JobNoteWhereInput")

// P returns a predicate for filtering jobnotes.
// An error is returned if the input is empty or invalid.
func (i *JobNoteWhereInput) P() (predicate.JobNote, error) {
	var predicates []predicate.JobNote
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, jobnote.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobNote, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobnote.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobNote, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobnote.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, jobnote.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobnote.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobnote.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobnote.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobnote.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobnote.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobnote.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobnote.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, jobnote.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, jobnote.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, jobnote.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, jobnote.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, jobnote.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, jobnote.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, jobnote.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, jobnote.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, jobnote.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, jobnote.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, jobnote.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, jobnote.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, jobnote.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, jobnote.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, jobnote.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, jobnote.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, jobnote.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, jobnote.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Note != nil {
		predicates = append(predicates, jobnote.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, jobnote.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, jobnote.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, jobnote.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, jobnote.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, jobnote.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, jobnote.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, jobnote.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, jobnote.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, jobnote.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, jobnote.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, jobnote.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, jobnote.NoteContainsFold(*i.NoteContainsFold))
	}

	if i.HasJob != nil {
		p := jobnote.HasJob()
		if !*i.HasJob {
			p = jobnote.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobWith))
		for _, w := range i.HasJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobnote.HasJobWith(with...))
	}
	if i.HasUser != nil {
		p := jobnote.HasUser()
		if !*i.HasUser {
			p = jobnote.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobnote.HasUserWith(with...))
	}
	if i.HasPartner != nil {
		p := jobnote.HasPartner()
		if !*i.HasPartner {
			p = jobnote.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobnote.HasPartnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobNoteWhereInput
	case 1:
		return predicates[0], nil
	default:
		return jobnote.And(predicates...), nil
	}
}

// JobProgressHistoryWhereInput represents a where input for filtering JobProgressHistory queries.
type JobProgressHistoryWhereInput struct {
	Predicates []predicate.JobProgressHistory  `json:"-"`
	Not        *JobProgressHistoryWhereInput   `json:"not,omitempty"`
	Or         []*JobProgressHistoryWhereInput `json:"or,omitempty"`
	And        []*JobProgressHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "status" field predicates.
	Status      *enum.JobProgress  `json:"status,omitempty"`
	StatusNEQ   *enum.JobProgress  `json:"statusNEQ,omitempty"`
	StatusIn    []enum.JobProgress `json:"statusIn,omitempty"`
	StatusNotIn []enum.JobProgress `json:"statusNotIn,omitempty"`

	// "complete" field predicates.
	Complete       *bool `json:"complete,omitempty"`
	CompleteNEQ    *bool `json:"completeNEQ,omitempty"`
	CompleteIsNil  bool  `json:"completeIsNil,omitempty"`
	CompleteNotNil bool  `json:"completeNotNil,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "job" edge predicates.
	HasJob     *bool            `json:"hasJob,omitempty"`
	HasJobWith []*JobWhereInput `json:"hasJobWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "creator_api_user" edge predicates.
	HasCreatorAPIUser     *bool                `json:"hasCreatorAPIUser,omitempty"`
	HasCreatorAPIUserWith []*ApiUserWhereInput `json:"hasCreatorAPIUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *JobProgressHistoryWhereInput) AddPredicates(predicates ...predicate.JobProgressHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the JobProgressHistoryWhereInput filter on the JobProgressHistoryQuery builder.
func (i *JobProgressHistoryWhereInput) Filter(q *JobProgressHistoryQuery) (*JobProgressHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyJobProgressHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyJobProgressHistoryWhereInput is returned in case the JobProgressHistoryWhereInput is empty.
var ErrEmptyJobProgressHistoryWhereInput = errors.New("ent: empty predicate JobProgressHistoryWhereInput")

// P returns a predicate for filtering jobprogresshistories.
// An error is returned if the input is empty or invalid.
func (i *JobProgressHistoryWhereInput) P() (predicate.JobProgressHistory, error) {
	var predicates []predicate.JobProgressHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, jobprogresshistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.JobProgressHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, jobprogresshistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.JobProgressHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, jobprogresshistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, jobprogresshistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, jobprogresshistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, jobprogresshistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, jobprogresshistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, jobprogresshistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, jobprogresshistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, jobprogresshistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, jobprogresshistory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, jobprogresshistory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, jobprogresshistory.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, jobprogresshistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, jobprogresshistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, jobprogresshistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, jobprogresshistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, jobprogresshistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, jobprogresshistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, jobprogresshistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, jobprogresshistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, jobprogresshistory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, jobprogresshistory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, jobprogresshistory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, jobprogresshistory.StatusNotIn(i.StatusNotIn...))
	}
	if i.Complete != nil {
		predicates = append(predicates, jobprogresshistory.CompleteEQ(*i.Complete))
	}
	if i.CompleteNEQ != nil {
		predicates = append(predicates, jobprogresshistory.CompleteNEQ(*i.CompleteNEQ))
	}
	if i.CompleteIsNil {
		predicates = append(predicates, jobprogresshistory.CompleteIsNil())
	}
	if i.CompleteNotNil {
		predicates = append(predicates, jobprogresshistory.CompleteNotNil())
	}
	if i.Note != nil {
		predicates = append(predicates, jobprogresshistory.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, jobprogresshistory.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, jobprogresshistory.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, jobprogresshistory.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, jobprogresshistory.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, jobprogresshistory.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, jobprogresshistory.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, jobprogresshistory.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, jobprogresshistory.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, jobprogresshistory.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, jobprogresshistory.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, jobprogresshistory.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, jobprogresshistory.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, jobprogresshistory.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, jobprogresshistory.NoteContainsFold(*i.NoteContainsFold))
	}

	if i.HasJob != nil {
		p := jobprogresshistory.HasJob()
		if !*i.HasJob {
			p = jobprogresshistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobWith))
		for _, w := range i.HasJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobprogresshistory.HasJobWith(with...))
	}
	if i.HasCreator != nil {
		p := jobprogresshistory.HasCreator()
		if !*i.HasCreator {
			p = jobprogresshistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobprogresshistory.HasCreatorWith(with...))
	}
	if i.HasCreatorAPIUser != nil {
		p := jobprogresshistory.HasCreatorAPIUser()
		if !*i.HasCreatorAPIUser {
			p = jobprogresshistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorAPIUserWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasCreatorAPIUserWith))
		for _, w := range i.HasCreatorAPIUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorAPIUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, jobprogresshistory.HasCreatorAPIUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyJobProgressHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return jobprogresshistory.And(predicates...), nil
	}
}

// NotifySettingWhereInput represents a where input for filtering NotifySetting queries.
type NotifySettingWhereInput struct {
	Predicates []predicate.NotifySetting  `json:"-"`
	Not        *NotifySettingWhereInput   `json:"not,omitempty"`
	Or         []*NotifySettingWhereInput `json:"or,omitempty"`
	And        []*NotifySettingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "topic_id" field predicates.
	TopicID             *string  `json:"topicID,omitempty"`
	TopicIDNEQ          *string  `json:"topicIDNEQ,omitempty"`
	TopicIDIn           []string `json:"topicIDIn,omitempty"`
	TopicIDNotIn        []string `json:"topicIDNotIn,omitempty"`
	TopicIDGT           *string  `json:"topicIDGT,omitempty"`
	TopicIDGTE          *string  `json:"topicIDGTE,omitempty"`
	TopicIDLT           *string  `json:"topicIDLT,omitempty"`
	TopicIDLTE          *string  `json:"topicIDLTE,omitempty"`
	TopicIDContains     *string  `json:"topicIDContains,omitempty"`
	TopicIDHasPrefix    *string  `json:"topicIDHasPrefix,omitempty"`
	TopicIDHasSuffix    *string  `json:"topicIDHasSuffix,omitempty"`
	TopicIDEqualFold    *string  `json:"topicIDEqualFold,omitempty"`
	TopicIDContainsFold *string  `json:"topicIDContainsFold,omitempty"`

	// "receive_email" field predicates.
	ReceiveEmail       *bool `json:"receiveEmail,omitempty"`
	ReceiveEmailNEQ    *bool `json:"receiveEmailNEQ,omitempty"`
	ReceiveEmailIsNil  bool  `json:"receiveEmailIsNil,omitempty"`
	ReceiveEmailNotNil bool  `json:"receiveEmailNotNil,omitempty"`

	// "receive_sms" field predicates.
	ReceiveSms       *bool `json:"receiveSms,omitempty"`
	ReceiveSmsNEQ    *bool `json:"receiveSmsNEQ,omitempty"`
	ReceiveSmsIsNil  bool  `json:"receiveSmsIsNil,omitempty"`
	ReceiveSmsNotNil bool  `json:"receiveSmsNotNil,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NotifySettingWhereInput) AddPredicates(predicates ...predicate.NotifySetting) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NotifySettingWhereInput filter on the NotifySettingQuery builder.
func (i *NotifySettingWhereInput) Filter(q *NotifySettingQuery) (*NotifySettingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNotifySettingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNotifySettingWhereInput is returned in case the NotifySettingWhereInput is empty.
var ErrEmptyNotifySettingWhereInput = errors.New("ent: empty predicate NotifySettingWhereInput")

// P returns a predicate for filtering notifysettings.
// An error is returned if the input is empty or invalid.
func (i *NotifySettingWhereInput) P() (predicate.NotifySetting, error) {
	var predicates []predicate.NotifySetting
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, notifysetting.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.NotifySetting, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, notifysetting.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.NotifySetting, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, notifysetting.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, notifysetting.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, notifysetting.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, notifysetting.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, notifysetting.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, notifysetting.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, notifysetting.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, notifysetting.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, notifysetting.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, notifysetting.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, notifysetting.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, notifysetting.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, notifysetting.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, notifysetting.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, notifysetting.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, notifysetting.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, notifysetting.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, notifysetting.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, notifysetting.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.TopicID != nil {
		predicates = append(predicates, notifysetting.TopicIDEQ(*i.TopicID))
	}
	if i.TopicIDNEQ != nil {
		predicates = append(predicates, notifysetting.TopicIDNEQ(*i.TopicIDNEQ))
	}
	if len(i.TopicIDIn) > 0 {
		predicates = append(predicates, notifysetting.TopicIDIn(i.TopicIDIn...))
	}
	if len(i.TopicIDNotIn) > 0 {
		predicates = append(predicates, notifysetting.TopicIDNotIn(i.TopicIDNotIn...))
	}
	if i.TopicIDGT != nil {
		predicates = append(predicates, notifysetting.TopicIDGT(*i.TopicIDGT))
	}
	if i.TopicIDGTE != nil {
		predicates = append(predicates, notifysetting.TopicIDGTE(*i.TopicIDGTE))
	}
	if i.TopicIDLT != nil {
		predicates = append(predicates, notifysetting.TopicIDLT(*i.TopicIDLT))
	}
	if i.TopicIDLTE != nil {
		predicates = append(predicates, notifysetting.TopicIDLTE(*i.TopicIDLTE))
	}
	if i.TopicIDContains != nil {
		predicates = append(predicates, notifysetting.TopicIDContains(*i.TopicIDContains))
	}
	if i.TopicIDHasPrefix != nil {
		predicates = append(predicates, notifysetting.TopicIDHasPrefix(*i.TopicIDHasPrefix))
	}
	if i.TopicIDHasSuffix != nil {
		predicates = append(predicates, notifysetting.TopicIDHasSuffix(*i.TopicIDHasSuffix))
	}
	if i.TopicIDEqualFold != nil {
		predicates = append(predicates, notifysetting.TopicIDEqualFold(*i.TopicIDEqualFold))
	}
	if i.TopicIDContainsFold != nil {
		predicates = append(predicates, notifysetting.TopicIDContainsFold(*i.TopicIDContainsFold))
	}
	if i.ReceiveEmail != nil {
		predicates = append(predicates, notifysetting.ReceiveEmailEQ(*i.ReceiveEmail))
	}
	if i.ReceiveEmailNEQ != nil {
		predicates = append(predicates, notifysetting.ReceiveEmailNEQ(*i.ReceiveEmailNEQ))
	}
	if i.ReceiveEmailIsNil {
		predicates = append(predicates, notifysetting.ReceiveEmailIsNil())
	}
	if i.ReceiveEmailNotNil {
		predicates = append(predicates, notifysetting.ReceiveEmailNotNil())
	}
	if i.ReceiveSms != nil {
		predicates = append(predicates, notifysetting.ReceiveSmsEQ(*i.ReceiveSms))
	}
	if i.ReceiveSmsNEQ != nil {
		predicates = append(predicates, notifysetting.ReceiveSmsNEQ(*i.ReceiveSmsNEQ))
	}
	if i.ReceiveSmsIsNil {
		predicates = append(predicates, notifysetting.ReceiveSmsIsNil())
	}
	if i.ReceiveSmsNotNil {
		predicates = append(predicates, notifysetting.ReceiveSmsNotNil())
	}

	if i.HasUser != nil {
		p := notifysetting.HasUser()
		if !*i.HasUser {
			p = notifysetting.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, notifysetting.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNotifySettingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return notifysetting.And(predicates...), nil
	}
}

// OptionListWhereInput represents a where input for filtering OptionList queries.
type OptionListWhereInput struct {
	Predicates []predicate.OptionList  `json:"-"`
	Not        *OptionListWhereInput   `json:"not,omitempty"`
	Or         []*OptionListWhereInput `json:"or,omitempty"`
	And        []*OptionListWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "type" field predicates.
	Type      *enum.OptionList  `json:"type,omitempty"`
	TypeNEQ   *enum.OptionList  `json:"typeNEQ,omitempty"`
	TypeIn    []enum.OptionList `json:"typeIn,omitempty"`
	TypeNotIn []enum.OptionList `json:"typeNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "display_name" field predicates.
	DisplayName             *string  `json:"displayName,omitempty"`
	DisplayNameNEQ          *string  `json:"displayNameNEQ,omitempty"`
	DisplayNameIn           []string `json:"displayNameIn,omitempty"`
	DisplayNameNotIn        []string `json:"displayNameNotIn,omitempty"`
	DisplayNameGT           *string  `json:"displayNameGT,omitempty"`
	DisplayNameGTE          *string  `json:"displayNameGTE,omitempty"`
	DisplayNameLT           *string  `json:"displayNameLT,omitempty"`
	DisplayNameLTE          *string  `json:"displayNameLTE,omitempty"`
	DisplayNameContains     *string  `json:"displayNameContains,omitempty"`
	DisplayNameHasPrefix    *string  `json:"displayNameHasPrefix,omitempty"`
	DisplayNameHasSuffix    *string  `json:"displayNameHasSuffix,omitempty"`
	DisplayNameEqualFold    *string  `json:"displayNameEqualFold,omitempty"`
	DisplayNameContainsFold *string  `json:"displayNameContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "order" field predicates.
	Order      *int  `json:"order,omitempty"`
	OrderNEQ   *int  `json:"orderNEQ,omitempty"`
	OrderIn    []int `json:"orderIn,omitempty"`
	OrderNotIn []int `json:"orderNotIn,omitempty"`
	OrderGT    *int  `json:"orderGT,omitempty"`
	OrderGTE   *int  `json:"orderGTE,omitempty"`
	OrderLT    *int  `json:"orderLT,omitempty"`
	OrderLTE   *int  `json:"orderLTE,omitempty"`

	// "finance_options" edge predicates.
	HasFinanceOptions     *bool                `json:"hasFinanceOptions,omitempty"`
	HasFinanceOptionsWith []*PartnerWhereInput `json:"hasFinanceOptionsWith,omitempty"`

	// "epc_options" edge predicates.
	HasEpcOptions     *bool                `json:"hasEpcOptions,omitempty"`
	HasEpcOptionsWith []*PartnerWhereInput `json:"hasEpcOptionsWith,omitempty"`

	// "epc" edge predicates.
	HasEpc     *bool            `json:"hasEpc,omitempty"`
	HasEpcWith []*JobWhereInput `json:"hasEpcWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OptionListWhereInput) AddPredicates(predicates ...predicate.OptionList) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OptionListWhereInput filter on the OptionListQuery builder.
func (i *OptionListWhereInput) Filter(q *OptionListQuery) (*OptionListQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOptionListWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOptionListWhereInput is returned in case the OptionListWhereInput is empty.
var ErrEmptyOptionListWhereInput = errors.New("ent: empty predicate OptionListWhereInput")

// P returns a predicate for filtering optionlists.
// An error is returned if the input is empty or invalid.
func (i *OptionListWhereInput) P() (predicate.OptionList, error) {
	var predicates []predicate.OptionList
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, optionlist.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OptionList, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, optionlist.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OptionList, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, optionlist.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, optionlist.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, optionlist.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, optionlist.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, optionlist.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, optionlist.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, optionlist.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, optionlist.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, optionlist.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, optionlist.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, optionlist.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, optionlist.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, optionlist.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, optionlist.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, optionlist.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, optionlist.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, optionlist.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, optionlist.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, optionlist.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, optionlist.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, optionlist.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, optionlist.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, optionlist.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, optionlist.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, optionlist.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, optionlist.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, optionlist.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, optionlist.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, optionlist.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, optionlist.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, optionlist.TypeNotIn(i.TypeNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, optionlist.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, optionlist.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, optionlist.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, optionlist.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, optionlist.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, optionlist.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, optionlist.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, optionlist.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, optionlist.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, optionlist.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, optionlist.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, optionlist.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, optionlist.NameContainsFold(*i.NameContainsFold))
	}
	if i.DisplayName != nil {
		predicates = append(predicates, optionlist.DisplayNameEQ(*i.DisplayName))
	}
	if i.DisplayNameNEQ != nil {
		predicates = append(predicates, optionlist.DisplayNameNEQ(*i.DisplayNameNEQ))
	}
	if len(i.DisplayNameIn) > 0 {
		predicates = append(predicates, optionlist.DisplayNameIn(i.DisplayNameIn...))
	}
	if len(i.DisplayNameNotIn) > 0 {
		predicates = append(predicates, optionlist.DisplayNameNotIn(i.DisplayNameNotIn...))
	}
	if i.DisplayNameGT != nil {
		predicates = append(predicates, optionlist.DisplayNameGT(*i.DisplayNameGT))
	}
	if i.DisplayNameGTE != nil {
		predicates = append(predicates, optionlist.DisplayNameGTE(*i.DisplayNameGTE))
	}
	if i.DisplayNameLT != nil {
		predicates = append(predicates, optionlist.DisplayNameLT(*i.DisplayNameLT))
	}
	if i.DisplayNameLTE != nil {
		predicates = append(predicates, optionlist.DisplayNameLTE(*i.DisplayNameLTE))
	}
	if i.DisplayNameContains != nil {
		predicates = append(predicates, optionlist.DisplayNameContains(*i.DisplayNameContains))
	}
	if i.DisplayNameHasPrefix != nil {
		predicates = append(predicates, optionlist.DisplayNameHasPrefix(*i.DisplayNameHasPrefix))
	}
	if i.DisplayNameHasSuffix != nil {
		predicates = append(predicates, optionlist.DisplayNameHasSuffix(*i.DisplayNameHasSuffix))
	}
	if i.DisplayNameEqualFold != nil {
		predicates = append(predicates, optionlist.DisplayNameEqualFold(*i.DisplayNameEqualFold))
	}
	if i.DisplayNameContainsFold != nil {
		predicates = append(predicates, optionlist.DisplayNameContainsFold(*i.DisplayNameContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, optionlist.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, optionlist.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.Order != nil {
		predicates = append(predicates, optionlist.OrderEQ(*i.Order))
	}
	if i.OrderNEQ != nil {
		predicates = append(predicates, optionlist.OrderNEQ(*i.OrderNEQ))
	}
	if len(i.OrderIn) > 0 {
		predicates = append(predicates, optionlist.OrderIn(i.OrderIn...))
	}
	if len(i.OrderNotIn) > 0 {
		predicates = append(predicates, optionlist.OrderNotIn(i.OrderNotIn...))
	}
	if i.OrderGT != nil {
		predicates = append(predicates, optionlist.OrderGT(*i.OrderGT))
	}
	if i.OrderGTE != nil {
		predicates = append(predicates, optionlist.OrderGTE(*i.OrderGTE))
	}
	if i.OrderLT != nil {
		predicates = append(predicates, optionlist.OrderLT(*i.OrderLT))
	}
	if i.OrderLTE != nil {
		predicates = append(predicates, optionlist.OrderLTE(*i.OrderLTE))
	}

	if i.HasFinanceOptions != nil {
		p := optionlist.HasFinanceOptions()
		if !*i.HasFinanceOptions {
			p = optionlist.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFinanceOptionsWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasFinanceOptionsWith))
		for _, w := range i.HasFinanceOptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFinanceOptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, optionlist.HasFinanceOptionsWith(with...))
	}
	if i.HasEpcOptions != nil {
		p := optionlist.HasEpcOptions()
		if !*i.HasEpcOptions {
			p = optionlist.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpcOptionsWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasEpcOptionsWith))
		for _, w := range i.HasEpcOptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpcOptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, optionlist.HasEpcOptionsWith(with...))
	}
	if i.HasEpc != nil {
		p := optionlist.HasEpc()
		if !*i.HasEpc {
			p = optionlist.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpcWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasEpcWith))
		for _, w := range i.HasEpcWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpcWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, optionlist.HasEpcWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOptionListWhereInput
	case 1:
		return predicates[0], nil
	default:
		return optionlist.And(predicates...), nil
	}
}

// PartnerWhereInput represents a where input for filtering Partner queries.
type PartnerWhereInput struct {
	Predicates []predicate.Partner  `json:"-"`
	Not        *PartnerWhereInput   `json:"not,omitempty"`
	Or         []*PartnerWhereInput `json:"or,omitempty"`
	And        []*PartnerWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "creator_id" field predicates.
	CreatorID             *string  `json:"creatorID,omitempty"`
	CreatorIDNEQ          *string  `json:"creatorIDNEQ,omitempty"`
	CreatorIDIn           []string `json:"creatorIDIn,omitempty"`
	CreatorIDNotIn        []string `json:"creatorIDNotIn,omitempty"`
	CreatorIDGT           *string  `json:"creatorIDGT,omitempty"`
	CreatorIDGTE          *string  `json:"creatorIDGTE,omitempty"`
	CreatorIDLT           *string  `json:"creatorIDLT,omitempty"`
	CreatorIDLTE          *string  `json:"creatorIDLTE,omitempty"`
	CreatorIDContains     *string  `json:"creatorIDContains,omitempty"`
	CreatorIDHasPrefix    *string  `json:"creatorIDHasPrefix,omitempty"`
	CreatorIDHasSuffix    *string  `json:"creatorIDHasSuffix,omitempty"`
	CreatorIDIsNil        bool     `json:"creatorIDIsNil,omitempty"`
	CreatorIDNotNil       bool     `json:"creatorIDNotNil,omitempty"`
	CreatorIDEqualFold    *string  `json:"creatorIDEqualFold,omitempty"`
	CreatorIDContainsFold *string  `json:"creatorIDContainsFold,omitempty"`

	// "type" field predicates.
	Type      *enum.Partner  `json:"type,omitempty"`
	TypeNEQ   *enum.Partner  `json:"typeNEQ,omitempty"`
	TypeIn    []enum.Partner `json:"typeIn,omitempty"`
	TypeNotIn []enum.Partner `json:"typeNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "website" field predicates.
	Website             *string  `json:"website,omitempty"`
	WebsiteNEQ          *string  `json:"websiteNEQ,omitempty"`
	WebsiteIn           []string `json:"websiteIn,omitempty"`
	WebsiteNotIn        []string `json:"websiteNotIn,omitempty"`
	WebsiteGT           *string  `json:"websiteGT,omitempty"`
	WebsiteGTE          *string  `json:"websiteGTE,omitempty"`
	WebsiteLT           *string  `json:"websiteLT,omitempty"`
	WebsiteLTE          *string  `json:"websiteLTE,omitempty"`
	WebsiteContains     *string  `json:"websiteContains,omitempty"`
	WebsiteHasPrefix    *string  `json:"websiteHasPrefix,omitempty"`
	WebsiteHasSuffix    *string  `json:"websiteHasSuffix,omitempty"`
	WebsiteIsNil        bool     `json:"websiteIsNil,omitempty"`
	WebsiteNotNil       bool     `json:"websiteNotNil,omitempty"`
	WebsiteEqualFold    *string  `json:"websiteEqualFold,omitempty"`
	WebsiteContainsFold *string  `json:"websiteContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "latitude" field predicates.
	Latitude       *float64  `json:"latitude,omitempty"`
	LatitudeNEQ    *float64  `json:"latitudeNEQ,omitempty"`
	LatitudeIn     []float64 `json:"latitudeIn,omitempty"`
	LatitudeNotIn  []float64 `json:"latitudeNotIn,omitempty"`
	LatitudeGT     *float64  `json:"latitudeGT,omitempty"`
	LatitudeGTE    *float64  `json:"latitudeGTE,omitempty"`
	LatitudeLT     *float64  `json:"latitudeLT,omitempty"`
	LatitudeLTE    *float64  `json:"latitudeLTE,omitempty"`
	LatitudeIsNil  bool      `json:"latitudeIsNil,omitempty"`
	LatitudeNotNil bool      `json:"latitudeNotNil,omitempty"`

	// "longitude" field predicates.
	Longitude       *float64  `json:"longitude,omitempty"`
	LongitudeNEQ    *float64  `json:"longitudeNEQ,omitempty"`
	LongitudeIn     []float64 `json:"longitudeIn,omitempty"`
	LongitudeNotIn  []float64 `json:"longitudeNotIn,omitempty"`
	LongitudeGT     *float64  `json:"longitudeGT,omitempty"`
	LongitudeGTE    *float64  `json:"longitudeGTE,omitempty"`
	LongitudeLT     *float64  `json:"longitudeLT,omitempty"`
	LongitudeLTE    *float64  `json:"longitudeLTE,omitempty"`
	LongitudeIsNil  bool      `json:"longitudeIsNil,omitempty"`
	LongitudeNotNil bool      `json:"longitudeNotNil,omitempty"`

	// "is_nation_wide" field predicates.
	IsNationWide    *bool `json:"isNationWide,omitempty"`
	IsNationWideNEQ *bool `json:"isNationWideNEQ,omitempty"`

	// "crew_count" field predicates.
	CrewCount      *uint16  `json:"crewCount,omitempty"`
	CrewCountNEQ   *uint16  `json:"crewCountNEQ,omitempty"`
	CrewCountIn    []uint16 `json:"crewCountIn,omitempty"`
	CrewCountNotIn []uint16 `json:"crewCountNotIn,omitempty"`
	CrewCountGT    *uint16  `json:"crewCountGT,omitempty"`
	CrewCountGTE   *uint16  `json:"crewCountGTE,omitempty"`
	CrewCountLT    *uint16  `json:"crewCountLT,omitempty"`
	CrewCountLTE   *uint16  `json:"crewCountLTE,omitempty"`

	// "years_in_business" field predicates.
	YearsInBusiness       *int  `json:"yearsInBusiness,omitempty"`
	YearsInBusinessNEQ    *int  `json:"yearsInBusinessNEQ,omitempty"`
	YearsInBusinessIn     []int `json:"yearsInBusinessIn,omitempty"`
	YearsInBusinessNotIn  []int `json:"yearsInBusinessNotIn,omitempty"`
	YearsInBusinessGT     *int  `json:"yearsInBusinessGT,omitempty"`
	YearsInBusinessGTE    *int  `json:"yearsInBusinessGTE,omitempty"`
	YearsInBusinessLT     *int  `json:"yearsInBusinessLT,omitempty"`
	YearsInBusinessLTE    *int  `json:"yearsInBusinessLTE,omitempty"`
	YearsInBusinessIsNil  bool  `json:"yearsInBusinessIsNil,omitempty"`
	YearsInBusinessNotNil bool  `json:"yearsInBusinessNotNil,omitempty"`

	// "job_capacity" field predicates.
	JobCapacity      *uint16  `json:"jobCapacity,omitempty"`
	JobCapacityNEQ   *uint16  `json:"jobCapacityNEQ,omitempty"`
	JobCapacityIn    []uint16 `json:"jobCapacityIn,omitempty"`
	JobCapacityNotIn []uint16 `json:"jobCapacityNotIn,omitempty"`
	JobCapacityGT    *uint16  `json:"jobCapacityGT,omitempty"`
	JobCapacityGTE   *uint16  `json:"jobCapacityGTE,omitempty"`
	JobCapacityLT    *uint16  `json:"jobCapacityLT,omitempty"`
	JobCapacityLTE   *uint16  `json:"jobCapacityLTE,omitempty"`

	// "asphalt_lead_t" field predicates.
	AsphaltLeadT             *string  `json:"asphaltLeadT,omitempty"`
	AsphaltLeadTNEQ          *string  `json:"asphaltLeadTNEQ,omitempty"`
	AsphaltLeadTIn           []string `json:"asphaltLeadTIn,omitempty"`
	AsphaltLeadTNotIn        []string `json:"asphaltLeadTNotIn,omitempty"`
	AsphaltLeadTGT           *string  `json:"asphaltLeadTGT,omitempty"`
	AsphaltLeadTGTE          *string  `json:"asphaltLeadTGTE,omitempty"`
	AsphaltLeadTLT           *string  `json:"asphaltLeadTLT,omitempty"`
	AsphaltLeadTLTE          *string  `json:"asphaltLeadTLTE,omitempty"`
	AsphaltLeadTContains     *string  `json:"asphaltLeadTContains,omitempty"`
	AsphaltLeadTHasPrefix    *string  `json:"asphaltLeadTHasPrefix,omitempty"`
	AsphaltLeadTHasSuffix    *string  `json:"asphaltLeadTHasSuffix,omitempty"`
	AsphaltLeadTIsNil        bool     `json:"asphaltLeadTIsNil,omitempty"`
	AsphaltLeadTNotNil       bool     `json:"asphaltLeadTNotNil,omitempty"`
	AsphaltLeadTEqualFold    *string  `json:"asphaltLeadTEqualFold,omitempty"`
	AsphaltLeadTContainsFold *string  `json:"asphaltLeadTContainsFold,omitempty"`

	// "metal_lead_t" field predicates.
	MetalLeadT             *string  `json:"metalLeadT,omitempty"`
	MetalLeadTNEQ          *string  `json:"metalLeadTNEQ,omitempty"`
	MetalLeadTIn           []string `json:"metalLeadTIn,omitempty"`
	MetalLeadTNotIn        []string `json:"metalLeadTNotIn,omitempty"`
	MetalLeadTGT           *string  `json:"metalLeadTGT,omitempty"`
	MetalLeadTGTE          *string  `json:"metalLeadTGTE,omitempty"`
	MetalLeadTLT           *string  `json:"metalLeadTLT,omitempty"`
	MetalLeadTLTE          *string  `json:"metalLeadTLTE,omitempty"`
	MetalLeadTContains     *string  `json:"metalLeadTContains,omitempty"`
	MetalLeadTHasPrefix    *string  `json:"metalLeadTHasPrefix,omitempty"`
	MetalLeadTHasSuffix    *string  `json:"metalLeadTHasSuffix,omitempty"`
	MetalLeadTIsNil        bool     `json:"metalLeadTIsNil,omitempty"`
	MetalLeadTNotNil       bool     `json:"metalLeadTNotNil,omitempty"`
	MetalLeadTEqualFold    *string  `json:"metalLeadTEqualFold,omitempty"`
	MetalLeadTContainsFold *string  `json:"metalLeadTContainsFold,omitempty"`

	// "tile_lead_t" field predicates.
	TileLeadT             *string  `json:"tileLeadT,omitempty"`
	TileLeadTNEQ          *string  `json:"tileLeadTNEQ,omitempty"`
	TileLeadTIn           []string `json:"tileLeadTIn,omitempty"`
	TileLeadTNotIn        []string `json:"tileLeadTNotIn,omitempty"`
	TileLeadTGT           *string  `json:"tileLeadTGT,omitempty"`
	TileLeadTGTE          *string  `json:"tileLeadTGTE,omitempty"`
	TileLeadTLT           *string  `json:"tileLeadTLT,omitempty"`
	TileLeadTLTE          *string  `json:"tileLeadTLTE,omitempty"`
	TileLeadTContains     *string  `json:"tileLeadTContains,omitempty"`
	TileLeadTHasPrefix    *string  `json:"tileLeadTHasPrefix,omitempty"`
	TileLeadTHasSuffix    *string  `json:"tileLeadTHasSuffix,omitempty"`
	TileLeadTIsNil        bool     `json:"tileLeadTIsNil,omitempty"`
	TileLeadTNotNil       bool     `json:"tileLeadTNotNil,omitempty"`
	TileLeadTEqualFold    *string  `json:"tileLeadTEqualFold,omitempty"`
	TileLeadTContainsFold *string  `json:"tileLeadTContainsFold,omitempty"`

	// "setup_steps_completed" field predicates.
	SetupStepsCompleted      *uint8  `json:"setupStepsCompleted,omitempty"`
	SetupStepsCompletedNEQ   *uint8  `json:"setupStepsCompletedNEQ,omitempty"`
	SetupStepsCompletedIn    []uint8 `json:"setupStepsCompletedIn,omitempty"`
	SetupStepsCompletedNotIn []uint8 `json:"setupStepsCompletedNotIn,omitempty"`
	SetupStepsCompletedGT    *uint8  `json:"setupStepsCompletedGT,omitempty"`
	SetupStepsCompletedGTE   *uint8  `json:"setupStepsCompletedGTE,omitempty"`
	SetupStepsCompletedLT    *uint8  `json:"setupStepsCompletedLT,omitempty"`
	SetupStepsCompletedLTE   *uint8  `json:"setupStepsCompletedLTE,omitempty"`

	// "sales_volume" field predicates.
	SalesVolume       *int  `json:"salesVolume,omitempty"`
	SalesVolumeNEQ    *int  `json:"salesVolumeNEQ,omitempty"`
	SalesVolumeIn     []int `json:"salesVolumeIn,omitempty"`
	SalesVolumeNotIn  []int `json:"salesVolumeNotIn,omitempty"`
	SalesVolumeGT     *int  `json:"salesVolumeGT,omitempty"`
	SalesVolumeGTE    *int  `json:"salesVolumeGTE,omitempty"`
	SalesVolumeLT     *int  `json:"salesVolumeLT,omitempty"`
	SalesVolumeLTE    *int  `json:"salesVolumeLTE,omitempty"`
	SalesVolumeIsNil  bool  `json:"salesVolumeIsNil,omitempty"`
	SalesVolumeNotNil bool  `json:"salesVolumeNotNil,omitempty"`

	// "down_payment" field predicates.
	DownPayment       *int  `json:"downPayment,omitempty"`
	DownPaymentNEQ    *int  `json:"downPaymentNEQ,omitempty"`
	DownPaymentIn     []int `json:"downPaymentIn,omitempty"`
	DownPaymentNotIn  []int `json:"downPaymentNotIn,omitempty"`
	DownPaymentGT     *int  `json:"downPaymentGT,omitempty"`
	DownPaymentGTE    *int  `json:"downPaymentGTE,omitempty"`
	DownPaymentLT     *int  `json:"downPaymentLT,omitempty"`
	DownPaymentLTE    *int  `json:"downPaymentLTE,omitempty"`
	DownPaymentIsNil  bool  `json:"downPaymentIsNil,omitempty"`
	DownPaymentNotNil bool  `json:"downPaymentNotNil,omitempty"`

	// "pif" field predicates.
	Pif       *int  `json:"pif,omitempty"`
	PifNEQ    *int  `json:"pifNEQ,omitempty"`
	PifIn     []int `json:"pifIn,omitempty"`
	PifNotIn  []int `json:"pifNotIn,omitempty"`
	PifGT     *int  `json:"pifGT,omitempty"`
	PifGTE    *int  `json:"pifGTE,omitempty"`
	PifLT     *int  `json:"pifLT,omitempty"`
	PifLTE    *int  `json:"pifLTE,omitempty"`
	PifIsNil  bool  `json:"pifIsNil,omitempty"`
	PifNotNil bool  `json:"pifNotNil,omitempty"`

	// "install_in_house" field predicates.
	InstallInHouse       *bool `json:"installInHouse,omitempty"`
	InstallInHouseNEQ    *bool `json:"installInHouseNEQ,omitempty"`
	InstallInHouseIsNil  bool  `json:"installInHouseIsNil,omitempty"`
	InstallInHouseNotNil bool  `json:"installInHouseNotNil,omitempty"`

	// "status" field predicates.
	Status      *enum.PartnerStatus  `json:"status,omitempty"`
	StatusNEQ   *enum.PartnerStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enum.PartnerStatus `json:"statusIn,omitempty"`
	StatusNotIn []enum.PartnerStatus `json:"statusNotIn,omitempty"`

	// "epc_status" field predicates.
	EpcStatus       *enum.EPCStatus  `json:"epcStatus,omitempty"`
	EpcStatusNEQ    *enum.EPCStatus  `json:"epcStatusNEQ,omitempty"`
	EpcStatusIn     []enum.EPCStatus `json:"epcStatusIn,omitempty"`
	EpcStatusNotIn  []enum.EPCStatus `json:"epcStatusNotIn,omitempty"`
	EpcStatusIsNil  bool             `json:"epcStatusIsNil,omitempty"`
	EpcStatusNotNil bool             `json:"epcStatusNotNil,omitempty"`

	// "requested_estimates" edge predicates.
	HasRequestedEstimates     *bool                 `json:"hasRequestedEstimates,omitempty"`
	HasRequestedEstimatesWith []*EstimateWhereInput `json:"hasRequestedEstimatesWith,omitempty"`

	// "estimate_home_owners" edge predicates.
	HasEstimateHomeOwners     *bool                  `json:"hasEstimateHomeOwners,omitempty"`
	HasEstimateHomeOwnersWith []*HomeOwnerWhereInput `json:"hasEstimateHomeOwnersWith,omitempty"`

	// "roofing_jobs" edge predicates.
	HasRoofingJobs     *bool            `json:"hasRoofingJobs,omitempty"`
	HasRoofingJobsWith []*JobWhereInput `json:"hasRoofingJobsWith,omitempty"`

	// "integration_jobs" edge predicates.
	HasIntegrationJobs     *bool            `json:"hasIntegrationJobs,omitempty"`
	HasIntegrationJobsWith []*JobWhereInput `json:"hasIntegrationJobsWith,omitempty"`

	// "epc_jobs" edge predicates.
	HasEpcJobs     *bool            `json:"hasEpcJobs,omitempty"`
	HasEpcJobsWith []*JobWhereInput `json:"hasEpcJobsWith,omitempty"`

	// "job_requests" edge predicates.
	HasJobRequests     *bool            `json:"hasJobRequests,omitempty"`
	HasJobRequestsWith []*JobWhereInput `json:"hasJobRequestsWith,omitempty"`

	// "activities" edge predicates.
	HasActivities     *bool                        `json:"hasActivities,omitempty"`
	HasActivitiesWith []*PartnerActivityWhereInput `json:"hasActivitiesWith,omitempty"`

	// "job_assignment_history" edge predicates.
	HasJobAssignmentHistory     *bool                             `json:"hasJobAssignmentHistory,omitempty"`
	HasJobAssignmentHistoryWith []*JobAssignmentHistoryWhereInput `json:"hasJobAssignmentHistoryWith,omitempty"`

	// "requested_installation_jobs" edge predicates.
	HasRequestedInstallationJobs     *bool                        `json:"hasRequestedInstallationJobs,omitempty"`
	HasRequestedInstallationJobsWith []*InstallationJobWhereInput `json:"hasRequestedInstallationJobsWith,omitempty"`

	// "assigned_installation_jobs" edge predicates.
	HasAssignedInstallationJobs     *bool                        `json:"hasAssignedInstallationJobs,omitempty"`
	HasAssignedInstallationJobsWith []*InstallationJobWhereInput `json:"hasAssignedInstallationJobsWith,omitempty"`

	// "contacts" edge predicates.
	HasContacts     *bool             `json:"hasContacts,omitempty"`
	HasContactsWith []*UserWhereInput `json:"hasContactsWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "creator_api" edge predicates.
	HasCreatorAPI     *bool                `json:"hasCreatorAPI,omitempty"`
	HasCreatorAPIWith []*ApiUserWhereInput `json:"hasCreatorAPIWith,omitempty"`

	// "services" edge predicates.
	HasServices     *bool                       `json:"hasServices,omitempty"`
	HasServicesWith []*PartnerServiceWhereInput `json:"hasServicesWith,omitempty"`

	// "service_states" edge predicates.
	HasServiceStates     *bool                            `json:"hasServiceStates,omitempty"`
	HasServiceStatesWith []*PartnerServiceStateWhereInput `json:"hasServiceStatesWith,omitempty"`

	// "service_cities" edge predicates.
	HasServiceCities     *bool                           `json:"hasServiceCities,omitempty"`
	HasServiceCitiesWith []*PartnerServiceCityWhereInput `json:"hasServiceCitiesWith,omitempty"`

	// "training_videos" edge predicates.
	HasTrainingVideos     *bool                             `json:"hasTrainingVideos,omitempty"`
	HasTrainingVideosWith []*PartnerTrainingVideoWhereInput `json:"hasTrainingVideosWith,omitempty"`

	// "contact_us_requests" edge predicates.
	HasContactUsRequests     *bool                  `json:"hasContactUsRequests,omitempty"`
	HasContactUsRequestsWith []*ContactUsWhereInput `json:"hasContactUsRequestsWith,omitempty"`

	// "surveys" edge predicates.
	HasSurveys     *bool               `json:"hasSurveys,omitempty"`
	HasSurveysWith []*SurveyWhereInput `json:"hasSurveysWith,omitempty"`

	// "sessions" edge predicates.
	HasSessions     *bool                    `json:"hasSessions,omitempty"`
	HasSessionsWith []*UserSessionWhereInput `json:"hasSessionsWith,omitempty"`

	// "job_notes" edge predicates.
	HasJobNotes     *bool                `json:"hasJobNotes,omitempty"`
	HasJobNotesWith []*JobNoteWhereInput `json:"hasJobNotesWith,omitempty"`

	// "channels" edge predicates.
	HasChannels     *bool                   `json:"hasChannels,omitempty"`
	HasChannelsWith []*ChannelSubWhereInput `json:"hasChannelsWith,omitempty"`

	// "finance_options" edge predicates.
	HasFinanceOptions     *bool                   `json:"hasFinanceOptions,omitempty"`
	HasFinanceOptionsWith []*OptionListWhereInput `json:"hasFinanceOptionsWith,omitempty"`

	// "epc_options" edge predicates.
	HasEpcOptions     *bool                   `json:"hasEpcOptions,omitempty"`
	HasEpcOptionsWith []*OptionListWhereInput `json:"hasEpcOptionsWith,omitempty"`

	// "partner_contacts" edge predicates.
	HasPartnerContacts     *bool                       `json:"hasPartnerContacts,omitempty"`
	HasPartnerContactsWith []*PartnerContactWhereInput `json:"hasPartnerContactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PartnerWhereInput) AddPredicates(predicates ...predicate.Partner) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PartnerWhereInput filter on the PartnerQuery builder.
func (i *PartnerWhereInput) Filter(q *PartnerQuery) (*PartnerQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPartnerWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPartnerWhereInput is returned in case the PartnerWhereInput is empty.
var ErrEmptyPartnerWhereInput = errors.New("ent: empty predicate PartnerWhereInput")

// P returns a predicate for filtering partners.
// An error is returned if the input is empty or invalid.
func (i *PartnerWhereInput) P() (predicate.Partner, error) {
	var predicates []predicate.Partner
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, partner.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Partner, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, partner.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Partner, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, partner.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, partner.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, partner.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, partner.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, partner.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, partner.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, partner.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, partner.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, partner.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, partner.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, partner.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, partner.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, partner.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, partner.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, partner.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, partner.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, partner.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, partner.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, partner.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, partner.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, partner.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, partner.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, partner.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, partner.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, partner.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, partner.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, partner.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ExternalID != nil {
		predicates = append(predicates, partner.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, partner.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, partner.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, partner.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, partner.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, partner.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, partner.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, partner.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, partner.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, partner.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, partner.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, partner.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, partner.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, partner.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, partner.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.CreatorID != nil {
		predicates = append(predicates, partner.CreatorIDEQ(*i.CreatorID))
	}
	if i.CreatorIDNEQ != nil {
		predicates = append(predicates, partner.CreatorIDNEQ(*i.CreatorIDNEQ))
	}
	if len(i.CreatorIDIn) > 0 {
		predicates = append(predicates, partner.CreatorIDIn(i.CreatorIDIn...))
	}
	if len(i.CreatorIDNotIn) > 0 {
		predicates = append(predicates, partner.CreatorIDNotIn(i.CreatorIDNotIn...))
	}
	if i.CreatorIDGT != nil {
		predicates = append(predicates, partner.CreatorIDGT(*i.CreatorIDGT))
	}
	if i.CreatorIDGTE != nil {
		predicates = append(predicates, partner.CreatorIDGTE(*i.CreatorIDGTE))
	}
	if i.CreatorIDLT != nil {
		predicates = append(predicates, partner.CreatorIDLT(*i.CreatorIDLT))
	}
	if i.CreatorIDLTE != nil {
		predicates = append(predicates, partner.CreatorIDLTE(*i.CreatorIDLTE))
	}
	if i.CreatorIDContains != nil {
		predicates = append(predicates, partner.CreatorIDContains(*i.CreatorIDContains))
	}
	if i.CreatorIDHasPrefix != nil {
		predicates = append(predicates, partner.CreatorIDHasPrefix(*i.CreatorIDHasPrefix))
	}
	if i.CreatorIDHasSuffix != nil {
		predicates = append(predicates, partner.CreatorIDHasSuffix(*i.CreatorIDHasSuffix))
	}
	if i.CreatorIDIsNil {
		predicates = append(predicates, partner.CreatorIDIsNil())
	}
	if i.CreatorIDNotNil {
		predicates = append(predicates, partner.CreatorIDNotNil())
	}
	if i.CreatorIDEqualFold != nil {
		predicates = append(predicates, partner.CreatorIDEqualFold(*i.CreatorIDEqualFold))
	}
	if i.CreatorIDContainsFold != nil {
		predicates = append(predicates, partner.CreatorIDContainsFold(*i.CreatorIDContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, partner.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, partner.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, partner.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, partner.TypeNotIn(i.TypeNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, partner.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, partner.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, partner.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, partner.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, partner.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, partner.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, partner.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, partner.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, partner.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, partner.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, partner.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, partner.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, partner.NameContainsFold(*i.NameContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, partner.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, partner.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, partner.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, partner.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, partner.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, partner.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, partner.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, partner.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, partner.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, partner.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, partner.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, partner.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, partner.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, partner.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, partner.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Website != nil {
		predicates = append(predicates, partner.WebsiteEQ(*i.Website))
	}
	if i.WebsiteNEQ != nil {
		predicates = append(predicates, partner.WebsiteNEQ(*i.WebsiteNEQ))
	}
	if len(i.WebsiteIn) > 0 {
		predicates = append(predicates, partner.WebsiteIn(i.WebsiteIn...))
	}
	if len(i.WebsiteNotIn) > 0 {
		predicates = append(predicates, partner.WebsiteNotIn(i.WebsiteNotIn...))
	}
	if i.WebsiteGT != nil {
		predicates = append(predicates, partner.WebsiteGT(*i.WebsiteGT))
	}
	if i.WebsiteGTE != nil {
		predicates = append(predicates, partner.WebsiteGTE(*i.WebsiteGTE))
	}
	if i.WebsiteLT != nil {
		predicates = append(predicates, partner.WebsiteLT(*i.WebsiteLT))
	}
	if i.WebsiteLTE != nil {
		predicates = append(predicates, partner.WebsiteLTE(*i.WebsiteLTE))
	}
	if i.WebsiteContains != nil {
		predicates = append(predicates, partner.WebsiteContains(*i.WebsiteContains))
	}
	if i.WebsiteHasPrefix != nil {
		predicates = append(predicates, partner.WebsiteHasPrefix(*i.WebsiteHasPrefix))
	}
	if i.WebsiteHasSuffix != nil {
		predicates = append(predicates, partner.WebsiteHasSuffix(*i.WebsiteHasSuffix))
	}
	if i.WebsiteIsNil {
		predicates = append(predicates, partner.WebsiteIsNil())
	}
	if i.WebsiteNotNil {
		predicates = append(predicates, partner.WebsiteNotNil())
	}
	if i.WebsiteEqualFold != nil {
		predicates = append(predicates, partner.WebsiteEqualFold(*i.WebsiteEqualFold))
	}
	if i.WebsiteContainsFold != nil {
		predicates = append(predicates, partner.WebsiteContainsFold(*i.WebsiteContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, partner.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, partner.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, partner.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, partner.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, partner.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, partner.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, partner.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, partner.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, partner.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, partner.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, partner.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, partner.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, partner.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, partner.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, partner.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Latitude != nil {
		predicates = append(predicates, partner.LatitudeEQ(*i.Latitude))
	}
	if i.LatitudeNEQ != nil {
		predicates = append(predicates, partner.LatitudeNEQ(*i.LatitudeNEQ))
	}
	if len(i.LatitudeIn) > 0 {
		predicates = append(predicates, partner.LatitudeIn(i.LatitudeIn...))
	}
	if len(i.LatitudeNotIn) > 0 {
		predicates = append(predicates, partner.LatitudeNotIn(i.LatitudeNotIn...))
	}
	if i.LatitudeGT != nil {
		predicates = append(predicates, partner.LatitudeGT(*i.LatitudeGT))
	}
	if i.LatitudeGTE != nil {
		predicates = append(predicates, partner.LatitudeGTE(*i.LatitudeGTE))
	}
	if i.LatitudeLT != nil {
		predicates = append(predicates, partner.LatitudeLT(*i.LatitudeLT))
	}
	if i.LatitudeLTE != nil {
		predicates = append(predicates, partner.LatitudeLTE(*i.LatitudeLTE))
	}
	if i.LatitudeIsNil {
		predicates = append(predicates, partner.LatitudeIsNil())
	}
	if i.LatitudeNotNil {
		predicates = append(predicates, partner.LatitudeNotNil())
	}
	if i.Longitude != nil {
		predicates = append(predicates, partner.LongitudeEQ(*i.Longitude))
	}
	if i.LongitudeNEQ != nil {
		predicates = append(predicates, partner.LongitudeNEQ(*i.LongitudeNEQ))
	}
	if len(i.LongitudeIn) > 0 {
		predicates = append(predicates, partner.LongitudeIn(i.LongitudeIn...))
	}
	if len(i.LongitudeNotIn) > 0 {
		predicates = append(predicates, partner.LongitudeNotIn(i.LongitudeNotIn...))
	}
	if i.LongitudeGT != nil {
		predicates = append(predicates, partner.LongitudeGT(*i.LongitudeGT))
	}
	if i.LongitudeGTE != nil {
		predicates = append(predicates, partner.LongitudeGTE(*i.LongitudeGTE))
	}
	if i.LongitudeLT != nil {
		predicates = append(predicates, partner.LongitudeLT(*i.LongitudeLT))
	}
	if i.LongitudeLTE != nil {
		predicates = append(predicates, partner.LongitudeLTE(*i.LongitudeLTE))
	}
	if i.LongitudeIsNil {
		predicates = append(predicates, partner.LongitudeIsNil())
	}
	if i.LongitudeNotNil {
		predicates = append(predicates, partner.LongitudeNotNil())
	}
	if i.IsNationWide != nil {
		predicates = append(predicates, partner.IsNationWideEQ(*i.IsNationWide))
	}
	if i.IsNationWideNEQ != nil {
		predicates = append(predicates, partner.IsNationWideNEQ(*i.IsNationWideNEQ))
	}
	if i.CrewCount != nil {
		predicates = append(predicates, partner.CrewCountEQ(*i.CrewCount))
	}
	if i.CrewCountNEQ != nil {
		predicates = append(predicates, partner.CrewCountNEQ(*i.CrewCountNEQ))
	}
	if len(i.CrewCountIn) > 0 {
		predicates = append(predicates, partner.CrewCountIn(i.CrewCountIn...))
	}
	if len(i.CrewCountNotIn) > 0 {
		predicates = append(predicates, partner.CrewCountNotIn(i.CrewCountNotIn...))
	}
	if i.CrewCountGT != nil {
		predicates = append(predicates, partner.CrewCountGT(*i.CrewCountGT))
	}
	if i.CrewCountGTE != nil {
		predicates = append(predicates, partner.CrewCountGTE(*i.CrewCountGTE))
	}
	if i.CrewCountLT != nil {
		predicates = append(predicates, partner.CrewCountLT(*i.CrewCountLT))
	}
	if i.CrewCountLTE != nil {
		predicates = append(predicates, partner.CrewCountLTE(*i.CrewCountLTE))
	}
	if i.YearsInBusiness != nil {
		predicates = append(predicates, partner.YearsInBusinessEQ(*i.YearsInBusiness))
	}
	if i.YearsInBusinessNEQ != nil {
		predicates = append(predicates, partner.YearsInBusinessNEQ(*i.YearsInBusinessNEQ))
	}
	if len(i.YearsInBusinessIn) > 0 {
		predicates = append(predicates, partner.YearsInBusinessIn(i.YearsInBusinessIn...))
	}
	if len(i.YearsInBusinessNotIn) > 0 {
		predicates = append(predicates, partner.YearsInBusinessNotIn(i.YearsInBusinessNotIn...))
	}
	if i.YearsInBusinessGT != nil {
		predicates = append(predicates, partner.YearsInBusinessGT(*i.YearsInBusinessGT))
	}
	if i.YearsInBusinessGTE != nil {
		predicates = append(predicates, partner.YearsInBusinessGTE(*i.YearsInBusinessGTE))
	}
	if i.YearsInBusinessLT != nil {
		predicates = append(predicates, partner.YearsInBusinessLT(*i.YearsInBusinessLT))
	}
	if i.YearsInBusinessLTE != nil {
		predicates = append(predicates, partner.YearsInBusinessLTE(*i.YearsInBusinessLTE))
	}
	if i.YearsInBusinessIsNil {
		predicates = append(predicates, partner.YearsInBusinessIsNil())
	}
	if i.YearsInBusinessNotNil {
		predicates = append(predicates, partner.YearsInBusinessNotNil())
	}
	if i.JobCapacity != nil {
		predicates = append(predicates, partner.JobCapacityEQ(*i.JobCapacity))
	}
	if i.JobCapacityNEQ != nil {
		predicates = append(predicates, partner.JobCapacityNEQ(*i.JobCapacityNEQ))
	}
	if len(i.JobCapacityIn) > 0 {
		predicates = append(predicates, partner.JobCapacityIn(i.JobCapacityIn...))
	}
	if len(i.JobCapacityNotIn) > 0 {
		predicates = append(predicates, partner.JobCapacityNotIn(i.JobCapacityNotIn...))
	}
	if i.JobCapacityGT != nil {
		predicates = append(predicates, partner.JobCapacityGT(*i.JobCapacityGT))
	}
	if i.JobCapacityGTE != nil {
		predicates = append(predicates, partner.JobCapacityGTE(*i.JobCapacityGTE))
	}
	if i.JobCapacityLT != nil {
		predicates = append(predicates, partner.JobCapacityLT(*i.JobCapacityLT))
	}
	if i.JobCapacityLTE != nil {
		predicates = append(predicates, partner.JobCapacityLTE(*i.JobCapacityLTE))
	}
	if i.AsphaltLeadT != nil {
		predicates = append(predicates, partner.AsphaltLeadTEQ(*i.AsphaltLeadT))
	}
	if i.AsphaltLeadTNEQ != nil {
		predicates = append(predicates, partner.AsphaltLeadTNEQ(*i.AsphaltLeadTNEQ))
	}
	if len(i.AsphaltLeadTIn) > 0 {
		predicates = append(predicates, partner.AsphaltLeadTIn(i.AsphaltLeadTIn...))
	}
	if len(i.AsphaltLeadTNotIn) > 0 {
		predicates = append(predicates, partner.AsphaltLeadTNotIn(i.AsphaltLeadTNotIn...))
	}
	if i.AsphaltLeadTGT != nil {
		predicates = append(predicates, partner.AsphaltLeadTGT(*i.AsphaltLeadTGT))
	}
	if i.AsphaltLeadTGTE != nil {
		predicates = append(predicates, partner.AsphaltLeadTGTE(*i.AsphaltLeadTGTE))
	}
	if i.AsphaltLeadTLT != nil {
		predicates = append(predicates, partner.AsphaltLeadTLT(*i.AsphaltLeadTLT))
	}
	if i.AsphaltLeadTLTE != nil {
		predicates = append(predicates, partner.AsphaltLeadTLTE(*i.AsphaltLeadTLTE))
	}
	if i.AsphaltLeadTContains != nil {
		predicates = append(predicates, partner.AsphaltLeadTContains(*i.AsphaltLeadTContains))
	}
	if i.AsphaltLeadTHasPrefix != nil {
		predicates = append(predicates, partner.AsphaltLeadTHasPrefix(*i.AsphaltLeadTHasPrefix))
	}
	if i.AsphaltLeadTHasSuffix != nil {
		predicates = append(predicates, partner.AsphaltLeadTHasSuffix(*i.AsphaltLeadTHasSuffix))
	}
	if i.AsphaltLeadTIsNil {
		predicates = append(predicates, partner.AsphaltLeadTIsNil())
	}
	if i.AsphaltLeadTNotNil {
		predicates = append(predicates, partner.AsphaltLeadTNotNil())
	}
	if i.AsphaltLeadTEqualFold != nil {
		predicates = append(predicates, partner.AsphaltLeadTEqualFold(*i.AsphaltLeadTEqualFold))
	}
	if i.AsphaltLeadTContainsFold != nil {
		predicates = append(predicates, partner.AsphaltLeadTContainsFold(*i.AsphaltLeadTContainsFold))
	}
	if i.MetalLeadT != nil {
		predicates = append(predicates, partner.MetalLeadTEQ(*i.MetalLeadT))
	}
	if i.MetalLeadTNEQ != nil {
		predicates = append(predicates, partner.MetalLeadTNEQ(*i.MetalLeadTNEQ))
	}
	if len(i.MetalLeadTIn) > 0 {
		predicates = append(predicates, partner.MetalLeadTIn(i.MetalLeadTIn...))
	}
	if len(i.MetalLeadTNotIn) > 0 {
		predicates = append(predicates, partner.MetalLeadTNotIn(i.MetalLeadTNotIn...))
	}
	if i.MetalLeadTGT != nil {
		predicates = append(predicates, partner.MetalLeadTGT(*i.MetalLeadTGT))
	}
	if i.MetalLeadTGTE != nil {
		predicates = append(predicates, partner.MetalLeadTGTE(*i.MetalLeadTGTE))
	}
	if i.MetalLeadTLT != nil {
		predicates = append(predicates, partner.MetalLeadTLT(*i.MetalLeadTLT))
	}
	if i.MetalLeadTLTE != nil {
		predicates = append(predicates, partner.MetalLeadTLTE(*i.MetalLeadTLTE))
	}
	if i.MetalLeadTContains != nil {
		predicates = append(predicates, partner.MetalLeadTContains(*i.MetalLeadTContains))
	}
	if i.MetalLeadTHasPrefix != nil {
		predicates = append(predicates, partner.MetalLeadTHasPrefix(*i.MetalLeadTHasPrefix))
	}
	if i.MetalLeadTHasSuffix != nil {
		predicates = append(predicates, partner.MetalLeadTHasSuffix(*i.MetalLeadTHasSuffix))
	}
	if i.MetalLeadTIsNil {
		predicates = append(predicates, partner.MetalLeadTIsNil())
	}
	if i.MetalLeadTNotNil {
		predicates = append(predicates, partner.MetalLeadTNotNil())
	}
	if i.MetalLeadTEqualFold != nil {
		predicates = append(predicates, partner.MetalLeadTEqualFold(*i.MetalLeadTEqualFold))
	}
	if i.MetalLeadTContainsFold != nil {
		predicates = append(predicates, partner.MetalLeadTContainsFold(*i.MetalLeadTContainsFold))
	}
	if i.TileLeadT != nil {
		predicates = append(predicates, partner.TileLeadTEQ(*i.TileLeadT))
	}
	if i.TileLeadTNEQ != nil {
		predicates = append(predicates, partner.TileLeadTNEQ(*i.TileLeadTNEQ))
	}
	if len(i.TileLeadTIn) > 0 {
		predicates = append(predicates, partner.TileLeadTIn(i.TileLeadTIn...))
	}
	if len(i.TileLeadTNotIn) > 0 {
		predicates = append(predicates, partner.TileLeadTNotIn(i.TileLeadTNotIn...))
	}
	if i.TileLeadTGT != nil {
		predicates = append(predicates, partner.TileLeadTGT(*i.TileLeadTGT))
	}
	if i.TileLeadTGTE != nil {
		predicates = append(predicates, partner.TileLeadTGTE(*i.TileLeadTGTE))
	}
	if i.TileLeadTLT != nil {
		predicates = append(predicates, partner.TileLeadTLT(*i.TileLeadTLT))
	}
	if i.TileLeadTLTE != nil {
		predicates = append(predicates, partner.TileLeadTLTE(*i.TileLeadTLTE))
	}
	if i.TileLeadTContains != nil {
		predicates = append(predicates, partner.TileLeadTContains(*i.TileLeadTContains))
	}
	if i.TileLeadTHasPrefix != nil {
		predicates = append(predicates, partner.TileLeadTHasPrefix(*i.TileLeadTHasPrefix))
	}
	if i.TileLeadTHasSuffix != nil {
		predicates = append(predicates, partner.TileLeadTHasSuffix(*i.TileLeadTHasSuffix))
	}
	if i.TileLeadTIsNil {
		predicates = append(predicates, partner.TileLeadTIsNil())
	}
	if i.TileLeadTNotNil {
		predicates = append(predicates, partner.TileLeadTNotNil())
	}
	if i.TileLeadTEqualFold != nil {
		predicates = append(predicates, partner.TileLeadTEqualFold(*i.TileLeadTEqualFold))
	}
	if i.TileLeadTContainsFold != nil {
		predicates = append(predicates, partner.TileLeadTContainsFold(*i.TileLeadTContainsFold))
	}
	if i.SetupStepsCompleted != nil {
		predicates = append(predicates, partner.SetupStepsCompletedEQ(*i.SetupStepsCompleted))
	}
	if i.SetupStepsCompletedNEQ != nil {
		predicates = append(predicates, partner.SetupStepsCompletedNEQ(*i.SetupStepsCompletedNEQ))
	}
	if len(i.SetupStepsCompletedIn) > 0 {
		predicates = append(predicates, partner.SetupStepsCompletedIn(i.SetupStepsCompletedIn...))
	}
	if len(i.SetupStepsCompletedNotIn) > 0 {
		predicates = append(predicates, partner.SetupStepsCompletedNotIn(i.SetupStepsCompletedNotIn...))
	}
	if i.SetupStepsCompletedGT != nil {
		predicates = append(predicates, partner.SetupStepsCompletedGT(*i.SetupStepsCompletedGT))
	}
	if i.SetupStepsCompletedGTE != nil {
		predicates = append(predicates, partner.SetupStepsCompletedGTE(*i.SetupStepsCompletedGTE))
	}
	if i.SetupStepsCompletedLT != nil {
		predicates = append(predicates, partner.SetupStepsCompletedLT(*i.SetupStepsCompletedLT))
	}
	if i.SetupStepsCompletedLTE != nil {
		predicates = append(predicates, partner.SetupStepsCompletedLTE(*i.SetupStepsCompletedLTE))
	}
	if i.SalesVolume != nil {
		predicates = append(predicates, partner.SalesVolumeEQ(*i.SalesVolume))
	}
	if i.SalesVolumeNEQ != nil {
		predicates = append(predicates, partner.SalesVolumeNEQ(*i.SalesVolumeNEQ))
	}
	if len(i.SalesVolumeIn) > 0 {
		predicates = append(predicates, partner.SalesVolumeIn(i.SalesVolumeIn...))
	}
	if len(i.SalesVolumeNotIn) > 0 {
		predicates = append(predicates, partner.SalesVolumeNotIn(i.SalesVolumeNotIn...))
	}
	if i.SalesVolumeGT != nil {
		predicates = append(predicates, partner.SalesVolumeGT(*i.SalesVolumeGT))
	}
	if i.SalesVolumeGTE != nil {
		predicates = append(predicates, partner.SalesVolumeGTE(*i.SalesVolumeGTE))
	}
	if i.SalesVolumeLT != nil {
		predicates = append(predicates, partner.SalesVolumeLT(*i.SalesVolumeLT))
	}
	if i.SalesVolumeLTE != nil {
		predicates = append(predicates, partner.SalesVolumeLTE(*i.SalesVolumeLTE))
	}
	if i.SalesVolumeIsNil {
		predicates = append(predicates, partner.SalesVolumeIsNil())
	}
	if i.SalesVolumeNotNil {
		predicates = append(predicates, partner.SalesVolumeNotNil())
	}
	if i.DownPayment != nil {
		predicates = append(predicates, partner.DownPaymentEQ(*i.DownPayment))
	}
	if i.DownPaymentNEQ != nil {
		predicates = append(predicates, partner.DownPaymentNEQ(*i.DownPaymentNEQ))
	}
	if len(i.DownPaymentIn) > 0 {
		predicates = append(predicates, partner.DownPaymentIn(i.DownPaymentIn...))
	}
	if len(i.DownPaymentNotIn) > 0 {
		predicates = append(predicates, partner.DownPaymentNotIn(i.DownPaymentNotIn...))
	}
	if i.DownPaymentGT != nil {
		predicates = append(predicates, partner.DownPaymentGT(*i.DownPaymentGT))
	}
	if i.DownPaymentGTE != nil {
		predicates = append(predicates, partner.DownPaymentGTE(*i.DownPaymentGTE))
	}
	if i.DownPaymentLT != nil {
		predicates = append(predicates, partner.DownPaymentLT(*i.DownPaymentLT))
	}
	if i.DownPaymentLTE != nil {
		predicates = append(predicates, partner.DownPaymentLTE(*i.DownPaymentLTE))
	}
	if i.DownPaymentIsNil {
		predicates = append(predicates, partner.DownPaymentIsNil())
	}
	if i.DownPaymentNotNil {
		predicates = append(predicates, partner.DownPaymentNotNil())
	}
	if i.Pif != nil {
		predicates = append(predicates, partner.PifEQ(*i.Pif))
	}
	if i.PifNEQ != nil {
		predicates = append(predicates, partner.PifNEQ(*i.PifNEQ))
	}
	if len(i.PifIn) > 0 {
		predicates = append(predicates, partner.PifIn(i.PifIn...))
	}
	if len(i.PifNotIn) > 0 {
		predicates = append(predicates, partner.PifNotIn(i.PifNotIn...))
	}
	if i.PifGT != nil {
		predicates = append(predicates, partner.PifGT(*i.PifGT))
	}
	if i.PifGTE != nil {
		predicates = append(predicates, partner.PifGTE(*i.PifGTE))
	}
	if i.PifLT != nil {
		predicates = append(predicates, partner.PifLT(*i.PifLT))
	}
	if i.PifLTE != nil {
		predicates = append(predicates, partner.PifLTE(*i.PifLTE))
	}
	if i.PifIsNil {
		predicates = append(predicates, partner.PifIsNil())
	}
	if i.PifNotNil {
		predicates = append(predicates, partner.PifNotNil())
	}
	if i.InstallInHouse != nil {
		predicates = append(predicates, partner.InstallInHouseEQ(*i.InstallInHouse))
	}
	if i.InstallInHouseNEQ != nil {
		predicates = append(predicates, partner.InstallInHouseNEQ(*i.InstallInHouseNEQ))
	}
	if i.InstallInHouseIsNil {
		predicates = append(predicates, partner.InstallInHouseIsNil())
	}
	if i.InstallInHouseNotNil {
		predicates = append(predicates, partner.InstallInHouseNotNil())
	}
	if i.Status != nil {
		predicates = append(predicates, partner.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, partner.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, partner.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, partner.StatusNotIn(i.StatusNotIn...))
	}
	if i.EpcStatus != nil {
		predicates = append(predicates, partner.EpcStatusEQ(*i.EpcStatus))
	}
	if i.EpcStatusNEQ != nil {
		predicates = append(predicates, partner.EpcStatusNEQ(*i.EpcStatusNEQ))
	}
	if len(i.EpcStatusIn) > 0 {
		predicates = append(predicates, partner.EpcStatusIn(i.EpcStatusIn...))
	}
	if len(i.EpcStatusNotIn) > 0 {
		predicates = append(predicates, partner.EpcStatusNotIn(i.EpcStatusNotIn...))
	}
	if i.EpcStatusIsNil {
		predicates = append(predicates, partner.EpcStatusIsNil())
	}
	if i.EpcStatusNotNil {
		predicates = append(predicates, partner.EpcStatusNotNil())
	}

	if i.HasRequestedEstimates != nil {
		p := partner.HasRequestedEstimates()
		if !*i.HasRequestedEstimates {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestedEstimatesWith) > 0 {
		with := make([]predicate.Estimate, 0, len(i.HasRequestedEstimatesWith))
		for _, w := range i.HasRequestedEstimatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestedEstimatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasRequestedEstimatesWith(with...))
	}
	if i.HasEstimateHomeOwners != nil {
		p := partner.HasEstimateHomeOwners()
		if !*i.HasEstimateHomeOwners {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEstimateHomeOwnersWith) > 0 {
		with := make([]predicate.HomeOwner, 0, len(i.HasEstimateHomeOwnersWith))
		for _, w := range i.HasEstimateHomeOwnersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEstimateHomeOwnersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasEstimateHomeOwnersWith(with...))
	}
	if i.HasRoofingJobs != nil {
		p := partner.HasRoofingJobs()
		if !*i.HasRoofingJobs {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRoofingJobsWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasRoofingJobsWith))
		for _, w := range i.HasRoofingJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRoofingJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasRoofingJobsWith(with...))
	}
	if i.HasIntegrationJobs != nil {
		p := partner.HasIntegrationJobs()
		if !*i.HasIntegrationJobs {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasIntegrationJobsWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasIntegrationJobsWith))
		for _, w := range i.HasIntegrationJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasIntegrationJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasIntegrationJobsWith(with...))
	}
	if i.HasEpcJobs != nil {
		p := partner.HasEpcJobs()
		if !*i.HasEpcJobs {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpcJobsWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasEpcJobsWith))
		for _, w := range i.HasEpcJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpcJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasEpcJobsWith(with...))
	}
	if i.HasJobRequests != nil {
		p := partner.HasJobRequests()
		if !*i.HasJobRequests {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobRequestsWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobRequestsWith))
		for _, w := range i.HasJobRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasJobRequestsWith(with...))
	}
	if i.HasActivities != nil {
		p := partner.HasActivities()
		if !*i.HasActivities {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActivitiesWith) > 0 {
		with := make([]predicate.PartnerActivity, 0, len(i.HasActivitiesWith))
		for _, w := range i.HasActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasActivitiesWith(with...))
	}
	if i.HasJobAssignmentHistory != nil {
		p := partner.HasJobAssignmentHistory()
		if !*i.HasJobAssignmentHistory {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobAssignmentHistoryWith) > 0 {
		with := make([]predicate.JobAssignmentHistory, 0, len(i.HasJobAssignmentHistoryWith))
		for _, w := range i.HasJobAssignmentHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobAssignmentHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasJobAssignmentHistoryWith(with...))
	}
	if i.HasRequestedInstallationJobs != nil {
		p := partner.HasRequestedInstallationJobs()
		if !*i.HasRequestedInstallationJobs {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRequestedInstallationJobsWith) > 0 {
		with := make([]predicate.InstallationJob, 0, len(i.HasRequestedInstallationJobsWith))
		for _, w := range i.HasRequestedInstallationJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRequestedInstallationJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasRequestedInstallationJobsWith(with...))
	}
	if i.HasAssignedInstallationJobs != nil {
		p := partner.HasAssignedInstallationJobs()
		if !*i.HasAssignedInstallationJobs {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedInstallationJobsWith) > 0 {
		with := make([]predicate.InstallationJob, 0, len(i.HasAssignedInstallationJobsWith))
		for _, w := range i.HasAssignedInstallationJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedInstallationJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasAssignedInstallationJobsWith(with...))
	}
	if i.HasContacts != nil {
		p := partner.HasContacts()
		if !*i.HasContacts {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContactsWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasContactsWith))
		for _, w := range i.HasContactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasContactsWith(with...))
	}
	if i.HasCreator != nil {
		p := partner.HasCreator()
		if !*i.HasCreator {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasCreatorWith(with...))
	}
	if i.HasCreatorAPI != nil {
		p := partner.HasCreatorAPI()
		if !*i.HasCreatorAPI {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorAPIWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasCreatorAPIWith))
		for _, w := range i.HasCreatorAPIWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorAPIWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasCreatorAPIWith(with...))
	}
	if i.HasServices != nil {
		p := partner.HasServices()
		if !*i.HasServices {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServicesWith) > 0 {
		with := make([]predicate.PartnerService, 0, len(i.HasServicesWith))
		for _, w := range i.HasServicesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServicesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasServicesWith(with...))
	}
	if i.HasServiceStates != nil {
		p := partner.HasServiceStates()
		if !*i.HasServiceStates {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceStatesWith) > 0 {
		with := make([]predicate.PartnerServiceState, 0, len(i.HasServiceStatesWith))
		for _, w := range i.HasServiceStatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceStatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasServiceStatesWith(with...))
	}
	if i.HasServiceCities != nil {
		p := partner.HasServiceCities()
		if !*i.HasServiceCities {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasServiceCitiesWith) > 0 {
		with := make([]predicate.PartnerServiceCity, 0, len(i.HasServiceCitiesWith))
		for _, w := range i.HasServiceCitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasServiceCitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasServiceCitiesWith(with...))
	}
	if i.HasTrainingVideos != nil {
		p := partner.HasTrainingVideos()
		if !*i.HasTrainingVideos {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTrainingVideosWith) > 0 {
		with := make([]predicate.PartnerTrainingVideo, 0, len(i.HasTrainingVideosWith))
		for _, w := range i.HasTrainingVideosWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTrainingVideosWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasTrainingVideosWith(with...))
	}
	if i.HasContactUsRequests != nil {
		p := partner.HasContactUsRequests()
		if !*i.HasContactUsRequests {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContactUsRequestsWith) > 0 {
		with := make([]predicate.ContactUs, 0, len(i.HasContactUsRequestsWith))
		for _, w := range i.HasContactUsRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContactUsRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasContactUsRequestsWith(with...))
	}
	if i.HasSurveys != nil {
		p := partner.HasSurveys()
		if !*i.HasSurveys {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSurveysWith) > 0 {
		with := make([]predicate.Survey, 0, len(i.HasSurveysWith))
		for _, w := range i.HasSurveysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSurveysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasSurveysWith(with...))
	}
	if i.HasSessions != nil {
		p := partner.HasSessions()
		if !*i.HasSessions {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionsWith) > 0 {
		with := make([]predicate.UserSession, 0, len(i.HasSessionsWith))
		for _, w := range i.HasSessionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasSessionsWith(with...))
	}
	if i.HasJobNotes != nil {
		p := partner.HasJobNotes()
		if !*i.HasJobNotes {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobNotesWith) > 0 {
		with := make([]predicate.JobNote, 0, len(i.HasJobNotesWith))
		for _, w := range i.HasJobNotesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobNotesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasJobNotesWith(with...))
	}
	if i.HasChannels != nil {
		p := partner.HasChannels()
		if !*i.HasChannels {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelsWith) > 0 {
		with := make([]predicate.ChannelSub, 0, len(i.HasChannelsWith))
		for _, w := range i.HasChannelsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasChannelsWith(with...))
	}
	if i.HasFinanceOptions != nil {
		p := partner.HasFinanceOptions()
		if !*i.HasFinanceOptions {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasFinanceOptionsWith) > 0 {
		with := make([]predicate.OptionList, 0, len(i.HasFinanceOptionsWith))
		for _, w := range i.HasFinanceOptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasFinanceOptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasFinanceOptionsWith(with...))
	}
	if i.HasEpcOptions != nil {
		p := partner.HasEpcOptions()
		if !*i.HasEpcOptions {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEpcOptionsWith) > 0 {
		with := make([]predicate.OptionList, 0, len(i.HasEpcOptionsWith))
		for _, w := range i.HasEpcOptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEpcOptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasEpcOptionsWith(with...))
	}
	if i.HasPartnerContacts != nil {
		p := partner.HasPartnerContacts()
		if !*i.HasPartnerContacts {
			p = partner.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerContactsWith) > 0 {
		with := make([]predicate.PartnerContact, 0, len(i.HasPartnerContactsWith))
		for _, w := range i.HasPartnerContactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerContactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partner.HasPartnerContactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPartnerWhereInput
	case 1:
		return predicates[0], nil
	default:
		return partner.And(predicates...), nil
	}
}

// PartnerActivityWhereInput represents a where input for filtering PartnerActivity queries.
type PartnerActivityWhereInput struct {
	Predicates []predicate.PartnerActivity  `json:"-"`
	Not        *PartnerActivityWhereInput   `json:"not,omitempty"`
	Or         []*PartnerActivityWhereInput `json:"or,omitempty"`
	And        []*PartnerActivityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "creator_api" edge predicates.
	HasCreatorAPI     *bool                `json:"hasCreatorAPI,omitempty"`
	HasCreatorAPIWith []*ApiUserWhereInput `json:"hasCreatorAPIWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PartnerActivityWhereInput) AddPredicates(predicates ...predicate.PartnerActivity) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PartnerActivityWhereInput filter on the PartnerActivityQuery builder.
func (i *PartnerActivityWhereInput) Filter(q *PartnerActivityQuery) (*PartnerActivityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPartnerActivityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPartnerActivityWhereInput is returned in case the PartnerActivityWhereInput is empty.
var ErrEmptyPartnerActivityWhereInput = errors.New("ent: empty predicate PartnerActivityWhereInput")

// P returns a predicate for filtering partneractivities.
// An error is returned if the input is empty or invalid.
func (i *PartnerActivityWhereInput) P() (predicate.PartnerActivity, error) {
	var predicates []predicate.PartnerActivity
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, partneractivity.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PartnerActivity, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, partneractivity.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PartnerActivity, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, partneractivity.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, partneractivity.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, partneractivity.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, partneractivity.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, partneractivity.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, partneractivity.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, partneractivity.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, partneractivity.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, partneractivity.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, partneractivity.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, partneractivity.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, partneractivity.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, partneractivity.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, partneractivity.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, partneractivity.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, partneractivity.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, partneractivity.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, partneractivity.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, partneractivity.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, partneractivity.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, partneractivity.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, partneractivity.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, partneractivity.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, partneractivity.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, partneractivity.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, partneractivity.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, partneractivity.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, partneractivity.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, partneractivity.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, partneractivity.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, partneractivity.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, partneractivity.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasPartner != nil {
		p := partneractivity.HasPartner()
		if !*i.HasPartner {
			p = partneractivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partneractivity.HasPartnerWith(with...))
	}
	if i.HasCreator != nil {
		p := partneractivity.HasCreator()
		if !*i.HasCreator {
			p = partneractivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partneractivity.HasCreatorWith(with...))
	}
	if i.HasCreatorAPI != nil {
		p := partneractivity.HasCreatorAPI()
		if !*i.HasCreatorAPI {
			p = partneractivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorAPIWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasCreatorAPIWith))
		for _, w := range i.HasCreatorAPIWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorAPIWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partneractivity.HasCreatorAPIWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPartnerActivityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return partneractivity.And(predicates...), nil
	}
}

// PartnerContactWhereInput represents a where input for filtering PartnerContact queries.
type PartnerContactWhereInput struct {
	Predicates []predicate.PartnerContact  `json:"-"`
	Not        *PartnerContactWhereInput   `json:"not,omitempty"`
	Or         []*PartnerContactWhereInput `json:"or,omitempty"`
	And        []*PartnerContactWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "partner_id" field predicates.
	PartnerID             *string  `json:"partnerID,omitempty"`
	PartnerIDNEQ          *string  `json:"partnerIDNEQ,omitempty"`
	PartnerIDIn           []string `json:"partnerIDIn,omitempty"`
	PartnerIDNotIn        []string `json:"partnerIDNotIn,omitempty"`
	PartnerIDGT           *string  `json:"partnerIDGT,omitempty"`
	PartnerIDGTE          *string  `json:"partnerIDGTE,omitempty"`
	PartnerIDLT           *string  `json:"partnerIDLT,omitempty"`
	PartnerIDLTE          *string  `json:"partnerIDLTE,omitempty"`
	PartnerIDContains     *string  `json:"partnerIDContains,omitempty"`
	PartnerIDHasPrefix    *string  `json:"partnerIDHasPrefix,omitempty"`
	PartnerIDHasSuffix    *string  `json:"partnerIDHasSuffix,omitempty"`
	PartnerIDEqualFold    *string  `json:"partnerIDEqualFold,omitempty"`
	PartnerIDContainsFold *string  `json:"partnerIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "role" field predicates.
	Role      *enum.PartnerContactRole  `json:"role,omitempty"`
	RoleNEQ   *enum.PartnerContactRole  `json:"roleNEQ,omitempty"`
	RoleIn    []enum.PartnerContactRole `json:"roleIn,omitempty"`
	RoleNotIn []enum.PartnerContactRole `json:"roleNotIn,omitempty"`

	// "type" field predicates.
	Type      *enum.PartnerContact  `json:"type,omitempty"`
	TypeNEQ   *enum.PartnerContact  `json:"typeNEQ,omitempty"`
	TypeIn    []enum.PartnerContact `json:"typeIn,omitempty"`
	TypeNotIn []enum.PartnerContact `json:"typeNotIn,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleIsNil        bool     `json:"titleIsNil,omitempty"`
	TitleNotNil       bool     `json:"titleNotNil,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "invoicing_email" field predicates.
	InvoicingEmail             *string  `json:"invoicingEmail,omitempty"`
	InvoicingEmailNEQ          *string  `json:"invoicingEmailNEQ,omitempty"`
	InvoicingEmailIn           []string `json:"invoicingEmailIn,omitempty"`
	InvoicingEmailNotIn        []string `json:"invoicingEmailNotIn,omitempty"`
	InvoicingEmailGT           *string  `json:"invoicingEmailGT,omitempty"`
	InvoicingEmailGTE          *string  `json:"invoicingEmailGTE,omitempty"`
	InvoicingEmailLT           *string  `json:"invoicingEmailLT,omitempty"`
	InvoicingEmailLTE          *string  `json:"invoicingEmailLTE,omitempty"`
	InvoicingEmailContains     *string  `json:"invoicingEmailContains,omitempty"`
	InvoicingEmailHasPrefix    *string  `json:"invoicingEmailHasPrefix,omitempty"`
	InvoicingEmailHasSuffix    *string  `json:"invoicingEmailHasSuffix,omitempty"`
	InvoicingEmailIsNil        bool     `json:"invoicingEmailIsNil,omitempty"`
	InvoicingEmailNotNil       bool     `json:"invoicingEmailNotNil,omitempty"`
	InvoicingEmailEqualFold    *string  `json:"invoicingEmailEqualFold,omitempty"`
	InvoicingEmailContainsFold *string  `json:"invoicingEmailContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`

	// "sessions" edge predicates.
	HasSessions     *bool                    `json:"hasSessions,omitempty"`
	HasSessionsWith []*UserSessionWhereInput `json:"hasSessionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PartnerContactWhereInput) AddPredicates(predicates ...predicate.PartnerContact) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PartnerContactWhereInput filter on the PartnerContactQuery builder.
func (i *PartnerContactWhereInput) Filter(q *PartnerContactQuery) (*PartnerContactQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPartnerContactWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPartnerContactWhereInput is returned in case the PartnerContactWhereInput is empty.
var ErrEmptyPartnerContactWhereInput = errors.New("ent: empty predicate PartnerContactWhereInput")

// P returns a predicate for filtering partnercontacts.
// An error is returned if the input is empty or invalid.
func (i *PartnerContactWhereInput) P() (predicate.PartnerContact, error) {
	var predicates []predicate.PartnerContact
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, partnercontact.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PartnerContact, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, partnercontact.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PartnerContact, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, partnercontact.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, partnercontact.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, partnercontact.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, partnercontact.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, partnercontact.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, partnercontact.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, partnercontact.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, partnercontact.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, partnercontact.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, partnercontact.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, partnercontact.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, partnercontact.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, partnercontact.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, partnercontact.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, partnercontact.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, partnercontact.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, partnercontact.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, partnercontact.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, partnercontact.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, partnercontact.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, partnercontact.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, partnercontact.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, partnercontact.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, partnercontact.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, partnercontact.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, partnercontact.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, partnercontact.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.PartnerID != nil {
		predicates = append(predicates, partnercontact.PartnerIDEQ(*i.PartnerID))
	}
	if i.PartnerIDNEQ != nil {
		predicates = append(predicates, partnercontact.PartnerIDNEQ(*i.PartnerIDNEQ))
	}
	if len(i.PartnerIDIn) > 0 {
		predicates = append(predicates, partnercontact.PartnerIDIn(i.PartnerIDIn...))
	}
	if len(i.PartnerIDNotIn) > 0 {
		predicates = append(predicates, partnercontact.PartnerIDNotIn(i.PartnerIDNotIn...))
	}
	if i.PartnerIDGT != nil {
		predicates = append(predicates, partnercontact.PartnerIDGT(*i.PartnerIDGT))
	}
	if i.PartnerIDGTE != nil {
		predicates = append(predicates, partnercontact.PartnerIDGTE(*i.PartnerIDGTE))
	}
	if i.PartnerIDLT != nil {
		predicates = append(predicates, partnercontact.PartnerIDLT(*i.PartnerIDLT))
	}
	if i.PartnerIDLTE != nil {
		predicates = append(predicates, partnercontact.PartnerIDLTE(*i.PartnerIDLTE))
	}
	if i.PartnerIDContains != nil {
		predicates = append(predicates, partnercontact.PartnerIDContains(*i.PartnerIDContains))
	}
	if i.PartnerIDHasPrefix != nil {
		predicates = append(predicates, partnercontact.PartnerIDHasPrefix(*i.PartnerIDHasPrefix))
	}
	if i.PartnerIDHasSuffix != nil {
		predicates = append(predicates, partnercontact.PartnerIDHasSuffix(*i.PartnerIDHasSuffix))
	}
	if i.PartnerIDEqualFold != nil {
		predicates = append(predicates, partnercontact.PartnerIDEqualFold(*i.PartnerIDEqualFold))
	}
	if i.PartnerIDContainsFold != nil {
		predicates = append(predicates, partnercontact.PartnerIDContainsFold(*i.PartnerIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, partnercontact.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, partnercontact.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, partnercontact.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, partnercontact.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, partnercontact.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, partnercontact.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, partnercontact.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, partnercontact.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, partnercontact.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, partnercontact.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, partnercontact.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, partnercontact.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, partnercontact.UserIDContainsFold(*i.UserIDContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, partnercontact.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, partnercontact.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, partnercontact.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, partnercontact.RoleNotIn(i.RoleNotIn...))
	}
	if i.Type != nil {
		predicates = append(predicates, partnercontact.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, partnercontact.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, partnercontact.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, partnercontact.TypeNotIn(i.TypeNotIn...))
	}
	if i.Title != nil {
		predicates = append(predicates, partnercontact.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, partnercontact.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, partnercontact.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, partnercontact.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, partnercontact.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, partnercontact.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, partnercontact.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, partnercontact.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, partnercontact.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, partnercontact.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, partnercontact.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleIsNil {
		predicates = append(predicates, partnercontact.TitleIsNil())
	}
	if i.TitleNotNil {
		predicates = append(predicates, partnercontact.TitleNotNil())
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, partnercontact.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, partnercontact.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, partnercontact.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, partnercontact.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, partnercontact.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, partnercontact.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, partnercontact.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, partnercontact.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, partnercontact.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, partnercontact.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, partnercontact.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, partnercontact.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, partnercontact.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, partnercontact.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, partnercontact.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, partnercontact.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, partnercontact.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.InvoicingEmail != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailEQ(*i.InvoicingEmail))
	}
	if i.InvoicingEmailNEQ != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailNEQ(*i.InvoicingEmailNEQ))
	}
	if len(i.InvoicingEmailIn) > 0 {
		predicates = append(predicates, partnercontact.InvoicingEmailIn(i.InvoicingEmailIn...))
	}
	if len(i.InvoicingEmailNotIn) > 0 {
		predicates = append(predicates, partnercontact.InvoicingEmailNotIn(i.InvoicingEmailNotIn...))
	}
	if i.InvoicingEmailGT != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailGT(*i.InvoicingEmailGT))
	}
	if i.InvoicingEmailGTE != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailGTE(*i.InvoicingEmailGTE))
	}
	if i.InvoicingEmailLT != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailLT(*i.InvoicingEmailLT))
	}
	if i.InvoicingEmailLTE != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailLTE(*i.InvoicingEmailLTE))
	}
	if i.InvoicingEmailContains != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailContains(*i.InvoicingEmailContains))
	}
	if i.InvoicingEmailHasPrefix != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailHasPrefix(*i.InvoicingEmailHasPrefix))
	}
	if i.InvoicingEmailHasSuffix != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailHasSuffix(*i.InvoicingEmailHasSuffix))
	}
	if i.InvoicingEmailIsNil {
		predicates = append(predicates, partnercontact.InvoicingEmailIsNil())
	}
	if i.InvoicingEmailNotNil {
		predicates = append(predicates, partnercontact.InvoicingEmailNotNil())
	}
	if i.InvoicingEmailEqualFold != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailEqualFold(*i.InvoicingEmailEqualFold))
	}
	if i.InvoicingEmailContainsFold != nil {
		predicates = append(predicates, partnercontact.InvoicingEmailContainsFold(*i.InvoicingEmailContainsFold))
	}

	if i.HasUser != nil {
		p := partnercontact.HasUser()
		if !*i.HasUser {
			p = partnercontact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partnercontact.HasUserWith(with...))
	}
	if i.HasPartner != nil {
		p := partnercontact.HasPartner()
		if !*i.HasPartner {
			p = partnercontact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partnercontact.HasPartnerWith(with...))
	}
	if i.HasSessions != nil {
		p := partnercontact.HasSessions()
		if !*i.HasSessions {
			p = partnercontact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionsWith) > 0 {
		with := make([]predicate.UserSession, 0, len(i.HasSessionsWith))
		for _, w := range i.HasSessionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partnercontact.HasSessionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPartnerContactWhereInput
	case 1:
		return predicates[0], nil
	default:
		return partnercontact.And(predicates...), nil
	}
}

// PartnerServiceWhereInput represents a where input for filtering PartnerService queries.
type PartnerServiceWhereInput struct {
	Predicates []predicate.PartnerService  `json:"-"`
	Not        *PartnerServiceWhereInput   `json:"not,omitempty"`
	Or         []*PartnerServiceWhereInput `json:"or,omitempty"`
	And        []*PartnerServiceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "service_id" field predicates.
	ServiceID      *uint8  `json:"serviceID,omitempty"`
	ServiceIDNEQ   *uint8  `json:"serviceIDNEQ,omitempty"`
	ServiceIDIn    []uint8 `json:"serviceIDIn,omitempty"`
	ServiceIDNotIn []uint8 `json:"serviceIDNotIn,omitempty"`
	ServiceIDGT    *uint8  `json:"serviceIDGT,omitempty"`
	ServiceIDGTE   *uint8  `json:"serviceIDGTE,omitempty"`
	ServiceIDLT    *uint8  `json:"serviceIDLT,omitempty"`
	ServiceIDLTE   *uint8  `json:"serviceIDLTE,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PartnerServiceWhereInput) AddPredicates(predicates ...predicate.PartnerService) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PartnerServiceWhereInput filter on the PartnerServiceQuery builder.
func (i *PartnerServiceWhereInput) Filter(q *PartnerServiceQuery) (*PartnerServiceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPartnerServiceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPartnerServiceWhereInput is returned in case the PartnerServiceWhereInput is empty.
var ErrEmptyPartnerServiceWhereInput = errors.New("ent: empty predicate PartnerServiceWhereInput")

// P returns a predicate for filtering partnerservices.
// An error is returned if the input is empty or invalid.
func (i *PartnerServiceWhereInput) P() (predicate.PartnerService, error) {
	var predicates []predicate.PartnerService
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, partnerservice.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PartnerService, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, partnerservice.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PartnerService, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, partnerservice.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, partnerservice.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, partnerservice.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, partnerservice.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, partnerservice.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, partnerservice.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, partnerservice.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, partnerservice.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, partnerservice.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, partnerservice.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, partnerservice.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, partnerservice.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, partnerservice.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, partnerservice.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, partnerservice.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, partnerservice.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, partnerservice.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, partnerservice.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, partnerservice.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, partnerservice.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, partnerservice.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, partnerservice.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, partnerservice.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, partnerservice.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, partnerservice.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, partnerservice.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, partnerservice.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ServiceID != nil {
		predicates = append(predicates, partnerservice.ServiceIDEQ(*i.ServiceID))
	}
	if i.ServiceIDNEQ != nil {
		predicates = append(predicates, partnerservice.ServiceIDNEQ(*i.ServiceIDNEQ))
	}
	if len(i.ServiceIDIn) > 0 {
		predicates = append(predicates, partnerservice.ServiceIDIn(i.ServiceIDIn...))
	}
	if len(i.ServiceIDNotIn) > 0 {
		predicates = append(predicates, partnerservice.ServiceIDNotIn(i.ServiceIDNotIn...))
	}
	if i.ServiceIDGT != nil {
		predicates = append(predicates, partnerservice.ServiceIDGT(*i.ServiceIDGT))
	}
	if i.ServiceIDGTE != nil {
		predicates = append(predicates, partnerservice.ServiceIDGTE(*i.ServiceIDGTE))
	}
	if i.ServiceIDLT != nil {
		predicates = append(predicates, partnerservice.ServiceIDLT(*i.ServiceIDLT))
	}
	if i.ServiceIDLTE != nil {
		predicates = append(predicates, partnerservice.ServiceIDLTE(*i.ServiceIDLTE))
	}
	if i.Active != nil {
		predicates = append(predicates, partnerservice.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, partnerservice.ActiveNEQ(*i.ActiveNEQ))
	}

	if i.HasPartner != nil {
		p := partnerservice.HasPartner()
		if !*i.HasPartner {
			p = partnerservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partnerservice.HasPartnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPartnerServiceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return partnerservice.And(predicates...), nil
	}
}

// PartnerServiceCityWhereInput represents a where input for filtering PartnerServiceCity queries.
type PartnerServiceCityWhereInput struct {
	Predicates []predicate.PartnerServiceCity  `json:"-"`
	Not        *PartnerServiceCityWhereInput   `json:"not,omitempty"`
	Or         []*PartnerServiceCityWhereInput `json:"or,omitempty"`
	And        []*PartnerServiceCityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "postal_id" field predicates.
	PostalID             *string  `json:"postalID,omitempty"`
	PostalIDNEQ          *string  `json:"postalIDNEQ,omitempty"`
	PostalIDIn           []string `json:"postalIDIn,omitempty"`
	PostalIDNotIn        []string `json:"postalIDNotIn,omitempty"`
	PostalIDGT           *string  `json:"postalIDGT,omitempty"`
	PostalIDGTE          *string  `json:"postalIDGTE,omitempty"`
	PostalIDLT           *string  `json:"postalIDLT,omitempty"`
	PostalIDLTE          *string  `json:"postalIDLTE,omitempty"`
	PostalIDContains     *string  `json:"postalIDContains,omitempty"`
	PostalIDHasPrefix    *string  `json:"postalIDHasPrefix,omitempty"`
	PostalIDHasSuffix    *string  `json:"postalIDHasSuffix,omitempty"`
	PostalIDEqualFold    *string  `json:"postalIDEqualFold,omitempty"`
	PostalIDContainsFold *string  `json:"postalIDContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "naics_code" field predicates.
	NaicsCode      *uint  `json:"naicsCode,omitempty"`
	NaicsCodeNEQ   *uint  `json:"naicsCodeNEQ,omitempty"`
	NaicsCodeIn    []uint `json:"naicsCodeIn,omitempty"`
	NaicsCodeNotIn []uint `json:"naicsCodeNotIn,omitempty"`
	NaicsCodeGT    *uint  `json:"naicsCodeGT,omitempty"`
	NaicsCodeGTE   *uint  `json:"naicsCodeGTE,omitempty"`
	NaicsCodeLT    *uint  `json:"naicsCodeLT,omitempty"`
	NaicsCodeLTE   *uint  `json:"naicsCodeLTE,omitempty"`

	// "license_no" field predicates.
	LicenseNo             *string  `json:"licenseNo,omitempty"`
	LicenseNoNEQ          *string  `json:"licenseNoNEQ,omitempty"`
	LicenseNoIn           []string `json:"licenseNoIn,omitempty"`
	LicenseNoNotIn        []string `json:"licenseNoNotIn,omitempty"`
	LicenseNoGT           *string  `json:"licenseNoGT,omitempty"`
	LicenseNoGTE          *string  `json:"licenseNoGTE,omitempty"`
	LicenseNoLT           *string  `json:"licenseNoLT,omitempty"`
	LicenseNoLTE          *string  `json:"licenseNoLTE,omitempty"`
	LicenseNoContains     *string  `json:"licenseNoContains,omitempty"`
	LicenseNoHasPrefix    *string  `json:"licenseNoHasPrefix,omitempty"`
	LicenseNoHasSuffix    *string  `json:"licenseNoHasSuffix,omitempty"`
	LicenseNoIsNil        bool     `json:"licenseNoIsNil,omitempty"`
	LicenseNoNotNil       bool     `json:"licenseNoNotNil,omitempty"`
	LicenseNoEqualFold    *string  `json:"licenseNoEqualFold,omitempty"`
	LicenseNoContainsFold *string  `json:"licenseNoContainsFold,omitempty"`

	// "proof_doc_id" field predicates.
	ProofDocID             *string  `json:"proofDocID,omitempty"`
	ProofDocIDNEQ          *string  `json:"proofDocIDNEQ,omitempty"`
	ProofDocIDIn           []string `json:"proofDocIDIn,omitempty"`
	ProofDocIDNotIn        []string `json:"proofDocIDNotIn,omitempty"`
	ProofDocIDGT           *string  `json:"proofDocIDGT,omitempty"`
	ProofDocIDGTE          *string  `json:"proofDocIDGTE,omitempty"`
	ProofDocIDLT           *string  `json:"proofDocIDLT,omitempty"`
	ProofDocIDLTE          *string  `json:"proofDocIDLTE,omitempty"`
	ProofDocIDContains     *string  `json:"proofDocIDContains,omitempty"`
	ProofDocIDHasPrefix    *string  `json:"proofDocIDHasPrefix,omitempty"`
	ProofDocIDHasSuffix    *string  `json:"proofDocIDHasSuffix,omitempty"`
	ProofDocIDIsNil        bool     `json:"proofDocIDIsNil,omitempty"`
	ProofDocIDNotNil       bool     `json:"proofDocIDNotNil,omitempty"`
	ProofDocIDEqualFold    *string  `json:"proofDocIDEqualFold,omitempty"`
	ProofDocIDContainsFold *string  `json:"proofDocIDContainsFold,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PartnerServiceCityWhereInput) AddPredicates(predicates ...predicate.PartnerServiceCity) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PartnerServiceCityWhereInput filter on the PartnerServiceCityQuery builder.
func (i *PartnerServiceCityWhereInput) Filter(q *PartnerServiceCityQuery) (*PartnerServiceCityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPartnerServiceCityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPartnerServiceCityWhereInput is returned in case the PartnerServiceCityWhereInput is empty.
var ErrEmptyPartnerServiceCityWhereInput = errors.New("ent: empty predicate PartnerServiceCityWhereInput")

// P returns a predicate for filtering partnerservicecities.
// An error is returned if the input is empty or invalid.
func (i *PartnerServiceCityWhereInput) P() (predicate.PartnerServiceCity, error) {
	var predicates []predicate.PartnerServiceCity
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, partnerservicecity.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PartnerServiceCity, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, partnerservicecity.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PartnerServiceCity, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, partnerservicecity.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, partnerservicecity.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, partnerservicecity.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, partnerservicecity.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, partnerservicecity.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, partnerservicecity.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, partnerservicecity.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, partnerservicecity.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, partnerservicecity.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, partnerservicecity.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, partnerservicecity.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, partnerservicecity.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, partnerservicecity.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, partnerservicecity.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, partnerservicecity.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, partnerservicecity.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, partnerservicecity.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, partnerservicecity.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, partnerservicecity.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, partnerservicecity.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, partnerservicecity.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, partnerservicecity.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, partnerservicecity.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, partnerservicecity.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, partnerservicecity.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, partnerservicecity.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, partnerservicecity.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.PostalID != nil {
		predicates = append(predicates, partnerservicecity.PostalIDEQ(*i.PostalID))
	}
	if i.PostalIDNEQ != nil {
		predicates = append(predicates, partnerservicecity.PostalIDNEQ(*i.PostalIDNEQ))
	}
	if len(i.PostalIDIn) > 0 {
		predicates = append(predicates, partnerservicecity.PostalIDIn(i.PostalIDIn...))
	}
	if len(i.PostalIDNotIn) > 0 {
		predicates = append(predicates, partnerservicecity.PostalIDNotIn(i.PostalIDNotIn...))
	}
	if i.PostalIDGT != nil {
		predicates = append(predicates, partnerservicecity.PostalIDGT(*i.PostalIDGT))
	}
	if i.PostalIDGTE != nil {
		predicates = append(predicates, partnerservicecity.PostalIDGTE(*i.PostalIDGTE))
	}
	if i.PostalIDLT != nil {
		predicates = append(predicates, partnerservicecity.PostalIDLT(*i.PostalIDLT))
	}
	if i.PostalIDLTE != nil {
		predicates = append(predicates, partnerservicecity.PostalIDLTE(*i.PostalIDLTE))
	}
	if i.PostalIDContains != nil {
		predicates = append(predicates, partnerservicecity.PostalIDContains(*i.PostalIDContains))
	}
	if i.PostalIDHasPrefix != nil {
		predicates = append(predicates, partnerservicecity.PostalIDHasPrefix(*i.PostalIDHasPrefix))
	}
	if i.PostalIDHasSuffix != nil {
		predicates = append(predicates, partnerservicecity.PostalIDHasSuffix(*i.PostalIDHasSuffix))
	}
	if i.PostalIDEqualFold != nil {
		predicates = append(predicates, partnerservicecity.PostalIDEqualFold(*i.PostalIDEqualFold))
	}
	if i.PostalIDContainsFold != nil {
		predicates = append(predicates, partnerservicecity.PostalIDContainsFold(*i.PostalIDContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, partnerservicecity.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, partnerservicecity.ActiveNEQ(*i.ActiveNEQ))
	}
	if i.Name != nil {
		predicates = append(predicates, partnerservicecity.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, partnerservicecity.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, partnerservicecity.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, partnerservicecity.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, partnerservicecity.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, partnerservicecity.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, partnerservicecity.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, partnerservicecity.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, partnerservicecity.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, partnerservicecity.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, partnerservicecity.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, partnerservicecity.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, partnerservicecity.NameContainsFold(*i.NameContainsFold))
	}
	if i.NaicsCode != nil {
		predicates = append(predicates, partnerservicecity.NaicsCodeEQ(*i.NaicsCode))
	}
	if i.NaicsCodeNEQ != nil {
		predicates = append(predicates, partnerservicecity.NaicsCodeNEQ(*i.NaicsCodeNEQ))
	}
	if len(i.NaicsCodeIn) > 0 {
		predicates = append(predicates, partnerservicecity.NaicsCodeIn(i.NaicsCodeIn...))
	}
	if len(i.NaicsCodeNotIn) > 0 {
		predicates = append(predicates, partnerservicecity.NaicsCodeNotIn(i.NaicsCodeNotIn...))
	}
	if i.NaicsCodeGT != nil {
		predicates = append(predicates, partnerservicecity.NaicsCodeGT(*i.NaicsCodeGT))
	}
	if i.NaicsCodeGTE != nil {
		predicates = append(predicates, partnerservicecity.NaicsCodeGTE(*i.NaicsCodeGTE))
	}
	if i.NaicsCodeLT != nil {
		predicates = append(predicates, partnerservicecity.NaicsCodeLT(*i.NaicsCodeLT))
	}
	if i.NaicsCodeLTE != nil {
		predicates = append(predicates, partnerservicecity.NaicsCodeLTE(*i.NaicsCodeLTE))
	}
	if i.LicenseNo != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoEQ(*i.LicenseNo))
	}
	if i.LicenseNoNEQ != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoNEQ(*i.LicenseNoNEQ))
	}
	if len(i.LicenseNoIn) > 0 {
		predicates = append(predicates, partnerservicecity.LicenseNoIn(i.LicenseNoIn...))
	}
	if len(i.LicenseNoNotIn) > 0 {
		predicates = append(predicates, partnerservicecity.LicenseNoNotIn(i.LicenseNoNotIn...))
	}
	if i.LicenseNoGT != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoGT(*i.LicenseNoGT))
	}
	if i.LicenseNoGTE != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoGTE(*i.LicenseNoGTE))
	}
	if i.LicenseNoLT != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoLT(*i.LicenseNoLT))
	}
	if i.LicenseNoLTE != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoLTE(*i.LicenseNoLTE))
	}
	if i.LicenseNoContains != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoContains(*i.LicenseNoContains))
	}
	if i.LicenseNoHasPrefix != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoHasPrefix(*i.LicenseNoHasPrefix))
	}
	if i.LicenseNoHasSuffix != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoHasSuffix(*i.LicenseNoHasSuffix))
	}
	if i.LicenseNoIsNil {
		predicates = append(predicates, partnerservicecity.LicenseNoIsNil())
	}
	if i.LicenseNoNotNil {
		predicates = append(predicates, partnerservicecity.LicenseNoNotNil())
	}
	if i.LicenseNoEqualFold != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoEqualFold(*i.LicenseNoEqualFold))
	}
	if i.LicenseNoContainsFold != nil {
		predicates = append(predicates, partnerservicecity.LicenseNoContainsFold(*i.LicenseNoContainsFold))
	}
	if i.ProofDocID != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDEQ(*i.ProofDocID))
	}
	if i.ProofDocIDNEQ != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDNEQ(*i.ProofDocIDNEQ))
	}
	if len(i.ProofDocIDIn) > 0 {
		predicates = append(predicates, partnerservicecity.ProofDocIDIn(i.ProofDocIDIn...))
	}
	if len(i.ProofDocIDNotIn) > 0 {
		predicates = append(predicates, partnerservicecity.ProofDocIDNotIn(i.ProofDocIDNotIn...))
	}
	if i.ProofDocIDGT != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDGT(*i.ProofDocIDGT))
	}
	if i.ProofDocIDGTE != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDGTE(*i.ProofDocIDGTE))
	}
	if i.ProofDocIDLT != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDLT(*i.ProofDocIDLT))
	}
	if i.ProofDocIDLTE != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDLTE(*i.ProofDocIDLTE))
	}
	if i.ProofDocIDContains != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDContains(*i.ProofDocIDContains))
	}
	if i.ProofDocIDHasPrefix != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDHasPrefix(*i.ProofDocIDHasPrefix))
	}
	if i.ProofDocIDHasSuffix != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDHasSuffix(*i.ProofDocIDHasSuffix))
	}
	if i.ProofDocIDIsNil {
		predicates = append(predicates, partnerservicecity.ProofDocIDIsNil())
	}
	if i.ProofDocIDNotNil {
		predicates = append(predicates, partnerservicecity.ProofDocIDNotNil())
	}
	if i.ProofDocIDEqualFold != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDEqualFold(*i.ProofDocIDEqualFold))
	}
	if i.ProofDocIDContainsFold != nil {
		predicates = append(predicates, partnerservicecity.ProofDocIDContainsFold(*i.ProofDocIDContainsFold))
	}

	if i.HasPartner != nil {
		p := partnerservicecity.HasPartner()
		if !*i.HasPartner {
			p = partnerservicecity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partnerservicecity.HasPartnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPartnerServiceCityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return partnerservicecity.And(predicates...), nil
	}
}

// PartnerServiceStateWhereInput represents a where input for filtering PartnerServiceState queries.
type PartnerServiceStateWhereInput struct {
	Predicates []predicate.PartnerServiceState  `json:"-"`
	Not        *PartnerServiceStateWhereInput   `json:"not,omitempty"`
	Or         []*PartnerServiceStateWhereInput `json:"or,omitempty"`
	And        []*PartnerServiceStateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "state" field predicates.
	State             *string  `json:"state,omitempty"`
	StateNEQ          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGT           *string  `json:"stateGT,omitempty"`
	StateGTE          *string  `json:"stateGTE,omitempty"`
	StateLT           *string  `json:"stateLT,omitempty"`
	StateLTE          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`

	// "license_no" field predicates.
	LicenseNo             *string  `json:"licenseNo,omitempty"`
	LicenseNoNEQ          *string  `json:"licenseNoNEQ,omitempty"`
	LicenseNoIn           []string `json:"licenseNoIn,omitempty"`
	LicenseNoNotIn        []string `json:"licenseNoNotIn,omitempty"`
	LicenseNoGT           *string  `json:"licenseNoGT,omitempty"`
	LicenseNoGTE          *string  `json:"licenseNoGTE,omitempty"`
	LicenseNoLT           *string  `json:"licenseNoLT,omitempty"`
	LicenseNoLTE          *string  `json:"licenseNoLTE,omitempty"`
	LicenseNoContains     *string  `json:"licenseNoContains,omitempty"`
	LicenseNoHasPrefix    *string  `json:"licenseNoHasPrefix,omitempty"`
	LicenseNoHasSuffix    *string  `json:"licenseNoHasSuffix,omitempty"`
	LicenseNoIsNil        bool     `json:"licenseNoIsNil,omitempty"`
	LicenseNoNotNil       bool     `json:"licenseNoNotNil,omitempty"`
	LicenseNoEqualFold    *string  `json:"licenseNoEqualFold,omitempty"`
	LicenseNoContainsFold *string  `json:"licenseNoContainsFold,omitempty"`

	// "license_exp_date" field predicates.
	LicenseExpDate       *time.Time  `json:"licenseExpDate,omitempty"`
	LicenseExpDateNEQ    *time.Time  `json:"licenseExpDateNEQ,omitempty"`
	LicenseExpDateIn     []time.Time `json:"licenseExpDateIn,omitempty"`
	LicenseExpDateNotIn  []time.Time `json:"licenseExpDateNotIn,omitempty"`
	LicenseExpDateGT     *time.Time  `json:"licenseExpDateGT,omitempty"`
	LicenseExpDateGTE    *time.Time  `json:"licenseExpDateGTE,omitempty"`
	LicenseExpDateLT     *time.Time  `json:"licenseExpDateLT,omitempty"`
	LicenseExpDateLTE    *time.Time  `json:"licenseExpDateLTE,omitempty"`
	LicenseExpDateIsNil  bool        `json:"licenseExpDateIsNil,omitempty"`
	LicenseExpDateNotNil bool        `json:"licenseExpDateNotNil,omitempty"`

	// "proof_doc_id" field predicates.
	ProofDocID             *string  `json:"proofDocID,omitempty"`
	ProofDocIDNEQ          *string  `json:"proofDocIDNEQ,omitempty"`
	ProofDocIDIn           []string `json:"proofDocIDIn,omitempty"`
	ProofDocIDNotIn        []string `json:"proofDocIDNotIn,omitempty"`
	ProofDocIDGT           *string  `json:"proofDocIDGT,omitempty"`
	ProofDocIDGTE          *string  `json:"proofDocIDGTE,omitempty"`
	ProofDocIDLT           *string  `json:"proofDocIDLT,omitempty"`
	ProofDocIDLTE          *string  `json:"proofDocIDLTE,omitempty"`
	ProofDocIDContains     *string  `json:"proofDocIDContains,omitempty"`
	ProofDocIDHasPrefix    *string  `json:"proofDocIDHasPrefix,omitempty"`
	ProofDocIDHasSuffix    *string  `json:"proofDocIDHasSuffix,omitempty"`
	ProofDocIDIsNil        bool     `json:"proofDocIDIsNil,omitempty"`
	ProofDocIDNotNil       bool     `json:"proofDocIDNotNil,omitempty"`
	ProofDocIDEqualFold    *string  `json:"proofDocIDEqualFold,omitempty"`
	ProofDocIDContainsFold *string  `json:"proofDocIDContainsFold,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PartnerServiceStateWhereInput) AddPredicates(predicates ...predicate.PartnerServiceState) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PartnerServiceStateWhereInput filter on the PartnerServiceStateQuery builder.
func (i *PartnerServiceStateWhereInput) Filter(q *PartnerServiceStateQuery) (*PartnerServiceStateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPartnerServiceStateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPartnerServiceStateWhereInput is returned in case the PartnerServiceStateWhereInput is empty.
var ErrEmptyPartnerServiceStateWhereInput = errors.New("ent: empty predicate PartnerServiceStateWhereInput")

// P returns a predicate for filtering partnerservicestates.
// An error is returned if the input is empty or invalid.
func (i *PartnerServiceStateWhereInput) P() (predicate.PartnerServiceState, error) {
	var predicates []predicate.PartnerServiceState
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, partnerservicestate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PartnerServiceState, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, partnerservicestate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PartnerServiceState, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, partnerservicestate.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, partnerservicestate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, partnerservicestate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, partnerservicestate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, partnerservicestate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, partnerservicestate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, partnerservicestate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, partnerservicestate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, partnerservicestate.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, partnerservicestate.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, partnerservicestate.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, partnerservicestate.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, partnerservicestate.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, partnerservicestate.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, partnerservicestate.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, partnerservicestate.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, partnerservicestate.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, partnerservicestate.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, partnerservicestate.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, partnerservicestate.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, partnerservicestate.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, partnerservicestate.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, partnerservicestate.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, partnerservicestate.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, partnerservicestate.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, partnerservicestate.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, partnerservicestate.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Country != nil {
		predicates = append(predicates, partnerservicestate.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, partnerservicestate.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, partnerservicestate.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, partnerservicestate.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, partnerservicestate.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, partnerservicestate.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, partnerservicestate.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, partnerservicestate.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, partnerservicestate.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, partnerservicestate.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, partnerservicestate.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, partnerservicestate.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, partnerservicestate.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.State != nil {
		predicates = append(predicates, partnerservicestate.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, partnerservicestate.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, partnerservicestate.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, partnerservicestate.StateNotIn(i.StateNotIn...))
	}
	if i.StateGT != nil {
		predicates = append(predicates, partnerservicestate.StateGT(*i.StateGT))
	}
	if i.StateGTE != nil {
		predicates = append(predicates, partnerservicestate.StateGTE(*i.StateGTE))
	}
	if i.StateLT != nil {
		predicates = append(predicates, partnerservicestate.StateLT(*i.StateLT))
	}
	if i.StateLTE != nil {
		predicates = append(predicates, partnerservicestate.StateLTE(*i.StateLTE))
	}
	if i.StateContains != nil {
		predicates = append(predicates, partnerservicestate.StateContains(*i.StateContains))
	}
	if i.StateHasPrefix != nil {
		predicates = append(predicates, partnerservicestate.StateHasPrefix(*i.StateHasPrefix))
	}
	if i.StateHasSuffix != nil {
		predicates = append(predicates, partnerservicestate.StateHasSuffix(*i.StateHasSuffix))
	}
	if i.StateEqualFold != nil {
		predicates = append(predicates, partnerservicestate.StateEqualFold(*i.StateEqualFold))
	}
	if i.StateContainsFold != nil {
		predicates = append(predicates, partnerservicestate.StateContainsFold(*i.StateContainsFold))
	}
	if i.LicenseNo != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoEQ(*i.LicenseNo))
	}
	if i.LicenseNoNEQ != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoNEQ(*i.LicenseNoNEQ))
	}
	if len(i.LicenseNoIn) > 0 {
		predicates = append(predicates, partnerservicestate.LicenseNoIn(i.LicenseNoIn...))
	}
	if len(i.LicenseNoNotIn) > 0 {
		predicates = append(predicates, partnerservicestate.LicenseNoNotIn(i.LicenseNoNotIn...))
	}
	if i.LicenseNoGT != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoGT(*i.LicenseNoGT))
	}
	if i.LicenseNoGTE != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoGTE(*i.LicenseNoGTE))
	}
	if i.LicenseNoLT != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoLT(*i.LicenseNoLT))
	}
	if i.LicenseNoLTE != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoLTE(*i.LicenseNoLTE))
	}
	if i.LicenseNoContains != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoContains(*i.LicenseNoContains))
	}
	if i.LicenseNoHasPrefix != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoHasPrefix(*i.LicenseNoHasPrefix))
	}
	if i.LicenseNoHasSuffix != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoHasSuffix(*i.LicenseNoHasSuffix))
	}
	if i.LicenseNoIsNil {
		predicates = append(predicates, partnerservicestate.LicenseNoIsNil())
	}
	if i.LicenseNoNotNil {
		predicates = append(predicates, partnerservicestate.LicenseNoNotNil())
	}
	if i.LicenseNoEqualFold != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoEqualFold(*i.LicenseNoEqualFold))
	}
	if i.LicenseNoContainsFold != nil {
		predicates = append(predicates, partnerservicestate.LicenseNoContainsFold(*i.LicenseNoContainsFold))
	}
	if i.LicenseExpDate != nil {
		predicates = append(predicates, partnerservicestate.LicenseExpDateEQ(*i.LicenseExpDate))
	}
	if i.LicenseExpDateNEQ != nil {
		predicates = append(predicates, partnerservicestate.LicenseExpDateNEQ(*i.LicenseExpDateNEQ))
	}
	if len(i.LicenseExpDateIn) > 0 {
		predicates = append(predicates, partnerservicestate.LicenseExpDateIn(i.LicenseExpDateIn...))
	}
	if len(i.LicenseExpDateNotIn) > 0 {
		predicates = append(predicates, partnerservicestate.LicenseExpDateNotIn(i.LicenseExpDateNotIn...))
	}
	if i.LicenseExpDateGT != nil {
		predicates = append(predicates, partnerservicestate.LicenseExpDateGT(*i.LicenseExpDateGT))
	}
	if i.LicenseExpDateGTE != nil {
		predicates = append(predicates, partnerservicestate.LicenseExpDateGTE(*i.LicenseExpDateGTE))
	}
	if i.LicenseExpDateLT != nil {
		predicates = append(predicates, partnerservicestate.LicenseExpDateLT(*i.LicenseExpDateLT))
	}
	if i.LicenseExpDateLTE != nil {
		predicates = append(predicates, partnerservicestate.LicenseExpDateLTE(*i.LicenseExpDateLTE))
	}
	if i.LicenseExpDateIsNil {
		predicates = append(predicates, partnerservicestate.LicenseExpDateIsNil())
	}
	if i.LicenseExpDateNotNil {
		predicates = append(predicates, partnerservicestate.LicenseExpDateNotNil())
	}
	if i.ProofDocID != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDEQ(*i.ProofDocID))
	}
	if i.ProofDocIDNEQ != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDNEQ(*i.ProofDocIDNEQ))
	}
	if len(i.ProofDocIDIn) > 0 {
		predicates = append(predicates, partnerservicestate.ProofDocIDIn(i.ProofDocIDIn...))
	}
	if len(i.ProofDocIDNotIn) > 0 {
		predicates = append(predicates, partnerservicestate.ProofDocIDNotIn(i.ProofDocIDNotIn...))
	}
	if i.ProofDocIDGT != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDGT(*i.ProofDocIDGT))
	}
	if i.ProofDocIDGTE != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDGTE(*i.ProofDocIDGTE))
	}
	if i.ProofDocIDLT != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDLT(*i.ProofDocIDLT))
	}
	if i.ProofDocIDLTE != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDLTE(*i.ProofDocIDLTE))
	}
	if i.ProofDocIDContains != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDContains(*i.ProofDocIDContains))
	}
	if i.ProofDocIDHasPrefix != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDHasPrefix(*i.ProofDocIDHasPrefix))
	}
	if i.ProofDocIDHasSuffix != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDHasSuffix(*i.ProofDocIDHasSuffix))
	}
	if i.ProofDocIDIsNil {
		predicates = append(predicates, partnerservicestate.ProofDocIDIsNil())
	}
	if i.ProofDocIDNotNil {
		predicates = append(predicates, partnerservicestate.ProofDocIDNotNil())
	}
	if i.ProofDocIDEqualFold != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDEqualFold(*i.ProofDocIDEqualFold))
	}
	if i.ProofDocIDContainsFold != nil {
		predicates = append(predicates, partnerservicestate.ProofDocIDContainsFold(*i.ProofDocIDContainsFold))
	}

	if i.HasPartner != nil {
		p := partnerservicestate.HasPartner()
		if !*i.HasPartner {
			p = partnerservicestate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partnerservicestate.HasPartnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPartnerServiceStateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return partnerservicestate.And(predicates...), nil
	}
}

// PartnerTrainingVideoWhereInput represents a where input for filtering PartnerTrainingVideo queries.
type PartnerTrainingVideoWhereInput struct {
	Predicates []predicate.PartnerTrainingVideo  `json:"-"`
	Not        *PartnerTrainingVideoWhereInput   `json:"not,omitempty"`
	Or         []*PartnerTrainingVideoWhereInput `json:"or,omitempty"`
	And        []*PartnerTrainingVideoWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "enabled" field predicates.
	Enabled    *bool `json:"enabled,omitempty"`
	EnabledNEQ *bool `json:"enabledNEQ,omitempty"`

	// "video" edge predicates.
	HasVideo     *bool                      `json:"hasVideo,omitempty"`
	HasVideoWith []*TrainingVideoWhereInput `json:"hasVideoWith,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PartnerTrainingVideoWhereInput) AddPredicates(predicates ...predicate.PartnerTrainingVideo) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PartnerTrainingVideoWhereInput filter on the PartnerTrainingVideoQuery builder.
func (i *PartnerTrainingVideoWhereInput) Filter(q *PartnerTrainingVideoQuery) (*PartnerTrainingVideoQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPartnerTrainingVideoWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPartnerTrainingVideoWhereInput is returned in case the PartnerTrainingVideoWhereInput is empty.
var ErrEmptyPartnerTrainingVideoWhereInput = errors.New("ent: empty predicate PartnerTrainingVideoWhereInput")

// P returns a predicate for filtering partnertrainingvideos.
// An error is returned if the input is empty or invalid.
func (i *PartnerTrainingVideoWhereInput) P() (predicate.PartnerTrainingVideo, error) {
	var predicates []predicate.PartnerTrainingVideo
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, partnertrainingvideo.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PartnerTrainingVideo, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, partnertrainingvideo.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PartnerTrainingVideo, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, partnertrainingvideo.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, partnertrainingvideo.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, partnertrainingvideo.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, partnertrainingvideo.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, partnertrainingvideo.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, partnertrainingvideo.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, partnertrainingvideo.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, partnertrainingvideo.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, partnertrainingvideo.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, partnertrainingvideo.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, partnertrainingvideo.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, partnertrainingvideo.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, partnertrainingvideo.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, partnertrainingvideo.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, partnertrainingvideo.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, partnertrainingvideo.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, partnertrainingvideo.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, partnertrainingvideo.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, partnertrainingvideo.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, partnertrainingvideo.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, partnertrainingvideo.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, partnertrainingvideo.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, partnertrainingvideo.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, partnertrainingvideo.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, partnertrainingvideo.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, partnertrainingvideo.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, partnertrainingvideo.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Enabled != nil {
		predicates = append(predicates, partnertrainingvideo.EnabledEQ(*i.Enabled))
	}
	if i.EnabledNEQ != nil {
		predicates = append(predicates, partnertrainingvideo.EnabledNEQ(*i.EnabledNEQ))
	}

	if i.HasVideo != nil {
		p := partnertrainingvideo.HasVideo()
		if !*i.HasVideo {
			p = partnertrainingvideo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVideoWith) > 0 {
		with := make([]predicate.TrainingVideo, 0, len(i.HasVideoWith))
		for _, w := range i.HasVideoWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVideoWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partnertrainingvideo.HasVideoWith(with...))
	}
	if i.HasPartner != nil {
		p := partnertrainingvideo.HasPartner()
		if !*i.HasPartner {
			p = partnertrainingvideo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, partnertrainingvideo.HasPartnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPartnerTrainingVideoWhereInput
	case 1:
		return predicates[0], nil
	default:
		return partnertrainingvideo.And(predicates...), nil
	}
}

// PaymentWhereInput represents a where input for filtering Payment queries.
type PaymentWhereInput struct {
	Predicates []predicate.Payment  `json:"-"`
	Not        *PaymentWhereInput   `json:"not,omitempty"`
	Or         []*PaymentWhereInput `json:"or,omitempty"`
	And        []*PaymentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "amount" field predicates.
	Amount      *float64  `json:"amount,omitempty"`
	AmountNEQ   *float64  `json:"amountNEQ,omitempty"`
	AmountIn    []float64 `json:"amountIn,omitempty"`
	AmountNotIn []float64 `json:"amountNotIn,omitempty"`
	AmountGT    *float64  `json:"amountGT,omitempty"`
	AmountGTE   *float64  `json:"amountGTE,omitempty"`
	AmountLT    *float64  `json:"amountLT,omitempty"`
	AmountLTE   *float64  `json:"amountLTE,omitempty"`

	// "status_id" field predicates.
	StatusID      *uint8  `json:"statusID,omitempty"`
	StatusIDNEQ   *uint8  `json:"statusIDNEQ,omitempty"`
	StatusIDIn    []uint8 `json:"statusIDIn,omitempty"`
	StatusIDNotIn []uint8 `json:"statusIDNotIn,omitempty"`
	StatusIDGT    *uint8  `json:"statusIDGT,omitempty"`
	StatusIDGTE   *uint8  `json:"statusIDGTE,omitempty"`
	StatusIDLT    *uint8  `json:"statusIDLT,omitempty"`
	StatusIDLTE   *uint8  `json:"statusIDLTE,omitempty"`

	// "job" edge predicates.
	HasJob     *bool            `json:"hasJob,omitempty"`
	HasJobWith []*JobWhereInput `json:"hasJobWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PaymentWhereInput) AddPredicates(predicates ...predicate.Payment) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PaymentWhereInput filter on the PaymentQuery builder.
func (i *PaymentWhereInput) Filter(q *PaymentQuery) (*PaymentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPaymentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPaymentWhereInput is returned in case the PaymentWhereInput is empty.
var ErrEmptyPaymentWhereInput = errors.New("ent: empty predicate PaymentWhereInput")

// P returns a predicate for filtering payments.
// An error is returned if the input is empty or invalid.
func (i *PaymentWhereInput) P() (predicate.Payment, error) {
	var predicates []predicate.Payment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, payment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Payment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, payment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Payment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, payment.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, payment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, payment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, payment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, payment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, payment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, payment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, payment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, payment.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, payment.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, payment.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, payment.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, payment.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, payment.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, payment.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, payment.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, payment.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, payment.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, payment.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, payment.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, payment.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, payment.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, payment.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, payment.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, payment.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, payment.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, payment.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Amount != nil {
		predicates = append(predicates, payment.AmountEQ(*i.Amount))
	}
	if i.AmountNEQ != nil {
		predicates = append(predicates, payment.AmountNEQ(*i.AmountNEQ))
	}
	if len(i.AmountIn) > 0 {
		predicates = append(predicates, payment.AmountIn(i.AmountIn...))
	}
	if len(i.AmountNotIn) > 0 {
		predicates = append(predicates, payment.AmountNotIn(i.AmountNotIn...))
	}
	if i.AmountGT != nil {
		predicates = append(predicates, payment.AmountGT(*i.AmountGT))
	}
	if i.AmountGTE != nil {
		predicates = append(predicates, payment.AmountGTE(*i.AmountGTE))
	}
	if i.AmountLT != nil {
		predicates = append(predicates, payment.AmountLT(*i.AmountLT))
	}
	if i.AmountLTE != nil {
		predicates = append(predicates, payment.AmountLTE(*i.AmountLTE))
	}
	if i.StatusID != nil {
		predicates = append(predicates, payment.StatusIDEQ(*i.StatusID))
	}
	if i.StatusIDNEQ != nil {
		predicates = append(predicates, payment.StatusIDNEQ(*i.StatusIDNEQ))
	}
	if len(i.StatusIDIn) > 0 {
		predicates = append(predicates, payment.StatusIDIn(i.StatusIDIn...))
	}
	if len(i.StatusIDNotIn) > 0 {
		predicates = append(predicates, payment.StatusIDNotIn(i.StatusIDNotIn...))
	}
	if i.StatusIDGT != nil {
		predicates = append(predicates, payment.StatusIDGT(*i.StatusIDGT))
	}
	if i.StatusIDGTE != nil {
		predicates = append(predicates, payment.StatusIDGTE(*i.StatusIDGTE))
	}
	if i.StatusIDLT != nil {
		predicates = append(predicates, payment.StatusIDLT(*i.StatusIDLT))
	}
	if i.StatusIDLTE != nil {
		predicates = append(predicates, payment.StatusIDLTE(*i.StatusIDLTE))
	}

	if i.HasJob != nil {
		p := payment.HasJob()
		if !*i.HasJob {
			p = payment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasJobWith))
		for _, w := range i.HasJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, payment.HasJobWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPaymentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return payment.And(predicates...), nil
	}
}

// PostalCodeWhereInput represents a where input for filtering PostalCode queries.
type PostalCodeWhereInput struct {
	Predicates []predicate.PostalCode  `json:"-"`
	Not        *PostalCodeWhereInput   `json:"not,omitempty"`
	Or         []*PostalCodeWhereInput `json:"or,omitempty"`
	And        []*PostalCodeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "country" field predicates.
	Country             *string  `json:"country,omitempty"`
	CountryNEQ          *string  `json:"countryNEQ,omitempty"`
	CountryIn           []string `json:"countryIn,omitempty"`
	CountryNotIn        []string `json:"countryNotIn,omitempty"`
	CountryGT           *string  `json:"countryGT,omitempty"`
	CountryGTE          *string  `json:"countryGTE,omitempty"`
	CountryLT           *string  `json:"countryLT,omitempty"`
	CountryLTE          *string  `json:"countryLTE,omitempty"`
	CountryContains     *string  `json:"countryContains,omitempty"`
	CountryHasPrefix    *string  `json:"countryHasPrefix,omitempty"`
	CountryHasSuffix    *string  `json:"countryHasSuffix,omitempty"`
	CountryEqualFold    *string  `json:"countryEqualFold,omitempty"`
	CountryContainsFold *string  `json:"countryContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "state" field predicates.
	State             *string  `json:"state,omitempty"`
	StateNEQ          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGT           *string  `json:"stateGT,omitempty"`
	StateGTE          *string  `json:"stateGTE,omitempty"`
	StateLT           *string  `json:"stateLT,omitempty"`
	StateLTE          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`

	// "state_abr" field predicates.
	StateAbr             *string  `json:"stateAbr,omitempty"`
	StateAbrNEQ          *string  `json:"stateAbrNEQ,omitempty"`
	StateAbrIn           []string `json:"stateAbrIn,omitempty"`
	StateAbrNotIn        []string `json:"stateAbrNotIn,omitempty"`
	StateAbrGT           *string  `json:"stateAbrGT,omitempty"`
	StateAbrGTE          *string  `json:"stateAbrGTE,omitempty"`
	StateAbrLT           *string  `json:"stateAbrLT,omitempty"`
	StateAbrLTE          *string  `json:"stateAbrLTE,omitempty"`
	StateAbrContains     *string  `json:"stateAbrContains,omitempty"`
	StateAbrHasPrefix    *string  `json:"stateAbrHasPrefix,omitempty"`
	StateAbrHasSuffix    *string  `json:"stateAbrHasSuffix,omitempty"`
	StateAbrEqualFold    *string  `json:"stateAbrEqualFold,omitempty"`
	StateAbrContainsFold *string  `json:"stateAbrContainsFold,omitempty"`

	// "region_id" field predicates.
	RegionID      *uint8  `json:"regionID,omitempty"`
	RegionIDNEQ   *uint8  `json:"regionIDNEQ,omitempty"`
	RegionIDIn    []uint8 `json:"regionIDIn,omitempty"`
	RegionIDNotIn []uint8 `json:"regionIDNotIn,omitempty"`
	RegionIDGT    *uint8  `json:"regionIDGT,omitempty"`
	RegionIDGTE   *uint8  `json:"regionIDGTE,omitempty"`
	RegionIDLT    *uint8  `json:"regionIDLT,omitempty"`
	RegionIDLTE   *uint8  `json:"regionIDLTE,omitempty"`

	// "latitude" field predicates.
	Latitude      *float64  `json:"latitude,omitempty"`
	LatitudeNEQ   *float64  `json:"latitudeNEQ,omitempty"`
	LatitudeIn    []float64 `json:"latitudeIn,omitempty"`
	LatitudeNotIn []float64 `json:"latitudeNotIn,omitempty"`
	LatitudeGT    *float64  `json:"latitudeGT,omitempty"`
	LatitudeGTE   *float64  `json:"latitudeGTE,omitempty"`
	LatitudeLT    *float64  `json:"latitudeLT,omitempty"`
	LatitudeLTE   *float64  `json:"latitudeLTE,omitempty"`

	// "longitude" field predicates.
	Longitude      *float64  `json:"longitude,omitempty"`
	LongitudeNEQ   *float64  `json:"longitudeNEQ,omitempty"`
	LongitudeIn    []float64 `json:"longitudeIn,omitempty"`
	LongitudeNotIn []float64 `json:"longitudeNotIn,omitempty"`
	LongitudeGT    *float64  `json:"longitudeGT,omitempty"`
	LongitudeGTE   *float64  `json:"longitudeGTE,omitempty"`
	LongitudeLT    *float64  `json:"longitudeLT,omitempty"`
	LongitudeLTE   *float64  `json:"longitudeLTE,omitempty"`

	// "accuracy" field predicates.
	Accuracy      *uint8  `json:"accuracy,omitempty"`
	AccuracyNEQ   *uint8  `json:"accuracyNEQ,omitempty"`
	AccuracyIn    []uint8 `json:"accuracyIn,omitempty"`
	AccuracyNotIn []uint8 `json:"accuracyNotIn,omitempty"`
	AccuracyGT    *uint8  `json:"accuracyGT,omitempty"`
	AccuracyGTE   *uint8  `json:"accuracyGTE,omitempty"`
	AccuracyLT    *uint8  `json:"accuracyLT,omitempty"`
	AccuracyLTE   *uint8  `json:"accuracyLTE,omitempty"`

	// "service_area" field predicates.
	ServiceArea    *bool `json:"serviceArea,omitempty"`
	ServiceAreaNEQ *bool `json:"serviceAreaNEQ,omitempty"`

	// "pricing" edge predicates.
	HasPricing     *bool                `json:"hasPricing,omitempty"`
	HasPricingWith []*PricingWhereInput `json:"hasPricingWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostalCodeWhereInput) AddPredicates(predicates ...predicate.PostalCode) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostalCodeWhereInput filter on the PostalCodeQuery builder.
func (i *PostalCodeWhereInput) Filter(q *PostalCodeQuery) (*PostalCodeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostalCodeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostalCodeWhereInput is returned in case the PostalCodeWhereInput is empty.
var ErrEmptyPostalCodeWhereInput = errors.New("ent: empty predicate PostalCodeWhereInput")

// P returns a predicate for filtering postalcodes.
// An error is returned if the input is empty or invalid.
func (i *PostalCodeWhereInput) P() (predicate.PostalCode, error) {
	var predicates []predicate.PostalCode
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, postalcode.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PostalCode, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, postalcode.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PostalCode, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, postalcode.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, postalcode.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, postalcode.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, postalcode.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, postalcode.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, postalcode.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, postalcode.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, postalcode.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, postalcode.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, postalcode.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, postalcode.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, postalcode.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, postalcode.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, postalcode.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, postalcode.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, postalcode.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, postalcode.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, postalcode.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, postalcode.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, postalcode.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, postalcode.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, postalcode.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, postalcode.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, postalcode.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, postalcode.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, postalcode.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, postalcode.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Country != nil {
		predicates = append(predicates, postalcode.CountryEQ(*i.Country))
	}
	if i.CountryNEQ != nil {
		predicates = append(predicates, postalcode.CountryNEQ(*i.CountryNEQ))
	}
	if len(i.CountryIn) > 0 {
		predicates = append(predicates, postalcode.CountryIn(i.CountryIn...))
	}
	if len(i.CountryNotIn) > 0 {
		predicates = append(predicates, postalcode.CountryNotIn(i.CountryNotIn...))
	}
	if i.CountryGT != nil {
		predicates = append(predicates, postalcode.CountryGT(*i.CountryGT))
	}
	if i.CountryGTE != nil {
		predicates = append(predicates, postalcode.CountryGTE(*i.CountryGTE))
	}
	if i.CountryLT != nil {
		predicates = append(predicates, postalcode.CountryLT(*i.CountryLT))
	}
	if i.CountryLTE != nil {
		predicates = append(predicates, postalcode.CountryLTE(*i.CountryLTE))
	}
	if i.CountryContains != nil {
		predicates = append(predicates, postalcode.CountryContains(*i.CountryContains))
	}
	if i.CountryHasPrefix != nil {
		predicates = append(predicates, postalcode.CountryHasPrefix(*i.CountryHasPrefix))
	}
	if i.CountryHasSuffix != nil {
		predicates = append(predicates, postalcode.CountryHasSuffix(*i.CountryHasSuffix))
	}
	if i.CountryEqualFold != nil {
		predicates = append(predicates, postalcode.CountryEqualFold(*i.CountryEqualFold))
	}
	if i.CountryContainsFold != nil {
		predicates = append(predicates, postalcode.CountryContainsFold(*i.CountryContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, postalcode.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, postalcode.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, postalcode.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, postalcode.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, postalcode.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, postalcode.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, postalcode.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, postalcode.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, postalcode.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, postalcode.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, postalcode.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, postalcode.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, postalcode.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, postalcode.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, postalcode.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, postalcode.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, postalcode.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, postalcode.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, postalcode.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, postalcode.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, postalcode.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, postalcode.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, postalcode.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, postalcode.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, postalcode.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, postalcode.CityContainsFold(*i.CityContainsFold))
	}
	if i.State != nil {
		predicates = append(predicates, postalcode.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, postalcode.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, postalcode.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, postalcode.StateNotIn(i.StateNotIn...))
	}
	if i.StateGT != nil {
		predicates = append(predicates, postalcode.StateGT(*i.StateGT))
	}
	if i.StateGTE != nil {
		predicates = append(predicates, postalcode.StateGTE(*i.StateGTE))
	}
	if i.StateLT != nil {
		predicates = append(predicates, postalcode.StateLT(*i.StateLT))
	}
	if i.StateLTE != nil {
		predicates = append(predicates, postalcode.StateLTE(*i.StateLTE))
	}
	if i.StateContains != nil {
		predicates = append(predicates, postalcode.StateContains(*i.StateContains))
	}
	if i.StateHasPrefix != nil {
		predicates = append(predicates, postalcode.StateHasPrefix(*i.StateHasPrefix))
	}
	if i.StateHasSuffix != nil {
		predicates = append(predicates, postalcode.StateHasSuffix(*i.StateHasSuffix))
	}
	if i.StateEqualFold != nil {
		predicates = append(predicates, postalcode.StateEqualFold(*i.StateEqualFold))
	}
	if i.StateContainsFold != nil {
		predicates = append(predicates, postalcode.StateContainsFold(*i.StateContainsFold))
	}
	if i.StateAbr != nil {
		predicates = append(predicates, postalcode.StateAbrEQ(*i.StateAbr))
	}
	if i.StateAbrNEQ != nil {
		predicates = append(predicates, postalcode.StateAbrNEQ(*i.StateAbrNEQ))
	}
	if len(i.StateAbrIn) > 0 {
		predicates = append(predicates, postalcode.StateAbrIn(i.StateAbrIn...))
	}
	if len(i.StateAbrNotIn) > 0 {
		predicates = append(predicates, postalcode.StateAbrNotIn(i.StateAbrNotIn...))
	}
	if i.StateAbrGT != nil {
		predicates = append(predicates, postalcode.StateAbrGT(*i.StateAbrGT))
	}
	if i.StateAbrGTE != nil {
		predicates = append(predicates, postalcode.StateAbrGTE(*i.StateAbrGTE))
	}
	if i.StateAbrLT != nil {
		predicates = append(predicates, postalcode.StateAbrLT(*i.StateAbrLT))
	}
	if i.StateAbrLTE != nil {
		predicates = append(predicates, postalcode.StateAbrLTE(*i.StateAbrLTE))
	}
	if i.StateAbrContains != nil {
		predicates = append(predicates, postalcode.StateAbrContains(*i.StateAbrContains))
	}
	if i.StateAbrHasPrefix != nil {
		predicates = append(predicates, postalcode.StateAbrHasPrefix(*i.StateAbrHasPrefix))
	}
	if i.StateAbrHasSuffix != nil {
		predicates = append(predicates, postalcode.StateAbrHasSuffix(*i.StateAbrHasSuffix))
	}
	if i.StateAbrEqualFold != nil {
		predicates = append(predicates, postalcode.StateAbrEqualFold(*i.StateAbrEqualFold))
	}
	if i.StateAbrContainsFold != nil {
		predicates = append(predicates, postalcode.StateAbrContainsFold(*i.StateAbrContainsFold))
	}
	if i.RegionID != nil {
		predicates = append(predicates, postalcode.RegionIDEQ(*i.RegionID))
	}
	if i.RegionIDNEQ != nil {
		predicates = append(predicates, postalcode.RegionIDNEQ(*i.RegionIDNEQ))
	}
	if len(i.RegionIDIn) > 0 {
		predicates = append(predicates, postalcode.RegionIDIn(i.RegionIDIn...))
	}
	if len(i.RegionIDNotIn) > 0 {
		predicates = append(predicates, postalcode.RegionIDNotIn(i.RegionIDNotIn...))
	}
	if i.RegionIDGT != nil {
		predicates = append(predicates, postalcode.RegionIDGT(*i.RegionIDGT))
	}
	if i.RegionIDGTE != nil {
		predicates = append(predicates, postalcode.RegionIDGTE(*i.RegionIDGTE))
	}
	if i.RegionIDLT != nil {
		predicates = append(predicates, postalcode.RegionIDLT(*i.RegionIDLT))
	}
	if i.RegionIDLTE != nil {
		predicates = append(predicates, postalcode.RegionIDLTE(*i.RegionIDLTE))
	}
	if i.Latitude != nil {
		predicates = append(predicates, postalcode.LatitudeEQ(*i.Latitude))
	}
	if i.LatitudeNEQ != nil {
		predicates = append(predicates, postalcode.LatitudeNEQ(*i.LatitudeNEQ))
	}
	if len(i.LatitudeIn) > 0 {
		predicates = append(predicates, postalcode.LatitudeIn(i.LatitudeIn...))
	}
	if len(i.LatitudeNotIn) > 0 {
		predicates = append(predicates, postalcode.LatitudeNotIn(i.LatitudeNotIn...))
	}
	if i.LatitudeGT != nil {
		predicates = append(predicates, postalcode.LatitudeGT(*i.LatitudeGT))
	}
	if i.LatitudeGTE != nil {
		predicates = append(predicates, postalcode.LatitudeGTE(*i.LatitudeGTE))
	}
	if i.LatitudeLT != nil {
		predicates = append(predicates, postalcode.LatitudeLT(*i.LatitudeLT))
	}
	if i.LatitudeLTE != nil {
		predicates = append(predicates, postalcode.LatitudeLTE(*i.LatitudeLTE))
	}
	if i.Longitude != nil {
		predicates = append(predicates, postalcode.LongitudeEQ(*i.Longitude))
	}
	if i.LongitudeNEQ != nil {
		predicates = append(predicates, postalcode.LongitudeNEQ(*i.LongitudeNEQ))
	}
	if len(i.LongitudeIn) > 0 {
		predicates = append(predicates, postalcode.LongitudeIn(i.LongitudeIn...))
	}
	if len(i.LongitudeNotIn) > 0 {
		predicates = append(predicates, postalcode.LongitudeNotIn(i.LongitudeNotIn...))
	}
	if i.LongitudeGT != nil {
		predicates = append(predicates, postalcode.LongitudeGT(*i.LongitudeGT))
	}
	if i.LongitudeGTE != nil {
		predicates = append(predicates, postalcode.LongitudeGTE(*i.LongitudeGTE))
	}
	if i.LongitudeLT != nil {
		predicates = append(predicates, postalcode.LongitudeLT(*i.LongitudeLT))
	}
	if i.LongitudeLTE != nil {
		predicates = append(predicates, postalcode.LongitudeLTE(*i.LongitudeLTE))
	}
	if i.Accuracy != nil {
		predicates = append(predicates, postalcode.AccuracyEQ(*i.Accuracy))
	}
	if i.AccuracyNEQ != nil {
		predicates = append(predicates, postalcode.AccuracyNEQ(*i.AccuracyNEQ))
	}
	if len(i.AccuracyIn) > 0 {
		predicates = append(predicates, postalcode.AccuracyIn(i.AccuracyIn...))
	}
	if len(i.AccuracyNotIn) > 0 {
		predicates = append(predicates, postalcode.AccuracyNotIn(i.AccuracyNotIn...))
	}
	if i.AccuracyGT != nil {
		predicates = append(predicates, postalcode.AccuracyGT(*i.AccuracyGT))
	}
	if i.AccuracyGTE != nil {
		predicates = append(predicates, postalcode.AccuracyGTE(*i.AccuracyGTE))
	}
	if i.AccuracyLT != nil {
		predicates = append(predicates, postalcode.AccuracyLT(*i.AccuracyLT))
	}
	if i.AccuracyLTE != nil {
		predicates = append(predicates, postalcode.AccuracyLTE(*i.AccuracyLTE))
	}
	if i.ServiceArea != nil {
		predicates = append(predicates, postalcode.ServiceAreaEQ(*i.ServiceArea))
	}
	if i.ServiceAreaNEQ != nil {
		predicates = append(predicates, postalcode.ServiceAreaNEQ(*i.ServiceAreaNEQ))
	}

	if i.HasPricing != nil {
		p := postalcode.HasPricing()
		if !*i.HasPricing {
			p = postalcode.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPricingWith) > 0 {
		with := make([]predicate.Pricing, 0, len(i.HasPricingWith))
		for _, w := range i.HasPricingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPricingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, postalcode.HasPricingWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostalCodeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return postalcode.And(predicates...), nil
	}
}

// PricingWhereInput represents a where input for filtering Pricing queries.
type PricingWhereInput struct {
	Predicates []predicate.Pricing  `json:"-"`
	Not        *PricingWhereInput   `json:"not,omitempty"`
	Or         []*PricingWhereInput `json:"or,omitempty"`
	And        []*PricingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "postal_country" field predicates.
	PostalCountry             *string  `json:"postalCountry,omitempty"`
	PostalCountryNEQ          *string  `json:"postalCountryNEQ,omitempty"`
	PostalCountryIn           []string `json:"postalCountryIn,omitempty"`
	PostalCountryNotIn        []string `json:"postalCountryNotIn,omitempty"`
	PostalCountryGT           *string  `json:"postalCountryGT,omitempty"`
	PostalCountryGTE          *string  `json:"postalCountryGTE,omitempty"`
	PostalCountryLT           *string  `json:"postalCountryLT,omitempty"`
	PostalCountryLTE          *string  `json:"postalCountryLTE,omitempty"`
	PostalCountryContains     *string  `json:"postalCountryContains,omitempty"`
	PostalCountryHasPrefix    *string  `json:"postalCountryHasPrefix,omitempty"`
	PostalCountryHasSuffix    *string  `json:"postalCountryHasSuffix,omitempty"`
	PostalCountryEqualFold    *string  `json:"postalCountryEqualFold,omitempty"`
	PostalCountryContainsFold *string  `json:"postalCountryContainsFold,omitempty"`

	// "postal_code" field predicates.
	PostalCode             *string  `json:"postalCode,omitempty"`
	PostalCodeNEQ          *string  `json:"postalCodeNEQ,omitempty"`
	PostalCodeIn           []string `json:"postalCodeIn,omitempty"`
	PostalCodeNotIn        []string `json:"postalCodeNotIn,omitempty"`
	PostalCodeGT           *string  `json:"postalCodeGT,omitempty"`
	PostalCodeGTE          *string  `json:"postalCodeGTE,omitempty"`
	PostalCodeLT           *string  `json:"postalCodeLT,omitempty"`
	PostalCodeLTE          *string  `json:"postalCodeLTE,omitempty"`
	PostalCodeContains     *string  `json:"postalCodeContains,omitempty"`
	PostalCodeHasPrefix    *string  `json:"postalCodeHasPrefix,omitempty"`
	PostalCodeHasSuffix    *string  `json:"postalCodeHasSuffix,omitempty"`
	PostalCodeEqualFold    *string  `json:"postalCodeEqualFold,omitempty"`
	PostalCodeContainsFold *string  `json:"postalCodeContainsFold,omitempty"`

	// "product_id" field predicates.
	ProductID      *uint8  `json:"productID,omitempty"`
	ProductIDNEQ   *uint8  `json:"productIDNEQ,omitempty"`
	ProductIDIn    []uint8 `json:"productIDIn,omitempty"`
	ProductIDNotIn []uint8 `json:"productIDNotIn,omitempty"`
	ProductIDGT    *uint8  `json:"productIDGT,omitempty"`
	ProductIDGTE   *uint8  `json:"productIDGTE,omitempty"`
	ProductIDLT    *uint8  `json:"productIDLT,omitempty"`
	ProductIDLTE   *uint8  `json:"productIDLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "price" field predicates.
	Price      *float64  `json:"price,omitempty"`
	PriceNEQ   *float64  `json:"priceNEQ,omitempty"`
	PriceIn    []float64 `json:"priceIn,omitempty"`
	PriceNotIn []float64 `json:"priceNotIn,omitempty"`
	PriceGT    *float64  `json:"priceGT,omitempty"`
	PriceGTE   *float64  `json:"priceGTE,omitempty"`
	PriceLT    *float64  `json:"priceLT,omitempty"`
	PriceLTE   *float64  `json:"priceLTE,omitempty"`

	// "price_per" field predicates.
	PricePer             *string  `json:"pricePer,omitempty"`
	PricePerNEQ          *string  `json:"pricePerNEQ,omitempty"`
	PricePerIn           []string `json:"pricePerIn,omitempty"`
	PricePerNotIn        []string `json:"pricePerNotIn,omitempty"`
	PricePerGT           *string  `json:"pricePerGT,omitempty"`
	PricePerGTE          *string  `json:"pricePerGTE,omitempty"`
	PricePerLT           *string  `json:"pricePerLT,omitempty"`
	PricePerLTE          *string  `json:"pricePerLTE,omitempty"`
	PricePerContains     *string  `json:"pricePerContains,omitempty"`
	PricePerHasPrefix    *string  `json:"pricePerHasPrefix,omitempty"`
	PricePerHasSuffix    *string  `json:"pricePerHasSuffix,omitempty"`
	PricePerEqualFold    *string  `json:"pricePerEqualFold,omitempty"`
	PricePerContainsFold *string  `json:"pricePerContainsFold,omitempty"`

	// "postal" edge predicates.
	HasPostal     *bool                   `json:"hasPostal,omitempty"`
	HasPostalWith []*PostalCodeWhereInput `json:"hasPostalWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PricingWhereInput) AddPredicates(predicates ...predicate.Pricing) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PricingWhereInput filter on the PricingQuery builder.
func (i *PricingWhereInput) Filter(q *PricingQuery) (*PricingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPricingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPricingWhereInput is returned in case the PricingWhereInput is empty.
var ErrEmptyPricingWhereInput = errors.New("ent: empty predicate PricingWhereInput")

// P returns a predicate for filtering pricings.
// An error is returned if the input is empty or invalid.
func (i *PricingWhereInput) P() (predicate.Pricing, error) {
	var predicates []predicate.Pricing
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, pricing.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Pricing, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, pricing.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Pricing, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, pricing.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, pricing.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, pricing.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, pricing.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, pricing.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, pricing.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, pricing.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, pricing.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, pricing.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, pricing.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, pricing.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, pricing.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, pricing.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, pricing.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, pricing.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, pricing.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, pricing.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, pricing.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, pricing.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, pricing.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, pricing.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, pricing.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, pricing.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, pricing.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, pricing.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, pricing.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, pricing.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.PostalCountry != nil {
		predicates = append(predicates, pricing.PostalCountryEQ(*i.PostalCountry))
	}
	if i.PostalCountryNEQ != nil {
		predicates = append(predicates, pricing.PostalCountryNEQ(*i.PostalCountryNEQ))
	}
	if len(i.PostalCountryIn) > 0 {
		predicates = append(predicates, pricing.PostalCountryIn(i.PostalCountryIn...))
	}
	if len(i.PostalCountryNotIn) > 0 {
		predicates = append(predicates, pricing.PostalCountryNotIn(i.PostalCountryNotIn...))
	}
	if i.PostalCountryGT != nil {
		predicates = append(predicates, pricing.PostalCountryGT(*i.PostalCountryGT))
	}
	if i.PostalCountryGTE != nil {
		predicates = append(predicates, pricing.PostalCountryGTE(*i.PostalCountryGTE))
	}
	if i.PostalCountryLT != nil {
		predicates = append(predicates, pricing.PostalCountryLT(*i.PostalCountryLT))
	}
	if i.PostalCountryLTE != nil {
		predicates = append(predicates, pricing.PostalCountryLTE(*i.PostalCountryLTE))
	}
	if i.PostalCountryContains != nil {
		predicates = append(predicates, pricing.PostalCountryContains(*i.PostalCountryContains))
	}
	if i.PostalCountryHasPrefix != nil {
		predicates = append(predicates, pricing.PostalCountryHasPrefix(*i.PostalCountryHasPrefix))
	}
	if i.PostalCountryHasSuffix != nil {
		predicates = append(predicates, pricing.PostalCountryHasSuffix(*i.PostalCountryHasSuffix))
	}
	if i.PostalCountryEqualFold != nil {
		predicates = append(predicates, pricing.PostalCountryEqualFold(*i.PostalCountryEqualFold))
	}
	if i.PostalCountryContainsFold != nil {
		predicates = append(predicates, pricing.PostalCountryContainsFold(*i.PostalCountryContainsFold))
	}
	if i.PostalCode != nil {
		predicates = append(predicates, pricing.PostalCodeEQ(*i.PostalCode))
	}
	if i.PostalCodeNEQ != nil {
		predicates = append(predicates, pricing.PostalCodeNEQ(*i.PostalCodeNEQ))
	}
	if len(i.PostalCodeIn) > 0 {
		predicates = append(predicates, pricing.PostalCodeIn(i.PostalCodeIn...))
	}
	if len(i.PostalCodeNotIn) > 0 {
		predicates = append(predicates, pricing.PostalCodeNotIn(i.PostalCodeNotIn...))
	}
	if i.PostalCodeGT != nil {
		predicates = append(predicates, pricing.PostalCodeGT(*i.PostalCodeGT))
	}
	if i.PostalCodeGTE != nil {
		predicates = append(predicates, pricing.PostalCodeGTE(*i.PostalCodeGTE))
	}
	if i.PostalCodeLT != nil {
		predicates = append(predicates, pricing.PostalCodeLT(*i.PostalCodeLT))
	}
	if i.PostalCodeLTE != nil {
		predicates = append(predicates, pricing.PostalCodeLTE(*i.PostalCodeLTE))
	}
	if i.PostalCodeContains != nil {
		predicates = append(predicates, pricing.PostalCodeContains(*i.PostalCodeContains))
	}
	if i.PostalCodeHasPrefix != nil {
		predicates = append(predicates, pricing.PostalCodeHasPrefix(*i.PostalCodeHasPrefix))
	}
	if i.PostalCodeHasSuffix != nil {
		predicates = append(predicates, pricing.PostalCodeHasSuffix(*i.PostalCodeHasSuffix))
	}
	if i.PostalCodeEqualFold != nil {
		predicates = append(predicates, pricing.PostalCodeEqualFold(*i.PostalCodeEqualFold))
	}
	if i.PostalCodeContainsFold != nil {
		predicates = append(predicates, pricing.PostalCodeContainsFold(*i.PostalCodeContainsFold))
	}
	if i.ProductID != nil {
		predicates = append(predicates, pricing.ProductIDEQ(*i.ProductID))
	}
	if i.ProductIDNEQ != nil {
		predicates = append(predicates, pricing.ProductIDNEQ(*i.ProductIDNEQ))
	}
	if len(i.ProductIDIn) > 0 {
		predicates = append(predicates, pricing.ProductIDIn(i.ProductIDIn...))
	}
	if len(i.ProductIDNotIn) > 0 {
		predicates = append(predicates, pricing.ProductIDNotIn(i.ProductIDNotIn...))
	}
	if i.ProductIDGT != nil {
		predicates = append(predicates, pricing.ProductIDGT(*i.ProductIDGT))
	}
	if i.ProductIDGTE != nil {
		predicates = append(predicates, pricing.ProductIDGTE(*i.ProductIDGTE))
	}
	if i.ProductIDLT != nil {
		predicates = append(predicates, pricing.ProductIDLT(*i.ProductIDLT))
	}
	if i.ProductIDLTE != nil {
		predicates = append(predicates, pricing.ProductIDLTE(*i.ProductIDLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, pricing.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, pricing.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, pricing.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, pricing.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, pricing.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, pricing.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, pricing.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, pricing.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, pricing.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, pricing.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, pricing.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, pricing.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, pricing.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, pricing.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, pricing.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, pricing.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, pricing.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, pricing.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, pricing.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, pricing.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, pricing.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, pricing.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, pricing.PriceLTE(*i.PriceLTE))
	}
	if i.PricePer != nil {
		predicates = append(predicates, pricing.PricePerEQ(*i.PricePer))
	}
	if i.PricePerNEQ != nil {
		predicates = append(predicates, pricing.PricePerNEQ(*i.PricePerNEQ))
	}
	if len(i.PricePerIn) > 0 {
		predicates = append(predicates, pricing.PricePerIn(i.PricePerIn...))
	}
	if len(i.PricePerNotIn) > 0 {
		predicates = append(predicates, pricing.PricePerNotIn(i.PricePerNotIn...))
	}
	if i.PricePerGT != nil {
		predicates = append(predicates, pricing.PricePerGT(*i.PricePerGT))
	}
	if i.PricePerGTE != nil {
		predicates = append(predicates, pricing.PricePerGTE(*i.PricePerGTE))
	}
	if i.PricePerLT != nil {
		predicates = append(predicates, pricing.PricePerLT(*i.PricePerLT))
	}
	if i.PricePerLTE != nil {
		predicates = append(predicates, pricing.PricePerLTE(*i.PricePerLTE))
	}
	if i.PricePerContains != nil {
		predicates = append(predicates, pricing.PricePerContains(*i.PricePerContains))
	}
	if i.PricePerHasPrefix != nil {
		predicates = append(predicates, pricing.PricePerHasPrefix(*i.PricePerHasPrefix))
	}
	if i.PricePerHasSuffix != nil {
		predicates = append(predicates, pricing.PricePerHasSuffix(*i.PricePerHasSuffix))
	}
	if i.PricePerEqualFold != nil {
		predicates = append(predicates, pricing.PricePerEqualFold(*i.PricePerEqualFold))
	}
	if i.PricePerContainsFold != nil {
		predicates = append(predicates, pricing.PricePerContainsFold(*i.PricePerContainsFold))
	}

	if i.HasPostal != nil {
		p := pricing.HasPostal()
		if !*i.HasPostal {
			p = pricing.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostalWith) > 0 {
		with := make([]predicate.PostalCode, 0, len(i.HasPostalWith))
		for _, w := range i.HasPostalWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostalWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, pricing.HasPostalWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPricingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return pricing.And(predicates...), nil
	}
}

// ProductWhereInput represents a where input for filtering Product queries.
type ProductWhereInput struct {
	Predicates []predicate.Product  `json:"-"`
	Not        *ProductWhereInput   `json:"not,omitempty"`
	Or         []*ProductWhereInput `json:"or,omitempty"`
	And        []*ProductWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "type" field predicates.
	Type      *enum.Product  `json:"type,omitempty"`
	TypeNEQ   *enum.Product  `json:"typeNEQ,omitempty"`
	TypeIn    []enum.Product `json:"typeIn,omitempty"`
	TypeNotIn []enum.Product `json:"typeNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "special_note" field predicates.
	SpecialNote             *string  `json:"specialNote,omitempty"`
	SpecialNoteNEQ          *string  `json:"specialNoteNEQ,omitempty"`
	SpecialNoteIn           []string `json:"specialNoteIn,omitempty"`
	SpecialNoteNotIn        []string `json:"specialNoteNotIn,omitempty"`
	SpecialNoteGT           *string  `json:"specialNoteGT,omitempty"`
	SpecialNoteGTE          *string  `json:"specialNoteGTE,omitempty"`
	SpecialNoteLT           *string  `json:"specialNoteLT,omitempty"`
	SpecialNoteLTE          *string  `json:"specialNoteLTE,omitempty"`
	SpecialNoteContains     *string  `json:"specialNoteContains,omitempty"`
	SpecialNoteHasPrefix    *string  `json:"specialNoteHasPrefix,omitempty"`
	SpecialNoteHasSuffix    *string  `json:"specialNoteHasSuffix,omitempty"`
	SpecialNoteIsNil        bool     `json:"specialNoteIsNil,omitempty"`
	SpecialNoteNotNil       bool     `json:"specialNoteNotNil,omitempty"`
	SpecialNoteEqualFold    *string  `json:"specialNoteEqualFold,omitempty"`
	SpecialNoteContainsFold *string  `json:"specialNoteContainsFold,omitempty"`

	// "unit_price" field predicates.
	UnitPrice      *float64  `json:"unitPrice,omitempty"`
	UnitPriceNEQ   *float64  `json:"unitPriceNEQ,omitempty"`
	UnitPriceIn    []float64 `json:"unitPriceIn,omitempty"`
	UnitPriceNotIn []float64 `json:"unitPriceNotIn,omitempty"`
	UnitPriceGT    *float64  `json:"unitPriceGT,omitempty"`
	UnitPriceGTE   *float64  `json:"unitPriceGTE,omitempty"`
	UnitPriceLT    *float64  `json:"unitPriceLT,omitempty"`
	UnitPriceLTE   *float64  `json:"unitPriceLTE,omitempty"`

	// "units_in_stock" field predicates.
	UnitsInStock       *int  `json:"unitsInStock,omitempty"`
	UnitsInStockNEQ    *int  `json:"unitsInStockNEQ,omitempty"`
	UnitsInStockIn     []int `json:"unitsInStockIn,omitempty"`
	UnitsInStockNotIn  []int `json:"unitsInStockNotIn,omitempty"`
	UnitsInStockGT     *int  `json:"unitsInStockGT,omitempty"`
	UnitsInStockGTE    *int  `json:"unitsInStockGTE,omitempty"`
	UnitsInStockLT     *int  `json:"unitsInStockLT,omitempty"`
	UnitsInStockLTE    *int  `json:"unitsInStockLTE,omitempty"`
	UnitsInStockIsNil  bool  `json:"unitsInStockIsNil,omitempty"`
	UnitsInStockNotNil bool  `json:"unitsInStockNotNil,omitempty"`

	// "units_on_order" field predicates.
	UnitsOnOrder       *int  `json:"unitsOnOrder,omitempty"`
	UnitsOnOrderNEQ    *int  `json:"unitsOnOrderNEQ,omitempty"`
	UnitsOnOrderIn     []int `json:"unitsOnOrderIn,omitempty"`
	UnitsOnOrderNotIn  []int `json:"unitsOnOrderNotIn,omitempty"`
	UnitsOnOrderGT     *int  `json:"unitsOnOrderGT,omitempty"`
	UnitsOnOrderGTE    *int  `json:"unitsOnOrderGTE,omitempty"`
	UnitsOnOrderLT     *int  `json:"unitsOnOrderLT,omitempty"`
	UnitsOnOrderLTE    *int  `json:"unitsOnOrderLTE,omitempty"`
	UnitsOnOrderIsNil  bool  `json:"unitsOnOrderIsNil,omitempty"`
	UnitsOnOrderNotNil bool  `json:"unitsOnOrderNotNil,omitempty"`

	// "discontinued" field predicates.
	Discontinued       *bool `json:"discontinued,omitempty"`
	DiscontinuedNEQ    *bool `json:"discontinuedNEQ,omitempty"`
	DiscontinuedIsNil  bool  `json:"discontinuedIsNil,omitempty"`
	DiscontinuedNotNil bool  `json:"discontinuedNotNil,omitempty"`

	// "package" edge predicates.
	HasPackage     *bool                       `json:"hasPackage,omitempty"`
	HasPackageWith []*ProductPackageWhereInput `json:"hasPackageWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "image" edge predicates.
	HasImage     *bool                 `json:"hasImage,omitempty"`
	HasImageWith []*DocumentWhereInput `json:"hasImageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductWhereInput) AddPredicates(predicates ...predicate.Product) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductWhereInput filter on the ProductQuery builder.
func (i *ProductWhereInput) Filter(q *ProductQuery) (*ProductQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductWhereInput is returned in case the ProductWhereInput is empty.
var ErrEmptyProductWhereInput = errors.New("ent: empty predicate ProductWhereInput")

// P returns a predicate for filtering products.
// An error is returned if the input is empty or invalid.
func (i *ProductWhereInput) P() (predicate.Product, error) {
	var predicates []predicate.Product
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, product.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Product, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, product.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Product, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, product.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, product.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, product.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, product.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, product.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, product.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, product.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, product.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, product.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, product.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, product.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, product.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, product.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, product.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, product.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, product.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, product.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, product.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, product.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, product.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, product.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, product.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, product.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, product.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, product.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, product.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, product.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, product.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, product.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, product.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, product.TypeNotIn(i.TypeNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, product.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, product.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, product.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, product.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, product.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, product.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, product.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, product.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, product.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, product.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, product.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, product.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, product.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, product.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, product.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, product.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, product.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, product.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, product.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, product.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, product.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, product.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, product.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, product.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, product.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, product.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.SpecialNote != nil {
		predicates = append(predicates, product.SpecialNoteEQ(*i.SpecialNote))
	}
	if i.SpecialNoteNEQ != nil {
		predicates = append(predicates, product.SpecialNoteNEQ(*i.SpecialNoteNEQ))
	}
	if len(i.SpecialNoteIn) > 0 {
		predicates = append(predicates, product.SpecialNoteIn(i.SpecialNoteIn...))
	}
	if len(i.SpecialNoteNotIn) > 0 {
		predicates = append(predicates, product.SpecialNoteNotIn(i.SpecialNoteNotIn...))
	}
	if i.SpecialNoteGT != nil {
		predicates = append(predicates, product.SpecialNoteGT(*i.SpecialNoteGT))
	}
	if i.SpecialNoteGTE != nil {
		predicates = append(predicates, product.SpecialNoteGTE(*i.SpecialNoteGTE))
	}
	if i.SpecialNoteLT != nil {
		predicates = append(predicates, product.SpecialNoteLT(*i.SpecialNoteLT))
	}
	if i.SpecialNoteLTE != nil {
		predicates = append(predicates, product.SpecialNoteLTE(*i.SpecialNoteLTE))
	}
	if i.SpecialNoteContains != nil {
		predicates = append(predicates, product.SpecialNoteContains(*i.SpecialNoteContains))
	}
	if i.SpecialNoteHasPrefix != nil {
		predicates = append(predicates, product.SpecialNoteHasPrefix(*i.SpecialNoteHasPrefix))
	}
	if i.SpecialNoteHasSuffix != nil {
		predicates = append(predicates, product.SpecialNoteHasSuffix(*i.SpecialNoteHasSuffix))
	}
	if i.SpecialNoteIsNil {
		predicates = append(predicates, product.SpecialNoteIsNil())
	}
	if i.SpecialNoteNotNil {
		predicates = append(predicates, product.SpecialNoteNotNil())
	}
	if i.SpecialNoteEqualFold != nil {
		predicates = append(predicates, product.SpecialNoteEqualFold(*i.SpecialNoteEqualFold))
	}
	if i.SpecialNoteContainsFold != nil {
		predicates = append(predicates, product.SpecialNoteContainsFold(*i.SpecialNoteContainsFold))
	}
	if i.UnitPrice != nil {
		predicates = append(predicates, product.UnitPriceEQ(*i.UnitPrice))
	}
	if i.UnitPriceNEQ != nil {
		predicates = append(predicates, product.UnitPriceNEQ(*i.UnitPriceNEQ))
	}
	if len(i.UnitPriceIn) > 0 {
		predicates = append(predicates, product.UnitPriceIn(i.UnitPriceIn...))
	}
	if len(i.UnitPriceNotIn) > 0 {
		predicates = append(predicates, product.UnitPriceNotIn(i.UnitPriceNotIn...))
	}
	if i.UnitPriceGT != nil {
		predicates = append(predicates, product.UnitPriceGT(*i.UnitPriceGT))
	}
	if i.UnitPriceGTE != nil {
		predicates = append(predicates, product.UnitPriceGTE(*i.UnitPriceGTE))
	}
	if i.UnitPriceLT != nil {
		predicates = append(predicates, product.UnitPriceLT(*i.UnitPriceLT))
	}
	if i.UnitPriceLTE != nil {
		predicates = append(predicates, product.UnitPriceLTE(*i.UnitPriceLTE))
	}
	if i.UnitsInStock != nil {
		predicates = append(predicates, product.UnitsInStockEQ(*i.UnitsInStock))
	}
	if i.UnitsInStockNEQ != nil {
		predicates = append(predicates, product.UnitsInStockNEQ(*i.UnitsInStockNEQ))
	}
	if len(i.UnitsInStockIn) > 0 {
		predicates = append(predicates, product.UnitsInStockIn(i.UnitsInStockIn...))
	}
	if len(i.UnitsInStockNotIn) > 0 {
		predicates = append(predicates, product.UnitsInStockNotIn(i.UnitsInStockNotIn...))
	}
	if i.UnitsInStockGT != nil {
		predicates = append(predicates, product.UnitsInStockGT(*i.UnitsInStockGT))
	}
	if i.UnitsInStockGTE != nil {
		predicates = append(predicates, product.UnitsInStockGTE(*i.UnitsInStockGTE))
	}
	if i.UnitsInStockLT != nil {
		predicates = append(predicates, product.UnitsInStockLT(*i.UnitsInStockLT))
	}
	if i.UnitsInStockLTE != nil {
		predicates = append(predicates, product.UnitsInStockLTE(*i.UnitsInStockLTE))
	}
	if i.UnitsInStockIsNil {
		predicates = append(predicates, product.UnitsInStockIsNil())
	}
	if i.UnitsInStockNotNil {
		predicates = append(predicates, product.UnitsInStockNotNil())
	}
	if i.UnitsOnOrder != nil {
		predicates = append(predicates, product.UnitsOnOrderEQ(*i.UnitsOnOrder))
	}
	if i.UnitsOnOrderNEQ != nil {
		predicates = append(predicates, product.UnitsOnOrderNEQ(*i.UnitsOnOrderNEQ))
	}
	if len(i.UnitsOnOrderIn) > 0 {
		predicates = append(predicates, product.UnitsOnOrderIn(i.UnitsOnOrderIn...))
	}
	if len(i.UnitsOnOrderNotIn) > 0 {
		predicates = append(predicates, product.UnitsOnOrderNotIn(i.UnitsOnOrderNotIn...))
	}
	if i.UnitsOnOrderGT != nil {
		predicates = append(predicates, product.UnitsOnOrderGT(*i.UnitsOnOrderGT))
	}
	if i.UnitsOnOrderGTE != nil {
		predicates = append(predicates, product.UnitsOnOrderGTE(*i.UnitsOnOrderGTE))
	}
	if i.UnitsOnOrderLT != nil {
		predicates = append(predicates, product.UnitsOnOrderLT(*i.UnitsOnOrderLT))
	}
	if i.UnitsOnOrderLTE != nil {
		predicates = append(predicates, product.UnitsOnOrderLTE(*i.UnitsOnOrderLTE))
	}
	if i.UnitsOnOrderIsNil {
		predicates = append(predicates, product.UnitsOnOrderIsNil())
	}
	if i.UnitsOnOrderNotNil {
		predicates = append(predicates, product.UnitsOnOrderNotNil())
	}
	if i.Discontinued != nil {
		predicates = append(predicates, product.DiscontinuedEQ(*i.Discontinued))
	}
	if i.DiscontinuedNEQ != nil {
		predicates = append(predicates, product.DiscontinuedNEQ(*i.DiscontinuedNEQ))
	}
	if i.DiscontinuedIsNil {
		predicates = append(predicates, product.DiscontinuedIsNil())
	}
	if i.DiscontinuedNotNil {
		predicates = append(predicates, product.DiscontinuedNotNil())
	}

	if i.HasPackage != nil {
		p := product.HasPackage()
		if !*i.HasPackage {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackageWith) > 0 {
		with := make([]predicate.ProductPackage, 0, len(i.HasPackageWith))
		for _, w := range i.HasPackageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasPackageWith(with...))
	}
	if i.HasCreator != nil {
		p := product.HasCreator()
		if !*i.HasCreator {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasCreatorWith(with...))
	}
	if i.HasImage != nil {
		p := product.HasImage()
		if !*i.HasImage {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasImageWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasImageWith))
		for _, w := range i.HasImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasImageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductWhereInput
	case 1:
		return predicates[0], nil
	default:
		return product.And(predicates...), nil
	}
}

// ProductPackageWhereInput represents a where input for filtering ProductPackage queries.
type ProductPackageWhereInput struct {
	Predicates []predicate.ProductPackage  `json:"-"`
	Not        *ProductPackageWhereInput   `json:"not,omitempty"`
	Or         []*ProductPackageWhereInput `json:"or,omitempty"`
	And        []*ProductPackageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "type" field predicates.
	Type      *enum.Product  `json:"type,omitempty"`
	TypeNEQ   *enum.Product  `json:"typeNEQ,omitempty"`
	TypeIn    []enum.Product `json:"typeIn,omitempty"`
	TypeNotIn []enum.Product `json:"typeNotIn,omitempty"`

	// "sold_as" field predicates.
	SoldAs      *enum.SoldAs  `json:"soldAs,omitempty"`
	SoldAsNEQ   *enum.SoldAs  `json:"soldAsNEQ,omitempty"`
	SoldAsIn    []enum.SoldAs `json:"soldAsIn,omitempty"`
	SoldAsNotIn []enum.SoldAs `json:"soldAsNotIn,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "price" field predicates.
	Price      *float64  `json:"price,omitempty"`
	PriceNEQ   *float64  `json:"priceNEQ,omitempty"`
	PriceIn    []float64 `json:"priceIn,omitempty"`
	PriceNotIn []float64 `json:"priceNotIn,omitempty"`
	PriceGT    *float64  `json:"priceGT,omitempty"`
	PriceGTE   *float64  `json:"priceGTE,omitempty"`
	PriceLT    *float64  `json:"priceLT,omitempty"`
	PriceLTE   *float64  `json:"priceLTE,omitempty"`

	// "discontinued" field predicates.
	Discontinued       *bool `json:"discontinued,omitempty"`
	DiscontinuedNEQ    *bool `json:"discontinuedNEQ,omitempty"`
	DiscontinuedIsNil  bool  `json:"discontinuedIsNil,omitempty"`
	DiscontinuedNotNil bool  `json:"discontinuedNotNil,omitempty"`

	// "items" edge predicates.
	HasItems     *bool                `json:"hasItems,omitempty"`
	HasItemsWith []*ProductWhereInput `json:"hasItemsWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductPackageWhereInput) AddPredicates(predicates ...predicate.ProductPackage) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductPackageWhereInput filter on the ProductPackageQuery builder.
func (i *ProductPackageWhereInput) Filter(q *ProductPackageQuery) (*ProductPackageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductPackageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductPackageWhereInput is returned in case the ProductPackageWhereInput is empty.
var ErrEmptyProductPackageWhereInput = errors.New("ent: empty predicate ProductPackageWhereInput")

// P returns a predicate for filtering productpackages.
// An error is returned if the input is empty or invalid.
func (i *ProductPackageWhereInput) P() (predicate.ProductPackage, error) {
	var predicates []predicate.ProductPackage
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, productpackage.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProductPackage, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, productpackage.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProductPackage, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, productpackage.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, productpackage.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, productpackage.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, productpackage.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, productpackage.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, productpackage.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, productpackage.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, productpackage.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, productpackage.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, productpackage.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, productpackage.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, productpackage.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, productpackage.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, productpackage.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, productpackage.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, productpackage.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, productpackage.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, productpackage.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, productpackage.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, productpackage.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, productpackage.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, productpackage.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, productpackage.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, productpackage.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, productpackage.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, productpackage.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, productpackage.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Type != nil {
		predicates = append(predicates, productpackage.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, productpackage.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, productpackage.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, productpackage.TypeNotIn(i.TypeNotIn...))
	}
	if i.SoldAs != nil {
		predicates = append(predicates, productpackage.SoldAsEQ(*i.SoldAs))
	}
	if i.SoldAsNEQ != nil {
		predicates = append(predicates, productpackage.SoldAsNEQ(*i.SoldAsNEQ))
	}
	if len(i.SoldAsIn) > 0 {
		predicates = append(predicates, productpackage.SoldAsIn(i.SoldAsIn...))
	}
	if len(i.SoldAsNotIn) > 0 {
		predicates = append(predicates, productpackage.SoldAsNotIn(i.SoldAsNotIn...))
	}
	if i.Name != nil {
		predicates = append(predicates, productpackage.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, productpackage.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, productpackage.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, productpackage.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, productpackage.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, productpackage.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, productpackage.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, productpackage.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, productpackage.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, productpackage.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, productpackage.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, productpackage.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, productpackage.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, productpackage.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, productpackage.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, productpackage.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, productpackage.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, productpackage.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, productpackage.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, productpackage.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, productpackage.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, productpackage.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, productpackage.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, productpackage.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, productpackage.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, productpackage.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, productpackage.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, productpackage.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, productpackage.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, productpackage.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, productpackage.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, productpackage.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, productpackage.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, productpackage.PriceLTE(*i.PriceLTE))
	}
	if i.Discontinued != nil {
		predicates = append(predicates, productpackage.DiscontinuedEQ(*i.Discontinued))
	}
	if i.DiscontinuedNEQ != nil {
		predicates = append(predicates, productpackage.DiscontinuedNEQ(*i.DiscontinuedNEQ))
	}
	if i.DiscontinuedIsNil {
		predicates = append(predicates, productpackage.DiscontinuedIsNil())
	}
	if i.DiscontinuedNotNil {
		predicates = append(predicates, productpackage.DiscontinuedNotNil())
	}

	if i.HasItems != nil {
		p := productpackage.HasItems()
		if !*i.HasItems {
			p = productpackage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasItemsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasItemsWith))
		for _, w := range i.HasItemsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasItemsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productpackage.HasItemsWith(with...))
	}
	if i.HasCreator != nil {
		p := productpackage.HasCreator()
		if !*i.HasCreator {
			p = productpackage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productpackage.HasCreatorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductPackageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return productpackage.And(predicates...), nil
	}
}

// SurveyWhereInput represents a where input for filtering Survey queries.
type SurveyWhereInput struct {
	Predicates []predicate.Survey  `json:"-"`
	Not        *SurveyWhereInput   `json:"not,omitempty"`
	Or         []*SurveyWhereInput `json:"or,omitempty"`
	And        []*SurveyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "date" field predicates.
	Date             *string  `json:"date,omitempty"`
	DateNEQ          *string  `json:"dateNEQ,omitempty"`
	DateIn           []string `json:"dateIn,omitempty"`
	DateNotIn        []string `json:"dateNotIn,omitempty"`
	DateGT           *string  `json:"dateGT,omitempty"`
	DateGTE          *string  `json:"dateGTE,omitempty"`
	DateLT           *string  `json:"dateLT,omitempty"`
	DateLTE          *string  `json:"dateLTE,omitempty"`
	DateContains     *string  `json:"dateContains,omitempty"`
	DateHasPrefix    *string  `json:"dateHasPrefix,omitempty"`
	DateHasSuffix    *string  `json:"dateHasSuffix,omitempty"`
	DateEqualFold    *string  `json:"dateEqualFold,omitempty"`
	DateContainsFold *string  `json:"dateContainsFold,omitempty"`

	// "slot" field predicates.
	Slot             *string  `json:"slot,omitempty"`
	SlotNEQ          *string  `json:"slotNEQ,omitempty"`
	SlotIn           []string `json:"slotIn,omitempty"`
	SlotNotIn        []string `json:"slotNotIn,omitempty"`
	SlotGT           *string  `json:"slotGT,omitempty"`
	SlotGTE          *string  `json:"slotGTE,omitempty"`
	SlotLT           *string  `json:"slotLT,omitempty"`
	SlotLTE          *string  `json:"slotLTE,omitempty"`
	SlotContains     *string  `json:"slotContains,omitempty"`
	SlotHasPrefix    *string  `json:"slotHasPrefix,omitempty"`
	SlotHasSuffix    *string  `json:"slotHasSuffix,omitempty"`
	SlotEqualFold    *string  `json:"slotEqualFold,omitempty"`
	SlotContainsFold *string  `json:"slotContainsFold,omitempty"`

	// "slot_id" field predicates.
	SlotID             *string  `json:"slotID,omitempty"`
	SlotIDNEQ          *string  `json:"slotIDNEQ,omitempty"`
	SlotIDIn           []string `json:"slotIDIn,omitempty"`
	SlotIDNotIn        []string `json:"slotIDNotIn,omitempty"`
	SlotIDGT           *string  `json:"slotIDGT,omitempty"`
	SlotIDGTE          *string  `json:"slotIDGTE,omitempty"`
	SlotIDLT           *string  `json:"slotIDLT,omitempty"`
	SlotIDLTE          *string  `json:"slotIDLTE,omitempty"`
	SlotIDContains     *string  `json:"slotIDContains,omitempty"`
	SlotIDHasPrefix    *string  `json:"slotIDHasPrefix,omitempty"`
	SlotIDHasSuffix    *string  `json:"slotIDHasSuffix,omitempty"`
	SlotIDEqualFold    *string  `json:"slotIDEqualFold,omitempty"`
	SlotIDContainsFold *string  `json:"slotIDContainsFold,omitempty"`

	// "from" field predicates.
	From      *time.Time  `json:"from,omitempty"`
	FromNEQ   *time.Time  `json:"fromNEQ,omitempty"`
	FromIn    []time.Time `json:"fromIn,omitempty"`
	FromNotIn []time.Time `json:"fromNotIn,omitempty"`
	FromGT    *time.Time  `json:"fromGT,omitempty"`
	FromGTE   *time.Time  `json:"fromGTE,omitempty"`
	FromLT    *time.Time  `json:"fromLT,omitempty"`
	FromLTE   *time.Time  `json:"fromLTE,omitempty"`

	// "to" field predicates.
	To      *time.Time  `json:"to,omitempty"`
	ToNEQ   *time.Time  `json:"toNEQ,omitempty"`
	ToIn    []time.Time `json:"toIn,omitempty"`
	ToNotIn []time.Time `json:"toNotIn,omitempty"`
	ToGT    *time.Time  `json:"toGT,omitempty"`
	ToGTE   *time.Time  `json:"toGTE,omitempty"`
	ToLT    *time.Time  `json:"toLT,omitempty"`
	ToLTE   *time.Time  `json:"toLTE,omitempty"`

	// "until" field predicates.
	Until       *time.Time  `json:"until,omitempty"`
	UntilNEQ    *time.Time  `json:"untilNEQ,omitempty"`
	UntilIn     []time.Time `json:"untilIn,omitempty"`
	UntilNotIn  []time.Time `json:"untilNotIn,omitempty"`
	UntilGT     *time.Time  `json:"untilGT,omitempty"`
	UntilGTE    *time.Time  `json:"untilGTE,omitempty"`
	UntilLT     *time.Time  `json:"untilLT,omitempty"`
	UntilLTE    *time.Time  `json:"untilLTE,omitempty"`
	UntilIsNil  bool        `json:"untilIsNil,omitempty"`
	UntilNotNil bool        `json:"untilNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "address" field predicates.
	Address             *string  `json:"address,omitempty"`
	AddressNEQ          *string  `json:"addressNEQ,omitempty"`
	AddressIn           []string `json:"addressIn,omitempty"`
	AddressNotIn        []string `json:"addressNotIn,omitempty"`
	AddressGT           *string  `json:"addressGT,omitempty"`
	AddressGTE          *string  `json:"addressGTE,omitempty"`
	AddressLT           *string  `json:"addressLT,omitempty"`
	AddressLTE          *string  `json:"addressLTE,omitempty"`
	AddressContains     *string  `json:"addressContains,omitempty"`
	AddressHasPrefix    *string  `json:"addressHasPrefix,omitempty"`
	AddressHasSuffix    *string  `json:"addressHasSuffix,omitempty"`
	AddressIsNil        bool     `json:"addressIsNil,omitempty"`
	AddressNotNil       bool     `json:"addressNotNil,omitempty"`
	AddressEqualFold    *string  `json:"addressEqualFold,omitempty"`
	AddressContainsFold *string  `json:"addressContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "notes" field predicates.
	Notes             *string  `json:"notes,omitempty"`
	NotesNEQ          *string  `json:"notesNEQ,omitempty"`
	NotesIn           []string `json:"notesIn,omitempty"`
	NotesNotIn        []string `json:"notesNotIn,omitempty"`
	NotesGT           *string  `json:"notesGT,omitempty"`
	NotesGTE          *string  `json:"notesGTE,omitempty"`
	NotesLT           *string  `json:"notesLT,omitempty"`
	NotesLTE          *string  `json:"notesLTE,omitempty"`
	NotesContains     *string  `json:"notesContains,omitempty"`
	NotesHasPrefix    *string  `json:"notesHasPrefix,omitempty"`
	NotesHasSuffix    *string  `json:"notesHasSuffix,omitempty"`
	NotesIsNil        bool     `json:"notesIsNil,omitempty"`
	NotesNotNil       bool     `json:"notesNotNil,omitempty"`
	NotesEqualFold    *string  `json:"notesEqualFold,omitempty"`
	NotesContainsFold *string  `json:"notesContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enum.SurveyStatus  `json:"status,omitempty"`
	StatusNEQ   *enum.SurveyStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enum.SurveyStatus `json:"statusIn,omitempty"`
	StatusNotIn []enum.SurveyStatus `json:"statusNotIn,omitempty"`

	// "progress" field predicates.
	Progress       *enum.SurveyProgress  `json:"progress,omitempty"`
	ProgressNEQ    *enum.SurveyProgress  `json:"progressNEQ,omitempty"`
	ProgressIn     []enum.SurveyProgress `json:"progressIn,omitempty"`
	ProgressNotIn  []enum.SurveyProgress `json:"progressNotIn,omitempty"`
	ProgressIsNil  bool                  `json:"progressIsNil,omitempty"`
	ProgressNotNil bool                  `json:"progressNotNil,omitempty"`

	// "progress_at" field predicates.
	ProgressAt       *time.Time  `json:"progressAt,omitempty"`
	ProgressAtNEQ    *time.Time  `json:"progressAtNEQ,omitempty"`
	ProgressAtIn     []time.Time `json:"progressAtIn,omitempty"`
	ProgressAtNotIn  []time.Time `json:"progressAtNotIn,omitempty"`
	ProgressAtGT     *time.Time  `json:"progressAtGT,omitempty"`
	ProgressAtGTE    *time.Time  `json:"progressAtGTE,omitempty"`
	ProgressAtLT     *time.Time  `json:"progressAtLT,omitempty"`
	ProgressAtLTE    *time.Time  `json:"progressAtLTE,omitempty"`
	ProgressAtIsNil  bool        `json:"progressAtIsNil,omitempty"`
	ProgressAtNotNil bool        `json:"progressAtNotNil,omitempty"`

	// "progress_flag_at" field predicates.
	ProgressFlagAt       *time.Time  `json:"progressFlagAt,omitempty"`
	ProgressFlagAtNEQ    *time.Time  `json:"progressFlagAtNEQ,omitempty"`
	ProgressFlagAtIn     []time.Time `json:"progressFlagAtIn,omitempty"`
	ProgressFlagAtNotIn  []time.Time `json:"progressFlagAtNotIn,omitempty"`
	ProgressFlagAtGT     *time.Time  `json:"progressFlagAtGT,omitempty"`
	ProgressFlagAtGTE    *time.Time  `json:"progressFlagAtGTE,omitempty"`
	ProgressFlagAtLT     *time.Time  `json:"progressFlagAtLT,omitempty"`
	ProgressFlagAtLTE    *time.Time  `json:"progressFlagAtLTE,omitempty"`
	ProgressFlagAtIsNil  bool        `json:"progressFlagAtIsNil,omitempty"`
	ProgressFlagAtNotNil bool        `json:"progressFlagAtNotNil,omitempty"`

	// "progress_history" edge predicates.
	HasProgressHistory     *bool                       `json:"hasProgressHistory,omitempty"`
	HasProgressHistoryWith []*SurveyProgressWhereInput `json:"hasProgressHistoryWith,omitempty"`

	// "created_by" edge predicates.
	HasCreatedBy     *bool             `json:"hasCreatedBy,omitempty"`
	HasCreatedByWith []*UserWhereInput `json:"hasCreatedByWith,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SurveyWhereInput) AddPredicates(predicates ...predicate.Survey) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SurveyWhereInput filter on the SurveyQuery builder.
func (i *SurveyWhereInput) Filter(q *SurveyQuery) (*SurveyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySurveyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySurveyWhereInput is returned in case the SurveyWhereInput is empty.
var ErrEmptySurveyWhereInput = errors.New("ent: empty predicate SurveyWhereInput")

// P returns a predicate for filtering surveys.
// An error is returned if the input is empty or invalid.
func (i *SurveyWhereInput) P() (predicate.Survey, error) {
	var predicates []predicate.Survey
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, survey.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Survey, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, survey.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Survey, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, survey.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, survey.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, survey.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, survey.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, survey.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, survey.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, survey.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, survey.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, survey.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, survey.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, survey.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, survey.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, survey.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, survey.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, survey.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, survey.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, survey.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, survey.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, survey.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, survey.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, survey.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, survey.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, survey.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, survey.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, survey.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, survey.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, survey.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Date != nil {
		predicates = append(predicates, survey.DateEQ(*i.Date))
	}
	if i.DateNEQ != nil {
		predicates = append(predicates, survey.DateNEQ(*i.DateNEQ))
	}
	if len(i.DateIn) > 0 {
		predicates = append(predicates, survey.DateIn(i.DateIn...))
	}
	if len(i.DateNotIn) > 0 {
		predicates = append(predicates, survey.DateNotIn(i.DateNotIn...))
	}
	if i.DateGT != nil {
		predicates = append(predicates, survey.DateGT(*i.DateGT))
	}
	if i.DateGTE != nil {
		predicates = append(predicates, survey.DateGTE(*i.DateGTE))
	}
	if i.DateLT != nil {
		predicates = append(predicates, survey.DateLT(*i.DateLT))
	}
	if i.DateLTE != nil {
		predicates = append(predicates, survey.DateLTE(*i.DateLTE))
	}
	if i.DateContains != nil {
		predicates = append(predicates, survey.DateContains(*i.DateContains))
	}
	if i.DateHasPrefix != nil {
		predicates = append(predicates, survey.DateHasPrefix(*i.DateHasPrefix))
	}
	if i.DateHasSuffix != nil {
		predicates = append(predicates, survey.DateHasSuffix(*i.DateHasSuffix))
	}
	if i.DateEqualFold != nil {
		predicates = append(predicates, survey.DateEqualFold(*i.DateEqualFold))
	}
	if i.DateContainsFold != nil {
		predicates = append(predicates, survey.DateContainsFold(*i.DateContainsFold))
	}
	if i.Slot != nil {
		predicates = append(predicates, survey.SlotEQ(*i.Slot))
	}
	if i.SlotNEQ != nil {
		predicates = append(predicates, survey.SlotNEQ(*i.SlotNEQ))
	}
	if len(i.SlotIn) > 0 {
		predicates = append(predicates, survey.SlotIn(i.SlotIn...))
	}
	if len(i.SlotNotIn) > 0 {
		predicates = append(predicates, survey.SlotNotIn(i.SlotNotIn...))
	}
	if i.SlotGT != nil {
		predicates = append(predicates, survey.SlotGT(*i.SlotGT))
	}
	if i.SlotGTE != nil {
		predicates = append(predicates, survey.SlotGTE(*i.SlotGTE))
	}
	if i.SlotLT != nil {
		predicates = append(predicates, survey.SlotLT(*i.SlotLT))
	}
	if i.SlotLTE != nil {
		predicates = append(predicates, survey.SlotLTE(*i.SlotLTE))
	}
	if i.SlotContains != nil {
		predicates = append(predicates, survey.SlotContains(*i.SlotContains))
	}
	if i.SlotHasPrefix != nil {
		predicates = append(predicates, survey.SlotHasPrefix(*i.SlotHasPrefix))
	}
	if i.SlotHasSuffix != nil {
		predicates = append(predicates, survey.SlotHasSuffix(*i.SlotHasSuffix))
	}
	if i.SlotEqualFold != nil {
		predicates = append(predicates, survey.SlotEqualFold(*i.SlotEqualFold))
	}
	if i.SlotContainsFold != nil {
		predicates = append(predicates, survey.SlotContainsFold(*i.SlotContainsFold))
	}
	if i.SlotID != nil {
		predicates = append(predicates, survey.SlotIDEQ(*i.SlotID))
	}
	if i.SlotIDNEQ != nil {
		predicates = append(predicates, survey.SlotIDNEQ(*i.SlotIDNEQ))
	}
	if len(i.SlotIDIn) > 0 {
		predicates = append(predicates, survey.SlotIDIn(i.SlotIDIn...))
	}
	if len(i.SlotIDNotIn) > 0 {
		predicates = append(predicates, survey.SlotIDNotIn(i.SlotIDNotIn...))
	}
	if i.SlotIDGT != nil {
		predicates = append(predicates, survey.SlotIDGT(*i.SlotIDGT))
	}
	if i.SlotIDGTE != nil {
		predicates = append(predicates, survey.SlotIDGTE(*i.SlotIDGTE))
	}
	if i.SlotIDLT != nil {
		predicates = append(predicates, survey.SlotIDLT(*i.SlotIDLT))
	}
	if i.SlotIDLTE != nil {
		predicates = append(predicates, survey.SlotIDLTE(*i.SlotIDLTE))
	}
	if i.SlotIDContains != nil {
		predicates = append(predicates, survey.SlotIDContains(*i.SlotIDContains))
	}
	if i.SlotIDHasPrefix != nil {
		predicates = append(predicates, survey.SlotIDHasPrefix(*i.SlotIDHasPrefix))
	}
	if i.SlotIDHasSuffix != nil {
		predicates = append(predicates, survey.SlotIDHasSuffix(*i.SlotIDHasSuffix))
	}
	if i.SlotIDEqualFold != nil {
		predicates = append(predicates, survey.SlotIDEqualFold(*i.SlotIDEqualFold))
	}
	if i.SlotIDContainsFold != nil {
		predicates = append(predicates, survey.SlotIDContainsFold(*i.SlotIDContainsFold))
	}
	if i.From != nil {
		predicates = append(predicates, survey.FromEQ(*i.From))
	}
	if i.FromNEQ != nil {
		predicates = append(predicates, survey.FromNEQ(*i.FromNEQ))
	}
	if len(i.FromIn) > 0 {
		predicates = append(predicates, survey.FromIn(i.FromIn...))
	}
	if len(i.FromNotIn) > 0 {
		predicates = append(predicates, survey.FromNotIn(i.FromNotIn...))
	}
	if i.FromGT != nil {
		predicates = append(predicates, survey.FromGT(*i.FromGT))
	}
	if i.FromGTE != nil {
		predicates = append(predicates, survey.FromGTE(*i.FromGTE))
	}
	if i.FromLT != nil {
		predicates = append(predicates, survey.FromLT(*i.FromLT))
	}
	if i.FromLTE != nil {
		predicates = append(predicates, survey.FromLTE(*i.FromLTE))
	}
	if i.To != nil {
		predicates = append(predicates, survey.ToEQ(*i.To))
	}
	if i.ToNEQ != nil {
		predicates = append(predicates, survey.ToNEQ(*i.ToNEQ))
	}
	if len(i.ToIn) > 0 {
		predicates = append(predicates, survey.ToIn(i.ToIn...))
	}
	if len(i.ToNotIn) > 0 {
		predicates = append(predicates, survey.ToNotIn(i.ToNotIn...))
	}
	if i.ToGT != nil {
		predicates = append(predicates, survey.ToGT(*i.ToGT))
	}
	if i.ToGTE != nil {
		predicates = append(predicates, survey.ToGTE(*i.ToGTE))
	}
	if i.ToLT != nil {
		predicates = append(predicates, survey.ToLT(*i.ToLT))
	}
	if i.ToLTE != nil {
		predicates = append(predicates, survey.ToLTE(*i.ToLTE))
	}
	if i.Until != nil {
		predicates = append(predicates, survey.UntilEQ(*i.Until))
	}
	if i.UntilNEQ != nil {
		predicates = append(predicates, survey.UntilNEQ(*i.UntilNEQ))
	}
	if len(i.UntilIn) > 0 {
		predicates = append(predicates, survey.UntilIn(i.UntilIn...))
	}
	if len(i.UntilNotIn) > 0 {
		predicates = append(predicates, survey.UntilNotIn(i.UntilNotIn...))
	}
	if i.UntilGT != nil {
		predicates = append(predicates, survey.UntilGT(*i.UntilGT))
	}
	if i.UntilGTE != nil {
		predicates = append(predicates, survey.UntilGTE(*i.UntilGTE))
	}
	if i.UntilLT != nil {
		predicates = append(predicates, survey.UntilLT(*i.UntilLT))
	}
	if i.UntilLTE != nil {
		predicates = append(predicates, survey.UntilLTE(*i.UntilLTE))
	}
	if i.UntilIsNil {
		predicates = append(predicates, survey.UntilIsNil())
	}
	if i.UntilNotNil {
		predicates = append(predicates, survey.UntilNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, survey.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, survey.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, survey.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, survey.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, survey.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, survey.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, survey.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, survey.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, survey.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, survey.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, survey.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, survey.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, survey.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, survey.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, survey.NameContainsFold(*i.NameContainsFold))
	}
	if i.Address != nil {
		predicates = append(predicates, survey.AddressEQ(*i.Address))
	}
	if i.AddressNEQ != nil {
		predicates = append(predicates, survey.AddressNEQ(*i.AddressNEQ))
	}
	if len(i.AddressIn) > 0 {
		predicates = append(predicates, survey.AddressIn(i.AddressIn...))
	}
	if len(i.AddressNotIn) > 0 {
		predicates = append(predicates, survey.AddressNotIn(i.AddressNotIn...))
	}
	if i.AddressGT != nil {
		predicates = append(predicates, survey.AddressGT(*i.AddressGT))
	}
	if i.AddressGTE != nil {
		predicates = append(predicates, survey.AddressGTE(*i.AddressGTE))
	}
	if i.AddressLT != nil {
		predicates = append(predicates, survey.AddressLT(*i.AddressLT))
	}
	if i.AddressLTE != nil {
		predicates = append(predicates, survey.AddressLTE(*i.AddressLTE))
	}
	if i.AddressContains != nil {
		predicates = append(predicates, survey.AddressContains(*i.AddressContains))
	}
	if i.AddressHasPrefix != nil {
		predicates = append(predicates, survey.AddressHasPrefix(*i.AddressHasPrefix))
	}
	if i.AddressHasSuffix != nil {
		predicates = append(predicates, survey.AddressHasSuffix(*i.AddressHasSuffix))
	}
	if i.AddressIsNil {
		predicates = append(predicates, survey.AddressIsNil())
	}
	if i.AddressNotNil {
		predicates = append(predicates, survey.AddressNotNil())
	}
	if i.AddressEqualFold != nil {
		predicates = append(predicates, survey.AddressEqualFold(*i.AddressEqualFold))
	}
	if i.AddressContainsFold != nil {
		predicates = append(predicates, survey.AddressContainsFold(*i.AddressContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, survey.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, survey.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, survey.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, survey.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, survey.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, survey.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, survey.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, survey.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, survey.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, survey.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, survey.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, survey.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, survey.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, survey.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, survey.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Notes != nil {
		predicates = append(predicates, survey.NotesEQ(*i.Notes))
	}
	if i.NotesNEQ != nil {
		predicates = append(predicates, survey.NotesNEQ(*i.NotesNEQ))
	}
	if len(i.NotesIn) > 0 {
		predicates = append(predicates, survey.NotesIn(i.NotesIn...))
	}
	if len(i.NotesNotIn) > 0 {
		predicates = append(predicates, survey.NotesNotIn(i.NotesNotIn...))
	}
	if i.NotesGT != nil {
		predicates = append(predicates, survey.NotesGT(*i.NotesGT))
	}
	if i.NotesGTE != nil {
		predicates = append(predicates, survey.NotesGTE(*i.NotesGTE))
	}
	if i.NotesLT != nil {
		predicates = append(predicates, survey.NotesLT(*i.NotesLT))
	}
	if i.NotesLTE != nil {
		predicates = append(predicates, survey.NotesLTE(*i.NotesLTE))
	}
	if i.NotesContains != nil {
		predicates = append(predicates, survey.NotesContains(*i.NotesContains))
	}
	if i.NotesHasPrefix != nil {
		predicates = append(predicates, survey.NotesHasPrefix(*i.NotesHasPrefix))
	}
	if i.NotesHasSuffix != nil {
		predicates = append(predicates, survey.NotesHasSuffix(*i.NotesHasSuffix))
	}
	if i.NotesIsNil {
		predicates = append(predicates, survey.NotesIsNil())
	}
	if i.NotesNotNil {
		predicates = append(predicates, survey.NotesNotNil())
	}
	if i.NotesEqualFold != nil {
		predicates = append(predicates, survey.NotesEqualFold(*i.NotesEqualFold))
	}
	if i.NotesContainsFold != nil {
		predicates = append(predicates, survey.NotesContainsFold(*i.NotesContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, survey.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, survey.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, survey.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, survey.StatusNotIn(i.StatusNotIn...))
	}
	if i.Progress != nil {
		predicates = append(predicates, survey.ProgressEQ(*i.Progress))
	}
	if i.ProgressNEQ != nil {
		predicates = append(predicates, survey.ProgressNEQ(*i.ProgressNEQ))
	}
	if len(i.ProgressIn) > 0 {
		predicates = append(predicates, survey.ProgressIn(i.ProgressIn...))
	}
	if len(i.ProgressNotIn) > 0 {
		predicates = append(predicates, survey.ProgressNotIn(i.ProgressNotIn...))
	}
	if i.ProgressIsNil {
		predicates = append(predicates, survey.ProgressIsNil())
	}
	if i.ProgressNotNil {
		predicates = append(predicates, survey.ProgressNotNil())
	}
	if i.ProgressAt != nil {
		predicates = append(predicates, survey.ProgressAtEQ(*i.ProgressAt))
	}
	if i.ProgressAtNEQ != nil {
		predicates = append(predicates, survey.ProgressAtNEQ(*i.ProgressAtNEQ))
	}
	if len(i.ProgressAtIn) > 0 {
		predicates = append(predicates, survey.ProgressAtIn(i.ProgressAtIn...))
	}
	if len(i.ProgressAtNotIn) > 0 {
		predicates = append(predicates, survey.ProgressAtNotIn(i.ProgressAtNotIn...))
	}
	if i.ProgressAtGT != nil {
		predicates = append(predicates, survey.ProgressAtGT(*i.ProgressAtGT))
	}
	if i.ProgressAtGTE != nil {
		predicates = append(predicates, survey.ProgressAtGTE(*i.ProgressAtGTE))
	}
	if i.ProgressAtLT != nil {
		predicates = append(predicates, survey.ProgressAtLT(*i.ProgressAtLT))
	}
	if i.ProgressAtLTE != nil {
		predicates = append(predicates, survey.ProgressAtLTE(*i.ProgressAtLTE))
	}
	if i.ProgressAtIsNil {
		predicates = append(predicates, survey.ProgressAtIsNil())
	}
	if i.ProgressAtNotNil {
		predicates = append(predicates, survey.ProgressAtNotNil())
	}
	if i.ProgressFlagAt != nil {
		predicates = append(predicates, survey.ProgressFlagAtEQ(*i.ProgressFlagAt))
	}
	if i.ProgressFlagAtNEQ != nil {
		predicates = append(predicates, survey.ProgressFlagAtNEQ(*i.ProgressFlagAtNEQ))
	}
	if len(i.ProgressFlagAtIn) > 0 {
		predicates = append(predicates, survey.ProgressFlagAtIn(i.ProgressFlagAtIn...))
	}
	if len(i.ProgressFlagAtNotIn) > 0 {
		predicates = append(predicates, survey.ProgressFlagAtNotIn(i.ProgressFlagAtNotIn...))
	}
	if i.ProgressFlagAtGT != nil {
		predicates = append(predicates, survey.ProgressFlagAtGT(*i.ProgressFlagAtGT))
	}
	if i.ProgressFlagAtGTE != nil {
		predicates = append(predicates, survey.ProgressFlagAtGTE(*i.ProgressFlagAtGTE))
	}
	if i.ProgressFlagAtLT != nil {
		predicates = append(predicates, survey.ProgressFlagAtLT(*i.ProgressFlagAtLT))
	}
	if i.ProgressFlagAtLTE != nil {
		predicates = append(predicates, survey.ProgressFlagAtLTE(*i.ProgressFlagAtLTE))
	}
	if i.ProgressFlagAtIsNil {
		predicates = append(predicates, survey.ProgressFlagAtIsNil())
	}
	if i.ProgressFlagAtNotNil {
		predicates = append(predicates, survey.ProgressFlagAtNotNil())
	}

	if i.HasProgressHistory != nil {
		p := survey.HasProgressHistory()
		if !*i.HasProgressHistory {
			p = survey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProgressHistoryWith) > 0 {
		with := make([]predicate.SurveyProgress, 0, len(i.HasProgressHistoryWith))
		for _, w := range i.HasProgressHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProgressHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, survey.HasProgressHistoryWith(with...))
	}
	if i.HasCreatedBy != nil {
		p := survey.HasCreatedBy()
		if !*i.HasCreatedBy {
			p = survey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatedByWith))
		for _, w := range i.HasCreatedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, survey.HasCreatedByWith(with...))
	}
	if i.HasPartner != nil {
		p := survey.HasPartner()
		if !*i.HasPartner {
			p = survey.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, survey.HasPartnerWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySurveyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return survey.And(predicates...), nil
	}
}

// SurveyProgressWhereInput represents a where input for filtering SurveyProgress queries.
type SurveyProgressWhereInput struct {
	Predicates []predicate.SurveyProgress  `json:"-"`
	Not        *SurveyProgressWhereInput   `json:"not,omitempty"`
	Or         []*SurveyProgressWhereInput `json:"or,omitempty"`
	And        []*SurveyProgressWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "status" field predicates.
	Status      *enum.SurveyProgress  `json:"status,omitempty"`
	StatusNEQ   *enum.SurveyProgress  `json:"statusNEQ,omitempty"`
	StatusIn    []enum.SurveyProgress `json:"statusIn,omitempty"`
	StatusNotIn []enum.SurveyProgress `json:"statusNotIn,omitempty"`

	// "complete" field predicates.
	Complete       *bool `json:"complete,omitempty"`
	CompleteNEQ    *bool `json:"completeNEQ,omitempty"`
	CompleteIsNil  bool  `json:"completeIsNil,omitempty"`
	CompleteNotNil bool  `json:"completeNotNil,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "survey" edge predicates.
	HasSurvey     *bool               `json:"hasSurvey,omitempty"`
	HasSurveyWith []*SurveyWhereInput `json:"hasSurveyWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "creator_api" edge predicates.
	HasCreatorAPI     *bool                `json:"hasCreatorAPI,omitempty"`
	HasCreatorAPIWith []*ApiUserWhereInput `json:"hasCreatorAPIWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SurveyProgressWhereInput) AddPredicates(predicates ...predicate.SurveyProgress) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SurveyProgressWhereInput filter on the SurveyProgressQuery builder.
func (i *SurveyProgressWhereInput) Filter(q *SurveyProgressQuery) (*SurveyProgressQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySurveyProgressWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySurveyProgressWhereInput is returned in case the SurveyProgressWhereInput is empty.
var ErrEmptySurveyProgressWhereInput = errors.New("ent: empty predicate SurveyProgressWhereInput")

// P returns a predicate for filtering surveyprogresses.
// An error is returned if the input is empty or invalid.
func (i *SurveyProgressWhereInput) P() (predicate.SurveyProgress, error) {
	var predicates []predicate.SurveyProgress
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, surveyprogress.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SurveyProgress, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, surveyprogress.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SurveyProgress, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, surveyprogress.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, surveyprogress.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, surveyprogress.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, surveyprogress.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, surveyprogress.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, surveyprogress.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, surveyprogress.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, surveyprogress.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, surveyprogress.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, surveyprogress.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, surveyprogress.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, surveyprogress.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, surveyprogress.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, surveyprogress.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, surveyprogress.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, surveyprogress.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, surveyprogress.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, surveyprogress.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, surveyprogress.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, surveyprogress.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, surveyprogress.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, surveyprogress.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, surveyprogress.StatusNotIn(i.StatusNotIn...))
	}
	if i.Complete != nil {
		predicates = append(predicates, surveyprogress.CompleteEQ(*i.Complete))
	}
	if i.CompleteNEQ != nil {
		predicates = append(predicates, surveyprogress.CompleteNEQ(*i.CompleteNEQ))
	}
	if i.CompleteIsNil {
		predicates = append(predicates, surveyprogress.CompleteIsNil())
	}
	if i.CompleteNotNil {
		predicates = append(predicates, surveyprogress.CompleteNotNil())
	}
	if i.Note != nil {
		predicates = append(predicates, surveyprogress.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, surveyprogress.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, surveyprogress.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, surveyprogress.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, surveyprogress.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, surveyprogress.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, surveyprogress.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, surveyprogress.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, surveyprogress.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, surveyprogress.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, surveyprogress.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, surveyprogress.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, surveyprogress.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, surveyprogress.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, surveyprogress.NoteContainsFold(*i.NoteContainsFold))
	}

	if i.HasSurvey != nil {
		p := surveyprogress.HasSurvey()
		if !*i.HasSurvey {
			p = surveyprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSurveyWith) > 0 {
		with := make([]predicate.Survey, 0, len(i.HasSurveyWith))
		for _, w := range i.HasSurveyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSurveyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, surveyprogress.HasSurveyWith(with...))
	}
	if i.HasCreator != nil {
		p := surveyprogress.HasCreator()
		if !*i.HasCreator {
			p = surveyprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, surveyprogress.HasCreatorWith(with...))
	}
	if i.HasCreatorAPI != nil {
		p := surveyprogress.HasCreatorAPI()
		if !*i.HasCreatorAPI {
			p = surveyprogress.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorAPIWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasCreatorAPIWith))
		for _, w := range i.HasCreatorAPIWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorAPIWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, surveyprogress.HasCreatorAPIWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySurveyProgressWhereInput
	case 1:
		return predicates[0], nil
	default:
		return surveyprogress.And(predicates...), nil
	}
}

// TokenWhereInput represents a where input for filtering Token queries.
type TokenWhereInput struct {
	Predicates []predicate.Token  `json:"-"`
	Not        *TokenWhereInput   `json:"not,omitempty"`
	Or         []*TokenWhereInput `json:"or,omitempty"`
	And        []*TokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "confirmed_at" field predicates.
	ConfirmedAt       *time.Time  `json:"confirmedAt,omitempty"`
	ConfirmedAtNEQ    *time.Time  `json:"confirmedAtNEQ,omitempty"`
	ConfirmedAtIn     []time.Time `json:"confirmedAtIn,omitempty"`
	ConfirmedAtNotIn  []time.Time `json:"confirmedAtNotIn,omitempty"`
	ConfirmedAtGT     *time.Time  `json:"confirmedAtGT,omitempty"`
	ConfirmedAtGTE    *time.Time  `json:"confirmedAtGTE,omitempty"`
	ConfirmedAtLT     *time.Time  `json:"confirmedAtLT,omitempty"`
	ConfirmedAtLTE    *time.Time  `json:"confirmedAtLTE,omitempty"`
	ConfirmedAtIsNil  bool        `json:"confirmedAtIsNil,omitempty"`
	ConfirmedAtNotNil bool        `json:"confirmedAtNotNil,omitempty"`

	// "action" field predicates.
	Action             *string  `json:"action,omitempty"`
	ActionNEQ          *string  `json:"actionNEQ,omitempty"`
	ActionIn           []string `json:"actionIn,omitempty"`
	ActionNotIn        []string `json:"actionNotIn,omitempty"`
	ActionGT           *string  `json:"actionGT,omitempty"`
	ActionGTE          *string  `json:"actionGTE,omitempty"`
	ActionLT           *string  `json:"actionLT,omitempty"`
	ActionLTE          *string  `json:"actionLTE,omitempty"`
	ActionContains     *string  `json:"actionContains,omitempty"`
	ActionHasPrefix    *string  `json:"actionHasPrefix,omitempty"`
	ActionHasSuffix    *string  `json:"actionHasSuffix,omitempty"`
	ActionEqualFold    *string  `json:"actionEqualFold,omitempty"`
	ActionContainsFold *string  `json:"actionContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TokenWhereInput) AddPredicates(predicates ...predicate.Token) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TokenWhereInput filter on the TokenQuery builder.
func (i *TokenWhereInput) Filter(q *TokenQuery) (*TokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTokenWhereInput is returned in case the TokenWhereInput is empty.
var ErrEmptyTokenWhereInput = errors.New("ent: empty predicate TokenWhereInput")

// P returns a predicate for filtering tokens.
// An error is returned if the input is empty or invalid.
func (i *TokenWhereInput) P() (predicate.Token, error) {
	var predicates []predicate.Token
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, token.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Token, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, token.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Token, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, token.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, token.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, token.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, token.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, token.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, token.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, token.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, token.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, token.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, token.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, token.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, token.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, token.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, token.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, token.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, token.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, token.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, token.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, token.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.ConfirmedAt != nil {
		predicates = append(predicates, token.ConfirmedAtEQ(*i.ConfirmedAt))
	}
	if i.ConfirmedAtNEQ != nil {
		predicates = append(predicates, token.ConfirmedAtNEQ(*i.ConfirmedAtNEQ))
	}
	if len(i.ConfirmedAtIn) > 0 {
		predicates = append(predicates, token.ConfirmedAtIn(i.ConfirmedAtIn...))
	}
	if len(i.ConfirmedAtNotIn) > 0 {
		predicates = append(predicates, token.ConfirmedAtNotIn(i.ConfirmedAtNotIn...))
	}
	if i.ConfirmedAtGT != nil {
		predicates = append(predicates, token.ConfirmedAtGT(*i.ConfirmedAtGT))
	}
	if i.ConfirmedAtGTE != nil {
		predicates = append(predicates, token.ConfirmedAtGTE(*i.ConfirmedAtGTE))
	}
	if i.ConfirmedAtLT != nil {
		predicates = append(predicates, token.ConfirmedAtLT(*i.ConfirmedAtLT))
	}
	if i.ConfirmedAtLTE != nil {
		predicates = append(predicates, token.ConfirmedAtLTE(*i.ConfirmedAtLTE))
	}
	if i.ConfirmedAtIsNil {
		predicates = append(predicates, token.ConfirmedAtIsNil())
	}
	if i.ConfirmedAtNotNil {
		predicates = append(predicates, token.ConfirmedAtNotNil())
	}
	if i.Action != nil {
		predicates = append(predicates, token.ActionEQ(*i.Action))
	}
	if i.ActionNEQ != nil {
		predicates = append(predicates, token.ActionNEQ(*i.ActionNEQ))
	}
	if len(i.ActionIn) > 0 {
		predicates = append(predicates, token.ActionIn(i.ActionIn...))
	}
	if len(i.ActionNotIn) > 0 {
		predicates = append(predicates, token.ActionNotIn(i.ActionNotIn...))
	}
	if i.ActionGT != nil {
		predicates = append(predicates, token.ActionGT(*i.ActionGT))
	}
	if i.ActionGTE != nil {
		predicates = append(predicates, token.ActionGTE(*i.ActionGTE))
	}
	if i.ActionLT != nil {
		predicates = append(predicates, token.ActionLT(*i.ActionLT))
	}
	if i.ActionLTE != nil {
		predicates = append(predicates, token.ActionLTE(*i.ActionLTE))
	}
	if i.ActionContains != nil {
		predicates = append(predicates, token.ActionContains(*i.ActionContains))
	}
	if i.ActionHasPrefix != nil {
		predicates = append(predicates, token.ActionHasPrefix(*i.ActionHasPrefix))
	}
	if i.ActionHasSuffix != nil {
		predicates = append(predicates, token.ActionHasSuffix(*i.ActionHasSuffix))
	}
	if i.ActionEqualFold != nil {
		predicates = append(predicates, token.ActionEqualFold(*i.ActionEqualFold))
	}
	if i.ActionContainsFold != nil {
		predicates = append(predicates, token.ActionContainsFold(*i.ActionContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return token.And(predicates...), nil
	}
}

// TrainingCourseWhereInput represents a where input for filtering TrainingCourse queries.
type TrainingCourseWhereInput struct {
	Predicates []predicate.TrainingCourse  `json:"-"`
	Not        *TrainingCourseWhereInput   `json:"not,omitempty"`
	Or         []*TrainingCourseWhereInput `json:"or,omitempty"`
	And        []*TrainingCourseWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "training_videos" edge predicates.
	HasTrainingVideos     *bool                      `json:"hasTrainingVideos,omitempty"`
	HasTrainingVideosWith []*TrainingVideoWhereInput `json:"hasTrainingVideosWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TrainingCourseWhereInput) AddPredicates(predicates ...predicate.TrainingCourse) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TrainingCourseWhereInput filter on the TrainingCourseQuery builder.
func (i *TrainingCourseWhereInput) Filter(q *TrainingCourseQuery) (*TrainingCourseQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTrainingCourseWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTrainingCourseWhereInput is returned in case the TrainingCourseWhereInput is empty.
var ErrEmptyTrainingCourseWhereInput = errors.New("ent: empty predicate TrainingCourseWhereInput")

// P returns a predicate for filtering trainingcourses.
// An error is returned if the input is empty or invalid.
func (i *TrainingCourseWhereInput) P() (predicate.TrainingCourse, error) {
	var predicates []predicate.TrainingCourse
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, trainingcourse.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TrainingCourse, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, trainingcourse.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TrainingCourse, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, trainingcourse.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, trainingcourse.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, trainingcourse.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, trainingcourse.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, trainingcourse.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, trainingcourse.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, trainingcourse.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, trainingcourse.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, trainingcourse.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, trainingcourse.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, trainingcourse.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, trainingcourse.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, trainingcourse.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, trainingcourse.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, trainingcourse.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, trainingcourse.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, trainingcourse.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, trainingcourse.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, trainingcourse.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, trainingcourse.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, trainingcourse.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, trainingcourse.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, trainingcourse.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, trainingcourse.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, trainingcourse.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, trainingcourse.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, trainingcourse.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, trainingcourse.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, trainingcourse.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, trainingcourse.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, trainingcourse.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, trainingcourse.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, trainingcourse.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, trainingcourse.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, trainingcourse.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, trainingcourse.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, trainingcourse.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, trainingcourse.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, trainingcourse.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, trainingcourse.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasTrainingVideos != nil {
		p := trainingcourse.HasTrainingVideos()
		if !*i.HasTrainingVideos {
			p = trainingcourse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTrainingVideosWith) > 0 {
		with := make([]predicate.TrainingVideo, 0, len(i.HasTrainingVideosWith))
		for _, w := range i.HasTrainingVideosWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTrainingVideosWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trainingcourse.HasTrainingVideosWith(with...))
	}
	if i.HasCreator != nil {
		p := trainingcourse.HasCreator()
		if !*i.HasCreator {
			p = trainingcourse.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trainingcourse.HasCreatorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTrainingCourseWhereInput
	case 1:
		return predicates[0], nil
	default:
		return trainingcourse.And(predicates...), nil
	}
}

// TrainingVideoWhereInput represents a where input for filtering TrainingVideo queries.
type TrainingVideoWhereInput struct {
	Predicates []predicate.TrainingVideo  `json:"-"`
	Not        *TrainingVideoWhereInput   `json:"not,omitempty"`
	Or         []*TrainingVideoWhereInput `json:"or,omitempty"`
	And        []*TrainingVideoWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "kind" field predicates.
	Kind      *enum.TrainingType  `json:"kind,omitempty"`
	KindNEQ   *enum.TrainingType  `json:"kindNEQ,omitempty"`
	KindIn    []enum.TrainingType `json:"kindIn,omitempty"`
	KindNotIn []enum.TrainingType `json:"kindNotIn,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "training_videos" edge predicates.
	HasTrainingVideos     *bool                             `json:"hasTrainingVideos,omitempty"`
	HasTrainingVideosWith []*PartnerTrainingVideoWhereInput `json:"hasTrainingVideosWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "course" edge predicates.
	HasCourse     *bool                       `json:"hasCourse,omitempty"`
	HasCourseWith []*TrainingCourseWhereInput `json:"hasCourseWith,omitempty"`

	// "poster" edge predicates.
	HasPoster     *bool                 `json:"hasPoster,omitempty"`
	HasPosterWith []*DocumentWhereInput `json:"hasPosterWith,omitempty"`

	// "video" edge predicates.
	HasVideo     *bool                 `json:"hasVideo,omitempty"`
	HasVideoWith []*DocumentWhereInput `json:"hasVideoWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TrainingVideoWhereInput) AddPredicates(predicates ...predicate.TrainingVideo) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TrainingVideoWhereInput filter on the TrainingVideoQuery builder.
func (i *TrainingVideoWhereInput) Filter(q *TrainingVideoQuery) (*TrainingVideoQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTrainingVideoWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTrainingVideoWhereInput is returned in case the TrainingVideoWhereInput is empty.
var ErrEmptyTrainingVideoWhereInput = errors.New("ent: empty predicate TrainingVideoWhereInput")

// P returns a predicate for filtering trainingvideos.
// An error is returned if the input is empty or invalid.
func (i *TrainingVideoWhereInput) P() (predicate.TrainingVideo, error) {
	var predicates []predicate.TrainingVideo
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, trainingvideo.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.TrainingVideo, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, trainingvideo.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.TrainingVideo, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, trainingvideo.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, trainingvideo.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, trainingvideo.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, trainingvideo.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, trainingvideo.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, trainingvideo.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, trainingvideo.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, trainingvideo.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, trainingvideo.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, trainingvideo.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, trainingvideo.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, trainingvideo.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, trainingvideo.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, trainingvideo.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, trainingvideo.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, trainingvideo.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, trainingvideo.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, trainingvideo.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, trainingvideo.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, trainingvideo.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, trainingvideo.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, trainingvideo.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, trainingvideo.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, trainingvideo.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, trainingvideo.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, trainingvideo.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, trainingvideo.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.Kind != nil {
		predicates = append(predicates, trainingvideo.KindEQ(*i.Kind))
	}
	if i.KindNEQ != nil {
		predicates = append(predicates, trainingvideo.KindNEQ(*i.KindNEQ))
	}
	if len(i.KindIn) > 0 {
		predicates = append(predicates, trainingvideo.KindIn(i.KindIn...))
	}
	if len(i.KindNotIn) > 0 {
		predicates = append(predicates, trainingvideo.KindNotIn(i.KindNotIn...))
	}
	if i.Title != nil {
		predicates = append(predicates, trainingvideo.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, trainingvideo.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, trainingvideo.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, trainingvideo.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, trainingvideo.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, trainingvideo.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, trainingvideo.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, trainingvideo.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, trainingvideo.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, trainingvideo.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, trainingvideo.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, trainingvideo.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, trainingvideo.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, trainingvideo.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, trainingvideo.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, trainingvideo.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, trainingvideo.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, trainingvideo.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, trainingvideo.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, trainingvideo.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, trainingvideo.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, trainingvideo.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, trainingvideo.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, trainingvideo.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, trainingvideo.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, trainingvideo.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasTrainingVideos != nil {
		p := trainingvideo.HasTrainingVideos()
		if !*i.HasTrainingVideos {
			p = trainingvideo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTrainingVideosWith) > 0 {
		with := make([]predicate.PartnerTrainingVideo, 0, len(i.HasTrainingVideosWith))
		for _, w := range i.HasTrainingVideosWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTrainingVideosWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trainingvideo.HasTrainingVideosWith(with...))
	}
	if i.HasCreator != nil {
		p := trainingvideo.HasCreator()
		if !*i.HasCreator {
			p = trainingvideo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trainingvideo.HasCreatorWith(with...))
	}
	if i.HasCourse != nil {
		p := trainingvideo.HasCourse()
		if !*i.HasCourse {
			p = trainingvideo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCourseWith) > 0 {
		with := make([]predicate.TrainingCourse, 0, len(i.HasCourseWith))
		for _, w := range i.HasCourseWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCourseWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trainingvideo.HasCourseWith(with...))
	}
	if i.HasPoster != nil {
		p := trainingvideo.HasPoster()
		if !*i.HasPoster {
			p = trainingvideo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPosterWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasPosterWith))
		for _, w := range i.HasPosterWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPosterWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trainingvideo.HasPosterWith(with...))
	}
	if i.HasVideo != nil {
		p := trainingvideo.HasVideo()
		if !*i.HasVideo {
			p = trainingvideo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasVideoWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasVideoWith))
		for _, w := range i.HasVideoWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasVideoWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, trainingvideo.HasVideoWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTrainingVideoWhereInput
	case 1:
		return predicates[0], nil
	default:
		return trainingvideo.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "deleted_at" field predicates.
	DeletedAt       *time.Time  `json:"deletedAt,omitempty"`
	DeletedAtNEQ    *time.Time  `json:"deletedAtNEQ,omitempty"`
	DeletedAtIn     []time.Time `json:"deletedAtIn,omitempty"`
	DeletedAtNotIn  []time.Time `json:"deletedAtNotIn,omitempty"`
	DeletedAtGT     *time.Time  `json:"deletedAtGT,omitempty"`
	DeletedAtGTE    *time.Time  `json:"deletedAtGTE,omitempty"`
	DeletedAtLT     *time.Time  `json:"deletedAtLT,omitempty"`
	DeletedAtLTE    *time.Time  `json:"deletedAtLTE,omitempty"`
	DeletedAtIsNil  bool        `json:"deletedAtIsNil,omitempty"`
	DeletedAtNotNil bool        `json:"deletedAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "pwd" field predicates.
	Pwd             *string  `json:"pwd,omitempty"`
	PwdNEQ          *string  `json:"pwdNEQ,omitempty"`
	PwdIn           []string `json:"pwdIn,omitempty"`
	PwdNotIn        []string `json:"pwdNotIn,omitempty"`
	PwdGT           *string  `json:"pwdGT,omitempty"`
	PwdGTE          *string  `json:"pwdGTE,omitempty"`
	PwdLT           *string  `json:"pwdLT,omitempty"`
	PwdLTE          *string  `json:"pwdLTE,omitempty"`
	PwdContains     *string  `json:"pwdContains,omitempty"`
	PwdHasPrefix    *string  `json:"pwdHasPrefix,omitempty"`
	PwdHasSuffix    *string  `json:"pwdHasSuffix,omitempty"`
	PwdEqualFold    *string  `json:"pwdEqualFold,omitempty"`
	PwdContainsFold *string  `json:"pwdContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        bool     `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       bool     `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        bool     `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       bool     `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "email_verified" field predicates.
	EmailVerified    *bool `json:"emailVerified,omitempty"`
	EmailVerifiedNEQ *bool `json:"emailVerifiedNEQ,omitempty"`

	// "phone_verified" field predicates.
	PhoneVerified    *bool `json:"phoneVerified,omitempty"`
	PhoneVerifiedNEQ *bool `json:"phoneVerifiedNEQ,omitempty"`

	// "picture" field predicates.
	Picture             *string  `json:"picture,omitempty"`
	PictureNEQ          *string  `json:"pictureNEQ,omitempty"`
	PictureIn           []string `json:"pictureIn,omitempty"`
	PictureNotIn        []string `json:"pictureNotIn,omitempty"`
	PictureGT           *string  `json:"pictureGT,omitempty"`
	PictureGTE          *string  `json:"pictureGTE,omitempty"`
	PictureLT           *string  `json:"pictureLT,omitempty"`
	PictureLTE          *string  `json:"pictureLTE,omitempty"`
	PictureContains     *string  `json:"pictureContains,omitempty"`
	PictureHasPrefix    *string  `json:"pictureHasPrefix,omitempty"`
	PictureHasSuffix    *string  `json:"pictureHasSuffix,omitempty"`
	PictureIsNil        bool     `json:"pictureIsNil,omitempty"`
	PictureNotNil       bool     `json:"pictureNotNil,omitempty"`
	PictureEqualFold    *string  `json:"pictureEqualFold,omitempty"`
	PictureContainsFold *string  `json:"pictureContainsFold,omitempty"`

	// "status" field predicates.
	Status      *enum.AccountStatus  `json:"status,omitempty"`
	StatusNEQ   *enum.AccountStatus  `json:"statusNEQ,omitempty"`
	StatusIn    []enum.AccountStatus `json:"statusIn,omitempty"`
	StatusNotIn []enum.AccountStatus `json:"statusNotIn,omitempty"`

	// "role" field predicates.
	Role      *enum.Role  `json:"role,omitempty"`
	RoleNEQ   *enum.Role  `json:"roleNEQ,omitempty"`
	RoleIn    []enum.Role `json:"roleIn,omitempty"`
	RoleNotIn []enum.Role `json:"roleNotIn,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "wrong_attempts" field predicates.
	WrongAttempts       *uint8  `json:"wrongAttempts,omitempty"`
	WrongAttemptsNEQ    *uint8  `json:"wrongAttemptsNEQ,omitempty"`
	WrongAttemptsIn     []uint8 `json:"wrongAttemptsIn,omitempty"`
	WrongAttemptsNotIn  []uint8 `json:"wrongAttemptsNotIn,omitempty"`
	WrongAttemptsGT     *uint8  `json:"wrongAttemptsGT,omitempty"`
	WrongAttemptsGTE    *uint8  `json:"wrongAttemptsGTE,omitempty"`
	WrongAttemptsLT     *uint8  `json:"wrongAttemptsLT,omitempty"`
	WrongAttemptsLTE    *uint8  `json:"wrongAttemptsLTE,omitempty"`
	WrongAttemptsIsNil  bool    `json:"wrongAttemptsIsNil,omitempty"`
	WrongAttemptsNotNil bool    `json:"wrongAttemptsNotNil,omitempty"`

	// "wrong_attempt_at" field predicates.
	WrongAttemptAt       *time.Time  `json:"wrongAttemptAt,omitempty"`
	WrongAttemptAtNEQ    *time.Time  `json:"wrongAttemptAtNEQ,omitempty"`
	WrongAttemptAtIn     []time.Time `json:"wrongAttemptAtIn,omitempty"`
	WrongAttemptAtNotIn  []time.Time `json:"wrongAttemptAtNotIn,omitempty"`
	WrongAttemptAtGT     *time.Time  `json:"wrongAttemptAtGT,omitempty"`
	WrongAttemptAtGTE    *time.Time  `json:"wrongAttemptAtGTE,omitempty"`
	WrongAttemptAtLT     *time.Time  `json:"wrongAttemptAtLT,omitempty"`
	WrongAttemptAtLTE    *time.Time  `json:"wrongAttemptAtLTE,omitempty"`
	WrongAttemptAtIsNil  bool        `json:"wrongAttemptAtIsNil,omitempty"`
	WrongAttemptAtNotNil bool        `json:"wrongAttemptAtNotNil,omitempty"`

	// "locked_until" field predicates.
	LockedUntil       *time.Time  `json:"lockedUntil,omitempty"`
	LockedUntilNEQ    *time.Time  `json:"lockedUntilNEQ,omitempty"`
	LockedUntilIn     []time.Time `json:"lockedUntilIn,omitempty"`
	LockedUntilNotIn  []time.Time `json:"lockedUntilNotIn,omitempty"`
	LockedUntilGT     *time.Time  `json:"lockedUntilGT,omitempty"`
	LockedUntilGTE    *time.Time  `json:"lockedUntilGTE,omitempty"`
	LockedUntilLT     *time.Time  `json:"lockedUntilLT,omitempty"`
	LockedUntilLTE    *time.Time  `json:"lockedUntilLTE,omitempty"`
	LockedUntilIsNil  bool        `json:"lockedUntilIsNil,omitempty"`
	LockedUntilNotNil bool        `json:"lockedUntilNotNil,omitempty"`

	// "location" field predicates.
	Location             *string  `json:"location,omitempty"`
	LocationNEQ          *string  `json:"locationNEQ,omitempty"`
	LocationIn           []string `json:"locationIn,omitempty"`
	LocationNotIn        []string `json:"locationNotIn,omitempty"`
	LocationGT           *string  `json:"locationGT,omitempty"`
	LocationGTE          *string  `json:"locationGTE,omitempty"`
	LocationLT           *string  `json:"locationLT,omitempty"`
	LocationLTE          *string  `json:"locationLTE,omitempty"`
	LocationContains     *string  `json:"locationContains,omitempty"`
	LocationHasPrefix    *string  `json:"locationHasPrefix,omitempty"`
	LocationHasSuffix    *string  `json:"locationHasSuffix,omitempty"`
	LocationIsNil        bool     `json:"locationIsNil,omitempty"`
	LocationNotNil       bool     `json:"locationNotNil,omitempty"`
	LocationEqualFold    *string  `json:"locationEqualFold,omitempty"`
	LocationContainsFold *string  `json:"locationContainsFold,omitempty"`

	// "accepted_general_terms" field predicates.
	AcceptedGeneralTerms       *bool `json:"acceptedGeneralTerms,omitempty"`
	AcceptedGeneralTermsNEQ    *bool `json:"acceptedGeneralTermsNEQ,omitempty"`
	AcceptedGeneralTermsIsNil  bool  `json:"acceptedGeneralTermsIsNil,omitempty"`
	AcceptedGeneralTermsNotNil bool  `json:"acceptedGeneralTermsNotNil,omitempty"`

	// "accepted_terms_n_privacy" field predicates.
	AcceptedTermsNPrivacy       *bool `json:"acceptedTermsNPrivacy,omitempty"`
	AcceptedTermsNPrivacyNEQ    *bool `json:"acceptedTermsNPrivacyNEQ,omitempty"`
	AcceptedTermsNPrivacyIsNil  bool  `json:"acceptedTermsNPrivacyIsNil,omitempty"`
	AcceptedTermsNPrivacyNotNil bool  `json:"acceptedTermsNPrivacyNotNil,omitempty"`

	// "auths" edge predicates.
	HasAuths     *bool                 `json:"hasAuths,omitempty"`
	HasAuthsWith []*UserAuthWhereInput `json:"hasAuthsWith,omitempty"`

	// "sessions" edge predicates.
	HasSessions     *bool                    `json:"hasSessions,omitempty"`
	HasSessionsWith []*UserSessionWhereInput `json:"hasSessionsWith,omitempty"`

	// "audit_logs" edge predicates.
	HasAuditLogs     *bool                 `json:"hasAuditLogs,omitempty"`
	HasAuditLogsWith []*AuditLogWhereInput `json:"hasAuditLogsWith,omitempty"`

	// "notify" edge predicates.
	HasNotify     *bool                      `json:"hasNotify,omitempty"`
	HasNotifyWith []*NotifySettingWhereInput `json:"hasNotifyWith,omitempty"`

	// "created_jobs" edge predicates.
	HasCreatedJobs     *bool            `json:"hasCreatedJobs,omitempty"`
	HasCreatedJobsWith []*JobWhereInput `json:"hasCreatedJobsWith,omitempty"`

	// "created_estimates" edge predicates.
	HasCreatedEstimates     *bool                 `json:"hasCreatedEstimates,omitempty"`
	HasCreatedEstimatesWith []*EstimateWhereInput `json:"hasCreatedEstimatesWith,omitempty"`

	// "sales_rep_estimates" edge predicates.
	HasSalesRepEstimates     *bool                 `json:"hasSalesRepEstimates,omitempty"`
	HasSalesRepEstimatesWith []*EstimateWhereInput `json:"hasSalesRepEstimatesWith,omitempty"`

	// "sales" edge predicates.
	HasSales     *bool            `json:"hasSales,omitempty"`
	HasSalesWith []*JobWhereInput `json:"hasSalesWith,omitempty"`

	// "created_installation_jobs" edge predicates.
	HasCreatedInstallationJobs     *bool                        `json:"hasCreatedInstallationJobs,omitempty"`
	HasCreatedInstallationJobsWith []*InstallationJobWhereInput `json:"hasCreatedInstallationJobsWith,omitempty"`

	// "installation_leads" edge predicates.
	HasInstallationLeads     *bool                        `json:"hasInstallationLeads,omitempty"`
	HasInstallationLeadsWith []*InstallationJobWhereInput `json:"hasInstallationLeadsWith,omitempty"`

	// "estimate_activities" edge predicates.
	HasEstimateActivities     *bool                         `json:"hasEstimateActivities,omitempty"`
	HasEstimateActivitiesWith []*EstimateActivityWhereInput `json:"hasEstimateActivitiesWith,omitempty"`

	// "job_activities" edge predicates.
	HasJobActivities     *bool                    `json:"hasJobActivities,omitempty"`
	HasJobActivitiesWith []*JobActivityWhereInput `json:"hasJobActivitiesWith,omitempty"`

	// "partner_activities" edge predicates.
	HasPartnerActivities     *bool                        `json:"hasPartnerActivities,omitempty"`
	HasPartnerActivitiesWith []*PartnerActivityWhereInput `json:"hasPartnerActivitiesWith,omitempty"`

	// "user_activities" edge predicates.
	HasUserActivities     *bool                     `json:"hasUserActivities,omitempty"`
	HasUserActivitiesWith []*UserActivityWhereInput `json:"hasUserActivitiesWith,omitempty"`

	// "activities" edge predicates.
	HasActivities     *bool                     `json:"hasActivities,omitempty"`
	HasActivitiesWith []*UserActivityWhereInput `json:"hasActivitiesWith,omitempty"`

	// "job_progress_history" edge predicates.
	HasJobProgressHistory     *bool                           `json:"hasJobProgressHistory,omitempty"`
	HasJobProgressHistoryWith []*JobProgressHistoryWhereInput `json:"hasJobProgressHistoryWith,omitempty"`

	// "installation_job_status_changer" edge predicates.
	HasInstallationJobStatusChanger     *bool                                `json:"hasInstallationJobStatusChanger,omitempty"`
	HasInstallationJobStatusChangerWith []*InstallationJobProgressWhereInput `json:"hasInstallationJobStatusChangerWith,omitempty"`

	// "contact_us_requests" edge predicates.
	HasContactUsRequests     *bool                  `json:"hasContactUsRequests,omitempty"`
	HasContactUsRequestsWith []*ContactUsWhereInput `json:"hasContactUsRequestsWith,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`

	// "surveys" edge predicates.
	HasSurveys     *bool               `json:"hasSurveys,omitempty"`
	HasSurveysWith []*SurveyWhereInput `json:"hasSurveysWith,omitempty"`

	// "survey_progress" edge predicates.
	HasSurveyProgress     *bool                       `json:"hasSurveyProgress,omitempty"`
	HasSurveyProgressWith []*SurveyProgressWhereInput `json:"hasSurveyProgressWith,omitempty"`

	// "created_training_videos" edge predicates.
	HasCreatedTrainingVideos     *bool                      `json:"hasCreatedTrainingVideos,omitempty"`
	HasCreatedTrainingVideosWith []*TrainingVideoWhereInput `json:"hasCreatedTrainingVideosWith,omitempty"`

	// "created_training_courses" edge predicates.
	HasCreatedTrainingCourses     *bool                       `json:"hasCreatedTrainingCourses,omitempty"`
	HasCreatedTrainingCoursesWith []*TrainingCourseWhereInput `json:"hasCreatedTrainingCoursesWith,omitempty"`

	// "job_notes" edge predicates.
	HasJobNotes     *bool                `json:"hasJobNotes,omitempty"`
	HasJobNotesWith []*JobNoteWhereInput `json:"hasJobNotesWith,omitempty"`

	// "chat_channels" edge predicates.
	HasChatChannels     *bool                   `json:"hasChatChannels,omitempty"`
	HasChatChannelsWith []*ChannelSubWhereInput `json:"hasChatChannelsWith,omitempty"`

	// "sent_messages" edge predicates.
	HasSentMessages     *bool                       `json:"hasSentMessages,omitempty"`
	HasSentMessagesWith []*ChannelMessageWhereInput `json:"hasSentMessagesWith,omitempty"`

	// "received_messages" edge predicates.
	HasReceivedMessages     *bool                       `json:"hasReceivedMessages,omitempty"`
	HasReceivedMessagesWith []*ChannelMessageWhereInput `json:"hasReceivedMessagesWith,omitempty"`

	// "channel_message_read" edge predicates.
	HasChannelMessageRead     *bool                           `json:"hasChannelMessageRead,omitempty"`
	HasChannelMessageReadWith []*ChannelMessageReadWhereInput `json:"hasChannelMessageReadWith,omitempty"`

	// "products_created" edge predicates.
	HasProductsCreated     *bool                `json:"hasProductsCreated,omitempty"`
	HasProductsCreatedWith []*ProductWhereInput `json:"hasProductsCreatedWith,omitempty"`

	// "product_pkg_created" edge predicates.
	HasProductPkgCreated     *bool                       `json:"hasProductPkgCreated,omitempty"`
	HasProductPkgCreatedWith []*ProductPackageWhereInput `json:"hasProductPkgCreatedWith,omitempty"`

	// "job_doc_urls" edge predicates.
	HasJobDocUrls     *bool                  `json:"hasJobDocUrls,omitempty"`
	HasJobDocUrlsWith []*JobDocURLWhereInput `json:"hasJobDocUrlsWith,omitempty"`

	// "partner_contacts" edge predicates.
	HasPartnerContacts     *bool                       `json:"hasPartnerContacts,omitempty"`
	HasPartnerContactsWith []*PartnerContactWhereInput `json:"hasPartnerContactsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, user.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, user.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.DeletedAt != nil {
		predicates = append(predicates, user.DeletedAtEQ(*i.DeletedAt))
	}
	if i.DeletedAtNEQ != nil {
		predicates = append(predicates, user.DeletedAtNEQ(*i.DeletedAtNEQ))
	}
	if len(i.DeletedAtIn) > 0 {
		predicates = append(predicates, user.DeletedAtIn(i.DeletedAtIn...))
	}
	if len(i.DeletedAtNotIn) > 0 {
		predicates = append(predicates, user.DeletedAtNotIn(i.DeletedAtNotIn...))
	}
	if i.DeletedAtGT != nil {
		predicates = append(predicates, user.DeletedAtGT(*i.DeletedAtGT))
	}
	if i.DeletedAtGTE != nil {
		predicates = append(predicates, user.DeletedAtGTE(*i.DeletedAtGTE))
	}
	if i.DeletedAtLT != nil {
		predicates = append(predicates, user.DeletedAtLT(*i.DeletedAtLT))
	}
	if i.DeletedAtLTE != nil {
		predicates = append(predicates, user.DeletedAtLTE(*i.DeletedAtLTE))
	}
	if i.DeletedAtIsNil {
		predicates = append(predicates, user.DeletedAtIsNil())
	}
	if i.DeletedAtNotNil {
		predicates = append(predicates, user.DeletedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ExternalID != nil {
		predicates = append(predicates, user.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, user.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, user.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, user.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, user.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, user.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, user.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, user.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, user.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, user.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, user.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, user.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, user.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, user.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, user.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, user.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, user.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, user.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, user.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, user.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, user.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, user.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, user.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, user.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, user.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, user.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, user.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, user.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, user.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, user.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.Pwd != nil {
		predicates = append(predicates, user.PwdEQ(*i.Pwd))
	}
	if i.PwdNEQ != nil {
		predicates = append(predicates, user.PwdNEQ(*i.PwdNEQ))
	}
	if len(i.PwdIn) > 0 {
		predicates = append(predicates, user.PwdIn(i.PwdIn...))
	}
	if len(i.PwdNotIn) > 0 {
		predicates = append(predicates, user.PwdNotIn(i.PwdNotIn...))
	}
	if i.PwdGT != nil {
		predicates = append(predicates, user.PwdGT(*i.PwdGT))
	}
	if i.PwdGTE != nil {
		predicates = append(predicates, user.PwdGTE(*i.PwdGTE))
	}
	if i.PwdLT != nil {
		predicates = append(predicates, user.PwdLT(*i.PwdLT))
	}
	if i.PwdLTE != nil {
		predicates = append(predicates, user.PwdLTE(*i.PwdLTE))
	}
	if i.PwdContains != nil {
		predicates = append(predicates, user.PwdContains(*i.PwdContains))
	}
	if i.PwdHasPrefix != nil {
		predicates = append(predicates, user.PwdHasPrefix(*i.PwdHasPrefix))
	}
	if i.PwdHasSuffix != nil {
		predicates = append(predicates, user.PwdHasSuffix(*i.PwdHasSuffix))
	}
	if i.PwdEqualFold != nil {
		predicates = append(predicates, user.PwdEqualFold(*i.PwdEqualFold))
	}
	if i.PwdContainsFold != nil {
		predicates = append(predicates, user.PwdContainsFold(*i.PwdContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, user.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, user.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, user.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, user.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, user.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, user.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, user.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, user.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, user.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, user.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, user.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameIsNil {
		predicates = append(predicates, user.FirstNameIsNil())
	}
	if i.FirstNameNotNil {
		predicates = append(predicates, user.FirstNameNotNil())
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, user.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, user.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, user.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, user.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, user.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, user.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, user.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, user.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, user.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, user.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, user.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, user.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, user.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameIsNil {
		predicates = append(predicates, user.LastNameIsNil())
	}
	if i.LastNameNotNil {
		predicates = append(predicates, user.LastNameNotNil())
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, user.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, user.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.EmailVerified != nil {
		predicates = append(predicates, user.EmailVerifiedEQ(*i.EmailVerified))
	}
	if i.EmailVerifiedNEQ != nil {
		predicates = append(predicates, user.EmailVerifiedNEQ(*i.EmailVerifiedNEQ))
	}
	if i.PhoneVerified != nil {
		predicates = append(predicates, user.PhoneVerifiedEQ(*i.PhoneVerified))
	}
	if i.PhoneVerifiedNEQ != nil {
		predicates = append(predicates, user.PhoneVerifiedNEQ(*i.PhoneVerifiedNEQ))
	}
	if i.Picture != nil {
		predicates = append(predicates, user.PictureEQ(*i.Picture))
	}
	if i.PictureNEQ != nil {
		predicates = append(predicates, user.PictureNEQ(*i.PictureNEQ))
	}
	if len(i.PictureIn) > 0 {
		predicates = append(predicates, user.PictureIn(i.PictureIn...))
	}
	if len(i.PictureNotIn) > 0 {
		predicates = append(predicates, user.PictureNotIn(i.PictureNotIn...))
	}
	if i.PictureGT != nil {
		predicates = append(predicates, user.PictureGT(*i.PictureGT))
	}
	if i.PictureGTE != nil {
		predicates = append(predicates, user.PictureGTE(*i.PictureGTE))
	}
	if i.PictureLT != nil {
		predicates = append(predicates, user.PictureLT(*i.PictureLT))
	}
	if i.PictureLTE != nil {
		predicates = append(predicates, user.PictureLTE(*i.PictureLTE))
	}
	if i.PictureContains != nil {
		predicates = append(predicates, user.PictureContains(*i.PictureContains))
	}
	if i.PictureHasPrefix != nil {
		predicates = append(predicates, user.PictureHasPrefix(*i.PictureHasPrefix))
	}
	if i.PictureHasSuffix != nil {
		predicates = append(predicates, user.PictureHasSuffix(*i.PictureHasSuffix))
	}
	if i.PictureIsNil {
		predicates = append(predicates, user.PictureIsNil())
	}
	if i.PictureNotNil {
		predicates = append(predicates, user.PictureNotNil())
	}
	if i.PictureEqualFold != nil {
		predicates = append(predicates, user.PictureEqualFold(*i.PictureEqualFold))
	}
	if i.PictureContainsFold != nil {
		predicates = append(predicates, user.PictureContainsFold(*i.PictureContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, user.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, user.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, user.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, user.StatusNotIn(i.StatusNotIn...))
	}
	if i.Role != nil {
		predicates = append(predicates, user.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, user.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, user.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, user.RoleNotIn(i.RoleNotIn...))
	}
	if i.Note != nil {
		predicates = append(predicates, user.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, user.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, user.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, user.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, user.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, user.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, user.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, user.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, user.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, user.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, user.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, user.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, user.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, user.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, user.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.WrongAttempts != nil {
		predicates = append(predicates, user.WrongAttemptsEQ(*i.WrongAttempts))
	}
	if i.WrongAttemptsNEQ != nil {
		predicates = append(predicates, user.WrongAttemptsNEQ(*i.WrongAttemptsNEQ))
	}
	if len(i.WrongAttemptsIn) > 0 {
		predicates = append(predicates, user.WrongAttemptsIn(i.WrongAttemptsIn...))
	}
	if len(i.WrongAttemptsNotIn) > 0 {
		predicates = append(predicates, user.WrongAttemptsNotIn(i.WrongAttemptsNotIn...))
	}
	if i.WrongAttemptsGT != nil {
		predicates = append(predicates, user.WrongAttemptsGT(*i.WrongAttemptsGT))
	}
	if i.WrongAttemptsGTE != nil {
		predicates = append(predicates, user.WrongAttemptsGTE(*i.WrongAttemptsGTE))
	}
	if i.WrongAttemptsLT != nil {
		predicates = append(predicates, user.WrongAttemptsLT(*i.WrongAttemptsLT))
	}
	if i.WrongAttemptsLTE != nil {
		predicates = append(predicates, user.WrongAttemptsLTE(*i.WrongAttemptsLTE))
	}
	if i.WrongAttemptsIsNil {
		predicates = append(predicates, user.WrongAttemptsIsNil())
	}
	if i.WrongAttemptsNotNil {
		predicates = append(predicates, user.WrongAttemptsNotNil())
	}
	if i.WrongAttemptAt != nil {
		predicates = append(predicates, user.WrongAttemptAtEQ(*i.WrongAttemptAt))
	}
	if i.WrongAttemptAtNEQ != nil {
		predicates = append(predicates, user.WrongAttemptAtNEQ(*i.WrongAttemptAtNEQ))
	}
	if len(i.WrongAttemptAtIn) > 0 {
		predicates = append(predicates, user.WrongAttemptAtIn(i.WrongAttemptAtIn...))
	}
	if len(i.WrongAttemptAtNotIn) > 0 {
		predicates = append(predicates, user.WrongAttemptAtNotIn(i.WrongAttemptAtNotIn...))
	}
	if i.WrongAttemptAtGT != nil {
		predicates = append(predicates, user.WrongAttemptAtGT(*i.WrongAttemptAtGT))
	}
	if i.WrongAttemptAtGTE != nil {
		predicates = append(predicates, user.WrongAttemptAtGTE(*i.WrongAttemptAtGTE))
	}
	if i.WrongAttemptAtLT != nil {
		predicates = append(predicates, user.WrongAttemptAtLT(*i.WrongAttemptAtLT))
	}
	if i.WrongAttemptAtLTE != nil {
		predicates = append(predicates, user.WrongAttemptAtLTE(*i.WrongAttemptAtLTE))
	}
	if i.WrongAttemptAtIsNil {
		predicates = append(predicates, user.WrongAttemptAtIsNil())
	}
	if i.WrongAttemptAtNotNil {
		predicates = append(predicates, user.WrongAttemptAtNotNil())
	}
	if i.LockedUntil != nil {
		predicates = append(predicates, user.LockedUntilEQ(*i.LockedUntil))
	}
	if i.LockedUntilNEQ != nil {
		predicates = append(predicates, user.LockedUntilNEQ(*i.LockedUntilNEQ))
	}
	if len(i.LockedUntilIn) > 0 {
		predicates = append(predicates, user.LockedUntilIn(i.LockedUntilIn...))
	}
	if len(i.LockedUntilNotIn) > 0 {
		predicates = append(predicates, user.LockedUntilNotIn(i.LockedUntilNotIn...))
	}
	if i.LockedUntilGT != nil {
		predicates = append(predicates, user.LockedUntilGT(*i.LockedUntilGT))
	}
	if i.LockedUntilGTE != nil {
		predicates = append(predicates, user.LockedUntilGTE(*i.LockedUntilGTE))
	}
	if i.LockedUntilLT != nil {
		predicates = append(predicates, user.LockedUntilLT(*i.LockedUntilLT))
	}
	if i.LockedUntilLTE != nil {
		predicates = append(predicates, user.LockedUntilLTE(*i.LockedUntilLTE))
	}
	if i.LockedUntilIsNil {
		predicates = append(predicates, user.LockedUntilIsNil())
	}
	if i.LockedUntilNotNil {
		predicates = append(predicates, user.LockedUntilNotNil())
	}
	if i.Location != nil {
		predicates = append(predicates, user.LocationEQ(*i.Location))
	}
	if i.LocationNEQ != nil {
		predicates = append(predicates, user.LocationNEQ(*i.LocationNEQ))
	}
	if len(i.LocationIn) > 0 {
		predicates = append(predicates, user.LocationIn(i.LocationIn...))
	}
	if len(i.LocationNotIn) > 0 {
		predicates = append(predicates, user.LocationNotIn(i.LocationNotIn...))
	}
	if i.LocationGT != nil {
		predicates = append(predicates, user.LocationGT(*i.LocationGT))
	}
	if i.LocationGTE != nil {
		predicates = append(predicates, user.LocationGTE(*i.LocationGTE))
	}
	if i.LocationLT != nil {
		predicates = append(predicates, user.LocationLT(*i.LocationLT))
	}
	if i.LocationLTE != nil {
		predicates = append(predicates, user.LocationLTE(*i.LocationLTE))
	}
	if i.LocationContains != nil {
		predicates = append(predicates, user.LocationContains(*i.LocationContains))
	}
	if i.LocationHasPrefix != nil {
		predicates = append(predicates, user.LocationHasPrefix(*i.LocationHasPrefix))
	}
	if i.LocationHasSuffix != nil {
		predicates = append(predicates, user.LocationHasSuffix(*i.LocationHasSuffix))
	}
	if i.LocationIsNil {
		predicates = append(predicates, user.LocationIsNil())
	}
	if i.LocationNotNil {
		predicates = append(predicates, user.LocationNotNil())
	}
	if i.LocationEqualFold != nil {
		predicates = append(predicates, user.LocationEqualFold(*i.LocationEqualFold))
	}
	if i.LocationContainsFold != nil {
		predicates = append(predicates, user.LocationContainsFold(*i.LocationContainsFold))
	}
	if i.AcceptedGeneralTerms != nil {
		predicates = append(predicates, user.AcceptedGeneralTermsEQ(*i.AcceptedGeneralTerms))
	}
	if i.AcceptedGeneralTermsNEQ != nil {
		predicates = append(predicates, user.AcceptedGeneralTermsNEQ(*i.AcceptedGeneralTermsNEQ))
	}
	if i.AcceptedGeneralTermsIsNil {
		predicates = append(predicates, user.AcceptedGeneralTermsIsNil())
	}
	if i.AcceptedGeneralTermsNotNil {
		predicates = append(predicates, user.AcceptedGeneralTermsNotNil())
	}
	if i.AcceptedTermsNPrivacy != nil {
		predicates = append(predicates, user.AcceptedTermsNPrivacyEQ(*i.AcceptedTermsNPrivacy))
	}
	if i.AcceptedTermsNPrivacyNEQ != nil {
		predicates = append(predicates, user.AcceptedTermsNPrivacyNEQ(*i.AcceptedTermsNPrivacyNEQ))
	}
	if i.AcceptedTermsNPrivacyIsNil {
		predicates = append(predicates, user.AcceptedTermsNPrivacyIsNil())
	}
	if i.AcceptedTermsNPrivacyNotNil {
		predicates = append(predicates, user.AcceptedTermsNPrivacyNotNil())
	}

	if i.HasAuths != nil {
		p := user.HasAuths()
		if !*i.HasAuths {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuthsWith) > 0 {
		with := make([]predicate.UserAuth, 0, len(i.HasAuthsWith))
		for _, w := range i.HasAuthsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuthsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAuthsWith(with...))
	}
	if i.HasSessions != nil {
		p := user.HasSessions()
		if !*i.HasSessions {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionsWith) > 0 {
		with := make([]predicate.UserSession, 0, len(i.HasSessionsWith))
		for _, w := range i.HasSessionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSessionsWith(with...))
	}
	if i.HasAuditLogs != nil {
		p := user.HasAuditLogs()
		if !*i.HasAuditLogs {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAuditLogsWith) > 0 {
		with := make([]predicate.AuditLog, 0, len(i.HasAuditLogsWith))
		for _, w := range i.HasAuditLogsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAuditLogsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAuditLogsWith(with...))
	}
	if i.HasNotify != nil {
		p := user.HasNotify()
		if !*i.HasNotify {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotifyWith) > 0 {
		with := make([]predicate.NotifySetting, 0, len(i.HasNotifyWith))
		for _, w := range i.HasNotifyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotifyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasNotifyWith(with...))
	}
	if i.HasCreatedJobs != nil {
		p := user.HasCreatedJobs()
		if !*i.HasCreatedJobs {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedJobsWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasCreatedJobsWith))
		for _, w := range i.HasCreatedJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedJobsWith(with...))
	}
	if i.HasCreatedEstimates != nil {
		p := user.HasCreatedEstimates()
		if !*i.HasCreatedEstimates {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedEstimatesWith) > 0 {
		with := make([]predicate.Estimate, 0, len(i.HasCreatedEstimatesWith))
		for _, w := range i.HasCreatedEstimatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedEstimatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedEstimatesWith(with...))
	}
	if i.HasSalesRepEstimates != nil {
		p := user.HasSalesRepEstimates()
		if !*i.HasSalesRepEstimates {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSalesRepEstimatesWith) > 0 {
		with := make([]predicate.Estimate, 0, len(i.HasSalesRepEstimatesWith))
		for _, w := range i.HasSalesRepEstimatesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSalesRepEstimatesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSalesRepEstimatesWith(with...))
	}
	if i.HasSales != nil {
		p := user.HasSales()
		if !*i.HasSales {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSalesWith) > 0 {
		with := make([]predicate.Job, 0, len(i.HasSalesWith))
		for _, w := range i.HasSalesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSalesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSalesWith(with...))
	}
	if i.HasCreatedInstallationJobs != nil {
		p := user.HasCreatedInstallationJobs()
		if !*i.HasCreatedInstallationJobs {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedInstallationJobsWith) > 0 {
		with := make([]predicate.InstallationJob, 0, len(i.HasCreatedInstallationJobsWith))
		for _, w := range i.HasCreatedInstallationJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedInstallationJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedInstallationJobsWith(with...))
	}
	if i.HasInstallationLeads != nil {
		p := user.HasInstallationLeads()
		if !*i.HasInstallationLeads {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstallationLeadsWith) > 0 {
		with := make([]predicate.InstallationJob, 0, len(i.HasInstallationLeadsWith))
		for _, w := range i.HasInstallationLeadsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInstallationLeadsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasInstallationLeadsWith(with...))
	}
	if i.HasEstimateActivities != nil {
		p := user.HasEstimateActivities()
		if !*i.HasEstimateActivities {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEstimateActivitiesWith) > 0 {
		with := make([]predicate.EstimateActivity, 0, len(i.HasEstimateActivitiesWith))
		for _, w := range i.HasEstimateActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEstimateActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasEstimateActivitiesWith(with...))
	}
	if i.HasJobActivities != nil {
		p := user.HasJobActivities()
		if !*i.HasJobActivities {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobActivitiesWith) > 0 {
		with := make([]predicate.JobActivity, 0, len(i.HasJobActivitiesWith))
		for _, w := range i.HasJobActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasJobActivitiesWith(with...))
	}
	if i.HasPartnerActivities != nil {
		p := user.HasPartnerActivities()
		if !*i.HasPartnerActivities {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerActivitiesWith) > 0 {
		with := make([]predicate.PartnerActivity, 0, len(i.HasPartnerActivitiesWith))
		for _, w := range i.HasPartnerActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPartnerActivitiesWith(with...))
	}
	if i.HasUserActivities != nil {
		p := user.HasUserActivities()
		if !*i.HasUserActivities {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserActivitiesWith) > 0 {
		with := make([]predicate.UserActivity, 0, len(i.HasUserActivitiesWith))
		for _, w := range i.HasUserActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasUserActivitiesWith(with...))
	}
	if i.HasActivities != nil {
		p := user.HasActivities()
		if !*i.HasActivities {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasActivitiesWith) > 0 {
		with := make([]predicate.UserActivity, 0, len(i.HasActivitiesWith))
		for _, w := range i.HasActivitiesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasActivitiesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasActivitiesWith(with...))
	}
	if i.HasJobProgressHistory != nil {
		p := user.HasJobProgressHistory()
		if !*i.HasJobProgressHistory {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobProgressHistoryWith) > 0 {
		with := make([]predicate.JobProgressHistory, 0, len(i.HasJobProgressHistoryWith))
		for _, w := range i.HasJobProgressHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobProgressHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasJobProgressHistoryWith(with...))
	}
	if i.HasInstallationJobStatusChanger != nil {
		p := user.HasInstallationJobStatusChanger()
		if !*i.HasInstallationJobStatusChanger {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInstallationJobStatusChangerWith) > 0 {
		with := make([]predicate.InstallationJobProgress, 0, len(i.HasInstallationJobStatusChangerWith))
		for _, w := range i.HasInstallationJobStatusChangerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInstallationJobStatusChangerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasInstallationJobStatusChangerWith(with...))
	}
	if i.HasContactUsRequests != nil {
		p := user.HasContactUsRequests()
		if !*i.HasContactUsRequests {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasContactUsRequestsWith) > 0 {
		with := make([]predicate.ContactUs, 0, len(i.HasContactUsRequestsWith))
		for _, w := range i.HasContactUsRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasContactUsRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasContactUsRequestsWith(with...))
	}
	if i.HasPartner != nil {
		p := user.HasPartner()
		if !*i.HasPartner {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPartnerWith(with...))
	}
	if i.HasSurveys != nil {
		p := user.HasSurveys()
		if !*i.HasSurveys {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSurveysWith) > 0 {
		with := make([]predicate.Survey, 0, len(i.HasSurveysWith))
		for _, w := range i.HasSurveysWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSurveysWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSurveysWith(with...))
	}
	if i.HasSurveyProgress != nil {
		p := user.HasSurveyProgress()
		if !*i.HasSurveyProgress {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSurveyProgressWith) > 0 {
		with := make([]predicate.SurveyProgress, 0, len(i.HasSurveyProgressWith))
		for _, w := range i.HasSurveyProgressWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSurveyProgressWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSurveyProgressWith(with...))
	}
	if i.HasCreatedTrainingVideos != nil {
		p := user.HasCreatedTrainingVideos()
		if !*i.HasCreatedTrainingVideos {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedTrainingVideosWith) > 0 {
		with := make([]predicate.TrainingVideo, 0, len(i.HasCreatedTrainingVideosWith))
		for _, w := range i.HasCreatedTrainingVideosWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedTrainingVideosWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedTrainingVideosWith(with...))
	}
	if i.HasCreatedTrainingCourses != nil {
		p := user.HasCreatedTrainingCourses()
		if !*i.HasCreatedTrainingCourses {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatedTrainingCoursesWith) > 0 {
		with := make([]predicate.TrainingCourse, 0, len(i.HasCreatedTrainingCoursesWith))
		for _, w := range i.HasCreatedTrainingCoursesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatedTrainingCoursesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasCreatedTrainingCoursesWith(with...))
	}
	if i.HasJobNotes != nil {
		p := user.HasJobNotes()
		if !*i.HasJobNotes {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobNotesWith) > 0 {
		with := make([]predicate.JobNote, 0, len(i.HasJobNotesWith))
		for _, w := range i.HasJobNotesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobNotesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasJobNotesWith(with...))
	}
	if i.HasChatChannels != nil {
		p := user.HasChatChannels()
		if !*i.HasChatChannels {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChatChannelsWith) > 0 {
		with := make([]predicate.ChannelSub, 0, len(i.HasChatChannelsWith))
		for _, w := range i.HasChatChannelsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChatChannelsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasChatChannelsWith(with...))
	}
	if i.HasSentMessages != nil {
		p := user.HasSentMessages()
		if !*i.HasSentMessages {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSentMessagesWith) > 0 {
		with := make([]predicate.ChannelMessage, 0, len(i.HasSentMessagesWith))
		for _, w := range i.HasSentMessagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSentMessagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSentMessagesWith(with...))
	}
	if i.HasReceivedMessages != nil {
		p := user.HasReceivedMessages()
		if !*i.HasReceivedMessages {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReceivedMessagesWith) > 0 {
		with := make([]predicate.ChannelMessage, 0, len(i.HasReceivedMessagesWith))
		for _, w := range i.HasReceivedMessagesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReceivedMessagesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasReceivedMessagesWith(with...))
	}
	if i.HasChannelMessageRead != nil {
		p := user.HasChannelMessageRead()
		if !*i.HasChannelMessageRead {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChannelMessageReadWith) > 0 {
		with := make([]predicate.ChannelMessageRead, 0, len(i.HasChannelMessageReadWith))
		for _, w := range i.HasChannelMessageReadWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChannelMessageReadWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasChannelMessageReadWith(with...))
	}
	if i.HasProductsCreated != nil {
		p := user.HasProductsCreated()
		if !*i.HasProductsCreated {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsCreatedWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsCreatedWith))
		for _, w := range i.HasProductsCreatedWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsCreatedWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasProductsCreatedWith(with...))
	}
	if i.HasProductPkgCreated != nil {
		p := user.HasProductPkgCreated()
		if !*i.HasProductPkgCreated {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductPkgCreatedWith) > 0 {
		with := make([]predicate.ProductPackage, 0, len(i.HasProductPkgCreatedWith))
		for _, w := range i.HasProductPkgCreatedWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductPkgCreatedWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasProductPkgCreatedWith(with...))
	}
	if i.HasJobDocUrls != nil {
		p := user.HasJobDocUrls()
		if !*i.HasJobDocUrls {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasJobDocUrlsWith) > 0 {
		with := make([]predicate.JobDocURL, 0, len(i.HasJobDocUrlsWith))
		for _, w := range i.HasJobDocUrlsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasJobDocUrlsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasJobDocUrlsWith(with...))
	}
	if i.HasPartnerContacts != nil {
		p := user.HasPartnerContacts()
		if !*i.HasPartnerContacts {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerContactsWith) > 0 {
		with := make([]predicate.PartnerContact, 0, len(i.HasPartnerContactsWith))
		for _, w := range i.HasPartnerContactsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerContactsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPartnerContactsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserActivityWhereInput represents a where input for filtering UserActivity queries.
type UserActivityWhereInput struct {
	Predicates []predicate.UserActivity  `json:"-"`
	Not        *UserActivityWhereInput   `json:"not,omitempty"`
	Or         []*UserActivityWhereInput `json:"or,omitempty"`
	And        []*UserActivityWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "creator" edge predicates.
	HasCreator     *bool             `json:"hasCreator,omitempty"`
	HasCreatorWith []*UserWhereInput `json:"hasCreatorWith,omitempty"`

	// "creator_api" edge predicates.
	HasCreatorAPI     *bool                `json:"hasCreatorAPI,omitempty"`
	HasCreatorAPIWith []*ApiUserWhereInput `json:"hasCreatorAPIWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserActivityWhereInput) AddPredicates(predicates ...predicate.UserActivity) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserActivityWhereInput filter on the UserActivityQuery builder.
func (i *UserActivityWhereInput) Filter(q *UserActivityQuery) (*UserActivityQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserActivityWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserActivityWhereInput is returned in case the UserActivityWhereInput is empty.
var ErrEmptyUserActivityWhereInput = errors.New("ent: empty predicate UserActivityWhereInput")

// P returns a predicate for filtering useractivities.
// An error is returned if the input is empty or invalid.
func (i *UserActivityWhereInput) P() (predicate.UserActivity, error) {
	var predicates []predicate.UserActivity
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, useractivity.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserActivity, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, useractivity.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserActivity, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, useractivity.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, useractivity.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, useractivity.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, useractivity.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, useractivity.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, useractivity.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, useractivity.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, useractivity.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, useractivity.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, useractivity.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, useractivity.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, useractivity.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, useractivity.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, useractivity.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, useractivity.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, useractivity.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, useractivity.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, useractivity.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, useractivity.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Description != nil {
		predicates = append(predicates, useractivity.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, useractivity.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, useractivity.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, useractivity.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, useractivity.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, useractivity.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, useractivity.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, useractivity.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, useractivity.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, useractivity.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, useractivity.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, useractivity.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, useractivity.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasUser != nil {
		p := useractivity.HasUser()
		if !*i.HasUser {
			p = useractivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, useractivity.HasUserWith(with...))
	}
	if i.HasCreator != nil {
		p := useractivity.HasCreator()
		if !*i.HasCreator {
			p = useractivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasCreatorWith))
		for _, w := range i.HasCreatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, useractivity.HasCreatorWith(with...))
	}
	if i.HasCreatorAPI != nil {
		p := useractivity.HasCreatorAPI()
		if !*i.HasCreatorAPI {
			p = useractivity.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCreatorAPIWith) > 0 {
		with := make([]predicate.ApiUser, 0, len(i.HasCreatorAPIWith))
		for _, w := range i.HasCreatorAPIWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCreatorAPIWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, useractivity.HasCreatorAPIWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserActivityWhereInput
	case 1:
		return predicates[0], nil
	default:
		return useractivity.And(predicates...), nil
	}
}

// UserAuthWhereInput represents a where input for filtering UserAuth queries.
type UserAuthWhereInput struct {
	Predicates []predicate.UserAuth  `json:"-"`
	Not        *UserAuthWhereInput   `json:"not,omitempty"`
	Or         []*UserAuthWhereInput `json:"or,omitempty"`
	And        []*UserAuthWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "provider_id" field predicates.
	ProviderID      *uint8  `json:"providerID,omitempty"`
	ProviderIDNEQ   *uint8  `json:"providerIDNEQ,omitempty"`
	ProviderIDIn    []uint8 `json:"providerIDIn,omitempty"`
	ProviderIDNotIn []uint8 `json:"providerIDNotIn,omitempty"`
	ProviderIDGT    *uint8  `json:"providerIDGT,omitempty"`
	ProviderIDGTE   *uint8  `json:"providerIDGTE,omitempty"`
	ProviderIDLT    *uint8  `json:"providerIDLT,omitempty"`
	ProviderIDLTE   *uint8  `json:"providerIDLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserAuthWhereInput) AddPredicates(predicates ...predicate.UserAuth) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserAuthWhereInput filter on the UserAuthQuery builder.
func (i *UserAuthWhereInput) Filter(q *UserAuthQuery) (*UserAuthQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserAuthWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserAuthWhereInput is returned in case the UserAuthWhereInput is empty.
var ErrEmptyUserAuthWhereInput = errors.New("ent: empty predicate UserAuthWhereInput")

// P returns a predicate for filtering userauths.
// An error is returned if the input is empty or invalid.
func (i *UserAuthWhereInput) P() (predicate.UserAuth, error) {
	var predicates []predicate.UserAuth
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userauth.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserAuth, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userauth.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserAuth, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userauth.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userauth.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userauth.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userauth.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userauth.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userauth.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userauth.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userauth.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userauth.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, userauth.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, userauth.IDContainsFold(*i.IDContainsFold))
	}
	if i.ProviderID != nil {
		predicates = append(predicates, userauth.ProviderIDEQ(*i.ProviderID))
	}
	if i.ProviderIDNEQ != nil {
		predicates = append(predicates, userauth.ProviderIDNEQ(*i.ProviderIDNEQ))
	}
	if len(i.ProviderIDIn) > 0 {
		predicates = append(predicates, userauth.ProviderIDIn(i.ProviderIDIn...))
	}
	if len(i.ProviderIDNotIn) > 0 {
		predicates = append(predicates, userauth.ProviderIDNotIn(i.ProviderIDNotIn...))
	}
	if i.ProviderIDGT != nil {
		predicates = append(predicates, userauth.ProviderIDGT(*i.ProviderIDGT))
	}
	if i.ProviderIDGTE != nil {
		predicates = append(predicates, userauth.ProviderIDGTE(*i.ProviderIDGTE))
	}
	if i.ProviderIDLT != nil {
		predicates = append(predicates, userauth.ProviderIDLT(*i.ProviderIDLT))
	}
	if i.ProviderIDLTE != nil {
		predicates = append(predicates, userauth.ProviderIDLTE(*i.ProviderIDLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userauth.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userauth.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userauth.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userauth.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userauth.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userauth.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userauth.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userauth.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasUser != nil {
		p := userauth.HasUser()
		if !*i.HasUser {
			p = userauth.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userauth.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserAuthWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userauth.And(predicates...), nil
	}
}

// UserSessionWhereInput represents a where input for filtering UserSession queries.
type UserSessionWhereInput struct {
	Predicates []predicate.UserSession  `json:"-"`
	Not        *UserSessionWhereInput   `json:"not,omitempty"`
	Or         []*UserSessionWhereInput `json:"or,omitempty"`
	And        []*UserSessionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "expires_at" field predicates.
	ExpiresAt      *time.Time  `json:"expiresAt,omitempty"`
	ExpiresAtNEQ   *time.Time  `json:"expiresAtNEQ,omitempty"`
	ExpiresAtIn    []time.Time `json:"expiresAtIn,omitempty"`
	ExpiresAtNotIn []time.Time `json:"expiresAtNotIn,omitempty"`
	ExpiresAtGT    *time.Time  `json:"expiresAtGT,omitempty"`
	ExpiresAtGTE   *time.Time  `json:"expiresAtGTE,omitempty"`
	ExpiresAtLT    *time.Time  `json:"expiresAtLT,omitempty"`
	ExpiresAtLTE   *time.Time  `json:"expiresAtLTE,omitempty"`

	// "ip" field predicates.
	IP             *string  `json:"ip,omitempty"`
	IPNEQ          *string  `json:"ipNEQ,omitempty"`
	IPIn           []string `json:"ipIn,omitempty"`
	IPNotIn        []string `json:"ipNotIn,omitempty"`
	IPGT           *string  `json:"ipGT,omitempty"`
	IPGTE          *string  `json:"ipGTE,omitempty"`
	IPLT           *string  `json:"ipLT,omitempty"`
	IPLTE          *string  `json:"ipLTE,omitempty"`
	IPContains     *string  `json:"ipContains,omitempty"`
	IPHasPrefix    *string  `json:"ipHasPrefix,omitempty"`
	IPHasSuffix    *string  `json:"ipHasSuffix,omitempty"`
	IPEqualFold    *string  `json:"ipEqualFold,omitempty"`
	IPContainsFold *string  `json:"ipContainsFold,omitempty"`

	// "sockets" edge predicates.
	HasSockets     *bool                          `json:"hasSockets,omitempty"`
	HasSocketsWith []*UserSessionSocketWhereInput `json:"hasSocketsWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "partner" edge predicates.
	HasPartner     *bool                `json:"hasPartner,omitempty"`
	HasPartnerWith []*PartnerWhereInput `json:"hasPartnerWith,omitempty"`

	// "partner_contact" edge predicates.
	HasPartnerContact     *bool                       `json:"hasPartnerContact,omitempty"`
	HasPartnerContactWith []*PartnerContactWhereInput `json:"hasPartnerContactWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserSessionWhereInput) AddPredicates(predicates ...predicate.UserSession) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserSessionWhereInput filter on the UserSessionQuery builder.
func (i *UserSessionWhereInput) Filter(q *UserSessionQuery) (*UserSessionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserSessionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserSessionWhereInput is returned in case the UserSessionWhereInput is empty.
var ErrEmptyUserSessionWhereInput = errors.New("ent: empty predicate UserSessionWhereInput")

// P returns a predicate for filtering usersessions.
// An error is returned if the input is empty or invalid.
func (i *UserSessionWhereInput) P() (predicate.UserSession, error) {
	var predicates []predicate.UserSession
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, usersession.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserSession, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, usersession.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserSession, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, usersession.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, usersession.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, usersession.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, usersession.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, usersession.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, usersession.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, usersession.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, usersession.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, usersession.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, usersession.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, usersession.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, usersession.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, usersession.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, usersession.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, usersession.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, usersession.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, usersession.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, usersession.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, usersession.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, usersession.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, usersession.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, usersession.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, usersession.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, usersession.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, usersession.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, usersession.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, usersession.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ExpiresAt != nil {
		predicates = append(predicates, usersession.ExpiresAtEQ(*i.ExpiresAt))
	}
	if i.ExpiresAtNEQ != nil {
		predicates = append(predicates, usersession.ExpiresAtNEQ(*i.ExpiresAtNEQ))
	}
	if len(i.ExpiresAtIn) > 0 {
		predicates = append(predicates, usersession.ExpiresAtIn(i.ExpiresAtIn...))
	}
	if len(i.ExpiresAtNotIn) > 0 {
		predicates = append(predicates, usersession.ExpiresAtNotIn(i.ExpiresAtNotIn...))
	}
	if i.ExpiresAtGT != nil {
		predicates = append(predicates, usersession.ExpiresAtGT(*i.ExpiresAtGT))
	}
	if i.ExpiresAtGTE != nil {
		predicates = append(predicates, usersession.ExpiresAtGTE(*i.ExpiresAtGTE))
	}
	if i.ExpiresAtLT != nil {
		predicates = append(predicates, usersession.ExpiresAtLT(*i.ExpiresAtLT))
	}
	if i.ExpiresAtLTE != nil {
		predicates = append(predicates, usersession.ExpiresAtLTE(*i.ExpiresAtLTE))
	}
	if i.IP != nil {
		predicates = append(predicates, usersession.IPEQ(*i.IP))
	}
	if i.IPNEQ != nil {
		predicates = append(predicates, usersession.IPNEQ(*i.IPNEQ))
	}
	if len(i.IPIn) > 0 {
		predicates = append(predicates, usersession.IPIn(i.IPIn...))
	}
	if len(i.IPNotIn) > 0 {
		predicates = append(predicates, usersession.IPNotIn(i.IPNotIn...))
	}
	if i.IPGT != nil {
		predicates = append(predicates, usersession.IPGT(*i.IPGT))
	}
	if i.IPGTE != nil {
		predicates = append(predicates, usersession.IPGTE(*i.IPGTE))
	}
	if i.IPLT != nil {
		predicates = append(predicates, usersession.IPLT(*i.IPLT))
	}
	if i.IPLTE != nil {
		predicates = append(predicates, usersession.IPLTE(*i.IPLTE))
	}
	if i.IPContains != nil {
		predicates = append(predicates, usersession.IPContains(*i.IPContains))
	}
	if i.IPHasPrefix != nil {
		predicates = append(predicates, usersession.IPHasPrefix(*i.IPHasPrefix))
	}
	if i.IPHasSuffix != nil {
		predicates = append(predicates, usersession.IPHasSuffix(*i.IPHasSuffix))
	}
	if i.IPEqualFold != nil {
		predicates = append(predicates, usersession.IPEqualFold(*i.IPEqualFold))
	}
	if i.IPContainsFold != nil {
		predicates = append(predicates, usersession.IPContainsFold(*i.IPContainsFold))
	}

	if i.HasSockets != nil {
		p := usersession.HasSockets()
		if !*i.HasSockets {
			p = usersession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSocketsWith) > 0 {
		with := make([]predicate.UserSessionSocket, 0, len(i.HasSocketsWith))
		for _, w := range i.HasSocketsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSocketsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usersession.HasSocketsWith(with...))
	}
	if i.HasUser != nil {
		p := usersession.HasUser()
		if !*i.HasUser {
			p = usersession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usersession.HasUserWith(with...))
	}
	if i.HasPartner != nil {
		p := usersession.HasPartner()
		if !*i.HasPartner {
			p = usersession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerWith) > 0 {
		with := make([]predicate.Partner, 0, len(i.HasPartnerWith))
		for _, w := range i.HasPartnerWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usersession.HasPartnerWith(with...))
	}
	if i.HasPartnerContact != nil {
		p := usersession.HasPartnerContact()
		if !*i.HasPartnerContact {
			p = usersession.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPartnerContactWith) > 0 {
		with := make([]predicate.PartnerContact, 0, len(i.HasPartnerContactWith))
		for _, w := range i.HasPartnerContactWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPartnerContactWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usersession.HasPartnerContactWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserSessionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return usersession.And(predicates...), nil
	}
}

// UserSessionSocketWhereInput represents a where input for filtering UserSessionSocket queries.
type UserSessionSocketWhereInput struct {
	Predicates []predicate.UserSessionSocket  `json:"-"`
	Not        *UserSessionSocketWhereInput   `json:"not,omitempty"`
	Or         []*UserSessionSocketWhereInput `json:"or,omitempty"`
	And        []*UserSessionSocketWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "session" edge predicates.
	HasSession     *bool                    `json:"hasSession,omitempty"`
	HasSessionWith []*UserSessionWhereInput `json:"hasSessionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserSessionSocketWhereInput) AddPredicates(predicates ...predicate.UserSessionSocket) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserSessionSocketWhereInput filter on the UserSessionSocketQuery builder.
func (i *UserSessionSocketWhereInput) Filter(q *UserSessionSocketQuery) (*UserSessionSocketQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserSessionSocketWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserSessionSocketWhereInput is returned in case the UserSessionSocketWhereInput is empty.
var ErrEmptyUserSessionSocketWhereInput = errors.New("ent: empty predicate UserSessionSocketWhereInput")

// P returns a predicate for filtering usersessionsockets.
// An error is returned if the input is empty or invalid.
func (i *UserSessionSocketWhereInput) P() (predicate.UserSessionSocket, error) {
	var predicates []predicate.UserSessionSocket
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, usersessionsocket.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserSessionSocket, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, usersessionsocket.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserSessionSocket, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, usersessionsocket.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, usersessionsocket.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, usersessionsocket.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, usersessionsocket.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, usersessionsocket.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, usersessionsocket.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, usersessionsocket.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, usersessionsocket.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, usersessionsocket.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, usersessionsocket.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, usersessionsocket.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, usersessionsocket.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, usersessionsocket.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, usersessionsocket.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, usersessionsocket.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, usersessionsocket.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, usersessionsocket.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, usersessionsocket.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, usersessionsocket.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, usersessionsocket.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, usersessionsocket.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, usersessionsocket.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, usersessionsocket.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, usersessionsocket.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, usersessionsocket.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, usersessionsocket.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, usersessionsocket.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasSession != nil {
		p := usersessionsocket.HasSession()
		if !*i.HasSession {
			p = usersessionsocket.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSessionWith) > 0 {
		with := make([]predicate.UserSession, 0, len(i.HasSessionWith))
		for _, w := range i.HasSessionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSessionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, usersessionsocket.HasSessionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserSessionSocketWhereInput
	case 1:
		return predicates[0], nil
	default:
		return usersessionsocket.And(predicates...), nil
	}
}
