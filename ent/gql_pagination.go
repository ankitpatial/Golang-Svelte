// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"roofix/ent/apiaccess"
	"roofix/ent/apiuser"
	"roofix/ent/apiusertoken"
	"roofix/ent/auditlog"
	"roofix/ent/channel"
	"roofix/ent/channelmessage"
	"roofix/ent/channelmessageread"
	"roofix/ent/channelsub"
	"roofix/ent/contactus"
	"roofix/ent/document"
	"roofix/ent/estimate"
	"roofix/ent/estimateactivity"
	"roofix/ent/homeowner"
	"roofix/ent/installationjob"
	"roofix/ent/installationjobitem"
	"roofix/ent/installationjobprogress"
	"roofix/ent/job"
	"roofix/ent/jobactivity"
	"roofix/ent/jobassignmenthistory"
	"roofix/ent/jobdocurl"
	"roofix/ent/jobnote"
	"roofix/ent/jobprogresshistory"
	"roofix/ent/notifysetting"
	"roofix/ent/optionlist"
	"roofix/ent/partner"
	"roofix/ent/partneractivity"
	"roofix/ent/partnercontact"
	"roofix/ent/partnerservice"
	"roofix/ent/partnerservicecity"
	"roofix/ent/partnerservicestate"
	"roofix/ent/partnertrainingvideo"
	"roofix/ent/payment"
	"roofix/ent/postalcode"
	"roofix/ent/pricing"
	"roofix/ent/product"
	"roofix/ent/productpackage"
	"roofix/ent/survey"
	"roofix/ent/surveyprogress"
	"roofix/ent/token"
	"roofix/ent/trainingcourse"
	"roofix/ent/trainingvideo"
	"roofix/ent/user"
	"roofix/ent/useractivity"
	"roofix/ent/userauth"
	"roofix/ent/usersession"
	"roofix/ent/usersessionsocket"
	"strconv"

	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[string]
	PageInfo       = entgql.PageInfo[string]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// ApiAccessEdge is the edge representation of ApiAccess.
type ApiAccessEdge struct {
	Node   *ApiAccess `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ApiAccessConnection is the connection containing edges to ApiAccess.
type ApiAccessConnection struct {
	Edges      []*ApiAccessEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *ApiAccessConnection) build(nodes []*ApiAccess, pager *apiaccessPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ApiAccess
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ApiAccess {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ApiAccess {
			return nodes[i]
		}
	}
	c.Edges = make([]*ApiAccessEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ApiAccessEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ApiAccessPaginateOption enables pagination customization.
type ApiAccessPaginateOption func(*apiaccessPager) error

// WithApiAccessOrder configures pagination ordering.
func WithApiAccessOrder(order *ApiAccessOrder) ApiAccessPaginateOption {
	if order == nil {
		order = DefaultApiAccessOrder
	}
	o := *order
	return func(pager *apiaccessPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultApiAccessOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithApiAccessFilter configures pagination filter.
func WithApiAccessFilter(filter func(*ApiAccessQuery) (*ApiAccessQuery, error)) ApiAccessPaginateOption {
	return func(pager *apiaccessPager) error {
		if filter == nil {
			return errors.New("ApiAccessQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type apiaccessPager struct {
	reverse bool
	order   *ApiAccessOrder
	filter  func(*ApiAccessQuery) (*ApiAccessQuery, error)
}

func newApiAccessPager(opts []ApiAccessPaginateOption, reverse bool) (*apiaccessPager, error) {
	pager := &apiaccessPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultApiAccessOrder
	}
	return pager, nil
}

func (p *apiaccessPager) applyFilter(query *ApiAccessQuery) (*ApiAccessQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *apiaccessPager) toCursor(aa *ApiAccess) Cursor {
	return p.order.Field.toCursor(aa)
}

func (p *apiaccessPager) applyCursors(query *ApiAccessQuery, after, before *Cursor) (*ApiAccessQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultApiAccessOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *apiaccessPager) applyOrder(query *ApiAccessQuery) *ApiAccessQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultApiAccessOrder.Field {
		query = query.Order(DefaultApiAccessOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *apiaccessPager) orderExpr(query *ApiAccessQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultApiAccessOrder.Field {
			b.Comma().Ident(DefaultApiAccessOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ApiAccess.
func (aa *ApiAccessQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ApiAccessPaginateOption,
) (*ApiAccessConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newApiAccessPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if aa, err = pager.applyFilter(aa); err != nil {
		return nil, err
	}
	conn := &ApiAccessConnection{Edges: []*ApiAccessEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = aa.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if aa, err = pager.applyCursors(aa, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		aa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := aa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	aa = pager.applyOrder(aa)
	nodes, err := aa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ApiAccessOrderFieldCreatedAt orders ApiAccess by created_at.
	ApiAccessOrderFieldCreatedAt = &ApiAccessOrderField{
		Value: func(aa *ApiAccess) (ent.Value, error) {
			return aa.CreatedAt, nil
		},
		column: apiaccess.FieldCreatedAt,
		toTerm: apiaccess.ByCreatedAt,
		toCursor: func(aa *ApiAccess) Cursor {
			return Cursor{
				ID:    aa.ID,
				Value: aa.CreatedAt,
			}
		},
	}
	// ApiAccessOrderFieldUpdatedAt orders ApiAccess by updated_at.
	ApiAccessOrderFieldUpdatedAt = &ApiAccessOrderField{
		Value: func(aa *ApiAccess) (ent.Value, error) {
			return aa.UpdatedAt, nil
		},
		column: apiaccess.FieldUpdatedAt,
		toTerm: apiaccess.ByUpdatedAt,
		toCursor: func(aa *ApiAccess) Cursor {
			return Cursor{
				ID:    aa.ID,
				Value: aa.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ApiAccessOrderField) String() string {
	var str string
	switch f.column {
	case ApiAccessOrderFieldCreatedAt.column:
		str = "CREATED"
	case ApiAccessOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ApiAccessOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ApiAccessOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ApiAccessOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *ApiAccessOrderFieldCreatedAt
	case "UPDATED":
		*f = *ApiAccessOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ApiAccessOrderField", str)
	}
	return nil
}

// ApiAccessOrderField defines the ordering field of ApiAccess.
type ApiAccessOrderField struct {
	// Value extracts the ordering value from the given ApiAccess.
	Value    func(*ApiAccess) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) apiaccess.OrderOption
	toCursor func(*ApiAccess) Cursor
}

// ApiAccessOrder defines the ordering of ApiAccess.
type ApiAccessOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ApiAccessOrderField `json:"field"`
}

// DefaultApiAccessOrder is the default ordering of ApiAccess.
var DefaultApiAccessOrder = &ApiAccessOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ApiAccessOrderField{
		Value: func(aa *ApiAccess) (ent.Value, error) {
			return aa.ID, nil
		},
		column: apiaccess.FieldID,
		toTerm: apiaccess.ByID,
		toCursor: func(aa *ApiAccess) Cursor {
			return Cursor{ID: aa.ID}
		},
	},
}

// ToEdge converts ApiAccess into ApiAccessEdge.
func (aa *ApiAccess) ToEdge(order *ApiAccessOrder) *ApiAccessEdge {
	if order == nil {
		order = DefaultApiAccessOrder
	}
	return &ApiAccessEdge{
		Node:   aa,
		Cursor: order.Field.toCursor(aa),
	}
}

// ApiUserEdge is the edge representation of ApiUser.
type ApiUserEdge struct {
	Node   *ApiUser `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ApiUserConnection is the connection containing edges to ApiUser.
type ApiUserConnection struct {
	Edges      []*ApiUserEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ApiUserConnection) build(nodes []*ApiUser, pager *apiuserPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ApiUser
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ApiUser {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ApiUser {
			return nodes[i]
		}
	}
	c.Edges = make([]*ApiUserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ApiUserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ApiUserPaginateOption enables pagination customization.
type ApiUserPaginateOption func(*apiuserPager) error

// WithApiUserOrder configures pagination ordering.
func WithApiUserOrder(order *ApiUserOrder) ApiUserPaginateOption {
	if order == nil {
		order = DefaultApiUserOrder
	}
	o := *order
	return func(pager *apiuserPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultApiUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithApiUserFilter configures pagination filter.
func WithApiUserFilter(filter func(*ApiUserQuery) (*ApiUserQuery, error)) ApiUserPaginateOption {
	return func(pager *apiuserPager) error {
		if filter == nil {
			return errors.New("ApiUserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type apiuserPager struct {
	reverse bool
	order   *ApiUserOrder
	filter  func(*ApiUserQuery) (*ApiUserQuery, error)
}

func newApiUserPager(opts []ApiUserPaginateOption, reverse bool) (*apiuserPager, error) {
	pager := &apiuserPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultApiUserOrder
	}
	return pager, nil
}

func (p *apiuserPager) applyFilter(query *ApiUserQuery) (*ApiUserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *apiuserPager) toCursor(au *ApiUser) Cursor {
	return p.order.Field.toCursor(au)
}

func (p *apiuserPager) applyCursors(query *ApiUserQuery, after, before *Cursor) (*ApiUserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultApiUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *apiuserPager) applyOrder(query *ApiUserQuery) *ApiUserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultApiUserOrder.Field {
		query = query.Order(DefaultApiUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *apiuserPager) orderExpr(query *ApiUserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultApiUserOrder.Field {
			b.Comma().Ident(DefaultApiUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ApiUser.
func (au *ApiUserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ApiUserPaginateOption,
) (*ApiUserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newApiUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if au, err = pager.applyFilter(au); err != nil {
		return nil, err
	}
	conn := &ApiUserConnection{Edges: []*ApiUserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = au.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if au, err = pager.applyCursors(au, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		au.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := au.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	au = pager.applyOrder(au)
	nodes, err := au.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ApiUserOrderFieldCreatedAt orders ApiUser by created_at.
	ApiUserOrderFieldCreatedAt = &ApiUserOrderField{
		Value: func(au *ApiUser) (ent.Value, error) {
			return au.CreatedAt, nil
		},
		column: apiuser.FieldCreatedAt,
		toTerm: apiuser.ByCreatedAt,
		toCursor: func(au *ApiUser) Cursor {
			return Cursor{
				ID:    au.ID,
				Value: au.CreatedAt,
			}
		},
	}
	// ApiUserOrderFieldUsername orders ApiUser by username.
	ApiUserOrderFieldUsername = &ApiUserOrderField{
		Value: func(au *ApiUser) (ent.Value, error) {
			return au.Username, nil
		},
		column: apiuser.FieldUsername,
		toTerm: apiuser.ByUsername,
		toCursor: func(au *ApiUser) Cursor {
			return Cursor{
				ID:    au.ID,
				Value: au.Username,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ApiUserOrderField) String() string {
	var str string
	switch f.column {
	case ApiUserOrderFieldCreatedAt.column:
		str = "CREATED"
	case ApiUserOrderFieldUsername.column:
		str = "USER_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ApiUserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ApiUserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ApiUserOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *ApiUserOrderFieldCreatedAt
	case "USER_NAME":
		*f = *ApiUserOrderFieldUsername
	default:
		return fmt.Errorf("%s is not a valid ApiUserOrderField", str)
	}
	return nil
}

// ApiUserOrderField defines the ordering field of ApiUser.
type ApiUserOrderField struct {
	// Value extracts the ordering value from the given ApiUser.
	Value    func(*ApiUser) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) apiuser.OrderOption
	toCursor func(*ApiUser) Cursor
}

// ApiUserOrder defines the ordering of ApiUser.
type ApiUserOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ApiUserOrderField `json:"field"`
}

// DefaultApiUserOrder is the default ordering of ApiUser.
var DefaultApiUserOrder = &ApiUserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ApiUserOrderField{
		Value: func(au *ApiUser) (ent.Value, error) {
			return au.ID, nil
		},
		column: apiuser.FieldID,
		toTerm: apiuser.ByID,
		toCursor: func(au *ApiUser) Cursor {
			return Cursor{ID: au.ID}
		},
	},
}

// ToEdge converts ApiUser into ApiUserEdge.
func (au *ApiUser) ToEdge(order *ApiUserOrder) *ApiUserEdge {
	if order == nil {
		order = DefaultApiUserOrder
	}
	return &ApiUserEdge{
		Node:   au,
		Cursor: order.Field.toCursor(au),
	}
}

// ApiUserTokenEdge is the edge representation of ApiUserToken.
type ApiUserTokenEdge struct {
	Node   *ApiUserToken `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ApiUserTokenConnection is the connection containing edges to ApiUserToken.
type ApiUserTokenConnection struct {
	Edges      []*ApiUserTokenEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ApiUserTokenConnection) build(nodes []*ApiUserToken, pager *apiusertokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ApiUserToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ApiUserToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ApiUserToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*ApiUserTokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ApiUserTokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ApiUserTokenPaginateOption enables pagination customization.
type ApiUserTokenPaginateOption func(*apiusertokenPager) error

// WithApiUserTokenOrder configures pagination ordering.
func WithApiUserTokenOrder(order *ApiUserTokenOrder) ApiUserTokenPaginateOption {
	if order == nil {
		order = DefaultApiUserTokenOrder
	}
	o := *order
	return func(pager *apiusertokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultApiUserTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithApiUserTokenFilter configures pagination filter.
func WithApiUserTokenFilter(filter func(*ApiUserTokenQuery) (*ApiUserTokenQuery, error)) ApiUserTokenPaginateOption {
	return func(pager *apiusertokenPager) error {
		if filter == nil {
			return errors.New("ApiUserTokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type apiusertokenPager struct {
	reverse bool
	order   *ApiUserTokenOrder
	filter  func(*ApiUserTokenQuery) (*ApiUserTokenQuery, error)
}

func newApiUserTokenPager(opts []ApiUserTokenPaginateOption, reverse bool) (*apiusertokenPager, error) {
	pager := &apiusertokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultApiUserTokenOrder
	}
	return pager, nil
}

func (p *apiusertokenPager) applyFilter(query *ApiUserTokenQuery) (*ApiUserTokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *apiusertokenPager) toCursor(aut *ApiUserToken) Cursor {
	return p.order.Field.toCursor(aut)
}

func (p *apiusertokenPager) applyCursors(query *ApiUserTokenQuery, after, before *Cursor) (*ApiUserTokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultApiUserTokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *apiusertokenPager) applyOrder(query *ApiUserTokenQuery) *ApiUserTokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultApiUserTokenOrder.Field {
		query = query.Order(DefaultApiUserTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *apiusertokenPager) orderExpr(query *ApiUserTokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultApiUserTokenOrder.Field {
			b.Comma().Ident(DefaultApiUserTokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ApiUserToken.
func (aut *ApiUserTokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ApiUserTokenPaginateOption,
) (*ApiUserTokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newApiUserTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if aut, err = pager.applyFilter(aut); err != nil {
		return nil, err
	}
	conn := &ApiUserTokenConnection{Edges: []*ApiUserTokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = aut.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if aut, err = pager.applyCursors(aut, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		aut.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := aut.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	aut = pager.applyOrder(aut)
	nodes, err := aut.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ApiUserTokenOrderFieldCreatedAt orders ApiUserToken by created_at.
	ApiUserTokenOrderFieldCreatedAt = &ApiUserTokenOrderField{
		Value: func(aut *ApiUserToken) (ent.Value, error) {
			return aut.CreatedAt, nil
		},
		column: apiusertoken.FieldCreatedAt,
		toTerm: apiusertoken.ByCreatedAt,
		toCursor: func(aut *ApiUserToken) Cursor {
			return Cursor{
				ID:    aut.ID,
				Value: aut.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ApiUserTokenOrderField) String() string {
	var str string
	switch f.column {
	case ApiUserTokenOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ApiUserTokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ApiUserTokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ApiUserTokenOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *ApiUserTokenOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid ApiUserTokenOrderField", str)
	}
	return nil
}

// ApiUserTokenOrderField defines the ordering field of ApiUserToken.
type ApiUserTokenOrderField struct {
	// Value extracts the ordering value from the given ApiUserToken.
	Value    func(*ApiUserToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) apiusertoken.OrderOption
	toCursor func(*ApiUserToken) Cursor
}

// ApiUserTokenOrder defines the ordering of ApiUserToken.
type ApiUserTokenOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ApiUserTokenOrderField `json:"field"`
}

// DefaultApiUserTokenOrder is the default ordering of ApiUserToken.
var DefaultApiUserTokenOrder = &ApiUserTokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ApiUserTokenOrderField{
		Value: func(aut *ApiUserToken) (ent.Value, error) {
			return aut.ID, nil
		},
		column: apiusertoken.FieldID,
		toTerm: apiusertoken.ByID,
		toCursor: func(aut *ApiUserToken) Cursor {
			return Cursor{ID: aut.ID}
		},
	},
}

// ToEdge converts ApiUserToken into ApiUserTokenEdge.
func (aut *ApiUserToken) ToEdge(order *ApiUserTokenOrder) *ApiUserTokenEdge {
	if order == nil {
		order = DefaultApiUserTokenOrder
	}
	return &ApiUserTokenEdge{
		Node:   aut,
		Cursor: order.Field.toCursor(aut),
	}
}

// AuditLogEdge is the edge representation of AuditLog.
type AuditLogEdge struct {
	Node   *AuditLog `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// AuditLogConnection is the connection containing edges to AuditLog.
type AuditLogConnection struct {
	Edges      []*AuditLogEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *AuditLogConnection) build(nodes []*AuditLog, pager *auditlogPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AuditLog
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AuditLog {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AuditLog {
			return nodes[i]
		}
	}
	c.Edges = make([]*AuditLogEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AuditLogEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AuditLogPaginateOption enables pagination customization.
type AuditLogPaginateOption func(*auditlogPager) error

// WithAuditLogOrder configures pagination ordering.
func WithAuditLogOrder(order *AuditLogOrder) AuditLogPaginateOption {
	if order == nil {
		order = DefaultAuditLogOrder
	}
	o := *order
	return func(pager *auditlogPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAuditLogOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAuditLogFilter configures pagination filter.
func WithAuditLogFilter(filter func(*AuditLogQuery) (*AuditLogQuery, error)) AuditLogPaginateOption {
	return func(pager *auditlogPager) error {
		if filter == nil {
			return errors.New("AuditLogQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type auditlogPager struct {
	reverse bool
	order   *AuditLogOrder
	filter  func(*AuditLogQuery) (*AuditLogQuery, error)
}

func newAuditLogPager(opts []AuditLogPaginateOption, reverse bool) (*auditlogPager, error) {
	pager := &auditlogPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAuditLogOrder
	}
	return pager, nil
}

func (p *auditlogPager) applyFilter(query *AuditLogQuery) (*AuditLogQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *auditlogPager) toCursor(al *AuditLog) Cursor {
	return p.order.Field.toCursor(al)
}

func (p *auditlogPager) applyCursors(query *AuditLogQuery, after, before *Cursor) (*AuditLogQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAuditLogOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *auditlogPager) applyOrder(query *AuditLogQuery) *AuditLogQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAuditLogOrder.Field {
		query = query.Order(DefaultAuditLogOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *auditlogPager) orderExpr(query *AuditLogQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAuditLogOrder.Field {
			b.Comma().Ident(DefaultAuditLogOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AuditLog.
func (al *AuditLogQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AuditLogPaginateOption,
) (*AuditLogConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAuditLogPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if al, err = pager.applyFilter(al); err != nil {
		return nil, err
	}
	conn := &AuditLogConnection{Edges: []*AuditLogEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = al.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if al, err = pager.applyCursors(al, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		al.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := al.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	al = pager.applyOrder(al)
	nodes, err := al.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// AuditLogOrderFieldCreatedAt orders AuditLog by created_at.
	AuditLogOrderFieldCreatedAt = &AuditLogOrderField{
		Value: func(al *AuditLog) (ent.Value, error) {
			return al.CreatedAt, nil
		},
		column: auditlog.FieldCreatedAt,
		toTerm: auditlog.ByCreatedAt,
		toCursor: func(al *AuditLog) Cursor {
			return Cursor{
				ID:    al.ID,
				Value: al.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f AuditLogOrderField) String() string {
	var str string
	switch f.column {
	case AuditLogOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f AuditLogOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *AuditLogOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("AuditLogOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *AuditLogOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid AuditLogOrderField", str)
	}
	return nil
}

// AuditLogOrderField defines the ordering field of AuditLog.
type AuditLogOrderField struct {
	// Value extracts the ordering value from the given AuditLog.
	Value    func(*AuditLog) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) auditlog.OrderOption
	toCursor func(*AuditLog) Cursor
}

// AuditLogOrder defines the ordering of AuditLog.
type AuditLogOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *AuditLogOrderField `json:"field"`
}

// DefaultAuditLogOrder is the default ordering of AuditLog.
var DefaultAuditLogOrder = &AuditLogOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AuditLogOrderField{
		Value: func(al *AuditLog) (ent.Value, error) {
			return al.ID, nil
		},
		column: auditlog.FieldID,
		toTerm: auditlog.ByID,
		toCursor: func(al *AuditLog) Cursor {
			return Cursor{ID: al.ID}
		},
	},
}

// ToEdge converts AuditLog into AuditLogEdge.
func (al *AuditLog) ToEdge(order *AuditLogOrder) *AuditLogEdge {
	if order == nil {
		order = DefaultAuditLogOrder
	}
	return &AuditLogEdge{
		Node:   al,
		Cursor: order.Field.toCursor(al),
	}
}

// ChannelEdge is the edge representation of Channel.
type ChannelEdge struct {
	Node   *Channel `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ChannelConnection is the connection containing edges to Channel.
type ChannelConnection struct {
	Edges      []*ChannelEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ChannelConnection) build(nodes []*Channel, pager *channelPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Channel
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Channel {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Channel {
			return nodes[i]
		}
	}
	c.Edges = make([]*ChannelEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ChannelEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ChannelPaginateOption enables pagination customization.
type ChannelPaginateOption func(*channelPager) error

// WithChannelOrder configures pagination ordering.
func WithChannelOrder(order *ChannelOrder) ChannelPaginateOption {
	if order == nil {
		order = DefaultChannelOrder
	}
	o := *order
	return func(pager *channelPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultChannelOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithChannelFilter configures pagination filter.
func WithChannelFilter(filter func(*ChannelQuery) (*ChannelQuery, error)) ChannelPaginateOption {
	return func(pager *channelPager) error {
		if filter == nil {
			return errors.New("ChannelQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type channelPager struct {
	reverse bool
	order   *ChannelOrder
	filter  func(*ChannelQuery) (*ChannelQuery, error)
}

func newChannelPager(opts []ChannelPaginateOption, reverse bool) (*channelPager, error) {
	pager := &channelPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultChannelOrder
	}
	return pager, nil
}

func (p *channelPager) applyFilter(query *ChannelQuery) (*ChannelQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *channelPager) toCursor(c *Channel) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *channelPager) applyCursors(query *ChannelQuery, after, before *Cursor) (*ChannelQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultChannelOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *channelPager) applyOrder(query *ChannelQuery) *ChannelQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultChannelOrder.Field {
		query = query.Order(DefaultChannelOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *channelPager) orderExpr(query *ChannelQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultChannelOrder.Field {
			b.Comma().Ident(DefaultChannelOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Channel.
func (c *ChannelQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ChannelPaginateOption,
) (*ChannelConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newChannelPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ChannelConnection{Edges: []*ChannelEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ChannelOrderFieldCreatedAt orders Channel by created_at.
	ChannelOrderFieldCreatedAt = &ChannelOrderField{
		Value: func(c *Channel) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: channel.FieldCreatedAt,
		toTerm: channel.ByCreatedAt,
		toCursor: func(c *Channel) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
	// ChannelOrderFieldUpdatedAt orders Channel by updated_at.
	ChannelOrderFieldUpdatedAt = &ChannelOrderField{
		Value: func(c *Channel) (ent.Value, error) {
			return c.UpdatedAt, nil
		},
		column: channel.FieldUpdatedAt,
		toTerm: channel.ByUpdatedAt,
		toCursor: func(c *Channel) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ChannelOrderField) String() string {
	var str string
	switch f.column {
	case ChannelOrderFieldCreatedAt.column:
		str = "CREATED"
	case ChannelOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ChannelOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ChannelOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ChannelOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *ChannelOrderFieldCreatedAt
	case "UPDATED":
		*f = *ChannelOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ChannelOrderField", str)
	}
	return nil
}

// ChannelOrderField defines the ordering field of Channel.
type ChannelOrderField struct {
	// Value extracts the ordering value from the given Channel.
	Value    func(*Channel) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) channel.OrderOption
	toCursor func(*Channel) Cursor
}

// ChannelOrder defines the ordering of Channel.
type ChannelOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ChannelOrderField `json:"field"`
}

// DefaultChannelOrder is the default ordering of Channel.
var DefaultChannelOrder = &ChannelOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ChannelOrderField{
		Value: func(c *Channel) (ent.Value, error) {
			return c.ID, nil
		},
		column: channel.FieldID,
		toTerm: channel.ByID,
		toCursor: func(c *Channel) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Channel into ChannelEdge.
func (c *Channel) ToEdge(order *ChannelOrder) *ChannelEdge {
	if order == nil {
		order = DefaultChannelOrder
	}
	return &ChannelEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// ChannelMessageEdge is the edge representation of ChannelMessage.
type ChannelMessageEdge struct {
	Node   *ChannelMessage `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ChannelMessageConnection is the connection containing edges to ChannelMessage.
type ChannelMessageConnection struct {
	Edges      []*ChannelMessageEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ChannelMessageConnection) build(nodes []*ChannelMessage, pager *channelmessagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ChannelMessage
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ChannelMessage {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ChannelMessage {
			return nodes[i]
		}
	}
	c.Edges = make([]*ChannelMessageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ChannelMessageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ChannelMessagePaginateOption enables pagination customization.
type ChannelMessagePaginateOption func(*channelmessagePager) error

// WithChannelMessageOrder configures pagination ordering.
func WithChannelMessageOrder(order *ChannelMessageOrder) ChannelMessagePaginateOption {
	if order == nil {
		order = DefaultChannelMessageOrder
	}
	o := *order
	return func(pager *channelmessagePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultChannelMessageOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithChannelMessageFilter configures pagination filter.
func WithChannelMessageFilter(filter func(*ChannelMessageQuery) (*ChannelMessageQuery, error)) ChannelMessagePaginateOption {
	return func(pager *channelmessagePager) error {
		if filter == nil {
			return errors.New("ChannelMessageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type channelmessagePager struct {
	reverse bool
	order   *ChannelMessageOrder
	filter  func(*ChannelMessageQuery) (*ChannelMessageQuery, error)
}

func newChannelMessagePager(opts []ChannelMessagePaginateOption, reverse bool) (*channelmessagePager, error) {
	pager := &channelmessagePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultChannelMessageOrder
	}
	return pager, nil
}

func (p *channelmessagePager) applyFilter(query *ChannelMessageQuery) (*ChannelMessageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *channelmessagePager) toCursor(cm *ChannelMessage) Cursor {
	return p.order.Field.toCursor(cm)
}

func (p *channelmessagePager) applyCursors(query *ChannelMessageQuery, after, before *Cursor) (*ChannelMessageQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultChannelMessageOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *channelmessagePager) applyOrder(query *ChannelMessageQuery) *ChannelMessageQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultChannelMessageOrder.Field {
		query = query.Order(DefaultChannelMessageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *channelmessagePager) orderExpr(query *ChannelMessageQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultChannelMessageOrder.Field {
			b.Comma().Ident(DefaultChannelMessageOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ChannelMessage.
func (cm *ChannelMessageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ChannelMessagePaginateOption,
) (*ChannelMessageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newChannelMessagePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cm, err = pager.applyFilter(cm); err != nil {
		return nil, err
	}
	conn := &ChannelMessageConnection{Edges: []*ChannelMessageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cm.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cm, err = pager.applyCursors(cm, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		cm.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cm.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cm = pager.applyOrder(cm)
	nodes, err := cm.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ChannelMessageOrderFieldCreatedAt orders ChannelMessage by created_at.
	ChannelMessageOrderFieldCreatedAt = &ChannelMessageOrderField{
		Value: func(cm *ChannelMessage) (ent.Value, error) {
			return cm.CreatedAt, nil
		},
		column: channelmessage.FieldCreatedAt,
		toTerm: channelmessage.ByCreatedAt,
		toCursor: func(cm *ChannelMessage) Cursor {
			return Cursor{
				ID:    cm.ID,
				Value: cm.CreatedAt,
			}
		},
	}
	// ChannelMessageOrderFieldUpdatedAt orders ChannelMessage by updated_at.
	ChannelMessageOrderFieldUpdatedAt = &ChannelMessageOrderField{
		Value: func(cm *ChannelMessage) (ent.Value, error) {
			return cm.UpdatedAt, nil
		},
		column: channelmessage.FieldUpdatedAt,
		toTerm: channelmessage.ByUpdatedAt,
		toCursor: func(cm *ChannelMessage) Cursor {
			return Cursor{
				ID:    cm.ID,
				Value: cm.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ChannelMessageOrderField) String() string {
	var str string
	switch f.column {
	case ChannelMessageOrderFieldCreatedAt.column:
		str = "CREATED"
	case ChannelMessageOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ChannelMessageOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ChannelMessageOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ChannelMessageOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *ChannelMessageOrderFieldCreatedAt
	case "UPDATED":
		*f = *ChannelMessageOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ChannelMessageOrderField", str)
	}
	return nil
}

// ChannelMessageOrderField defines the ordering field of ChannelMessage.
type ChannelMessageOrderField struct {
	// Value extracts the ordering value from the given ChannelMessage.
	Value    func(*ChannelMessage) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) channelmessage.OrderOption
	toCursor func(*ChannelMessage) Cursor
}

// ChannelMessageOrder defines the ordering of ChannelMessage.
type ChannelMessageOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ChannelMessageOrderField `json:"field"`
}

// DefaultChannelMessageOrder is the default ordering of ChannelMessage.
var DefaultChannelMessageOrder = &ChannelMessageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ChannelMessageOrderField{
		Value: func(cm *ChannelMessage) (ent.Value, error) {
			return cm.ID, nil
		},
		column: channelmessage.FieldID,
		toTerm: channelmessage.ByID,
		toCursor: func(cm *ChannelMessage) Cursor {
			return Cursor{ID: cm.ID}
		},
	},
}

// ToEdge converts ChannelMessage into ChannelMessageEdge.
func (cm *ChannelMessage) ToEdge(order *ChannelMessageOrder) *ChannelMessageEdge {
	if order == nil {
		order = DefaultChannelMessageOrder
	}
	return &ChannelMessageEdge{
		Node:   cm,
		Cursor: order.Field.toCursor(cm),
	}
}

// ChannelMessageReadEdge is the edge representation of ChannelMessageRead.
type ChannelMessageReadEdge struct {
	Node   *ChannelMessageRead `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// ChannelMessageReadConnection is the connection containing edges to ChannelMessageRead.
type ChannelMessageReadConnection struct {
	Edges      []*ChannelMessageReadEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *ChannelMessageReadConnection) build(nodes []*ChannelMessageRead, pager *channelmessagereadPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ChannelMessageRead
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ChannelMessageRead {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ChannelMessageRead {
			return nodes[i]
		}
	}
	c.Edges = make([]*ChannelMessageReadEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ChannelMessageReadEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ChannelMessageReadPaginateOption enables pagination customization.
type ChannelMessageReadPaginateOption func(*channelmessagereadPager) error

// WithChannelMessageReadOrder configures pagination ordering.
func WithChannelMessageReadOrder(order *ChannelMessageReadOrder) ChannelMessageReadPaginateOption {
	if order == nil {
		order = DefaultChannelMessageReadOrder
	}
	o := *order
	return func(pager *channelmessagereadPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultChannelMessageReadOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithChannelMessageReadFilter configures pagination filter.
func WithChannelMessageReadFilter(filter func(*ChannelMessageReadQuery) (*ChannelMessageReadQuery, error)) ChannelMessageReadPaginateOption {
	return func(pager *channelmessagereadPager) error {
		if filter == nil {
			return errors.New("ChannelMessageReadQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type channelmessagereadPager struct {
	reverse bool
	order   *ChannelMessageReadOrder
	filter  func(*ChannelMessageReadQuery) (*ChannelMessageReadQuery, error)
}

func newChannelMessageReadPager(opts []ChannelMessageReadPaginateOption, reverse bool) (*channelmessagereadPager, error) {
	pager := &channelmessagereadPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultChannelMessageReadOrder
	}
	return pager, nil
}

func (p *channelmessagereadPager) applyFilter(query *ChannelMessageReadQuery) (*ChannelMessageReadQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *channelmessagereadPager) toCursor(cmr *ChannelMessageRead) Cursor {
	return p.order.Field.toCursor(cmr)
}

func (p *channelmessagereadPager) applyCursors(query *ChannelMessageReadQuery, after, before *Cursor) (*ChannelMessageReadQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultChannelMessageReadOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *channelmessagereadPager) applyOrder(query *ChannelMessageReadQuery) *ChannelMessageReadQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultChannelMessageReadOrder.Field {
		query = query.Order(DefaultChannelMessageReadOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *channelmessagereadPager) orderExpr(query *ChannelMessageReadQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultChannelMessageReadOrder.Field {
			b.Comma().Ident(DefaultChannelMessageReadOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ChannelMessageRead.
func (cmr *ChannelMessageReadQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ChannelMessageReadPaginateOption,
) (*ChannelMessageReadConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newChannelMessageReadPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cmr, err = pager.applyFilter(cmr); err != nil {
		return nil, err
	}
	conn := &ChannelMessageReadConnection{Edges: []*ChannelMessageReadEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cmr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cmr, err = pager.applyCursors(cmr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		cmr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cmr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cmr = pager.applyOrder(cmr)
	nodes, err := cmr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ChannelMessageReadOrderFieldCreatedAt orders ChannelMessageRead by created_at.
	ChannelMessageReadOrderFieldCreatedAt = &ChannelMessageReadOrderField{
		Value: func(cmr *ChannelMessageRead) (ent.Value, error) {
			return cmr.CreatedAt, nil
		},
		column: channelmessageread.FieldCreatedAt,
		toTerm: channelmessageread.ByCreatedAt,
		toCursor: func(cmr *ChannelMessageRead) Cursor {
			return Cursor{
				ID:    cmr.ID,
				Value: cmr.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ChannelMessageReadOrderField) String() string {
	var str string
	switch f.column {
	case ChannelMessageReadOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ChannelMessageReadOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ChannelMessageReadOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ChannelMessageReadOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *ChannelMessageReadOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid ChannelMessageReadOrderField", str)
	}
	return nil
}

// ChannelMessageReadOrderField defines the ordering field of ChannelMessageRead.
type ChannelMessageReadOrderField struct {
	// Value extracts the ordering value from the given ChannelMessageRead.
	Value    func(*ChannelMessageRead) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) channelmessageread.OrderOption
	toCursor func(*ChannelMessageRead) Cursor
}

// ChannelMessageReadOrder defines the ordering of ChannelMessageRead.
type ChannelMessageReadOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *ChannelMessageReadOrderField `json:"field"`
}

// DefaultChannelMessageReadOrder is the default ordering of ChannelMessageRead.
var DefaultChannelMessageReadOrder = &ChannelMessageReadOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ChannelMessageReadOrderField{
		Value: func(cmr *ChannelMessageRead) (ent.Value, error) {
			return cmr.ID, nil
		},
		column: channelmessageread.FieldID,
		toTerm: channelmessageread.ByID,
		toCursor: func(cmr *ChannelMessageRead) Cursor {
			return Cursor{ID: cmr.ID}
		},
	},
}

// ToEdge converts ChannelMessageRead into ChannelMessageReadEdge.
func (cmr *ChannelMessageRead) ToEdge(order *ChannelMessageReadOrder) *ChannelMessageReadEdge {
	if order == nil {
		order = DefaultChannelMessageReadOrder
	}
	return &ChannelMessageReadEdge{
		Node:   cmr,
		Cursor: order.Field.toCursor(cmr),
	}
}

// ChannelSubEdge is the edge representation of ChannelSub.
type ChannelSubEdge struct {
	Node   *ChannelSub `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ChannelSubConnection is the connection containing edges to ChannelSub.
type ChannelSubConnection struct {
	Edges      []*ChannelSubEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ChannelSubConnection) build(nodes []*ChannelSub, pager *channelsubPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ChannelSub
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ChannelSub {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ChannelSub {
			return nodes[i]
		}
	}
	c.Edges = make([]*ChannelSubEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ChannelSubEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ChannelSubPaginateOption enables pagination customization.
type ChannelSubPaginateOption func(*channelsubPager) error

// WithChannelSubOrder configures pagination ordering.
func WithChannelSubOrder(order *ChannelSubOrder) ChannelSubPaginateOption {
	if order == nil {
		order = DefaultChannelSubOrder
	}
	o := *order
	return func(pager *channelsubPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultChannelSubOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithChannelSubFilter configures pagination filter.
func WithChannelSubFilter(filter func(*ChannelSubQuery) (*ChannelSubQuery, error)) ChannelSubPaginateOption {
	return func(pager *channelsubPager) error {
		if filter == nil {
			return errors.New("ChannelSubQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type channelsubPager struct {
	reverse bool
	order   *ChannelSubOrder
	filter  func(*ChannelSubQuery) (*ChannelSubQuery, error)
}

func newChannelSubPager(opts []ChannelSubPaginateOption, reverse bool) (*channelsubPager, error) {
	pager := &channelsubPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultChannelSubOrder
	}
	return pager, nil
}

func (p *channelsubPager) applyFilter(query *ChannelSubQuery) (*ChannelSubQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *channelsubPager) toCursor(cs *ChannelSub) Cursor {
	return p.order.Field.toCursor(cs)
}

func (p *channelsubPager) applyCursors(query *ChannelSubQuery, after, before *Cursor) (*ChannelSubQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultChannelSubOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *channelsubPager) applyOrder(query *ChannelSubQuery) *ChannelSubQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultChannelSubOrder.Field {
		query = query.Order(DefaultChannelSubOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *channelsubPager) orderExpr(query *ChannelSubQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultChannelSubOrder.Field {
			b.Comma().Ident(DefaultChannelSubOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ChannelSub.
func (cs *ChannelSubQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ChannelSubPaginateOption,
) (*ChannelSubConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newChannelSubPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cs, err = pager.applyFilter(cs); err != nil {
		return nil, err
	}
	conn := &ChannelSubConnection{Edges: []*ChannelSubEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cs.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cs, err = pager.applyCursors(cs, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		cs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cs.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cs = pager.applyOrder(cs)
	nodes, err := cs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ChannelSubOrderFieldCreatedAt orders ChannelSub by created_at.
	ChannelSubOrderFieldCreatedAt = &ChannelSubOrderField{
		Value: func(cs *ChannelSub) (ent.Value, error) {
			return cs.CreatedAt, nil
		},
		column: channelsub.FieldCreatedAt,
		toTerm: channelsub.ByCreatedAt,
		toCursor: func(cs *ChannelSub) Cursor {
			return Cursor{
				ID:    cs.ID,
				Value: cs.CreatedAt,
			}
		},
	}
	// ChannelSubOrderFieldUpdatedAt orders ChannelSub by updated_at.
	ChannelSubOrderFieldUpdatedAt = &ChannelSubOrderField{
		Value: func(cs *ChannelSub) (ent.Value, error) {
			return cs.UpdatedAt, nil
		},
		column: channelsub.FieldUpdatedAt,
		toTerm: channelsub.ByUpdatedAt,
		toCursor: func(cs *ChannelSub) Cursor {
			return Cursor{
				ID:    cs.ID,
				Value: cs.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ChannelSubOrderField) String() string {
	var str string
	switch f.column {
	case ChannelSubOrderFieldCreatedAt.column:
		str = "CREATED"
	case ChannelSubOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ChannelSubOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ChannelSubOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ChannelSubOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *ChannelSubOrderFieldCreatedAt
	case "UPDATED":
		*f = *ChannelSubOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ChannelSubOrderField", str)
	}
	return nil
}

// ChannelSubOrderField defines the ordering field of ChannelSub.
type ChannelSubOrderField struct {
	// Value extracts the ordering value from the given ChannelSub.
	Value    func(*ChannelSub) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) channelsub.OrderOption
	toCursor func(*ChannelSub) Cursor
}

// ChannelSubOrder defines the ordering of ChannelSub.
type ChannelSubOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ChannelSubOrderField `json:"field"`
}

// DefaultChannelSubOrder is the default ordering of ChannelSub.
var DefaultChannelSubOrder = &ChannelSubOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ChannelSubOrderField{
		Value: func(cs *ChannelSub) (ent.Value, error) {
			return cs.ID, nil
		},
		column: channelsub.FieldID,
		toTerm: channelsub.ByID,
		toCursor: func(cs *ChannelSub) Cursor {
			return Cursor{ID: cs.ID}
		},
	},
}

// ToEdge converts ChannelSub into ChannelSubEdge.
func (cs *ChannelSub) ToEdge(order *ChannelSubOrder) *ChannelSubEdge {
	if order == nil {
		order = DefaultChannelSubOrder
	}
	return &ChannelSubEdge{
		Node:   cs,
		Cursor: order.Field.toCursor(cs),
	}
}

// ContactUsEdge is the edge representation of ContactUs.
type ContactUsEdge struct {
	Node   *ContactUs `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// ContactUsConnection is the connection containing edges to ContactUs.
type ContactUsConnection struct {
	Edges      []*ContactUsEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *ContactUsConnection) build(nodes []*ContactUs, pager *contactusPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ContactUs
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ContactUs {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ContactUs {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContactUsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContactUsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContactUsPaginateOption enables pagination customization.
type ContactUsPaginateOption func(*contactusPager) error

// WithContactUsOrder configures pagination ordering.
func WithContactUsOrder(order *ContactUsOrder) ContactUsPaginateOption {
	if order == nil {
		order = DefaultContactUsOrder
	}
	o := *order
	return func(pager *contactusPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultContactUsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithContactUsFilter configures pagination filter.
func WithContactUsFilter(filter func(*ContactUsQuery) (*ContactUsQuery, error)) ContactUsPaginateOption {
	return func(pager *contactusPager) error {
		if filter == nil {
			return errors.New("ContactUsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contactusPager struct {
	reverse bool
	order   *ContactUsOrder
	filter  func(*ContactUsQuery) (*ContactUsQuery, error)
}

func newContactUsPager(opts []ContactUsPaginateOption, reverse bool) (*contactusPager, error) {
	pager := &contactusPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultContactUsOrder
	}
	return pager, nil
}

func (p *contactusPager) applyFilter(query *ContactUsQuery) (*ContactUsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contactusPager) toCursor(cu *ContactUs) Cursor {
	return p.order.Field.toCursor(cu)
}

func (p *contactusPager) applyCursors(query *ContactUsQuery, after, before *Cursor) (*ContactUsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultContactUsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *contactusPager) applyOrder(query *ContactUsQuery) *ContactUsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultContactUsOrder.Field {
		query = query.Order(DefaultContactUsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *contactusPager) orderExpr(query *ContactUsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultContactUsOrder.Field {
			b.Comma().Ident(DefaultContactUsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ContactUs.
func (cu *ContactUsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContactUsPaginateOption,
) (*ContactUsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContactUsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cu, err = pager.applyFilter(cu); err != nil {
		return nil, err
	}
	conn := &ContactUsConnection{Edges: []*ContactUsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = cu.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cu, err = pager.applyCursors(cu, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		cu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cu.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cu = pager.applyOrder(cu)
	nodes, err := cu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ContactUsOrderFieldCreatedAt orders ContactUs by created_at.
	ContactUsOrderFieldCreatedAt = &ContactUsOrderField{
		Value: func(cu *ContactUs) (ent.Value, error) {
			return cu.CreatedAt, nil
		},
		column: contactus.FieldCreatedAt,
		toTerm: contactus.ByCreatedAt,
		toCursor: func(cu *ContactUs) Cursor {
			return Cursor{
				ID:    cu.ID,
				Value: cu.CreatedAt,
			}
		},
	}
	// ContactUsOrderFieldUpdatedAt orders ContactUs by updated_at.
	ContactUsOrderFieldUpdatedAt = &ContactUsOrderField{
		Value: func(cu *ContactUs) (ent.Value, error) {
			return cu.UpdatedAt, nil
		},
		column: contactus.FieldUpdatedAt,
		toTerm: contactus.ByUpdatedAt,
		toCursor: func(cu *ContactUs) Cursor {
			return Cursor{
				ID:    cu.ID,
				Value: cu.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ContactUsOrderField) String() string {
	var str string
	switch f.column {
	case ContactUsOrderFieldCreatedAt.column:
		str = "CREATED"
	case ContactUsOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ContactUsOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ContactUsOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ContactUsOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *ContactUsOrderFieldCreatedAt
	case "UPDATED":
		*f = *ContactUsOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid ContactUsOrderField", str)
	}
	return nil
}

// ContactUsOrderField defines the ordering field of ContactUs.
type ContactUsOrderField struct {
	// Value extracts the ordering value from the given ContactUs.
	Value    func(*ContactUs) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contactus.OrderOption
	toCursor func(*ContactUs) Cursor
}

// ContactUsOrder defines the ordering of ContactUs.
type ContactUsOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *ContactUsOrderField `json:"field"`
}

// DefaultContactUsOrder is the default ordering of ContactUs.
var DefaultContactUsOrder = &ContactUsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContactUsOrderField{
		Value: func(cu *ContactUs) (ent.Value, error) {
			return cu.ID, nil
		},
		column: contactus.FieldID,
		toTerm: contactus.ByID,
		toCursor: func(cu *ContactUs) Cursor {
			return Cursor{ID: cu.ID}
		},
	},
}

// ToEdge converts ContactUs into ContactUsEdge.
func (cu *ContactUs) ToEdge(order *ContactUsOrder) *ContactUsEdge {
	if order == nil {
		order = DefaultContactUsOrder
	}
	return &ContactUsEdge{
		Node:   cu,
		Cursor: order.Field.toCursor(cu),
	}
}

// DocumentEdge is the edge representation of Document.
type DocumentEdge struct {
	Node   *Document `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// DocumentConnection is the connection containing edges to Document.
type DocumentConnection struct {
	Edges      []*DocumentEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *DocumentConnection) build(nodes []*Document, pager *documentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Document
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Document {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Document {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentPaginateOption enables pagination customization.
type DocumentPaginateOption func(*documentPager) error

// WithDocumentOrder configures pagination ordering.
func WithDocumentOrder(order *DocumentOrder) DocumentPaginateOption {
	if order == nil {
		order = DefaultDocumentOrder
	}
	o := *order
	return func(pager *documentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDocumentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDocumentFilter configures pagination filter.
func WithDocumentFilter(filter func(*DocumentQuery) (*DocumentQuery, error)) DocumentPaginateOption {
	return func(pager *documentPager) error {
		if filter == nil {
			return errors.New("DocumentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentPager struct {
	reverse bool
	order   *DocumentOrder
	filter  func(*DocumentQuery) (*DocumentQuery, error)
}

func newDocumentPager(opts []DocumentPaginateOption, reverse bool) (*documentPager, error) {
	pager := &documentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDocumentOrder
	}
	return pager, nil
}

func (p *documentPager) applyFilter(query *DocumentQuery) (*DocumentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentPager) toCursor(d *Document) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *documentPager) applyCursors(query *DocumentQuery, after, before *Cursor) (*DocumentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDocumentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *documentPager) applyOrder(query *DocumentQuery) *DocumentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDocumentOrder.Field {
		query = query.Order(DefaultDocumentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *documentPager) orderExpr(query *DocumentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDocumentOrder.Field {
			b.Comma().Ident(DefaultDocumentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Document.
func (d *DocumentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentPaginateOption,
) (*DocumentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DocumentConnection{Edges: []*DocumentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = d.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		d.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// DocumentOrderFieldCreatedAt orders Document by created_at.
	DocumentOrderFieldCreatedAt = &DocumentOrderField{
		Value: func(d *Document) (ent.Value, error) {
			return d.CreatedAt, nil
		},
		column: document.FieldCreatedAt,
		toTerm: document.ByCreatedAt,
		toCursor: func(d *Document) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.CreatedAt,
			}
		},
	}
	// DocumentOrderFieldUpdatedAt orders Document by updated_at.
	DocumentOrderFieldUpdatedAt = &DocumentOrderField{
		Value: func(d *Document) (ent.Value, error) {
			return d.UpdatedAt, nil
		},
		column: document.FieldUpdatedAt,
		toTerm: document.ByUpdatedAt,
		toCursor: func(d *Document) Cursor {
			return Cursor{
				ID:    d.ID,
				Value: d.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f DocumentOrderField) String() string {
	var str string
	switch f.column {
	case DocumentOrderFieldCreatedAt.column:
		str = "CREATED"
	case DocumentOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f DocumentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *DocumentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("DocumentOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *DocumentOrderFieldCreatedAt
	case "UPDATED":
		*f = *DocumentOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid DocumentOrderField", str)
	}
	return nil
}

// DocumentOrderField defines the ordering field of Document.
type DocumentOrderField struct {
	// Value extracts the ordering value from the given Document.
	Value    func(*Document) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) document.OrderOption
	toCursor func(*Document) Cursor
}

// DocumentOrder defines the ordering of Document.
type DocumentOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *DocumentOrderField `json:"field"`
}

// DefaultDocumentOrder is the default ordering of Document.
var DefaultDocumentOrder = &DocumentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentOrderField{
		Value: func(d *Document) (ent.Value, error) {
			return d.ID, nil
		},
		column: document.FieldID,
		toTerm: document.ByID,
		toCursor: func(d *Document) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts Document into DocumentEdge.
func (d *Document) ToEdge(order *DocumentOrder) *DocumentEdge {
	if order == nil {
		order = DefaultDocumentOrder
	}
	return &DocumentEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// EstimateEdge is the edge representation of Estimate.
type EstimateEdge struct {
	Node   *Estimate `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// EstimateConnection is the connection containing edges to Estimate.
type EstimateConnection struct {
	Edges      []*EstimateEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *EstimateConnection) build(nodes []*Estimate, pager *estimatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Estimate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Estimate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Estimate {
			return nodes[i]
		}
	}
	c.Edges = make([]*EstimateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EstimateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EstimatePaginateOption enables pagination customization.
type EstimatePaginateOption func(*estimatePager) error

// WithEstimateOrder configures pagination ordering.
func WithEstimateOrder(order *EstimateOrder) EstimatePaginateOption {
	if order == nil {
		order = DefaultEstimateOrder
	}
	o := *order
	return func(pager *estimatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEstimateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEstimateFilter configures pagination filter.
func WithEstimateFilter(filter func(*EstimateQuery) (*EstimateQuery, error)) EstimatePaginateOption {
	return func(pager *estimatePager) error {
		if filter == nil {
			return errors.New("EstimateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type estimatePager struct {
	reverse bool
	order   *EstimateOrder
	filter  func(*EstimateQuery) (*EstimateQuery, error)
}

func newEstimatePager(opts []EstimatePaginateOption, reverse bool) (*estimatePager, error) {
	pager := &estimatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEstimateOrder
	}
	return pager, nil
}

func (p *estimatePager) applyFilter(query *EstimateQuery) (*EstimateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *estimatePager) toCursor(e *Estimate) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *estimatePager) applyCursors(query *EstimateQuery, after, before *Cursor) (*EstimateQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEstimateOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *estimatePager) applyOrder(query *EstimateQuery) *EstimateQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEstimateOrder.Field {
		query = query.Order(DefaultEstimateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *estimatePager) orderExpr(query *EstimateQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEstimateOrder.Field {
			b.Comma().Ident(DefaultEstimateOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Estimate.
func (e *EstimateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EstimatePaginateOption,
) (*EstimateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEstimatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EstimateConnection{Edges: []*EstimateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if e, err = pager.applyCursors(e, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	e = pager.applyOrder(e)
	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EstimateOrderFieldCreatedAt orders Estimate by created_at.
	EstimateOrderFieldCreatedAt = &EstimateOrderField{
		Value: func(e *Estimate) (ent.Value, error) {
			return e.CreatedAt, nil
		},
		column: estimate.FieldCreatedAt,
		toTerm: estimate.ByCreatedAt,
		toCursor: func(e *Estimate) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.CreatedAt,
			}
		},
	}
	// EstimateOrderFieldUpdatedAt orders Estimate by updated_at.
	EstimateOrderFieldUpdatedAt = &EstimateOrderField{
		Value: func(e *Estimate) (ent.Value, error) {
			return e.UpdatedAt, nil
		},
		column: estimate.FieldUpdatedAt,
		toTerm: estimate.ByUpdatedAt,
		toCursor: func(e *Estimate) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EstimateOrderField) String() string {
	var str string
	switch f.column {
	case EstimateOrderFieldCreatedAt.column:
		str = "CREATED"
	case EstimateOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EstimateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EstimateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EstimateOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *EstimateOrderFieldCreatedAt
	case "UPDATED":
		*f = *EstimateOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid EstimateOrderField", str)
	}
	return nil
}

// EstimateOrderField defines the ordering field of Estimate.
type EstimateOrderField struct {
	// Value extracts the ordering value from the given Estimate.
	Value    func(*Estimate) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) estimate.OrderOption
	toCursor func(*Estimate) Cursor
}

// EstimateOrder defines the ordering of Estimate.
type EstimateOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *EstimateOrderField `json:"field"`
}

// DefaultEstimateOrder is the default ordering of Estimate.
var DefaultEstimateOrder = &EstimateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EstimateOrderField{
		Value: func(e *Estimate) (ent.Value, error) {
			return e.ID, nil
		},
		column: estimate.FieldID,
		toTerm: estimate.ByID,
		toCursor: func(e *Estimate) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Estimate into EstimateEdge.
func (e *Estimate) ToEdge(order *EstimateOrder) *EstimateEdge {
	if order == nil {
		order = DefaultEstimateOrder
	}
	return &EstimateEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// EstimateActivityEdge is the edge representation of EstimateActivity.
type EstimateActivityEdge struct {
	Node   *EstimateActivity `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// EstimateActivityConnection is the connection containing edges to EstimateActivity.
type EstimateActivityConnection struct {
	Edges      []*EstimateActivityEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *EstimateActivityConnection) build(nodes []*EstimateActivity, pager *estimateactivityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EstimateActivity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EstimateActivity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EstimateActivity {
			return nodes[i]
		}
	}
	c.Edges = make([]*EstimateActivityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EstimateActivityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EstimateActivityPaginateOption enables pagination customization.
type EstimateActivityPaginateOption func(*estimateactivityPager) error

// WithEstimateActivityOrder configures pagination ordering.
func WithEstimateActivityOrder(order *EstimateActivityOrder) EstimateActivityPaginateOption {
	if order == nil {
		order = DefaultEstimateActivityOrder
	}
	o := *order
	return func(pager *estimateactivityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEstimateActivityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEstimateActivityFilter configures pagination filter.
func WithEstimateActivityFilter(filter func(*EstimateActivityQuery) (*EstimateActivityQuery, error)) EstimateActivityPaginateOption {
	return func(pager *estimateactivityPager) error {
		if filter == nil {
			return errors.New("EstimateActivityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type estimateactivityPager struct {
	reverse bool
	order   *EstimateActivityOrder
	filter  func(*EstimateActivityQuery) (*EstimateActivityQuery, error)
}

func newEstimateActivityPager(opts []EstimateActivityPaginateOption, reverse bool) (*estimateactivityPager, error) {
	pager := &estimateactivityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEstimateActivityOrder
	}
	return pager, nil
}

func (p *estimateactivityPager) applyFilter(query *EstimateActivityQuery) (*EstimateActivityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *estimateactivityPager) toCursor(ea *EstimateActivity) Cursor {
	return p.order.Field.toCursor(ea)
}

func (p *estimateactivityPager) applyCursors(query *EstimateActivityQuery, after, before *Cursor) (*EstimateActivityQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEstimateActivityOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *estimateactivityPager) applyOrder(query *EstimateActivityQuery) *EstimateActivityQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEstimateActivityOrder.Field {
		query = query.Order(DefaultEstimateActivityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *estimateactivityPager) orderExpr(query *EstimateActivityQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEstimateActivityOrder.Field {
			b.Comma().Ident(DefaultEstimateActivityOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EstimateActivity.
func (ea *EstimateActivityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EstimateActivityPaginateOption,
) (*EstimateActivityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEstimateActivityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ea, err = pager.applyFilter(ea); err != nil {
		return nil, err
	}
	conn := &EstimateActivityConnection{Edges: []*EstimateActivityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ea.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ea, err = pager.applyCursors(ea, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ea.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ea.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ea = pager.applyOrder(ea)
	nodes, err := ea.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EstimateActivityOrderFieldCreatedAt orders EstimateActivity by created_at.
	EstimateActivityOrderFieldCreatedAt = &EstimateActivityOrderField{
		Value: func(ea *EstimateActivity) (ent.Value, error) {
			return ea.CreatedAt, nil
		},
		column: estimateactivity.FieldCreatedAt,
		toTerm: estimateactivity.ByCreatedAt,
		toCursor: func(ea *EstimateActivity) Cursor {
			return Cursor{
				ID:    ea.ID,
				Value: ea.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EstimateActivityOrderField) String() string {
	var str string
	switch f.column {
	case EstimateActivityOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EstimateActivityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EstimateActivityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EstimateActivityOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *EstimateActivityOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid EstimateActivityOrderField", str)
	}
	return nil
}

// EstimateActivityOrderField defines the ordering field of EstimateActivity.
type EstimateActivityOrderField struct {
	// Value extracts the ordering value from the given EstimateActivity.
	Value    func(*EstimateActivity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) estimateactivity.OrderOption
	toCursor func(*EstimateActivity) Cursor
}

// EstimateActivityOrder defines the ordering of EstimateActivity.
type EstimateActivityOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *EstimateActivityOrderField `json:"field"`
}

// DefaultEstimateActivityOrder is the default ordering of EstimateActivity.
var DefaultEstimateActivityOrder = &EstimateActivityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EstimateActivityOrderField{
		Value: func(ea *EstimateActivity) (ent.Value, error) {
			return ea.ID, nil
		},
		column: estimateactivity.FieldID,
		toTerm: estimateactivity.ByID,
		toCursor: func(ea *EstimateActivity) Cursor {
			return Cursor{ID: ea.ID}
		},
	},
}

// ToEdge converts EstimateActivity into EstimateActivityEdge.
func (ea *EstimateActivity) ToEdge(order *EstimateActivityOrder) *EstimateActivityEdge {
	if order == nil {
		order = DefaultEstimateActivityOrder
	}
	return &EstimateActivityEdge{
		Node:   ea,
		Cursor: order.Field.toCursor(ea),
	}
}

// HomeOwnerEdge is the edge representation of HomeOwner.
type HomeOwnerEdge struct {
	Node   *HomeOwner `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// HomeOwnerConnection is the connection containing edges to HomeOwner.
type HomeOwnerConnection struct {
	Edges      []*HomeOwnerEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *HomeOwnerConnection) build(nodes []*HomeOwner, pager *homeownerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HomeOwner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HomeOwner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HomeOwner {
			return nodes[i]
		}
	}
	c.Edges = make([]*HomeOwnerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HomeOwnerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HomeOwnerPaginateOption enables pagination customization.
type HomeOwnerPaginateOption func(*homeownerPager) error

// WithHomeOwnerOrder configures pagination ordering.
func WithHomeOwnerOrder(order *HomeOwnerOrder) HomeOwnerPaginateOption {
	if order == nil {
		order = DefaultHomeOwnerOrder
	}
	o := *order
	return func(pager *homeownerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHomeOwnerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHomeOwnerFilter configures pagination filter.
func WithHomeOwnerFilter(filter func(*HomeOwnerQuery) (*HomeOwnerQuery, error)) HomeOwnerPaginateOption {
	return func(pager *homeownerPager) error {
		if filter == nil {
			return errors.New("HomeOwnerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type homeownerPager struct {
	reverse bool
	order   *HomeOwnerOrder
	filter  func(*HomeOwnerQuery) (*HomeOwnerQuery, error)
}

func newHomeOwnerPager(opts []HomeOwnerPaginateOption, reverse bool) (*homeownerPager, error) {
	pager := &homeownerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHomeOwnerOrder
	}
	return pager, nil
}

func (p *homeownerPager) applyFilter(query *HomeOwnerQuery) (*HomeOwnerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *homeownerPager) toCursor(ho *HomeOwner) Cursor {
	return p.order.Field.toCursor(ho)
}

func (p *homeownerPager) applyCursors(query *HomeOwnerQuery, after, before *Cursor) (*HomeOwnerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHomeOwnerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *homeownerPager) applyOrder(query *HomeOwnerQuery) *HomeOwnerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHomeOwnerOrder.Field {
		query = query.Order(DefaultHomeOwnerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *homeownerPager) orderExpr(query *HomeOwnerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHomeOwnerOrder.Field {
			b.Comma().Ident(DefaultHomeOwnerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HomeOwner.
func (ho *HomeOwnerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HomeOwnerPaginateOption,
) (*HomeOwnerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHomeOwnerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ho, err = pager.applyFilter(ho); err != nil {
		return nil, err
	}
	conn := &HomeOwnerConnection{Edges: []*HomeOwnerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ho.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ho, err = pager.applyCursors(ho, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ho.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ho.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ho = pager.applyOrder(ho)
	nodes, err := ho.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// HomeOwnerOrderFieldCreatedAt orders HomeOwner by created_at.
	HomeOwnerOrderFieldCreatedAt = &HomeOwnerOrderField{
		Value: func(ho *HomeOwner) (ent.Value, error) {
			return ho.CreatedAt, nil
		},
		column: homeowner.FieldCreatedAt,
		toTerm: homeowner.ByCreatedAt,
		toCursor: func(ho *HomeOwner) Cursor {
			return Cursor{
				ID:    ho.ID,
				Value: ho.CreatedAt,
			}
		},
	}
	// HomeOwnerOrderFieldUpdatedAt orders HomeOwner by updated_at.
	HomeOwnerOrderFieldUpdatedAt = &HomeOwnerOrderField{
		Value: func(ho *HomeOwner) (ent.Value, error) {
			return ho.UpdatedAt, nil
		},
		column: homeowner.FieldUpdatedAt,
		toTerm: homeowner.ByUpdatedAt,
		toCursor: func(ho *HomeOwner) Cursor {
			return Cursor{
				ID:    ho.ID,
				Value: ho.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f HomeOwnerOrderField) String() string {
	var str string
	switch f.column {
	case HomeOwnerOrderFieldCreatedAt.column:
		str = "CREATED"
	case HomeOwnerOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f HomeOwnerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *HomeOwnerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("HomeOwnerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *HomeOwnerOrderFieldCreatedAt
	case "UPDATED":
		*f = *HomeOwnerOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid HomeOwnerOrderField", str)
	}
	return nil
}

// HomeOwnerOrderField defines the ordering field of HomeOwner.
type HomeOwnerOrderField struct {
	// Value extracts the ordering value from the given HomeOwner.
	Value    func(*HomeOwner) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) homeowner.OrderOption
	toCursor func(*HomeOwner) Cursor
}

// HomeOwnerOrder defines the ordering of HomeOwner.
type HomeOwnerOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *HomeOwnerOrderField `json:"field"`
}

// DefaultHomeOwnerOrder is the default ordering of HomeOwner.
var DefaultHomeOwnerOrder = &HomeOwnerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HomeOwnerOrderField{
		Value: func(ho *HomeOwner) (ent.Value, error) {
			return ho.ID, nil
		},
		column: homeowner.FieldID,
		toTerm: homeowner.ByID,
		toCursor: func(ho *HomeOwner) Cursor {
			return Cursor{ID: ho.ID}
		},
	},
}

// ToEdge converts HomeOwner into HomeOwnerEdge.
func (ho *HomeOwner) ToEdge(order *HomeOwnerOrder) *HomeOwnerEdge {
	if order == nil {
		order = DefaultHomeOwnerOrder
	}
	return &HomeOwnerEdge{
		Node:   ho,
		Cursor: order.Field.toCursor(ho),
	}
}

// InstallationJobEdge is the edge representation of InstallationJob.
type InstallationJobEdge struct {
	Node   *InstallationJob `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// InstallationJobConnection is the connection containing edges to InstallationJob.
type InstallationJobConnection struct {
	Edges      []*InstallationJobEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *InstallationJobConnection) build(nodes []*InstallationJob, pager *installationjobPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *InstallationJob
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InstallationJob {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InstallationJob {
			return nodes[i]
		}
	}
	c.Edges = make([]*InstallationJobEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InstallationJobEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InstallationJobPaginateOption enables pagination customization.
type InstallationJobPaginateOption func(*installationjobPager) error

// WithInstallationJobOrder configures pagination ordering.
func WithInstallationJobOrder(order *InstallationJobOrder) InstallationJobPaginateOption {
	if order == nil {
		order = DefaultInstallationJobOrder
	}
	o := *order
	return func(pager *installationjobPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInstallationJobOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInstallationJobFilter configures pagination filter.
func WithInstallationJobFilter(filter func(*InstallationJobQuery) (*InstallationJobQuery, error)) InstallationJobPaginateOption {
	return func(pager *installationjobPager) error {
		if filter == nil {
			return errors.New("InstallationJobQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type installationjobPager struct {
	reverse bool
	order   *InstallationJobOrder
	filter  func(*InstallationJobQuery) (*InstallationJobQuery, error)
}

func newInstallationJobPager(opts []InstallationJobPaginateOption, reverse bool) (*installationjobPager, error) {
	pager := &installationjobPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInstallationJobOrder
	}
	return pager, nil
}

func (p *installationjobPager) applyFilter(query *InstallationJobQuery) (*InstallationJobQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *installationjobPager) toCursor(ij *InstallationJob) Cursor {
	return p.order.Field.toCursor(ij)
}

func (p *installationjobPager) applyCursors(query *InstallationJobQuery, after, before *Cursor) (*InstallationJobQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInstallationJobOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *installationjobPager) applyOrder(query *InstallationJobQuery) *InstallationJobQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInstallationJobOrder.Field {
		query = query.Order(DefaultInstallationJobOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *installationjobPager) orderExpr(query *InstallationJobQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInstallationJobOrder.Field {
			b.Comma().Ident(DefaultInstallationJobOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to InstallationJob.
func (ij *InstallationJobQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InstallationJobPaginateOption,
) (*InstallationJobConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInstallationJobPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ij, err = pager.applyFilter(ij); err != nil {
		return nil, err
	}
	conn := &InstallationJobConnection{Edges: []*InstallationJobEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ij.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ij, err = pager.applyCursors(ij, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ij.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ij.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ij = pager.applyOrder(ij)
	nodes, err := ij.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InstallationJobOrderFieldCreatedAt orders InstallationJob by created_at.
	InstallationJobOrderFieldCreatedAt = &InstallationJobOrderField{
		Value: func(ij *InstallationJob) (ent.Value, error) {
			return ij.CreatedAt, nil
		},
		column: installationjob.FieldCreatedAt,
		toTerm: installationjob.ByCreatedAt,
		toCursor: func(ij *InstallationJob) Cursor {
			return Cursor{
				ID:    ij.ID,
				Value: ij.CreatedAt,
			}
		},
	}
	// InstallationJobOrderFieldUpdatedAt orders InstallationJob by updated_at.
	InstallationJobOrderFieldUpdatedAt = &InstallationJobOrderField{
		Value: func(ij *InstallationJob) (ent.Value, error) {
			return ij.UpdatedAt, nil
		},
		column: installationjob.FieldUpdatedAt,
		toTerm: installationjob.ByUpdatedAt,
		toCursor: func(ij *InstallationJob) Cursor {
			return Cursor{
				ID:    ij.ID,
				Value: ij.UpdatedAt,
			}
		},
	}
	// InstallationJobOrderFieldApprovalAt orders InstallationJob by approval_at.
	InstallationJobOrderFieldApprovalAt = &InstallationJobOrderField{
		Value: func(ij *InstallationJob) (ent.Value, error) {
			return ij.ApprovalAt, nil
		},
		column: installationjob.FieldApprovalAt,
		toTerm: installationjob.ByApprovalAt,
		toCursor: func(ij *InstallationJob) Cursor {
			return Cursor{
				ID:    ij.ID,
				Value: ij.ApprovalAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InstallationJobOrderField) String() string {
	var str string
	switch f.column {
	case InstallationJobOrderFieldCreatedAt.column:
		str = "CREATED"
	case InstallationJobOrderFieldUpdatedAt.column:
		str = "UPDATED"
	case InstallationJobOrderFieldApprovalAt.column:
		str = "APPROVAL_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InstallationJobOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InstallationJobOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InstallationJobOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *InstallationJobOrderFieldCreatedAt
	case "UPDATED":
		*f = *InstallationJobOrderFieldUpdatedAt
	case "APPROVAL_AT":
		*f = *InstallationJobOrderFieldApprovalAt
	default:
		return fmt.Errorf("%s is not a valid InstallationJobOrderField", str)
	}
	return nil
}

// InstallationJobOrderField defines the ordering field of InstallationJob.
type InstallationJobOrderField struct {
	// Value extracts the ordering value from the given InstallationJob.
	Value    func(*InstallationJob) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) installationjob.OrderOption
	toCursor func(*InstallationJob) Cursor
}

// InstallationJobOrder defines the ordering of InstallationJob.
type InstallationJobOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *InstallationJobOrderField `json:"field"`
}

// DefaultInstallationJobOrder is the default ordering of InstallationJob.
var DefaultInstallationJobOrder = &InstallationJobOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InstallationJobOrderField{
		Value: func(ij *InstallationJob) (ent.Value, error) {
			return ij.ID, nil
		},
		column: installationjob.FieldID,
		toTerm: installationjob.ByID,
		toCursor: func(ij *InstallationJob) Cursor {
			return Cursor{ID: ij.ID}
		},
	},
}

// ToEdge converts InstallationJob into InstallationJobEdge.
func (ij *InstallationJob) ToEdge(order *InstallationJobOrder) *InstallationJobEdge {
	if order == nil {
		order = DefaultInstallationJobOrder
	}
	return &InstallationJobEdge{
		Node:   ij,
		Cursor: order.Field.toCursor(ij),
	}
}

// InstallationJobItemEdge is the edge representation of InstallationJobItem.
type InstallationJobItemEdge struct {
	Node   *InstallationJobItem `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// InstallationJobItemConnection is the connection containing edges to InstallationJobItem.
type InstallationJobItemConnection struct {
	Edges      []*InstallationJobItemEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *InstallationJobItemConnection) build(nodes []*InstallationJobItem, pager *installationjobitemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *InstallationJobItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InstallationJobItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InstallationJobItem {
			return nodes[i]
		}
	}
	c.Edges = make([]*InstallationJobItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InstallationJobItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InstallationJobItemPaginateOption enables pagination customization.
type InstallationJobItemPaginateOption func(*installationjobitemPager) error

// WithInstallationJobItemOrder configures pagination ordering.
func WithInstallationJobItemOrder(order *InstallationJobItemOrder) InstallationJobItemPaginateOption {
	if order == nil {
		order = DefaultInstallationJobItemOrder
	}
	o := *order
	return func(pager *installationjobitemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInstallationJobItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInstallationJobItemFilter configures pagination filter.
func WithInstallationJobItemFilter(filter func(*InstallationJobItemQuery) (*InstallationJobItemQuery, error)) InstallationJobItemPaginateOption {
	return func(pager *installationjobitemPager) error {
		if filter == nil {
			return errors.New("InstallationJobItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type installationjobitemPager struct {
	reverse bool
	order   *InstallationJobItemOrder
	filter  func(*InstallationJobItemQuery) (*InstallationJobItemQuery, error)
}

func newInstallationJobItemPager(opts []InstallationJobItemPaginateOption, reverse bool) (*installationjobitemPager, error) {
	pager := &installationjobitemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInstallationJobItemOrder
	}
	return pager, nil
}

func (p *installationjobitemPager) applyFilter(query *InstallationJobItemQuery) (*InstallationJobItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *installationjobitemPager) toCursor(iji *InstallationJobItem) Cursor {
	return p.order.Field.toCursor(iji)
}

func (p *installationjobitemPager) applyCursors(query *InstallationJobItemQuery, after, before *Cursor) (*InstallationJobItemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInstallationJobItemOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *installationjobitemPager) applyOrder(query *InstallationJobItemQuery) *InstallationJobItemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInstallationJobItemOrder.Field {
		query = query.Order(DefaultInstallationJobItemOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *installationjobitemPager) orderExpr(query *InstallationJobItemQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInstallationJobItemOrder.Field {
			b.Comma().Ident(DefaultInstallationJobItemOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to InstallationJobItem.
func (iji *InstallationJobItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InstallationJobItemPaginateOption,
) (*InstallationJobItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInstallationJobItemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if iji, err = pager.applyFilter(iji); err != nil {
		return nil, err
	}
	conn := &InstallationJobItemConnection{Edges: []*InstallationJobItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = iji.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if iji, err = pager.applyCursors(iji, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		iji.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := iji.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	iji = pager.applyOrder(iji)
	nodes, err := iji.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// InstallationJobItemOrderField defines the ordering field of InstallationJobItem.
type InstallationJobItemOrderField struct {
	// Value extracts the ordering value from the given InstallationJobItem.
	Value    func(*InstallationJobItem) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) installationjobitem.OrderOption
	toCursor func(*InstallationJobItem) Cursor
}

// InstallationJobItemOrder defines the ordering of InstallationJobItem.
type InstallationJobItemOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *InstallationJobItemOrderField `json:"field"`
}

// DefaultInstallationJobItemOrder is the default ordering of InstallationJobItem.
var DefaultInstallationJobItemOrder = &InstallationJobItemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InstallationJobItemOrderField{
		Value: func(iji *InstallationJobItem) (ent.Value, error) {
			return iji.ID, nil
		},
		column: installationjobitem.FieldID,
		toTerm: installationjobitem.ByID,
		toCursor: func(iji *InstallationJobItem) Cursor {
			return Cursor{ID: iji.ID}
		},
	},
}

// ToEdge converts InstallationJobItem into InstallationJobItemEdge.
func (iji *InstallationJobItem) ToEdge(order *InstallationJobItemOrder) *InstallationJobItemEdge {
	if order == nil {
		order = DefaultInstallationJobItemOrder
	}
	return &InstallationJobItemEdge{
		Node:   iji,
		Cursor: order.Field.toCursor(iji),
	}
}

// InstallationJobProgressEdge is the edge representation of InstallationJobProgress.
type InstallationJobProgressEdge struct {
	Node   *InstallationJobProgress `json:"node"`
	Cursor Cursor                   `json:"cursor"`
}

// InstallationJobProgressConnection is the connection containing edges to InstallationJobProgress.
type InstallationJobProgressConnection struct {
	Edges      []*InstallationJobProgressEdge `json:"edges"`
	PageInfo   PageInfo                       `json:"pageInfo"`
	TotalCount int                            `json:"totalCount"`
}

func (c *InstallationJobProgressConnection) build(nodes []*InstallationJobProgress, pager *installationjobprogressPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *InstallationJobProgress
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InstallationJobProgress {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InstallationJobProgress {
			return nodes[i]
		}
	}
	c.Edges = make([]*InstallationJobProgressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InstallationJobProgressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InstallationJobProgressPaginateOption enables pagination customization.
type InstallationJobProgressPaginateOption func(*installationjobprogressPager) error

// WithInstallationJobProgressOrder configures pagination ordering.
func WithInstallationJobProgressOrder(order *InstallationJobProgressOrder) InstallationJobProgressPaginateOption {
	if order == nil {
		order = DefaultInstallationJobProgressOrder
	}
	o := *order
	return func(pager *installationjobprogressPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInstallationJobProgressOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInstallationJobProgressFilter configures pagination filter.
func WithInstallationJobProgressFilter(filter func(*InstallationJobProgressQuery) (*InstallationJobProgressQuery, error)) InstallationJobProgressPaginateOption {
	return func(pager *installationjobprogressPager) error {
		if filter == nil {
			return errors.New("InstallationJobProgressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type installationjobprogressPager struct {
	reverse bool
	order   *InstallationJobProgressOrder
	filter  func(*InstallationJobProgressQuery) (*InstallationJobProgressQuery, error)
}

func newInstallationJobProgressPager(opts []InstallationJobProgressPaginateOption, reverse bool) (*installationjobprogressPager, error) {
	pager := &installationjobprogressPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInstallationJobProgressOrder
	}
	return pager, nil
}

func (p *installationjobprogressPager) applyFilter(query *InstallationJobProgressQuery) (*InstallationJobProgressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *installationjobprogressPager) toCursor(ijp *InstallationJobProgress) Cursor {
	return p.order.Field.toCursor(ijp)
}

func (p *installationjobprogressPager) applyCursors(query *InstallationJobProgressQuery, after, before *Cursor) (*InstallationJobProgressQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInstallationJobProgressOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *installationjobprogressPager) applyOrder(query *InstallationJobProgressQuery) *InstallationJobProgressQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInstallationJobProgressOrder.Field {
		query = query.Order(DefaultInstallationJobProgressOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *installationjobprogressPager) orderExpr(query *InstallationJobProgressQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInstallationJobProgressOrder.Field {
			b.Comma().Ident(DefaultInstallationJobProgressOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to InstallationJobProgress.
func (ijp *InstallationJobProgressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InstallationJobProgressPaginateOption,
) (*InstallationJobProgressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInstallationJobProgressPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ijp, err = pager.applyFilter(ijp); err != nil {
		return nil, err
	}
	conn := &InstallationJobProgressConnection{Edges: []*InstallationJobProgressEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ijp.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ijp, err = pager.applyCursors(ijp, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ijp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ijp.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ijp = pager.applyOrder(ijp)
	nodes, err := ijp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// InstallationJobProgressOrderFieldCreatedAt orders InstallationJobProgress by created_at.
	InstallationJobProgressOrderFieldCreatedAt = &InstallationJobProgressOrderField{
		Value: func(ijp *InstallationJobProgress) (ent.Value, error) {
			return ijp.CreatedAt, nil
		},
		column: installationjobprogress.FieldCreatedAt,
		toTerm: installationjobprogress.ByCreatedAt,
		toCursor: func(ijp *InstallationJobProgress) Cursor {
			return Cursor{
				ID:    ijp.ID,
				Value: ijp.CreatedAt,
			}
		},
	}
	// InstallationJobProgressOrderFieldUpdatedAt orders InstallationJobProgress by updated_at.
	InstallationJobProgressOrderFieldUpdatedAt = &InstallationJobProgressOrderField{
		Value: func(ijp *InstallationJobProgress) (ent.Value, error) {
			return ijp.UpdatedAt, nil
		},
		column: installationjobprogress.FieldUpdatedAt,
		toTerm: installationjobprogress.ByUpdatedAt,
		toCursor: func(ijp *InstallationJobProgress) Cursor {
			return Cursor{
				ID:    ijp.ID,
				Value: ijp.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InstallationJobProgressOrderField) String() string {
	var str string
	switch f.column {
	case InstallationJobProgressOrderFieldCreatedAt.column:
		str = "CREATED"
	case InstallationJobProgressOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InstallationJobProgressOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InstallationJobProgressOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InstallationJobProgressOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *InstallationJobProgressOrderFieldCreatedAt
	case "UPDATED":
		*f = *InstallationJobProgressOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid InstallationJobProgressOrderField", str)
	}
	return nil
}

// InstallationJobProgressOrderField defines the ordering field of InstallationJobProgress.
type InstallationJobProgressOrderField struct {
	// Value extracts the ordering value from the given InstallationJobProgress.
	Value    func(*InstallationJobProgress) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) installationjobprogress.OrderOption
	toCursor func(*InstallationJobProgress) Cursor
}

// InstallationJobProgressOrder defines the ordering of InstallationJobProgress.
type InstallationJobProgressOrder struct {
	Direction OrderDirection                     `json:"direction"`
	Field     *InstallationJobProgressOrderField `json:"field"`
}

// DefaultInstallationJobProgressOrder is the default ordering of InstallationJobProgress.
var DefaultInstallationJobProgressOrder = &InstallationJobProgressOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InstallationJobProgressOrderField{
		Value: func(ijp *InstallationJobProgress) (ent.Value, error) {
			return ijp.ID, nil
		},
		column: installationjobprogress.FieldID,
		toTerm: installationjobprogress.ByID,
		toCursor: func(ijp *InstallationJobProgress) Cursor {
			return Cursor{ID: ijp.ID}
		},
	},
}

// ToEdge converts InstallationJobProgress into InstallationJobProgressEdge.
func (ijp *InstallationJobProgress) ToEdge(order *InstallationJobProgressOrder) *InstallationJobProgressEdge {
	if order == nil {
		order = DefaultInstallationJobProgressOrder
	}
	return &InstallationJobProgressEdge{
		Node:   ijp,
		Cursor: order.Field.toCursor(ijp),
	}
}

// JobEdge is the edge representation of Job.
type JobEdge struct {
	Node   *Job   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// JobConnection is the connection containing edges to Job.
type JobConnection struct {
	Edges      []*JobEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

func (c *JobConnection) build(nodes []*Job, pager *jobPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Job
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Job {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Job {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobPaginateOption enables pagination customization.
type JobPaginateOption func(*jobPager) error

// WithJobOrder configures pagination ordering.
func WithJobOrder(order *JobOrder) JobPaginateOption {
	if order == nil {
		order = DefaultJobOrder
	}
	o := *order
	return func(pager *jobPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobFilter configures pagination filter.
func WithJobFilter(filter func(*JobQuery) (*JobQuery, error)) JobPaginateOption {
	return func(pager *jobPager) error {
		if filter == nil {
			return errors.New("JobQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobPager struct {
	reverse bool
	order   *JobOrder
	filter  func(*JobQuery) (*JobQuery, error)
}

func newJobPager(opts []JobPaginateOption, reverse bool) (*jobPager, error) {
	pager := &jobPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobOrder
	}
	return pager, nil
}

func (p *jobPager) applyFilter(query *JobQuery) (*JobQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobPager) toCursor(j *Job) Cursor {
	return p.order.Field.toCursor(j)
}

func (p *jobPager) applyCursors(query *JobQuery, after, before *Cursor) (*JobQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobPager) applyOrder(query *JobQuery) *JobQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobOrder.Field {
		query = query.Order(DefaultJobOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobPager) orderExpr(query *JobQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobOrder.Field {
			b.Comma().Ident(DefaultJobOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Job.
func (j *JobQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobPaginateOption,
) (*JobConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if j, err = pager.applyFilter(j); err != nil {
		return nil, err
	}
	conn := &JobConnection{Edges: []*JobEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = j.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if j, err = pager.applyCursors(j, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		j.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := j.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	j = pager.applyOrder(j)
	nodes, err := j.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobOrderFieldCreatedAt orders Job by created_at.
	JobOrderFieldCreatedAt = &JobOrderField{
		Value: func(j *Job) (ent.Value, error) {
			return j.CreatedAt, nil
		},
		column: job.FieldCreatedAt,
		toTerm: job.ByCreatedAt,
		toCursor: func(j *Job) Cursor {
			return Cursor{
				ID:    j.ID,
				Value: j.CreatedAt,
			}
		},
	}
	// JobOrderFieldUpdatedAt orders Job by updated_at.
	JobOrderFieldUpdatedAt = &JobOrderField{
		Value: func(j *Job) (ent.Value, error) {
			return j.UpdatedAt, nil
		},
		column: job.FieldUpdatedAt,
		toTerm: job.ByUpdatedAt,
		toCursor: func(j *Job) Cursor {
			return Cursor{
				ID:    j.ID,
				Value: j.UpdatedAt,
			}
		},
	}
	// JobOrderFieldProgressAt orders Job by progress_at.
	JobOrderFieldProgressAt = &JobOrderField{
		Value: func(j *Job) (ent.Value, error) {
			return j.ProgressAt, nil
		},
		column: job.FieldProgressAt,
		toTerm: job.ByProgressAt,
		toCursor: func(j *Job) Cursor {
			return Cursor{
				ID:    j.ID,
				Value: j.ProgressAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobOrderField) String() string {
	var str string
	switch f.column {
	case JobOrderFieldCreatedAt.column:
		str = "CREATED"
	case JobOrderFieldUpdatedAt.column:
		str = "UPDATED"
	case JobOrderFieldProgressAt.column:
		str = "PROGRESS_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *JobOrderFieldCreatedAt
	case "UPDATED":
		*f = *JobOrderFieldUpdatedAt
	case "PROGRESS_AT":
		*f = *JobOrderFieldProgressAt
	default:
		return fmt.Errorf("%s is not a valid JobOrderField", str)
	}
	return nil
}

// JobOrderField defines the ordering field of Job.
type JobOrderField struct {
	// Value extracts the ordering value from the given Job.
	Value    func(*Job) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) job.OrderOption
	toCursor func(*Job) Cursor
}

// JobOrder defines the ordering of Job.
type JobOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *JobOrderField `json:"field"`
}

// DefaultJobOrder is the default ordering of Job.
var DefaultJobOrder = &JobOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobOrderField{
		Value: func(j *Job) (ent.Value, error) {
			return j.ID, nil
		},
		column: job.FieldID,
		toTerm: job.ByID,
		toCursor: func(j *Job) Cursor {
			return Cursor{ID: j.ID}
		},
	},
}

// ToEdge converts Job into JobEdge.
func (j *Job) ToEdge(order *JobOrder) *JobEdge {
	if order == nil {
		order = DefaultJobOrder
	}
	return &JobEdge{
		Node:   j,
		Cursor: order.Field.toCursor(j),
	}
}

// JobActivityEdge is the edge representation of JobActivity.
type JobActivityEdge struct {
	Node   *JobActivity `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// JobActivityConnection is the connection containing edges to JobActivity.
type JobActivityConnection struct {
	Edges      []*JobActivityEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *JobActivityConnection) build(nodes []*JobActivity, pager *jobactivityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobActivity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobActivity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobActivity {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobActivityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobActivityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobActivityPaginateOption enables pagination customization.
type JobActivityPaginateOption func(*jobactivityPager) error

// WithJobActivityOrder configures pagination ordering.
func WithJobActivityOrder(order *JobActivityOrder) JobActivityPaginateOption {
	if order == nil {
		order = DefaultJobActivityOrder
	}
	o := *order
	return func(pager *jobactivityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobActivityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobActivityFilter configures pagination filter.
func WithJobActivityFilter(filter func(*JobActivityQuery) (*JobActivityQuery, error)) JobActivityPaginateOption {
	return func(pager *jobactivityPager) error {
		if filter == nil {
			return errors.New("JobActivityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobactivityPager struct {
	reverse bool
	order   *JobActivityOrder
	filter  func(*JobActivityQuery) (*JobActivityQuery, error)
}

func newJobActivityPager(opts []JobActivityPaginateOption, reverse bool) (*jobactivityPager, error) {
	pager := &jobactivityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobActivityOrder
	}
	return pager, nil
}

func (p *jobactivityPager) applyFilter(query *JobActivityQuery) (*JobActivityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobactivityPager) toCursor(ja *JobActivity) Cursor {
	return p.order.Field.toCursor(ja)
}

func (p *jobactivityPager) applyCursors(query *JobActivityQuery, after, before *Cursor) (*JobActivityQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobActivityOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobactivityPager) applyOrder(query *JobActivityQuery) *JobActivityQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobActivityOrder.Field {
		query = query.Order(DefaultJobActivityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobactivityPager) orderExpr(query *JobActivityQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobActivityOrder.Field {
			b.Comma().Ident(DefaultJobActivityOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobActivity.
func (ja *JobActivityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobActivityPaginateOption,
) (*JobActivityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobActivityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ja, err = pager.applyFilter(ja); err != nil {
		return nil, err
	}
	conn := &JobActivityConnection{Edges: []*JobActivityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ja.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ja, err = pager.applyCursors(ja, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ja.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ja.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ja = pager.applyOrder(ja)
	nodes, err := ja.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobActivityOrderFieldCreatedAt orders JobActivity by created_at.
	JobActivityOrderFieldCreatedAt = &JobActivityOrderField{
		Value: func(ja *JobActivity) (ent.Value, error) {
			return ja.CreatedAt, nil
		},
		column: jobactivity.FieldCreatedAt,
		toTerm: jobactivity.ByCreatedAt,
		toCursor: func(ja *JobActivity) Cursor {
			return Cursor{
				ID:    ja.ID,
				Value: ja.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobActivityOrderField) String() string {
	var str string
	switch f.column {
	case JobActivityOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobActivityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobActivityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobActivityOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *JobActivityOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid JobActivityOrderField", str)
	}
	return nil
}

// JobActivityOrderField defines the ordering field of JobActivity.
type JobActivityOrderField struct {
	// Value extracts the ordering value from the given JobActivity.
	Value    func(*JobActivity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobactivity.OrderOption
	toCursor func(*JobActivity) Cursor
}

// JobActivityOrder defines the ordering of JobActivity.
type JobActivityOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *JobActivityOrderField `json:"field"`
}

// DefaultJobActivityOrder is the default ordering of JobActivity.
var DefaultJobActivityOrder = &JobActivityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobActivityOrderField{
		Value: func(ja *JobActivity) (ent.Value, error) {
			return ja.ID, nil
		},
		column: jobactivity.FieldID,
		toTerm: jobactivity.ByID,
		toCursor: func(ja *JobActivity) Cursor {
			return Cursor{ID: ja.ID}
		},
	},
}

// ToEdge converts JobActivity into JobActivityEdge.
func (ja *JobActivity) ToEdge(order *JobActivityOrder) *JobActivityEdge {
	if order == nil {
		order = DefaultJobActivityOrder
	}
	return &JobActivityEdge{
		Node:   ja,
		Cursor: order.Field.toCursor(ja),
	}
}

// JobAssignmentHistoryEdge is the edge representation of JobAssignmentHistory.
type JobAssignmentHistoryEdge struct {
	Node   *JobAssignmentHistory `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// JobAssignmentHistoryConnection is the connection containing edges to JobAssignmentHistory.
type JobAssignmentHistoryConnection struct {
	Edges      []*JobAssignmentHistoryEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *JobAssignmentHistoryConnection) build(nodes []*JobAssignmentHistory, pager *jobassignmenthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobAssignmentHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobAssignmentHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobAssignmentHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobAssignmentHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobAssignmentHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobAssignmentHistoryPaginateOption enables pagination customization.
type JobAssignmentHistoryPaginateOption func(*jobassignmenthistoryPager) error

// WithJobAssignmentHistoryOrder configures pagination ordering.
func WithJobAssignmentHistoryOrder(order *JobAssignmentHistoryOrder) JobAssignmentHistoryPaginateOption {
	if order == nil {
		order = DefaultJobAssignmentHistoryOrder
	}
	o := *order
	return func(pager *jobassignmenthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobAssignmentHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobAssignmentHistoryFilter configures pagination filter.
func WithJobAssignmentHistoryFilter(filter func(*JobAssignmentHistoryQuery) (*JobAssignmentHistoryQuery, error)) JobAssignmentHistoryPaginateOption {
	return func(pager *jobassignmenthistoryPager) error {
		if filter == nil {
			return errors.New("JobAssignmentHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobassignmenthistoryPager struct {
	reverse bool
	order   *JobAssignmentHistoryOrder
	filter  func(*JobAssignmentHistoryQuery) (*JobAssignmentHistoryQuery, error)
}

func newJobAssignmentHistoryPager(opts []JobAssignmentHistoryPaginateOption, reverse bool) (*jobassignmenthistoryPager, error) {
	pager := &jobassignmenthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobAssignmentHistoryOrder
	}
	return pager, nil
}

func (p *jobassignmenthistoryPager) applyFilter(query *JobAssignmentHistoryQuery) (*JobAssignmentHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobassignmenthistoryPager) toCursor(jah *JobAssignmentHistory) Cursor {
	return p.order.Field.toCursor(jah)
}

func (p *jobassignmenthistoryPager) applyCursors(query *JobAssignmentHistoryQuery, after, before *Cursor) (*JobAssignmentHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobAssignmentHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobassignmenthistoryPager) applyOrder(query *JobAssignmentHistoryQuery) *JobAssignmentHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobAssignmentHistoryOrder.Field {
		query = query.Order(DefaultJobAssignmentHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobassignmenthistoryPager) orderExpr(query *JobAssignmentHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobAssignmentHistoryOrder.Field {
			b.Comma().Ident(DefaultJobAssignmentHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobAssignmentHistory.
func (jah *JobAssignmentHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobAssignmentHistoryPaginateOption,
) (*JobAssignmentHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobAssignmentHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jah, err = pager.applyFilter(jah); err != nil {
		return nil, err
	}
	conn := &JobAssignmentHistoryConnection{Edges: []*JobAssignmentHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = jah.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jah, err = pager.applyCursors(jah, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		jah.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jah.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jah = pager.applyOrder(jah)
	nodes, err := jah.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobAssignmentHistoryOrderFieldCreatedAt orders JobAssignmentHistory by created_at.
	JobAssignmentHistoryOrderFieldCreatedAt = &JobAssignmentHistoryOrderField{
		Value: func(jah *JobAssignmentHistory) (ent.Value, error) {
			return jah.CreatedAt, nil
		},
		column: jobassignmenthistory.FieldCreatedAt,
		toTerm: jobassignmenthistory.ByCreatedAt,
		toCursor: func(jah *JobAssignmentHistory) Cursor {
			return Cursor{
				ID:    jah.ID,
				Value: jah.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobAssignmentHistoryOrderField) String() string {
	var str string
	switch f.column {
	case JobAssignmentHistoryOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobAssignmentHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobAssignmentHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobAssignmentHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *JobAssignmentHistoryOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid JobAssignmentHistoryOrderField", str)
	}
	return nil
}

// JobAssignmentHistoryOrderField defines the ordering field of JobAssignmentHistory.
type JobAssignmentHistoryOrderField struct {
	// Value extracts the ordering value from the given JobAssignmentHistory.
	Value    func(*JobAssignmentHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobassignmenthistory.OrderOption
	toCursor func(*JobAssignmentHistory) Cursor
}

// JobAssignmentHistoryOrder defines the ordering of JobAssignmentHistory.
type JobAssignmentHistoryOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *JobAssignmentHistoryOrderField `json:"field"`
}

// DefaultJobAssignmentHistoryOrder is the default ordering of JobAssignmentHistory.
var DefaultJobAssignmentHistoryOrder = &JobAssignmentHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobAssignmentHistoryOrderField{
		Value: func(jah *JobAssignmentHistory) (ent.Value, error) {
			return jah.ID, nil
		},
		column: jobassignmenthistory.FieldID,
		toTerm: jobassignmenthistory.ByID,
		toCursor: func(jah *JobAssignmentHistory) Cursor {
			return Cursor{ID: jah.ID}
		},
	},
}

// ToEdge converts JobAssignmentHistory into JobAssignmentHistoryEdge.
func (jah *JobAssignmentHistory) ToEdge(order *JobAssignmentHistoryOrder) *JobAssignmentHistoryEdge {
	if order == nil {
		order = DefaultJobAssignmentHistoryOrder
	}
	return &JobAssignmentHistoryEdge{
		Node:   jah,
		Cursor: order.Field.toCursor(jah),
	}
}

// JobDocURLEdge is the edge representation of JobDocURL.
type JobDocURLEdge struct {
	Node   *JobDocURL `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// JobDocURLConnection is the connection containing edges to JobDocURL.
type JobDocURLConnection struct {
	Edges      []*JobDocURLEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *JobDocURLConnection) build(nodes []*JobDocURL, pager *jobdocurlPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobDocURL
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobDocURL {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobDocURL {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobDocURLEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobDocURLEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobDocURLPaginateOption enables pagination customization.
type JobDocURLPaginateOption func(*jobdocurlPager) error

// WithJobDocURLOrder configures pagination ordering.
func WithJobDocURLOrder(order *JobDocURLOrder) JobDocURLPaginateOption {
	if order == nil {
		order = DefaultJobDocURLOrder
	}
	o := *order
	return func(pager *jobdocurlPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobDocURLOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobDocURLFilter configures pagination filter.
func WithJobDocURLFilter(filter func(*JobDocURLQuery) (*JobDocURLQuery, error)) JobDocURLPaginateOption {
	return func(pager *jobdocurlPager) error {
		if filter == nil {
			return errors.New("JobDocURLQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobdocurlPager struct {
	reverse bool
	order   *JobDocURLOrder
	filter  func(*JobDocURLQuery) (*JobDocURLQuery, error)
}

func newJobDocURLPager(opts []JobDocURLPaginateOption, reverse bool) (*jobdocurlPager, error) {
	pager := &jobdocurlPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobDocURLOrder
	}
	return pager, nil
}

func (p *jobdocurlPager) applyFilter(query *JobDocURLQuery) (*JobDocURLQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobdocurlPager) toCursor(jdu *JobDocURL) Cursor {
	return p.order.Field.toCursor(jdu)
}

func (p *jobdocurlPager) applyCursors(query *JobDocURLQuery, after, before *Cursor) (*JobDocURLQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobDocURLOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobdocurlPager) applyOrder(query *JobDocURLQuery) *JobDocURLQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobDocURLOrder.Field {
		query = query.Order(DefaultJobDocURLOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobdocurlPager) orderExpr(query *JobDocURLQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobDocURLOrder.Field {
			b.Comma().Ident(DefaultJobDocURLOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobDocURL.
func (jdu *JobDocURLQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobDocURLPaginateOption,
) (*JobDocURLConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobDocURLPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jdu, err = pager.applyFilter(jdu); err != nil {
		return nil, err
	}
	conn := &JobDocURLConnection{Edges: []*JobDocURLEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = jdu.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jdu, err = pager.applyCursors(jdu, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		jdu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jdu.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jdu = pager.applyOrder(jdu)
	nodes, err := jdu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobDocURLOrderFieldCreatedAt orders JobDocURL by created_at.
	JobDocURLOrderFieldCreatedAt = &JobDocURLOrderField{
		Value: func(jdu *JobDocURL) (ent.Value, error) {
			return jdu.CreatedAt, nil
		},
		column: jobdocurl.FieldCreatedAt,
		toTerm: jobdocurl.ByCreatedAt,
		toCursor: func(jdu *JobDocURL) Cursor {
			return Cursor{
				ID:    jdu.ID,
				Value: jdu.CreatedAt,
			}
		},
	}
	// JobDocURLOrderFieldUpdatedAt orders JobDocURL by updated_at.
	JobDocURLOrderFieldUpdatedAt = &JobDocURLOrderField{
		Value: func(jdu *JobDocURL) (ent.Value, error) {
			return jdu.UpdatedAt, nil
		},
		column: jobdocurl.FieldUpdatedAt,
		toTerm: jobdocurl.ByUpdatedAt,
		toCursor: func(jdu *JobDocURL) Cursor {
			return Cursor{
				ID:    jdu.ID,
				Value: jdu.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobDocURLOrderField) String() string {
	var str string
	switch f.column {
	case JobDocURLOrderFieldCreatedAt.column:
		str = "CREATED"
	case JobDocURLOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobDocURLOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobDocURLOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobDocURLOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *JobDocURLOrderFieldCreatedAt
	case "UPDATED":
		*f = *JobDocURLOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid JobDocURLOrderField", str)
	}
	return nil
}

// JobDocURLOrderField defines the ordering field of JobDocURL.
type JobDocURLOrderField struct {
	// Value extracts the ordering value from the given JobDocURL.
	Value    func(*JobDocURL) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobdocurl.OrderOption
	toCursor func(*JobDocURL) Cursor
}

// JobDocURLOrder defines the ordering of JobDocURL.
type JobDocURLOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *JobDocURLOrderField `json:"field"`
}

// DefaultJobDocURLOrder is the default ordering of JobDocURL.
var DefaultJobDocURLOrder = &JobDocURLOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobDocURLOrderField{
		Value: func(jdu *JobDocURL) (ent.Value, error) {
			return jdu.ID, nil
		},
		column: jobdocurl.FieldID,
		toTerm: jobdocurl.ByID,
		toCursor: func(jdu *JobDocURL) Cursor {
			return Cursor{ID: jdu.ID}
		},
	},
}

// ToEdge converts JobDocURL into JobDocURLEdge.
func (jdu *JobDocURL) ToEdge(order *JobDocURLOrder) *JobDocURLEdge {
	if order == nil {
		order = DefaultJobDocURLOrder
	}
	return &JobDocURLEdge{
		Node:   jdu,
		Cursor: order.Field.toCursor(jdu),
	}
}

// JobNoteEdge is the edge representation of JobNote.
type JobNoteEdge struct {
	Node   *JobNote `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// JobNoteConnection is the connection containing edges to JobNote.
type JobNoteConnection struct {
	Edges      []*JobNoteEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *JobNoteConnection) build(nodes []*JobNote, pager *jobnotePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobNote
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobNote {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobNote {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobNoteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobNoteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobNotePaginateOption enables pagination customization.
type JobNotePaginateOption func(*jobnotePager) error

// WithJobNoteOrder configures pagination ordering.
func WithJobNoteOrder(order *JobNoteOrder) JobNotePaginateOption {
	if order == nil {
		order = DefaultJobNoteOrder
	}
	o := *order
	return func(pager *jobnotePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobNoteOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobNoteFilter configures pagination filter.
func WithJobNoteFilter(filter func(*JobNoteQuery) (*JobNoteQuery, error)) JobNotePaginateOption {
	return func(pager *jobnotePager) error {
		if filter == nil {
			return errors.New("JobNoteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobnotePager struct {
	reverse bool
	order   *JobNoteOrder
	filter  func(*JobNoteQuery) (*JobNoteQuery, error)
}

func newJobNotePager(opts []JobNotePaginateOption, reverse bool) (*jobnotePager, error) {
	pager := &jobnotePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobNoteOrder
	}
	return pager, nil
}

func (p *jobnotePager) applyFilter(query *JobNoteQuery) (*JobNoteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobnotePager) toCursor(jn *JobNote) Cursor {
	return p.order.Field.toCursor(jn)
}

func (p *jobnotePager) applyCursors(query *JobNoteQuery, after, before *Cursor) (*JobNoteQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobNoteOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobnotePager) applyOrder(query *JobNoteQuery) *JobNoteQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobNoteOrder.Field {
		query = query.Order(DefaultJobNoteOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobnotePager) orderExpr(query *JobNoteQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobNoteOrder.Field {
			b.Comma().Ident(DefaultJobNoteOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobNote.
func (jn *JobNoteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobNotePaginateOption,
) (*JobNoteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobNotePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jn, err = pager.applyFilter(jn); err != nil {
		return nil, err
	}
	conn := &JobNoteConnection{Edges: []*JobNoteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = jn.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jn, err = pager.applyCursors(jn, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		jn.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jn.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jn = pager.applyOrder(jn)
	nodes, err := jn.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobNoteOrderFieldCreatedAt orders JobNote by created_at.
	JobNoteOrderFieldCreatedAt = &JobNoteOrderField{
		Value: func(jn *JobNote) (ent.Value, error) {
			return jn.CreatedAt, nil
		},
		column: jobnote.FieldCreatedAt,
		toTerm: jobnote.ByCreatedAt,
		toCursor: func(jn *JobNote) Cursor {
			return Cursor{
				ID:    jn.ID,
				Value: jn.CreatedAt,
			}
		},
	}
	// JobNoteOrderFieldUpdatedAt orders JobNote by updated_at.
	JobNoteOrderFieldUpdatedAt = &JobNoteOrderField{
		Value: func(jn *JobNote) (ent.Value, error) {
			return jn.UpdatedAt, nil
		},
		column: jobnote.FieldUpdatedAt,
		toTerm: jobnote.ByUpdatedAt,
		toCursor: func(jn *JobNote) Cursor {
			return Cursor{
				ID:    jn.ID,
				Value: jn.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobNoteOrderField) String() string {
	var str string
	switch f.column {
	case JobNoteOrderFieldCreatedAt.column:
		str = "CREATED"
	case JobNoteOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobNoteOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobNoteOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobNoteOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *JobNoteOrderFieldCreatedAt
	case "UPDATED":
		*f = *JobNoteOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid JobNoteOrderField", str)
	}
	return nil
}

// JobNoteOrderField defines the ordering field of JobNote.
type JobNoteOrderField struct {
	// Value extracts the ordering value from the given JobNote.
	Value    func(*JobNote) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobnote.OrderOption
	toCursor func(*JobNote) Cursor
}

// JobNoteOrder defines the ordering of JobNote.
type JobNoteOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *JobNoteOrderField `json:"field"`
}

// DefaultJobNoteOrder is the default ordering of JobNote.
var DefaultJobNoteOrder = &JobNoteOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobNoteOrderField{
		Value: func(jn *JobNote) (ent.Value, error) {
			return jn.ID, nil
		},
		column: jobnote.FieldID,
		toTerm: jobnote.ByID,
		toCursor: func(jn *JobNote) Cursor {
			return Cursor{ID: jn.ID}
		},
	},
}

// ToEdge converts JobNote into JobNoteEdge.
func (jn *JobNote) ToEdge(order *JobNoteOrder) *JobNoteEdge {
	if order == nil {
		order = DefaultJobNoteOrder
	}
	return &JobNoteEdge{
		Node:   jn,
		Cursor: order.Field.toCursor(jn),
	}
}

// JobProgressHistoryEdge is the edge representation of JobProgressHistory.
type JobProgressHistoryEdge struct {
	Node   *JobProgressHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// JobProgressHistoryConnection is the connection containing edges to JobProgressHistory.
type JobProgressHistoryConnection struct {
	Edges      []*JobProgressHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *JobProgressHistoryConnection) build(nodes []*JobProgressHistory, pager *jobprogresshistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *JobProgressHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *JobProgressHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *JobProgressHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*JobProgressHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &JobProgressHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// JobProgressHistoryPaginateOption enables pagination customization.
type JobProgressHistoryPaginateOption func(*jobprogresshistoryPager) error

// WithJobProgressHistoryOrder configures pagination ordering.
func WithJobProgressHistoryOrder(order *JobProgressHistoryOrder) JobProgressHistoryPaginateOption {
	if order == nil {
		order = DefaultJobProgressHistoryOrder
	}
	o := *order
	return func(pager *jobprogresshistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultJobProgressHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithJobProgressHistoryFilter configures pagination filter.
func WithJobProgressHistoryFilter(filter func(*JobProgressHistoryQuery) (*JobProgressHistoryQuery, error)) JobProgressHistoryPaginateOption {
	return func(pager *jobprogresshistoryPager) error {
		if filter == nil {
			return errors.New("JobProgressHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type jobprogresshistoryPager struct {
	reverse bool
	order   *JobProgressHistoryOrder
	filter  func(*JobProgressHistoryQuery) (*JobProgressHistoryQuery, error)
}

func newJobProgressHistoryPager(opts []JobProgressHistoryPaginateOption, reverse bool) (*jobprogresshistoryPager, error) {
	pager := &jobprogresshistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultJobProgressHistoryOrder
	}
	return pager, nil
}

func (p *jobprogresshistoryPager) applyFilter(query *JobProgressHistoryQuery) (*JobProgressHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *jobprogresshistoryPager) toCursor(jph *JobProgressHistory) Cursor {
	return p.order.Field.toCursor(jph)
}

func (p *jobprogresshistoryPager) applyCursors(query *JobProgressHistoryQuery, after, before *Cursor) (*JobProgressHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultJobProgressHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *jobprogresshistoryPager) applyOrder(query *JobProgressHistoryQuery) *JobProgressHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultJobProgressHistoryOrder.Field {
		query = query.Order(DefaultJobProgressHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *jobprogresshistoryPager) orderExpr(query *JobProgressHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultJobProgressHistoryOrder.Field {
			b.Comma().Ident(DefaultJobProgressHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to JobProgressHistory.
func (jph *JobProgressHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...JobProgressHistoryPaginateOption,
) (*JobProgressHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newJobProgressHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if jph, err = pager.applyFilter(jph); err != nil {
		return nil, err
	}
	conn := &JobProgressHistoryConnection{Edges: []*JobProgressHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = jph.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if jph, err = pager.applyCursors(jph, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		jph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := jph.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	jph = pager.applyOrder(jph)
	nodes, err := jph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// JobProgressHistoryOrderFieldCreatedAt orders JobProgressHistory by created_at.
	JobProgressHistoryOrderFieldCreatedAt = &JobProgressHistoryOrderField{
		Value: func(jph *JobProgressHistory) (ent.Value, error) {
			return jph.CreatedAt, nil
		},
		column: jobprogresshistory.FieldCreatedAt,
		toTerm: jobprogresshistory.ByCreatedAt,
		toCursor: func(jph *JobProgressHistory) Cursor {
			return Cursor{
				ID:    jph.ID,
				Value: jph.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f JobProgressHistoryOrderField) String() string {
	var str string
	switch f.column {
	case JobProgressHistoryOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f JobProgressHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *JobProgressHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("JobProgressHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *JobProgressHistoryOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid JobProgressHistoryOrderField", str)
	}
	return nil
}

// JobProgressHistoryOrderField defines the ordering field of JobProgressHistory.
type JobProgressHistoryOrderField struct {
	// Value extracts the ordering value from the given JobProgressHistory.
	Value    func(*JobProgressHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) jobprogresshistory.OrderOption
	toCursor func(*JobProgressHistory) Cursor
}

// JobProgressHistoryOrder defines the ordering of JobProgressHistory.
type JobProgressHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *JobProgressHistoryOrderField `json:"field"`
}

// DefaultJobProgressHistoryOrder is the default ordering of JobProgressHistory.
var DefaultJobProgressHistoryOrder = &JobProgressHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &JobProgressHistoryOrderField{
		Value: func(jph *JobProgressHistory) (ent.Value, error) {
			return jph.ID, nil
		},
		column: jobprogresshistory.FieldID,
		toTerm: jobprogresshistory.ByID,
		toCursor: func(jph *JobProgressHistory) Cursor {
			return Cursor{ID: jph.ID}
		},
	},
}

// ToEdge converts JobProgressHistory into JobProgressHistoryEdge.
func (jph *JobProgressHistory) ToEdge(order *JobProgressHistoryOrder) *JobProgressHistoryEdge {
	if order == nil {
		order = DefaultJobProgressHistoryOrder
	}
	return &JobProgressHistoryEdge{
		Node:   jph,
		Cursor: order.Field.toCursor(jph),
	}
}

// NotifySettingEdge is the edge representation of NotifySetting.
type NotifySettingEdge struct {
	Node   *NotifySetting `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// NotifySettingConnection is the connection containing edges to NotifySetting.
type NotifySettingConnection struct {
	Edges      []*NotifySettingEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *NotifySettingConnection) build(nodes []*NotifySetting, pager *notifysettingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *NotifySetting
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *NotifySetting {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *NotifySetting {
			return nodes[i]
		}
	}
	c.Edges = make([]*NotifySettingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NotifySettingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotifySettingPaginateOption enables pagination customization.
type NotifySettingPaginateOption func(*notifysettingPager) error

// WithNotifySettingOrder configures pagination ordering.
func WithNotifySettingOrder(order *NotifySettingOrder) NotifySettingPaginateOption {
	if order == nil {
		order = DefaultNotifySettingOrder
	}
	o := *order
	return func(pager *notifysettingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNotifySettingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNotifySettingFilter configures pagination filter.
func WithNotifySettingFilter(filter func(*NotifySettingQuery) (*NotifySettingQuery, error)) NotifySettingPaginateOption {
	return func(pager *notifysettingPager) error {
		if filter == nil {
			return errors.New("NotifySettingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notifysettingPager struct {
	reverse bool
	order   *NotifySettingOrder
	filter  func(*NotifySettingQuery) (*NotifySettingQuery, error)
}

func newNotifySettingPager(opts []NotifySettingPaginateOption, reverse bool) (*notifysettingPager, error) {
	pager := &notifysettingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNotifySettingOrder
	}
	return pager, nil
}

func (p *notifysettingPager) applyFilter(query *NotifySettingQuery) (*NotifySettingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notifysettingPager) toCursor(ns *NotifySetting) Cursor {
	return p.order.Field.toCursor(ns)
}

func (p *notifysettingPager) applyCursors(query *NotifySettingQuery, after, before *Cursor) (*NotifySettingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNotifySettingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notifysettingPager) applyOrder(query *NotifySettingQuery) *NotifySettingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNotifySettingOrder.Field {
		query = query.Order(DefaultNotifySettingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notifysettingPager) orderExpr(query *NotifySettingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNotifySettingOrder.Field {
			b.Comma().Ident(DefaultNotifySettingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to NotifySetting.
func (ns *NotifySettingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotifySettingPaginateOption,
) (*NotifySettingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotifySettingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ns, err = pager.applyFilter(ns); err != nil {
		return nil, err
	}
	conn := &NotifySettingConnection{Edges: []*NotifySettingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ns.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ns, err = pager.applyCursors(ns, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ns.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ns.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ns = pager.applyOrder(ns)
	nodes, err := ns.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// NotifySettingOrderFieldCreatedAt orders NotifySetting by created_at.
	NotifySettingOrderFieldCreatedAt = &NotifySettingOrderField{
		Value: func(ns *NotifySetting) (ent.Value, error) {
			return ns.CreatedAt, nil
		},
		column: notifysetting.FieldCreatedAt,
		toTerm: notifysetting.ByCreatedAt,
		toCursor: func(ns *NotifySetting) Cursor {
			return Cursor{
				ID:    ns.ID,
				Value: ns.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NotifySettingOrderField) String() string {
	var str string
	switch f.column {
	case NotifySettingOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NotifySettingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NotifySettingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NotifySettingOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *NotifySettingOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid NotifySettingOrderField", str)
	}
	return nil
}

// NotifySettingOrderField defines the ordering field of NotifySetting.
type NotifySettingOrderField struct {
	// Value extracts the ordering value from the given NotifySetting.
	Value    func(*NotifySetting) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notifysetting.OrderOption
	toCursor func(*NotifySetting) Cursor
}

// NotifySettingOrder defines the ordering of NotifySetting.
type NotifySettingOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *NotifySettingOrderField `json:"field"`
}

// DefaultNotifySettingOrder is the default ordering of NotifySetting.
var DefaultNotifySettingOrder = &NotifySettingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NotifySettingOrderField{
		Value: func(ns *NotifySetting) (ent.Value, error) {
			return ns.ID, nil
		},
		column: notifysetting.FieldID,
		toTerm: notifysetting.ByID,
		toCursor: func(ns *NotifySetting) Cursor {
			return Cursor{ID: ns.ID}
		},
	},
}

// ToEdge converts NotifySetting into NotifySettingEdge.
func (ns *NotifySetting) ToEdge(order *NotifySettingOrder) *NotifySettingEdge {
	if order == nil {
		order = DefaultNotifySettingOrder
	}
	return &NotifySettingEdge{
		Node:   ns,
		Cursor: order.Field.toCursor(ns),
	}
}

// OptionListEdge is the edge representation of OptionList.
type OptionListEdge struct {
	Node   *OptionList `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// OptionListConnection is the connection containing edges to OptionList.
type OptionListConnection struct {
	Edges      []*OptionListEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *OptionListConnection) build(nodes []*OptionList, pager *optionlistPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OptionList
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OptionList {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OptionList {
			return nodes[i]
		}
	}
	c.Edges = make([]*OptionListEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OptionListEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OptionListPaginateOption enables pagination customization.
type OptionListPaginateOption func(*optionlistPager) error

// WithOptionListOrder configures pagination ordering.
func WithOptionListOrder(order *OptionListOrder) OptionListPaginateOption {
	if order == nil {
		order = DefaultOptionListOrder
	}
	o := *order
	return func(pager *optionlistPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOptionListOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOptionListFilter configures pagination filter.
func WithOptionListFilter(filter func(*OptionListQuery) (*OptionListQuery, error)) OptionListPaginateOption {
	return func(pager *optionlistPager) error {
		if filter == nil {
			return errors.New("OptionListQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type optionlistPager struct {
	reverse bool
	order   *OptionListOrder
	filter  func(*OptionListQuery) (*OptionListQuery, error)
}

func newOptionListPager(opts []OptionListPaginateOption, reverse bool) (*optionlistPager, error) {
	pager := &optionlistPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOptionListOrder
	}
	return pager, nil
}

func (p *optionlistPager) applyFilter(query *OptionListQuery) (*OptionListQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *optionlistPager) toCursor(ol *OptionList) Cursor {
	return p.order.Field.toCursor(ol)
}

func (p *optionlistPager) applyCursors(query *OptionListQuery, after, before *Cursor) (*OptionListQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOptionListOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *optionlistPager) applyOrder(query *OptionListQuery) *OptionListQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOptionListOrder.Field {
		query = query.Order(DefaultOptionListOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *optionlistPager) orderExpr(query *OptionListQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOptionListOrder.Field {
			b.Comma().Ident(DefaultOptionListOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OptionList.
func (ol *OptionListQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OptionListPaginateOption,
) (*OptionListConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOptionListPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ol, err = pager.applyFilter(ol); err != nil {
		return nil, err
	}
	conn := &OptionListConnection{Edges: []*OptionListEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ol.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ol, err = pager.applyCursors(ol, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ol.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ol.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ol = pager.applyOrder(ol)
	nodes, err := ol.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OptionListOrderFieldCreatedAt orders OptionList by created_at.
	OptionListOrderFieldCreatedAt = &OptionListOrderField{
		Value: func(ol *OptionList) (ent.Value, error) {
			return ol.CreatedAt, nil
		},
		column: optionlist.FieldCreatedAt,
		toTerm: optionlist.ByCreatedAt,
		toCursor: func(ol *OptionList) Cursor {
			return Cursor{
				ID:    ol.ID,
				Value: ol.CreatedAt,
			}
		},
	}
	// OptionListOrderFieldUpdatedAt orders OptionList by updated_at.
	OptionListOrderFieldUpdatedAt = &OptionListOrderField{
		Value: func(ol *OptionList) (ent.Value, error) {
			return ol.UpdatedAt, nil
		},
		column: optionlist.FieldUpdatedAt,
		toTerm: optionlist.ByUpdatedAt,
		toCursor: func(ol *OptionList) Cursor {
			return Cursor{
				ID:    ol.ID,
				Value: ol.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OptionListOrderField) String() string {
	var str string
	switch f.column {
	case OptionListOrderFieldCreatedAt.column:
		str = "CREATED"
	case OptionListOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OptionListOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OptionListOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OptionListOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *OptionListOrderFieldCreatedAt
	case "UPDATED":
		*f = *OptionListOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid OptionListOrderField", str)
	}
	return nil
}

// OptionListOrderField defines the ordering field of OptionList.
type OptionListOrderField struct {
	// Value extracts the ordering value from the given OptionList.
	Value    func(*OptionList) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) optionlist.OrderOption
	toCursor func(*OptionList) Cursor
}

// OptionListOrder defines the ordering of OptionList.
type OptionListOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *OptionListOrderField `json:"field"`
}

// DefaultOptionListOrder is the default ordering of OptionList.
var DefaultOptionListOrder = &OptionListOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OptionListOrderField{
		Value: func(ol *OptionList) (ent.Value, error) {
			return ol.ID, nil
		},
		column: optionlist.FieldID,
		toTerm: optionlist.ByID,
		toCursor: func(ol *OptionList) Cursor {
			return Cursor{ID: ol.ID}
		},
	},
}

// ToEdge converts OptionList into OptionListEdge.
func (ol *OptionList) ToEdge(order *OptionListOrder) *OptionListEdge {
	if order == nil {
		order = DefaultOptionListOrder
	}
	return &OptionListEdge{
		Node:   ol,
		Cursor: order.Field.toCursor(ol),
	}
}

// PartnerEdge is the edge representation of Partner.
type PartnerEdge struct {
	Node   *Partner `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// PartnerConnection is the connection containing edges to Partner.
type PartnerConnection struct {
	Edges      []*PartnerEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *PartnerConnection) build(nodes []*Partner, pager *partnerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Partner
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Partner {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Partner {
			return nodes[i]
		}
	}
	c.Edges = make([]*PartnerEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PartnerEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PartnerPaginateOption enables pagination customization.
type PartnerPaginateOption func(*partnerPager) error

// WithPartnerOrder configures pagination ordering.
func WithPartnerOrder(order *PartnerOrder) PartnerPaginateOption {
	if order == nil {
		order = DefaultPartnerOrder
	}
	o := *order
	return func(pager *partnerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPartnerOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPartnerFilter configures pagination filter.
func WithPartnerFilter(filter func(*PartnerQuery) (*PartnerQuery, error)) PartnerPaginateOption {
	return func(pager *partnerPager) error {
		if filter == nil {
			return errors.New("PartnerQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type partnerPager struct {
	reverse bool
	order   *PartnerOrder
	filter  func(*PartnerQuery) (*PartnerQuery, error)
}

func newPartnerPager(opts []PartnerPaginateOption, reverse bool) (*partnerPager, error) {
	pager := &partnerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPartnerOrder
	}
	return pager, nil
}

func (p *partnerPager) applyFilter(query *PartnerQuery) (*PartnerQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *partnerPager) toCursor(pa *Partner) Cursor {
	return p.order.Field.toCursor(pa)
}

func (p *partnerPager) applyCursors(query *PartnerQuery, after, before *Cursor) (*PartnerQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPartnerOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *partnerPager) applyOrder(query *PartnerQuery) *PartnerQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPartnerOrder.Field {
		query = query.Order(DefaultPartnerOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *partnerPager) orderExpr(query *PartnerQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPartnerOrder.Field {
			b.Comma().Ident(DefaultPartnerOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Partner.
func (pa *PartnerQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PartnerPaginateOption,
) (*PartnerConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPartnerPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &PartnerConnection{Edges: []*PartnerEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pa.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pa, err = pager.applyCursors(pa, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pa = pager.applyOrder(pa)
	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PartnerOrderFieldCreatedAt orders Partner by created_at.
	PartnerOrderFieldCreatedAt = &PartnerOrderField{
		Value: func(pa *Partner) (ent.Value, error) {
			return pa.CreatedAt, nil
		},
		column: partner.FieldCreatedAt,
		toTerm: partner.ByCreatedAt,
		toCursor: func(pa *Partner) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.CreatedAt,
			}
		},
	}
	// PartnerOrderFieldUpdatedAt orders Partner by updated_at.
	PartnerOrderFieldUpdatedAt = &PartnerOrderField{
		Value: func(pa *Partner) (ent.Value, error) {
			return pa.UpdatedAt, nil
		},
		column: partner.FieldUpdatedAt,
		toTerm: partner.ByUpdatedAt,
		toCursor: func(pa *Partner) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.UpdatedAt,
			}
		},
	}
	// PartnerOrderFieldName orders Partner by name.
	PartnerOrderFieldName = &PartnerOrderField{
		Value: func(pa *Partner) (ent.Value, error) {
			return pa.Name, nil
		},
		column: partner.FieldName,
		toTerm: partner.ByName,
		toCursor: func(pa *Partner) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PartnerOrderField) String() string {
	var str string
	switch f.column {
	case PartnerOrderFieldCreatedAt.column:
		str = "CREATED"
	case PartnerOrderFieldUpdatedAt.column:
		str = "UPDATED"
	case PartnerOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PartnerOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PartnerOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PartnerOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *PartnerOrderFieldCreatedAt
	case "UPDATED":
		*f = *PartnerOrderFieldUpdatedAt
	case "NAME":
		*f = *PartnerOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid PartnerOrderField", str)
	}
	return nil
}

// PartnerOrderField defines the ordering field of Partner.
type PartnerOrderField struct {
	// Value extracts the ordering value from the given Partner.
	Value    func(*Partner) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) partner.OrderOption
	toCursor func(*Partner) Cursor
}

// PartnerOrder defines the ordering of Partner.
type PartnerOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *PartnerOrderField `json:"field"`
}

// DefaultPartnerOrder is the default ordering of Partner.
var DefaultPartnerOrder = &PartnerOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PartnerOrderField{
		Value: func(pa *Partner) (ent.Value, error) {
			return pa.ID, nil
		},
		column: partner.FieldID,
		toTerm: partner.ByID,
		toCursor: func(pa *Partner) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts Partner into PartnerEdge.
func (pa *Partner) ToEdge(order *PartnerOrder) *PartnerEdge {
	if order == nil {
		order = DefaultPartnerOrder
	}
	return &PartnerEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// PartnerActivityEdge is the edge representation of PartnerActivity.
type PartnerActivityEdge struct {
	Node   *PartnerActivity `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// PartnerActivityConnection is the connection containing edges to PartnerActivity.
type PartnerActivityConnection struct {
	Edges      []*PartnerActivityEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *PartnerActivityConnection) build(nodes []*PartnerActivity, pager *partneractivityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PartnerActivity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PartnerActivity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PartnerActivity {
			return nodes[i]
		}
	}
	c.Edges = make([]*PartnerActivityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PartnerActivityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PartnerActivityPaginateOption enables pagination customization.
type PartnerActivityPaginateOption func(*partneractivityPager) error

// WithPartnerActivityOrder configures pagination ordering.
func WithPartnerActivityOrder(order *PartnerActivityOrder) PartnerActivityPaginateOption {
	if order == nil {
		order = DefaultPartnerActivityOrder
	}
	o := *order
	return func(pager *partneractivityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPartnerActivityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPartnerActivityFilter configures pagination filter.
func WithPartnerActivityFilter(filter func(*PartnerActivityQuery) (*PartnerActivityQuery, error)) PartnerActivityPaginateOption {
	return func(pager *partneractivityPager) error {
		if filter == nil {
			return errors.New("PartnerActivityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type partneractivityPager struct {
	reverse bool
	order   *PartnerActivityOrder
	filter  func(*PartnerActivityQuery) (*PartnerActivityQuery, error)
}

func newPartnerActivityPager(opts []PartnerActivityPaginateOption, reverse bool) (*partneractivityPager, error) {
	pager := &partneractivityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPartnerActivityOrder
	}
	return pager, nil
}

func (p *partneractivityPager) applyFilter(query *PartnerActivityQuery) (*PartnerActivityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *partneractivityPager) toCursor(pa *PartnerActivity) Cursor {
	return p.order.Field.toCursor(pa)
}

func (p *partneractivityPager) applyCursors(query *PartnerActivityQuery, after, before *Cursor) (*PartnerActivityQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPartnerActivityOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *partneractivityPager) applyOrder(query *PartnerActivityQuery) *PartnerActivityQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPartnerActivityOrder.Field {
		query = query.Order(DefaultPartnerActivityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *partneractivityPager) orderExpr(query *PartnerActivityQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPartnerActivityOrder.Field {
			b.Comma().Ident(DefaultPartnerActivityOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PartnerActivity.
func (pa *PartnerActivityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PartnerActivityPaginateOption,
) (*PartnerActivityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPartnerActivityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &PartnerActivityConnection{Edges: []*PartnerActivityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pa.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pa, err = pager.applyCursors(pa, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pa = pager.applyOrder(pa)
	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PartnerActivityOrderFieldCreatedAt orders PartnerActivity by created_at.
	PartnerActivityOrderFieldCreatedAt = &PartnerActivityOrderField{
		Value: func(pa *PartnerActivity) (ent.Value, error) {
			return pa.CreatedAt, nil
		},
		column: partneractivity.FieldCreatedAt,
		toTerm: partneractivity.ByCreatedAt,
		toCursor: func(pa *PartnerActivity) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PartnerActivityOrderField) String() string {
	var str string
	switch f.column {
	case PartnerActivityOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PartnerActivityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PartnerActivityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PartnerActivityOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *PartnerActivityOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid PartnerActivityOrderField", str)
	}
	return nil
}

// PartnerActivityOrderField defines the ordering field of PartnerActivity.
type PartnerActivityOrderField struct {
	// Value extracts the ordering value from the given PartnerActivity.
	Value    func(*PartnerActivity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) partneractivity.OrderOption
	toCursor func(*PartnerActivity) Cursor
}

// PartnerActivityOrder defines the ordering of PartnerActivity.
type PartnerActivityOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *PartnerActivityOrderField `json:"field"`
}

// DefaultPartnerActivityOrder is the default ordering of PartnerActivity.
var DefaultPartnerActivityOrder = &PartnerActivityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PartnerActivityOrderField{
		Value: func(pa *PartnerActivity) (ent.Value, error) {
			return pa.ID, nil
		},
		column: partneractivity.FieldID,
		toTerm: partneractivity.ByID,
		toCursor: func(pa *PartnerActivity) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts PartnerActivity into PartnerActivityEdge.
func (pa *PartnerActivity) ToEdge(order *PartnerActivityOrder) *PartnerActivityEdge {
	if order == nil {
		order = DefaultPartnerActivityOrder
	}
	return &PartnerActivityEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// PartnerContactEdge is the edge representation of PartnerContact.
type PartnerContactEdge struct {
	Node   *PartnerContact `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// PartnerContactConnection is the connection containing edges to PartnerContact.
type PartnerContactConnection struct {
	Edges      []*PartnerContactEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *PartnerContactConnection) build(nodes []*PartnerContact, pager *partnercontactPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PartnerContact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PartnerContact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PartnerContact {
			return nodes[i]
		}
	}
	c.Edges = make([]*PartnerContactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PartnerContactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PartnerContactPaginateOption enables pagination customization.
type PartnerContactPaginateOption func(*partnercontactPager) error

// WithPartnerContactOrder configures pagination ordering.
func WithPartnerContactOrder(order *PartnerContactOrder) PartnerContactPaginateOption {
	if order == nil {
		order = DefaultPartnerContactOrder
	}
	o := *order
	return func(pager *partnercontactPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPartnerContactOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPartnerContactFilter configures pagination filter.
func WithPartnerContactFilter(filter func(*PartnerContactQuery) (*PartnerContactQuery, error)) PartnerContactPaginateOption {
	return func(pager *partnercontactPager) error {
		if filter == nil {
			return errors.New("PartnerContactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type partnercontactPager struct {
	reverse bool
	order   *PartnerContactOrder
	filter  func(*PartnerContactQuery) (*PartnerContactQuery, error)
}

func newPartnerContactPager(opts []PartnerContactPaginateOption, reverse bool) (*partnercontactPager, error) {
	pager := &partnercontactPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPartnerContactOrder
	}
	return pager, nil
}

func (p *partnercontactPager) applyFilter(query *PartnerContactQuery) (*PartnerContactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *partnercontactPager) toCursor(pc *PartnerContact) Cursor {
	return p.order.Field.toCursor(pc)
}

func (p *partnercontactPager) applyCursors(query *PartnerContactQuery, after, before *Cursor) (*PartnerContactQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPartnerContactOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *partnercontactPager) applyOrder(query *PartnerContactQuery) *PartnerContactQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPartnerContactOrder.Field {
		query = query.Order(DefaultPartnerContactOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *partnercontactPager) orderExpr(query *PartnerContactQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPartnerContactOrder.Field {
			b.Comma().Ident(DefaultPartnerContactOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PartnerContact.
func (pc *PartnerContactQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PartnerContactPaginateOption,
) (*PartnerContactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPartnerContactPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pc, err = pager.applyFilter(pc); err != nil {
		return nil, err
	}
	conn := &PartnerContactConnection{Edges: []*PartnerContactEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pc, err = pager.applyCursors(pc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pc = pager.applyOrder(pc)
	nodes, err := pc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PartnerContactOrderFieldCreatedAt orders PartnerContact by created_at.
	PartnerContactOrderFieldCreatedAt = &PartnerContactOrderField{
		Value: func(pc *PartnerContact) (ent.Value, error) {
			return pc.CreatedAt, nil
		},
		column: partnercontact.FieldCreatedAt,
		toTerm: partnercontact.ByCreatedAt,
		toCursor: func(pc *PartnerContact) Cursor {
			return Cursor{
				ID:    pc.ID,
				Value: pc.CreatedAt,
			}
		},
	}
	// PartnerContactOrderFieldUpdatedAt orders PartnerContact by updated_at.
	PartnerContactOrderFieldUpdatedAt = &PartnerContactOrderField{
		Value: func(pc *PartnerContact) (ent.Value, error) {
			return pc.UpdatedAt, nil
		},
		column: partnercontact.FieldUpdatedAt,
		toTerm: partnercontact.ByUpdatedAt,
		toCursor: func(pc *PartnerContact) Cursor {
			return Cursor{
				ID:    pc.ID,
				Value: pc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PartnerContactOrderField) String() string {
	var str string
	switch f.column {
	case PartnerContactOrderFieldCreatedAt.column:
		str = "CREATED"
	case PartnerContactOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PartnerContactOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PartnerContactOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PartnerContactOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *PartnerContactOrderFieldCreatedAt
	case "UPDATED":
		*f = *PartnerContactOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PartnerContactOrderField", str)
	}
	return nil
}

// PartnerContactOrderField defines the ordering field of PartnerContact.
type PartnerContactOrderField struct {
	// Value extracts the ordering value from the given PartnerContact.
	Value    func(*PartnerContact) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) partnercontact.OrderOption
	toCursor func(*PartnerContact) Cursor
}

// PartnerContactOrder defines the ordering of PartnerContact.
type PartnerContactOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *PartnerContactOrderField `json:"field"`
}

// DefaultPartnerContactOrder is the default ordering of PartnerContact.
var DefaultPartnerContactOrder = &PartnerContactOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PartnerContactOrderField{
		Value: func(pc *PartnerContact) (ent.Value, error) {
			return pc.ID, nil
		},
		column: partnercontact.FieldID,
		toTerm: partnercontact.ByID,
		toCursor: func(pc *PartnerContact) Cursor {
			return Cursor{ID: pc.ID}
		},
	},
}

// ToEdge converts PartnerContact into PartnerContactEdge.
func (pc *PartnerContact) ToEdge(order *PartnerContactOrder) *PartnerContactEdge {
	if order == nil {
		order = DefaultPartnerContactOrder
	}
	return &PartnerContactEdge{
		Node:   pc,
		Cursor: order.Field.toCursor(pc),
	}
}

// PartnerServiceEdge is the edge representation of PartnerService.
type PartnerServiceEdge struct {
	Node   *PartnerService `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// PartnerServiceConnection is the connection containing edges to PartnerService.
type PartnerServiceConnection struct {
	Edges      []*PartnerServiceEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *PartnerServiceConnection) build(nodes []*PartnerService, pager *partnerservicePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PartnerService
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PartnerService {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PartnerService {
			return nodes[i]
		}
	}
	c.Edges = make([]*PartnerServiceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PartnerServiceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PartnerServicePaginateOption enables pagination customization.
type PartnerServicePaginateOption func(*partnerservicePager) error

// WithPartnerServiceOrder configures pagination ordering.
func WithPartnerServiceOrder(order *PartnerServiceOrder) PartnerServicePaginateOption {
	if order == nil {
		order = DefaultPartnerServiceOrder
	}
	o := *order
	return func(pager *partnerservicePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPartnerServiceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPartnerServiceFilter configures pagination filter.
func WithPartnerServiceFilter(filter func(*PartnerServiceQuery) (*PartnerServiceQuery, error)) PartnerServicePaginateOption {
	return func(pager *partnerservicePager) error {
		if filter == nil {
			return errors.New("PartnerServiceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type partnerservicePager struct {
	reverse bool
	order   *PartnerServiceOrder
	filter  func(*PartnerServiceQuery) (*PartnerServiceQuery, error)
}

func newPartnerServicePager(opts []PartnerServicePaginateOption, reverse bool) (*partnerservicePager, error) {
	pager := &partnerservicePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPartnerServiceOrder
	}
	return pager, nil
}

func (p *partnerservicePager) applyFilter(query *PartnerServiceQuery) (*PartnerServiceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *partnerservicePager) toCursor(ps *PartnerService) Cursor {
	return p.order.Field.toCursor(ps)
}

func (p *partnerservicePager) applyCursors(query *PartnerServiceQuery, after, before *Cursor) (*PartnerServiceQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPartnerServiceOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *partnerservicePager) applyOrder(query *PartnerServiceQuery) *PartnerServiceQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPartnerServiceOrder.Field {
		query = query.Order(DefaultPartnerServiceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *partnerservicePager) orderExpr(query *PartnerServiceQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPartnerServiceOrder.Field {
			b.Comma().Ident(DefaultPartnerServiceOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PartnerService.
func (ps *PartnerServiceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PartnerServicePaginateOption,
) (*PartnerServiceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPartnerServicePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ps, err = pager.applyFilter(ps); err != nil {
		return nil, err
	}
	conn := &PartnerServiceConnection{Edges: []*PartnerServiceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ps.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ps, err = pager.applyCursors(ps, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ps.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ps.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ps = pager.applyOrder(ps)
	nodes, err := ps.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PartnerServiceOrderFieldCreatedAt orders PartnerService by created_at.
	PartnerServiceOrderFieldCreatedAt = &PartnerServiceOrderField{
		Value: func(ps *PartnerService) (ent.Value, error) {
			return ps.CreatedAt, nil
		},
		column: partnerservice.FieldCreatedAt,
		toTerm: partnerservice.ByCreatedAt,
		toCursor: func(ps *PartnerService) Cursor {
			return Cursor{
				ID:    ps.ID,
				Value: ps.CreatedAt,
			}
		},
	}
	// PartnerServiceOrderFieldUpdatedAt orders PartnerService by updated_at.
	PartnerServiceOrderFieldUpdatedAt = &PartnerServiceOrderField{
		Value: func(ps *PartnerService) (ent.Value, error) {
			return ps.UpdatedAt, nil
		},
		column: partnerservice.FieldUpdatedAt,
		toTerm: partnerservice.ByUpdatedAt,
		toCursor: func(ps *PartnerService) Cursor {
			return Cursor{
				ID:    ps.ID,
				Value: ps.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PartnerServiceOrderField) String() string {
	var str string
	switch f.column {
	case PartnerServiceOrderFieldCreatedAt.column:
		str = "CREATED"
	case PartnerServiceOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PartnerServiceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PartnerServiceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PartnerServiceOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *PartnerServiceOrderFieldCreatedAt
	case "UPDATED":
		*f = *PartnerServiceOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PartnerServiceOrderField", str)
	}
	return nil
}

// PartnerServiceOrderField defines the ordering field of PartnerService.
type PartnerServiceOrderField struct {
	// Value extracts the ordering value from the given PartnerService.
	Value    func(*PartnerService) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) partnerservice.OrderOption
	toCursor func(*PartnerService) Cursor
}

// PartnerServiceOrder defines the ordering of PartnerService.
type PartnerServiceOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *PartnerServiceOrderField `json:"field"`
}

// DefaultPartnerServiceOrder is the default ordering of PartnerService.
var DefaultPartnerServiceOrder = &PartnerServiceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PartnerServiceOrderField{
		Value: func(ps *PartnerService) (ent.Value, error) {
			return ps.ID, nil
		},
		column: partnerservice.FieldID,
		toTerm: partnerservice.ByID,
		toCursor: func(ps *PartnerService) Cursor {
			return Cursor{ID: ps.ID}
		},
	},
}

// ToEdge converts PartnerService into PartnerServiceEdge.
func (ps *PartnerService) ToEdge(order *PartnerServiceOrder) *PartnerServiceEdge {
	if order == nil {
		order = DefaultPartnerServiceOrder
	}
	return &PartnerServiceEdge{
		Node:   ps,
		Cursor: order.Field.toCursor(ps),
	}
}

// PartnerServiceCityEdge is the edge representation of PartnerServiceCity.
type PartnerServiceCityEdge struct {
	Node   *PartnerServiceCity `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// PartnerServiceCityConnection is the connection containing edges to PartnerServiceCity.
type PartnerServiceCityConnection struct {
	Edges      []*PartnerServiceCityEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *PartnerServiceCityConnection) build(nodes []*PartnerServiceCity, pager *partnerservicecityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PartnerServiceCity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PartnerServiceCity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PartnerServiceCity {
			return nodes[i]
		}
	}
	c.Edges = make([]*PartnerServiceCityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PartnerServiceCityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PartnerServiceCityPaginateOption enables pagination customization.
type PartnerServiceCityPaginateOption func(*partnerservicecityPager) error

// WithPartnerServiceCityOrder configures pagination ordering.
func WithPartnerServiceCityOrder(order *PartnerServiceCityOrder) PartnerServiceCityPaginateOption {
	if order == nil {
		order = DefaultPartnerServiceCityOrder
	}
	o := *order
	return func(pager *partnerservicecityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPartnerServiceCityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPartnerServiceCityFilter configures pagination filter.
func WithPartnerServiceCityFilter(filter func(*PartnerServiceCityQuery) (*PartnerServiceCityQuery, error)) PartnerServiceCityPaginateOption {
	return func(pager *partnerservicecityPager) error {
		if filter == nil {
			return errors.New("PartnerServiceCityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type partnerservicecityPager struct {
	reverse bool
	order   *PartnerServiceCityOrder
	filter  func(*PartnerServiceCityQuery) (*PartnerServiceCityQuery, error)
}

func newPartnerServiceCityPager(opts []PartnerServiceCityPaginateOption, reverse bool) (*partnerservicecityPager, error) {
	pager := &partnerservicecityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPartnerServiceCityOrder
	}
	return pager, nil
}

func (p *partnerservicecityPager) applyFilter(query *PartnerServiceCityQuery) (*PartnerServiceCityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *partnerservicecityPager) toCursor(psc *PartnerServiceCity) Cursor {
	return p.order.Field.toCursor(psc)
}

func (p *partnerservicecityPager) applyCursors(query *PartnerServiceCityQuery, after, before *Cursor) (*PartnerServiceCityQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPartnerServiceCityOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *partnerservicecityPager) applyOrder(query *PartnerServiceCityQuery) *PartnerServiceCityQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPartnerServiceCityOrder.Field {
		query = query.Order(DefaultPartnerServiceCityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *partnerservicecityPager) orderExpr(query *PartnerServiceCityQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPartnerServiceCityOrder.Field {
			b.Comma().Ident(DefaultPartnerServiceCityOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PartnerServiceCity.
func (psc *PartnerServiceCityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PartnerServiceCityPaginateOption,
) (*PartnerServiceCityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPartnerServiceCityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if psc, err = pager.applyFilter(psc); err != nil {
		return nil, err
	}
	conn := &PartnerServiceCityConnection{Edges: []*PartnerServiceCityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = psc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if psc, err = pager.applyCursors(psc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		psc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := psc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	psc = pager.applyOrder(psc)
	nodes, err := psc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PartnerServiceCityOrderFieldCreatedAt orders PartnerServiceCity by created_at.
	PartnerServiceCityOrderFieldCreatedAt = &PartnerServiceCityOrderField{
		Value: func(psc *PartnerServiceCity) (ent.Value, error) {
			return psc.CreatedAt, nil
		},
		column: partnerservicecity.FieldCreatedAt,
		toTerm: partnerservicecity.ByCreatedAt,
		toCursor: func(psc *PartnerServiceCity) Cursor {
			return Cursor{
				ID:    psc.ID,
				Value: psc.CreatedAt,
			}
		},
	}
	// PartnerServiceCityOrderFieldUpdatedAt orders PartnerServiceCity by updated_at.
	PartnerServiceCityOrderFieldUpdatedAt = &PartnerServiceCityOrderField{
		Value: func(psc *PartnerServiceCity) (ent.Value, error) {
			return psc.UpdatedAt, nil
		},
		column: partnerservicecity.FieldUpdatedAt,
		toTerm: partnerservicecity.ByUpdatedAt,
		toCursor: func(psc *PartnerServiceCity) Cursor {
			return Cursor{
				ID:    psc.ID,
				Value: psc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PartnerServiceCityOrderField) String() string {
	var str string
	switch f.column {
	case PartnerServiceCityOrderFieldCreatedAt.column:
		str = "CREATED"
	case PartnerServiceCityOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PartnerServiceCityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PartnerServiceCityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PartnerServiceCityOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *PartnerServiceCityOrderFieldCreatedAt
	case "UPDATED":
		*f = *PartnerServiceCityOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PartnerServiceCityOrderField", str)
	}
	return nil
}

// PartnerServiceCityOrderField defines the ordering field of PartnerServiceCity.
type PartnerServiceCityOrderField struct {
	// Value extracts the ordering value from the given PartnerServiceCity.
	Value    func(*PartnerServiceCity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) partnerservicecity.OrderOption
	toCursor func(*PartnerServiceCity) Cursor
}

// PartnerServiceCityOrder defines the ordering of PartnerServiceCity.
type PartnerServiceCityOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *PartnerServiceCityOrderField `json:"field"`
}

// DefaultPartnerServiceCityOrder is the default ordering of PartnerServiceCity.
var DefaultPartnerServiceCityOrder = &PartnerServiceCityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PartnerServiceCityOrderField{
		Value: func(psc *PartnerServiceCity) (ent.Value, error) {
			return psc.ID, nil
		},
		column: partnerservicecity.FieldID,
		toTerm: partnerservicecity.ByID,
		toCursor: func(psc *PartnerServiceCity) Cursor {
			return Cursor{ID: psc.ID}
		},
	},
}

// ToEdge converts PartnerServiceCity into PartnerServiceCityEdge.
func (psc *PartnerServiceCity) ToEdge(order *PartnerServiceCityOrder) *PartnerServiceCityEdge {
	if order == nil {
		order = DefaultPartnerServiceCityOrder
	}
	return &PartnerServiceCityEdge{
		Node:   psc,
		Cursor: order.Field.toCursor(psc),
	}
}

// PartnerServiceStateEdge is the edge representation of PartnerServiceState.
type PartnerServiceStateEdge struct {
	Node   *PartnerServiceState `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// PartnerServiceStateConnection is the connection containing edges to PartnerServiceState.
type PartnerServiceStateConnection struct {
	Edges      []*PartnerServiceStateEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *PartnerServiceStateConnection) build(nodes []*PartnerServiceState, pager *partnerservicestatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PartnerServiceState
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PartnerServiceState {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PartnerServiceState {
			return nodes[i]
		}
	}
	c.Edges = make([]*PartnerServiceStateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PartnerServiceStateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PartnerServiceStatePaginateOption enables pagination customization.
type PartnerServiceStatePaginateOption func(*partnerservicestatePager) error

// WithPartnerServiceStateOrder configures pagination ordering.
func WithPartnerServiceStateOrder(order *PartnerServiceStateOrder) PartnerServiceStatePaginateOption {
	if order == nil {
		order = DefaultPartnerServiceStateOrder
	}
	o := *order
	return func(pager *partnerservicestatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPartnerServiceStateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPartnerServiceStateFilter configures pagination filter.
func WithPartnerServiceStateFilter(filter func(*PartnerServiceStateQuery) (*PartnerServiceStateQuery, error)) PartnerServiceStatePaginateOption {
	return func(pager *partnerservicestatePager) error {
		if filter == nil {
			return errors.New("PartnerServiceStateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type partnerservicestatePager struct {
	reverse bool
	order   *PartnerServiceStateOrder
	filter  func(*PartnerServiceStateQuery) (*PartnerServiceStateQuery, error)
}

func newPartnerServiceStatePager(opts []PartnerServiceStatePaginateOption, reverse bool) (*partnerservicestatePager, error) {
	pager := &partnerservicestatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPartnerServiceStateOrder
	}
	return pager, nil
}

func (p *partnerservicestatePager) applyFilter(query *PartnerServiceStateQuery) (*PartnerServiceStateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *partnerservicestatePager) toCursor(pss *PartnerServiceState) Cursor {
	return p.order.Field.toCursor(pss)
}

func (p *partnerservicestatePager) applyCursors(query *PartnerServiceStateQuery, after, before *Cursor) (*PartnerServiceStateQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPartnerServiceStateOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *partnerservicestatePager) applyOrder(query *PartnerServiceStateQuery) *PartnerServiceStateQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPartnerServiceStateOrder.Field {
		query = query.Order(DefaultPartnerServiceStateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *partnerservicestatePager) orderExpr(query *PartnerServiceStateQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPartnerServiceStateOrder.Field {
			b.Comma().Ident(DefaultPartnerServiceStateOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PartnerServiceState.
func (pss *PartnerServiceStateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PartnerServiceStatePaginateOption,
) (*PartnerServiceStateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPartnerServiceStatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pss, err = pager.applyFilter(pss); err != nil {
		return nil, err
	}
	conn := &PartnerServiceStateConnection{Edges: []*PartnerServiceStateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pss.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pss, err = pager.applyCursors(pss, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pss.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pss.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pss = pager.applyOrder(pss)
	nodes, err := pss.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PartnerServiceStateOrderFieldCreatedAt orders PartnerServiceState by created_at.
	PartnerServiceStateOrderFieldCreatedAt = &PartnerServiceStateOrderField{
		Value: func(pss *PartnerServiceState) (ent.Value, error) {
			return pss.CreatedAt, nil
		},
		column: partnerservicestate.FieldCreatedAt,
		toTerm: partnerservicestate.ByCreatedAt,
		toCursor: func(pss *PartnerServiceState) Cursor {
			return Cursor{
				ID:    pss.ID,
				Value: pss.CreatedAt,
			}
		},
	}
	// PartnerServiceStateOrderFieldUpdatedAt orders PartnerServiceState by updated_at.
	PartnerServiceStateOrderFieldUpdatedAt = &PartnerServiceStateOrderField{
		Value: func(pss *PartnerServiceState) (ent.Value, error) {
			return pss.UpdatedAt, nil
		},
		column: partnerservicestate.FieldUpdatedAt,
		toTerm: partnerservicestate.ByUpdatedAt,
		toCursor: func(pss *PartnerServiceState) Cursor {
			return Cursor{
				ID:    pss.ID,
				Value: pss.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PartnerServiceStateOrderField) String() string {
	var str string
	switch f.column {
	case PartnerServiceStateOrderFieldCreatedAt.column:
		str = "CREATED"
	case PartnerServiceStateOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PartnerServiceStateOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PartnerServiceStateOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PartnerServiceStateOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *PartnerServiceStateOrderFieldCreatedAt
	case "UPDATED":
		*f = *PartnerServiceStateOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PartnerServiceStateOrderField", str)
	}
	return nil
}

// PartnerServiceStateOrderField defines the ordering field of PartnerServiceState.
type PartnerServiceStateOrderField struct {
	// Value extracts the ordering value from the given PartnerServiceState.
	Value    func(*PartnerServiceState) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) partnerservicestate.OrderOption
	toCursor func(*PartnerServiceState) Cursor
}

// PartnerServiceStateOrder defines the ordering of PartnerServiceState.
type PartnerServiceStateOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *PartnerServiceStateOrderField `json:"field"`
}

// DefaultPartnerServiceStateOrder is the default ordering of PartnerServiceState.
var DefaultPartnerServiceStateOrder = &PartnerServiceStateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PartnerServiceStateOrderField{
		Value: func(pss *PartnerServiceState) (ent.Value, error) {
			return pss.ID, nil
		},
		column: partnerservicestate.FieldID,
		toTerm: partnerservicestate.ByID,
		toCursor: func(pss *PartnerServiceState) Cursor {
			return Cursor{ID: pss.ID}
		},
	},
}

// ToEdge converts PartnerServiceState into PartnerServiceStateEdge.
func (pss *PartnerServiceState) ToEdge(order *PartnerServiceStateOrder) *PartnerServiceStateEdge {
	if order == nil {
		order = DefaultPartnerServiceStateOrder
	}
	return &PartnerServiceStateEdge{
		Node:   pss,
		Cursor: order.Field.toCursor(pss),
	}
}

// PartnerTrainingVideoEdge is the edge representation of PartnerTrainingVideo.
type PartnerTrainingVideoEdge struct {
	Node   *PartnerTrainingVideo `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// PartnerTrainingVideoConnection is the connection containing edges to PartnerTrainingVideo.
type PartnerTrainingVideoConnection struct {
	Edges      []*PartnerTrainingVideoEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *PartnerTrainingVideoConnection) build(nodes []*PartnerTrainingVideo, pager *partnertrainingvideoPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PartnerTrainingVideo
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PartnerTrainingVideo {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PartnerTrainingVideo {
			return nodes[i]
		}
	}
	c.Edges = make([]*PartnerTrainingVideoEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PartnerTrainingVideoEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PartnerTrainingVideoPaginateOption enables pagination customization.
type PartnerTrainingVideoPaginateOption func(*partnertrainingvideoPager) error

// WithPartnerTrainingVideoOrder configures pagination ordering.
func WithPartnerTrainingVideoOrder(order *PartnerTrainingVideoOrder) PartnerTrainingVideoPaginateOption {
	if order == nil {
		order = DefaultPartnerTrainingVideoOrder
	}
	o := *order
	return func(pager *partnertrainingvideoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPartnerTrainingVideoOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPartnerTrainingVideoFilter configures pagination filter.
func WithPartnerTrainingVideoFilter(filter func(*PartnerTrainingVideoQuery) (*PartnerTrainingVideoQuery, error)) PartnerTrainingVideoPaginateOption {
	return func(pager *partnertrainingvideoPager) error {
		if filter == nil {
			return errors.New("PartnerTrainingVideoQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type partnertrainingvideoPager struct {
	reverse bool
	order   *PartnerTrainingVideoOrder
	filter  func(*PartnerTrainingVideoQuery) (*PartnerTrainingVideoQuery, error)
}

func newPartnerTrainingVideoPager(opts []PartnerTrainingVideoPaginateOption, reverse bool) (*partnertrainingvideoPager, error) {
	pager := &partnertrainingvideoPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPartnerTrainingVideoOrder
	}
	return pager, nil
}

func (p *partnertrainingvideoPager) applyFilter(query *PartnerTrainingVideoQuery) (*PartnerTrainingVideoQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *partnertrainingvideoPager) toCursor(ptv *PartnerTrainingVideo) Cursor {
	return p.order.Field.toCursor(ptv)
}

func (p *partnertrainingvideoPager) applyCursors(query *PartnerTrainingVideoQuery, after, before *Cursor) (*PartnerTrainingVideoQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPartnerTrainingVideoOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *partnertrainingvideoPager) applyOrder(query *PartnerTrainingVideoQuery) *PartnerTrainingVideoQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPartnerTrainingVideoOrder.Field {
		query = query.Order(DefaultPartnerTrainingVideoOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *partnertrainingvideoPager) orderExpr(query *PartnerTrainingVideoQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPartnerTrainingVideoOrder.Field {
			b.Comma().Ident(DefaultPartnerTrainingVideoOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PartnerTrainingVideo.
func (ptv *PartnerTrainingVideoQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PartnerTrainingVideoPaginateOption,
) (*PartnerTrainingVideoConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPartnerTrainingVideoPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ptv, err = pager.applyFilter(ptv); err != nil {
		return nil, err
	}
	conn := &PartnerTrainingVideoConnection{Edges: []*PartnerTrainingVideoEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ptv.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ptv, err = pager.applyCursors(ptv, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ptv.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ptv.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ptv = pager.applyOrder(ptv)
	nodes, err := ptv.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PartnerTrainingVideoOrderFieldCreatedAt orders PartnerTrainingVideo by created_at.
	PartnerTrainingVideoOrderFieldCreatedAt = &PartnerTrainingVideoOrderField{
		Value: func(ptv *PartnerTrainingVideo) (ent.Value, error) {
			return ptv.CreatedAt, nil
		},
		column: partnertrainingvideo.FieldCreatedAt,
		toTerm: partnertrainingvideo.ByCreatedAt,
		toCursor: func(ptv *PartnerTrainingVideo) Cursor {
			return Cursor{
				ID:    ptv.ID,
				Value: ptv.CreatedAt,
			}
		},
	}
	// PartnerTrainingVideoOrderFieldUpdatedAt orders PartnerTrainingVideo by updated_at.
	PartnerTrainingVideoOrderFieldUpdatedAt = &PartnerTrainingVideoOrderField{
		Value: func(ptv *PartnerTrainingVideo) (ent.Value, error) {
			return ptv.UpdatedAt, nil
		},
		column: partnertrainingvideo.FieldUpdatedAt,
		toTerm: partnertrainingvideo.ByUpdatedAt,
		toCursor: func(ptv *PartnerTrainingVideo) Cursor {
			return Cursor{
				ID:    ptv.ID,
				Value: ptv.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PartnerTrainingVideoOrderField) String() string {
	var str string
	switch f.column {
	case PartnerTrainingVideoOrderFieldCreatedAt.column:
		str = "CREATED"
	case PartnerTrainingVideoOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PartnerTrainingVideoOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PartnerTrainingVideoOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PartnerTrainingVideoOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *PartnerTrainingVideoOrderFieldCreatedAt
	case "UPDATED":
		*f = *PartnerTrainingVideoOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PartnerTrainingVideoOrderField", str)
	}
	return nil
}

// PartnerTrainingVideoOrderField defines the ordering field of PartnerTrainingVideo.
type PartnerTrainingVideoOrderField struct {
	// Value extracts the ordering value from the given PartnerTrainingVideo.
	Value    func(*PartnerTrainingVideo) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) partnertrainingvideo.OrderOption
	toCursor func(*PartnerTrainingVideo) Cursor
}

// PartnerTrainingVideoOrder defines the ordering of PartnerTrainingVideo.
type PartnerTrainingVideoOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *PartnerTrainingVideoOrderField `json:"field"`
}

// DefaultPartnerTrainingVideoOrder is the default ordering of PartnerTrainingVideo.
var DefaultPartnerTrainingVideoOrder = &PartnerTrainingVideoOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PartnerTrainingVideoOrderField{
		Value: func(ptv *PartnerTrainingVideo) (ent.Value, error) {
			return ptv.ID, nil
		},
		column: partnertrainingvideo.FieldID,
		toTerm: partnertrainingvideo.ByID,
		toCursor: func(ptv *PartnerTrainingVideo) Cursor {
			return Cursor{ID: ptv.ID}
		},
	},
}

// ToEdge converts PartnerTrainingVideo into PartnerTrainingVideoEdge.
func (ptv *PartnerTrainingVideo) ToEdge(order *PartnerTrainingVideoOrder) *PartnerTrainingVideoEdge {
	if order == nil {
		order = DefaultPartnerTrainingVideoOrder
	}
	return &PartnerTrainingVideoEdge{
		Node:   ptv,
		Cursor: order.Field.toCursor(ptv),
	}
}

// PaymentEdge is the edge representation of Payment.
type PaymentEdge struct {
	Node   *Payment `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// PaymentConnection is the connection containing edges to Payment.
type PaymentConnection struct {
	Edges      []*PaymentEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *PaymentConnection) build(nodes []*Payment, pager *paymentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Payment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Payment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Payment {
			return nodes[i]
		}
	}
	c.Edges = make([]*PaymentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PaymentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PaymentPaginateOption enables pagination customization.
type PaymentPaginateOption func(*paymentPager) error

// WithPaymentOrder configures pagination ordering.
func WithPaymentOrder(order *PaymentOrder) PaymentPaginateOption {
	if order == nil {
		order = DefaultPaymentOrder
	}
	o := *order
	return func(pager *paymentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPaymentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPaymentFilter configures pagination filter.
func WithPaymentFilter(filter func(*PaymentQuery) (*PaymentQuery, error)) PaymentPaginateOption {
	return func(pager *paymentPager) error {
		if filter == nil {
			return errors.New("PaymentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type paymentPager struct {
	reverse bool
	order   *PaymentOrder
	filter  func(*PaymentQuery) (*PaymentQuery, error)
}

func newPaymentPager(opts []PaymentPaginateOption, reverse bool) (*paymentPager, error) {
	pager := &paymentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPaymentOrder
	}
	return pager, nil
}

func (p *paymentPager) applyFilter(query *PaymentQuery) (*PaymentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *paymentPager) toCursor(pa *Payment) Cursor {
	return p.order.Field.toCursor(pa)
}

func (p *paymentPager) applyCursors(query *PaymentQuery, after, before *Cursor) (*PaymentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPaymentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *paymentPager) applyOrder(query *PaymentQuery) *PaymentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPaymentOrder.Field {
		query = query.Order(DefaultPaymentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *paymentPager) orderExpr(query *PaymentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPaymentOrder.Field {
			b.Comma().Ident(DefaultPaymentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Payment.
func (pa *PaymentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PaymentPaginateOption,
) (*PaymentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPaymentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &PaymentConnection{Edges: []*PaymentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pa.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pa, err = pager.applyCursors(pa, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pa = pager.applyOrder(pa)
	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PaymentOrderFieldCreatedAt orders Payment by created_at.
	PaymentOrderFieldCreatedAt = &PaymentOrderField{
		Value: func(pa *Payment) (ent.Value, error) {
			return pa.CreatedAt, nil
		},
		column: payment.FieldCreatedAt,
		toTerm: payment.ByCreatedAt,
		toCursor: func(pa *Payment) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.CreatedAt,
			}
		},
	}
	// PaymentOrderFieldUpdatedAt orders Payment by updated_at.
	PaymentOrderFieldUpdatedAt = &PaymentOrderField{
		Value: func(pa *Payment) (ent.Value, error) {
			return pa.UpdatedAt, nil
		},
		column: payment.FieldUpdatedAt,
		toTerm: payment.ByUpdatedAt,
		toCursor: func(pa *Payment) Cursor {
			return Cursor{
				ID:    pa.ID,
				Value: pa.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PaymentOrderField) String() string {
	var str string
	switch f.column {
	case PaymentOrderFieldCreatedAt.column:
		str = "CREATED"
	case PaymentOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PaymentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PaymentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PaymentOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *PaymentOrderFieldCreatedAt
	case "UPDATED":
		*f = *PaymentOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PaymentOrderField", str)
	}
	return nil
}

// PaymentOrderField defines the ordering field of Payment.
type PaymentOrderField struct {
	// Value extracts the ordering value from the given Payment.
	Value    func(*Payment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) payment.OrderOption
	toCursor func(*Payment) Cursor
}

// PaymentOrder defines the ordering of Payment.
type PaymentOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *PaymentOrderField `json:"field"`
}

// DefaultPaymentOrder is the default ordering of Payment.
var DefaultPaymentOrder = &PaymentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PaymentOrderField{
		Value: func(pa *Payment) (ent.Value, error) {
			return pa.ID, nil
		},
		column: payment.FieldID,
		toTerm: payment.ByID,
		toCursor: func(pa *Payment) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts Payment into PaymentEdge.
func (pa *Payment) ToEdge(order *PaymentOrder) *PaymentEdge {
	if order == nil {
		order = DefaultPaymentOrder
	}
	return &PaymentEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// PostalCodeEdge is the edge representation of PostalCode.
type PostalCodeEdge struct {
	Node   *PostalCode `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// PostalCodeConnection is the connection containing edges to PostalCode.
type PostalCodeConnection struct {
	Edges      []*PostalCodeEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *PostalCodeConnection) build(nodes []*PostalCode, pager *postalcodePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PostalCode
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PostalCode {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PostalCode {
			return nodes[i]
		}
	}
	c.Edges = make([]*PostalCodeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PostalCodeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PostalCodePaginateOption enables pagination customization.
type PostalCodePaginateOption func(*postalcodePager) error

// WithPostalCodeOrder configures pagination ordering.
func WithPostalCodeOrder(order *PostalCodeOrder) PostalCodePaginateOption {
	if order == nil {
		order = DefaultPostalCodeOrder
	}
	o := *order
	return func(pager *postalcodePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPostalCodeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPostalCodeFilter configures pagination filter.
func WithPostalCodeFilter(filter func(*PostalCodeQuery) (*PostalCodeQuery, error)) PostalCodePaginateOption {
	return func(pager *postalcodePager) error {
		if filter == nil {
			return errors.New("PostalCodeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type postalcodePager struct {
	reverse bool
	order   *PostalCodeOrder
	filter  func(*PostalCodeQuery) (*PostalCodeQuery, error)
}

func newPostalCodePager(opts []PostalCodePaginateOption, reverse bool) (*postalcodePager, error) {
	pager := &postalcodePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPostalCodeOrder
	}
	return pager, nil
}

func (p *postalcodePager) applyFilter(query *PostalCodeQuery) (*PostalCodeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *postalcodePager) toCursor(pc *PostalCode) Cursor {
	return p.order.Field.toCursor(pc)
}

func (p *postalcodePager) applyCursors(query *PostalCodeQuery, after, before *Cursor) (*PostalCodeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPostalCodeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *postalcodePager) applyOrder(query *PostalCodeQuery) *PostalCodeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPostalCodeOrder.Field {
		query = query.Order(DefaultPostalCodeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *postalcodePager) orderExpr(query *PostalCodeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPostalCodeOrder.Field {
			b.Comma().Ident(DefaultPostalCodeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PostalCode.
func (pc *PostalCodeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PostalCodePaginateOption,
) (*PostalCodeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPostalCodePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pc, err = pager.applyFilter(pc); err != nil {
		return nil, err
	}
	conn := &PostalCodeConnection{Edges: []*PostalCodeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pc, err = pager.applyCursors(pc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pc = pager.applyOrder(pc)
	nodes, err := pc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PostalCodeOrderFieldCreatedAt orders PostalCode by created_at.
	PostalCodeOrderFieldCreatedAt = &PostalCodeOrderField{
		Value: func(pc *PostalCode) (ent.Value, error) {
			return pc.CreatedAt, nil
		},
		column: postalcode.FieldCreatedAt,
		toTerm: postalcode.ByCreatedAt,
		toCursor: func(pc *PostalCode) Cursor {
			return Cursor{
				ID:    pc.ID,
				Value: pc.CreatedAt,
			}
		},
	}
	// PostalCodeOrderFieldUpdatedAt orders PostalCode by updated_at.
	PostalCodeOrderFieldUpdatedAt = &PostalCodeOrderField{
		Value: func(pc *PostalCode) (ent.Value, error) {
			return pc.UpdatedAt, nil
		},
		column: postalcode.FieldUpdatedAt,
		toTerm: postalcode.ByUpdatedAt,
		toCursor: func(pc *PostalCode) Cursor {
			return Cursor{
				ID:    pc.ID,
				Value: pc.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PostalCodeOrderField) String() string {
	var str string
	switch f.column {
	case PostalCodeOrderFieldCreatedAt.column:
		str = "CREATED"
	case PostalCodeOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PostalCodeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PostalCodeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PostalCodeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *PostalCodeOrderFieldCreatedAt
	case "UPDATED":
		*f = *PostalCodeOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PostalCodeOrderField", str)
	}
	return nil
}

// PostalCodeOrderField defines the ordering field of PostalCode.
type PostalCodeOrderField struct {
	// Value extracts the ordering value from the given PostalCode.
	Value    func(*PostalCode) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) postalcode.OrderOption
	toCursor func(*PostalCode) Cursor
}

// PostalCodeOrder defines the ordering of PostalCode.
type PostalCodeOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *PostalCodeOrderField `json:"field"`
}

// DefaultPostalCodeOrder is the default ordering of PostalCode.
var DefaultPostalCodeOrder = &PostalCodeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PostalCodeOrderField{
		Value: func(pc *PostalCode) (ent.Value, error) {
			return pc.ID, nil
		},
		column: postalcode.FieldID,
		toTerm: postalcode.ByID,
		toCursor: func(pc *PostalCode) Cursor {
			return Cursor{ID: pc.ID}
		},
	},
}

// ToEdge converts PostalCode into PostalCodeEdge.
func (pc *PostalCode) ToEdge(order *PostalCodeOrder) *PostalCodeEdge {
	if order == nil {
		order = DefaultPostalCodeOrder
	}
	return &PostalCodeEdge{
		Node:   pc,
		Cursor: order.Field.toCursor(pc),
	}
}

// PricingEdge is the edge representation of Pricing.
type PricingEdge struct {
	Node   *Pricing `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// PricingConnection is the connection containing edges to Pricing.
type PricingConnection struct {
	Edges      []*PricingEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *PricingConnection) build(nodes []*Pricing, pager *pricingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Pricing
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Pricing {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Pricing {
			return nodes[i]
		}
	}
	c.Edges = make([]*PricingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PricingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PricingPaginateOption enables pagination customization.
type PricingPaginateOption func(*pricingPager) error

// WithPricingOrder configures pagination ordering.
func WithPricingOrder(order *PricingOrder) PricingPaginateOption {
	if order == nil {
		order = DefaultPricingOrder
	}
	o := *order
	return func(pager *pricingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPricingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPricingFilter configures pagination filter.
func WithPricingFilter(filter func(*PricingQuery) (*PricingQuery, error)) PricingPaginateOption {
	return func(pager *pricingPager) error {
		if filter == nil {
			return errors.New("PricingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type pricingPager struct {
	reverse bool
	order   *PricingOrder
	filter  func(*PricingQuery) (*PricingQuery, error)
}

func newPricingPager(opts []PricingPaginateOption, reverse bool) (*pricingPager, error) {
	pager := &pricingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPricingOrder
	}
	return pager, nil
}

func (p *pricingPager) applyFilter(query *PricingQuery) (*PricingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *pricingPager) toCursor(pr *Pricing) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *pricingPager) applyCursors(query *PricingQuery, after, before *Cursor) (*PricingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPricingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *pricingPager) applyOrder(query *PricingQuery) *PricingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPricingOrder.Field {
		query = query.Order(DefaultPricingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *pricingPager) orderExpr(query *PricingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPricingOrder.Field {
			b.Comma().Ident(DefaultPricingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Pricing.
func (pr *PricingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PricingPaginateOption,
) (*PricingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPricingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &PricingConnection{Edges: []*PricingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PricingOrderFieldCreatedAt orders Pricing by created_at.
	PricingOrderFieldCreatedAt = &PricingOrderField{
		Value: func(pr *Pricing) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: pricing.FieldCreatedAt,
		toTerm: pricing.ByCreatedAt,
		toCursor: func(pr *Pricing) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// PricingOrderFieldUpdatedAt orders Pricing by updated_at.
	PricingOrderFieldUpdatedAt = &PricingOrderField{
		Value: func(pr *Pricing) (ent.Value, error) {
			return pr.UpdatedAt, nil
		},
		column: pricing.FieldUpdatedAt,
		toTerm: pricing.ByUpdatedAt,
		toCursor: func(pr *Pricing) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PricingOrderField) String() string {
	var str string
	switch f.column {
	case PricingOrderFieldCreatedAt.column:
		str = "CREATED"
	case PricingOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PricingOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PricingOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PricingOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *PricingOrderFieldCreatedAt
	case "UPDATED":
		*f = *PricingOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid PricingOrderField", str)
	}
	return nil
}

// PricingOrderField defines the ordering field of Pricing.
type PricingOrderField struct {
	// Value extracts the ordering value from the given Pricing.
	Value    func(*Pricing) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) pricing.OrderOption
	toCursor func(*Pricing) Cursor
}

// PricingOrder defines the ordering of Pricing.
type PricingOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *PricingOrderField `json:"field"`
}

// DefaultPricingOrder is the default ordering of Pricing.
var DefaultPricingOrder = &PricingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PricingOrderField{
		Value: func(pr *Pricing) (ent.Value, error) {
			return pr.ID, nil
		},
		column: pricing.FieldID,
		toTerm: pricing.ByID,
		toCursor: func(pr *Pricing) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Pricing into PricingEdge.
func (pr *Pricing) ToEdge(order *PricingOrder) *PricingEdge {
	if order == nil {
		order = DefaultPricingOrder
	}
	return &PricingEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProductEdge is the edge representation of Product.
type ProductEdge struct {
	Node   *Product `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProductConnection is the connection containing edges to Product.
type ProductConnection struct {
	Edges      []*ProductEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProductConnection) build(nodes []*Product, pager *productPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Product
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Product {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Product {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductPaginateOption enables pagination customization.
type ProductPaginateOption func(*productPager) error

// WithProductOrder configures pagination ordering.
func WithProductOrder(order *ProductOrder) ProductPaginateOption {
	if order == nil {
		order = DefaultProductOrder
	}
	o := *order
	return func(pager *productPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductFilter configures pagination filter.
func WithProductFilter(filter func(*ProductQuery) (*ProductQuery, error)) ProductPaginateOption {
	return func(pager *productPager) error {
		if filter == nil {
			return errors.New("ProductQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productPager struct {
	reverse bool
	order   *ProductOrder
	filter  func(*ProductQuery) (*ProductQuery, error)
}

func newProductPager(opts []ProductPaginateOption, reverse bool) (*productPager, error) {
	pager := &productPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductOrder
	}
	return pager, nil
}

func (p *productPager) applyFilter(query *ProductQuery) (*ProductQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productPager) toCursor(pr *Product) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *productPager) applyCursors(query *ProductQuery, after, before *Cursor) (*ProductQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productPager) applyOrder(query *ProductQuery) *ProductQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductOrder.Field {
		query = query.Order(DefaultProductOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *productPager) orderExpr(query *ProductQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductOrder.Field {
			b.Comma().Ident(DefaultProductOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Product.
func (pr *ProductQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPaginateOption,
) (*ProductConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProductConnection{Edges: []*ProductEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProductOrderFieldCreatedAt orders Product by created_at.
	ProductOrderFieldCreatedAt = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.CreatedAt, nil
		},
		column: product.FieldCreatedAt,
		toTerm: product.ByCreatedAt,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// ProductOrderFieldUpdatedAt orders Product by updated_at.
	ProductOrderFieldUpdatedAt = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.UpdatedAt, nil
		},
		column: product.FieldUpdatedAt,
		toTerm: product.ByUpdatedAt,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.UpdatedAt,
			}
		},
	}
	// ProductOrderFieldName orders Product by name.
	ProductOrderFieldName = &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.Name, nil
		},
		column: product.FieldName,
		toTerm: product.ByName,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProductOrderField) String() string {
	var str string
	switch f.column {
	case ProductOrderFieldCreatedAt.column:
		str = "CREATED"
	case ProductOrderFieldUpdatedAt.column:
		str = "UPDATED"
	case ProductOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProductOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProductOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProductOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *ProductOrderFieldCreatedAt
	case "UPDATED":
		*f = *ProductOrderFieldUpdatedAt
	case "NAME":
		*f = *ProductOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid ProductOrderField", str)
	}
	return nil
}

// ProductOrderField defines the ordering field of Product.
type ProductOrderField struct {
	// Value extracts the ordering value from the given Product.
	Value    func(*Product) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) product.OrderOption
	toCursor func(*Product) Cursor
}

// ProductOrder defines the ordering of Product.
type ProductOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProductOrderField `json:"field"`
}

// DefaultProductOrder is the default ordering of Product.
var DefaultProductOrder = &ProductOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.ID, nil
		},
		column: product.FieldID,
		toTerm: product.ByID,
		toCursor: func(pr *Product) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Product into ProductEdge.
func (pr *Product) ToEdge(order *ProductOrder) *ProductEdge {
	if order == nil {
		order = DefaultProductOrder
	}
	return &ProductEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProductPackageEdge is the edge representation of ProductPackage.
type ProductPackageEdge struct {
	Node   *ProductPackage `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ProductPackageConnection is the connection containing edges to ProductPackage.
type ProductPackageConnection struct {
	Edges      []*ProductPackageEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ProductPackageConnection) build(nodes []*ProductPackage, pager *productpackagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProductPackage
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProductPackage {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProductPackage {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductPackageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductPackageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductPackagePaginateOption enables pagination customization.
type ProductPackagePaginateOption func(*productpackagePager) error

// WithProductPackageOrder configures pagination ordering.
func WithProductPackageOrder(order *ProductPackageOrder) ProductPackagePaginateOption {
	if order == nil {
		order = DefaultProductPackageOrder
	}
	o := *order
	return func(pager *productpackagePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductPackageOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductPackageFilter configures pagination filter.
func WithProductPackageFilter(filter func(*ProductPackageQuery) (*ProductPackageQuery, error)) ProductPackagePaginateOption {
	return func(pager *productpackagePager) error {
		if filter == nil {
			return errors.New("ProductPackageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productpackagePager struct {
	reverse bool
	order   *ProductPackageOrder
	filter  func(*ProductPackageQuery) (*ProductPackageQuery, error)
}

func newProductPackagePager(opts []ProductPackagePaginateOption, reverse bool) (*productpackagePager, error) {
	pager := &productpackagePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductPackageOrder
	}
	return pager, nil
}

func (p *productpackagePager) applyFilter(query *ProductPackageQuery) (*ProductPackageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productpackagePager) toCursor(pp *ProductPackage) Cursor {
	return p.order.Field.toCursor(pp)
}

func (p *productpackagePager) applyCursors(query *ProductPackageQuery, after, before *Cursor) (*ProductPackageQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductPackageOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productpackagePager) applyOrder(query *ProductPackageQuery) *ProductPackageQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductPackageOrder.Field {
		query = query.Order(DefaultProductPackageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *productpackagePager) orderExpr(query *ProductPackageQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductPackageOrder.Field {
			b.Comma().Ident(DefaultProductPackageOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProductPackage.
func (pp *ProductPackageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPackagePaginateOption,
) (*ProductPackageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPackagePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pp, err = pager.applyFilter(pp); err != nil {
		return nil, err
	}
	conn := &ProductPackageConnection{Edges: []*ProductPackageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pp.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pp, err = pager.applyCursors(pp, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		pp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pp.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pp = pager.applyOrder(pp)
	nodes, err := pp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProductPackageOrderFieldCreatedAt orders ProductPackage by created_at.
	ProductPackageOrderFieldCreatedAt = &ProductPackageOrderField{
		Value: func(pp *ProductPackage) (ent.Value, error) {
			return pp.CreatedAt, nil
		},
		column: productpackage.FieldCreatedAt,
		toTerm: productpackage.ByCreatedAt,
		toCursor: func(pp *ProductPackage) Cursor {
			return Cursor{
				ID:    pp.ID,
				Value: pp.CreatedAt,
			}
		},
	}
	// ProductPackageOrderFieldUpdatedAt orders ProductPackage by updated_at.
	ProductPackageOrderFieldUpdatedAt = &ProductPackageOrderField{
		Value: func(pp *ProductPackage) (ent.Value, error) {
			return pp.UpdatedAt, nil
		},
		column: productpackage.FieldUpdatedAt,
		toTerm: productpackage.ByUpdatedAt,
		toCursor: func(pp *ProductPackage) Cursor {
			return Cursor{
				ID:    pp.ID,
				Value: pp.UpdatedAt,
			}
		},
	}
	// ProductPackageOrderFieldName orders ProductPackage by name.
	ProductPackageOrderFieldName = &ProductPackageOrderField{
		Value: func(pp *ProductPackage) (ent.Value, error) {
			return pp.Name, nil
		},
		column: productpackage.FieldName,
		toTerm: productpackage.ByName,
		toCursor: func(pp *ProductPackage) Cursor {
			return Cursor{
				ID:    pp.ID,
				Value: pp.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProductPackageOrderField) String() string {
	var str string
	switch f.column {
	case ProductPackageOrderFieldCreatedAt.column:
		str = "CREATED"
	case ProductPackageOrderFieldUpdatedAt.column:
		str = "UPDATED"
	case ProductPackageOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProductPackageOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProductPackageOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProductPackageOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *ProductPackageOrderFieldCreatedAt
	case "UPDATED":
		*f = *ProductPackageOrderFieldUpdatedAt
	case "NAME":
		*f = *ProductPackageOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid ProductPackageOrderField", str)
	}
	return nil
}

// ProductPackageOrderField defines the ordering field of ProductPackage.
type ProductPackageOrderField struct {
	// Value extracts the ordering value from the given ProductPackage.
	Value    func(*ProductPackage) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) productpackage.OrderOption
	toCursor func(*ProductPackage) Cursor
}

// ProductPackageOrder defines the ordering of ProductPackage.
type ProductPackageOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ProductPackageOrderField `json:"field"`
}

// DefaultProductPackageOrder is the default ordering of ProductPackage.
var DefaultProductPackageOrder = &ProductPackageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductPackageOrderField{
		Value: func(pp *ProductPackage) (ent.Value, error) {
			return pp.ID, nil
		},
		column: productpackage.FieldID,
		toTerm: productpackage.ByID,
		toCursor: func(pp *ProductPackage) Cursor {
			return Cursor{ID: pp.ID}
		},
	},
}

// ToEdge converts ProductPackage into ProductPackageEdge.
func (pp *ProductPackage) ToEdge(order *ProductPackageOrder) *ProductPackageEdge {
	if order == nil {
		order = DefaultProductPackageOrder
	}
	return &ProductPackageEdge{
		Node:   pp,
		Cursor: order.Field.toCursor(pp),
	}
}

// SurveyEdge is the edge representation of Survey.
type SurveyEdge struct {
	Node   *Survey `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// SurveyConnection is the connection containing edges to Survey.
type SurveyConnection struct {
	Edges      []*SurveyEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *SurveyConnection) build(nodes []*Survey, pager *surveyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Survey
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Survey {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Survey {
			return nodes[i]
		}
	}
	c.Edges = make([]*SurveyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SurveyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SurveyPaginateOption enables pagination customization.
type SurveyPaginateOption func(*surveyPager) error

// WithSurveyOrder configures pagination ordering.
func WithSurveyOrder(order *SurveyOrder) SurveyPaginateOption {
	if order == nil {
		order = DefaultSurveyOrder
	}
	o := *order
	return func(pager *surveyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSurveyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSurveyFilter configures pagination filter.
func WithSurveyFilter(filter func(*SurveyQuery) (*SurveyQuery, error)) SurveyPaginateOption {
	return func(pager *surveyPager) error {
		if filter == nil {
			return errors.New("SurveyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type surveyPager struct {
	reverse bool
	order   *SurveyOrder
	filter  func(*SurveyQuery) (*SurveyQuery, error)
}

func newSurveyPager(opts []SurveyPaginateOption, reverse bool) (*surveyPager, error) {
	pager := &surveyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSurveyOrder
	}
	return pager, nil
}

func (p *surveyPager) applyFilter(query *SurveyQuery) (*SurveyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *surveyPager) toCursor(s *Survey) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *surveyPager) applyCursors(query *SurveyQuery, after, before *Cursor) (*SurveyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSurveyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *surveyPager) applyOrder(query *SurveyQuery) *SurveyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSurveyOrder.Field {
		query = query.Order(DefaultSurveyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *surveyPager) orderExpr(query *SurveyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSurveyOrder.Field {
			b.Comma().Ident(DefaultSurveyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Survey.
func (s *SurveyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SurveyPaginateOption,
) (*SurveyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSurveyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &SurveyConnection{Edges: []*SurveyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = s.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SurveyOrderFieldCreatedAt orders Survey by created_at.
	SurveyOrderFieldCreatedAt = &SurveyOrderField{
		Value: func(s *Survey) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: survey.FieldCreatedAt,
		toTerm: survey.ByCreatedAt,
		toCursor: func(s *Survey) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
	// SurveyOrderFieldUpdatedAt orders Survey by updated_at.
	SurveyOrderFieldUpdatedAt = &SurveyOrderField{
		Value: func(s *Survey) (ent.Value, error) {
			return s.UpdatedAt, nil
		},
		column: survey.FieldUpdatedAt,
		toTerm: survey.ByUpdatedAt,
		toCursor: func(s *Survey) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.UpdatedAt,
			}
		},
	}
	// SurveyOrderFieldName orders Survey by name.
	SurveyOrderFieldName = &SurveyOrderField{
		Value: func(s *Survey) (ent.Value, error) {
			return s.Name, nil
		},
		column: survey.FieldName,
		toTerm: survey.ByName,
		toCursor: func(s *Survey) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Name,
			}
		},
	}
	// SurveyOrderFieldAddress orders Survey by address.
	SurveyOrderFieldAddress = &SurveyOrderField{
		Value: func(s *Survey) (ent.Value, error) {
			return s.Address, nil
		},
		column: survey.FieldAddress,
		toTerm: survey.ByAddress,
		toCursor: func(s *Survey) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Address,
			}
		},
	}
	// SurveyOrderFieldPhone orders Survey by phone.
	SurveyOrderFieldPhone = &SurveyOrderField{
		Value: func(s *Survey) (ent.Value, error) {
			return s.Phone, nil
		},
		column: survey.FieldPhone,
		toTerm: survey.ByPhone,
		toCursor: func(s *Survey) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.Phone,
			}
		},
	}
	// SurveyOrderFieldProgressAt orders Survey by progress_at.
	SurveyOrderFieldProgressAt = &SurveyOrderField{
		Value: func(s *Survey) (ent.Value, error) {
			return s.ProgressAt, nil
		},
		column: survey.FieldProgressAt,
		toTerm: survey.ByProgressAt,
		toCursor: func(s *Survey) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.ProgressAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SurveyOrderField) String() string {
	var str string
	switch f.column {
	case SurveyOrderFieldCreatedAt.column:
		str = "CREATED"
	case SurveyOrderFieldUpdatedAt.column:
		str = "UPDATED"
	case SurveyOrderFieldName.column:
		str = "NAME"
	case SurveyOrderFieldAddress.column:
		str = "ADDRESS"
	case SurveyOrderFieldPhone.column:
		str = "PHONE"
	case SurveyOrderFieldProgressAt.column:
		str = "PROGRESS_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SurveyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SurveyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SurveyOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *SurveyOrderFieldCreatedAt
	case "UPDATED":
		*f = *SurveyOrderFieldUpdatedAt
	case "NAME":
		*f = *SurveyOrderFieldName
	case "ADDRESS":
		*f = *SurveyOrderFieldAddress
	case "PHONE":
		*f = *SurveyOrderFieldPhone
	case "PROGRESS_AT":
		*f = *SurveyOrderFieldProgressAt
	default:
		return fmt.Errorf("%s is not a valid SurveyOrderField", str)
	}
	return nil
}

// SurveyOrderField defines the ordering field of Survey.
type SurveyOrderField struct {
	// Value extracts the ordering value from the given Survey.
	Value    func(*Survey) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) survey.OrderOption
	toCursor func(*Survey) Cursor
}

// SurveyOrder defines the ordering of Survey.
type SurveyOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *SurveyOrderField `json:"field"`
}

// DefaultSurveyOrder is the default ordering of Survey.
var DefaultSurveyOrder = &SurveyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SurveyOrderField{
		Value: func(s *Survey) (ent.Value, error) {
			return s.ID, nil
		},
		column: survey.FieldID,
		toTerm: survey.ByID,
		toCursor: func(s *Survey) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Survey into SurveyEdge.
func (s *Survey) ToEdge(order *SurveyOrder) *SurveyEdge {
	if order == nil {
		order = DefaultSurveyOrder
	}
	return &SurveyEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// SurveyProgressEdge is the edge representation of SurveyProgress.
type SurveyProgressEdge struct {
	Node   *SurveyProgress `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// SurveyProgressConnection is the connection containing edges to SurveyProgress.
type SurveyProgressConnection struct {
	Edges      []*SurveyProgressEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *SurveyProgressConnection) build(nodes []*SurveyProgress, pager *surveyprogressPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SurveyProgress
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SurveyProgress {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SurveyProgress {
			return nodes[i]
		}
	}
	c.Edges = make([]*SurveyProgressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SurveyProgressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SurveyProgressPaginateOption enables pagination customization.
type SurveyProgressPaginateOption func(*surveyprogressPager) error

// WithSurveyProgressOrder configures pagination ordering.
func WithSurveyProgressOrder(order *SurveyProgressOrder) SurveyProgressPaginateOption {
	if order == nil {
		order = DefaultSurveyProgressOrder
	}
	o := *order
	return func(pager *surveyprogressPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSurveyProgressOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSurveyProgressFilter configures pagination filter.
func WithSurveyProgressFilter(filter func(*SurveyProgressQuery) (*SurveyProgressQuery, error)) SurveyProgressPaginateOption {
	return func(pager *surveyprogressPager) error {
		if filter == nil {
			return errors.New("SurveyProgressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type surveyprogressPager struct {
	reverse bool
	order   *SurveyProgressOrder
	filter  func(*SurveyProgressQuery) (*SurveyProgressQuery, error)
}

func newSurveyProgressPager(opts []SurveyProgressPaginateOption, reverse bool) (*surveyprogressPager, error) {
	pager := &surveyprogressPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSurveyProgressOrder
	}
	return pager, nil
}

func (p *surveyprogressPager) applyFilter(query *SurveyProgressQuery) (*SurveyProgressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *surveyprogressPager) toCursor(sp *SurveyProgress) Cursor {
	return p.order.Field.toCursor(sp)
}

func (p *surveyprogressPager) applyCursors(query *SurveyProgressQuery, after, before *Cursor) (*SurveyProgressQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSurveyProgressOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *surveyprogressPager) applyOrder(query *SurveyProgressQuery) *SurveyProgressQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSurveyProgressOrder.Field {
		query = query.Order(DefaultSurveyProgressOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *surveyprogressPager) orderExpr(query *SurveyProgressQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSurveyProgressOrder.Field {
			b.Comma().Ident(DefaultSurveyProgressOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SurveyProgress.
func (sp *SurveyProgressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SurveyProgressPaginateOption,
) (*SurveyProgressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSurveyProgressPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sp, err = pager.applyFilter(sp); err != nil {
		return nil, err
	}
	conn := &SurveyProgressConnection{Edges: []*SurveyProgressEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = sp.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sp, err = pager.applyCursors(sp, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		sp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sp.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sp = pager.applyOrder(sp)
	nodes, err := sp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// SurveyProgressOrderFieldCreatedAt orders SurveyProgress by created_at.
	SurveyProgressOrderFieldCreatedAt = &SurveyProgressOrderField{
		Value: func(sp *SurveyProgress) (ent.Value, error) {
			return sp.CreatedAt, nil
		},
		column: surveyprogress.FieldCreatedAt,
		toTerm: surveyprogress.ByCreatedAt,
		toCursor: func(sp *SurveyProgress) Cursor {
			return Cursor{
				ID:    sp.ID,
				Value: sp.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f SurveyProgressOrderField) String() string {
	var str string
	switch f.column {
	case SurveyProgressOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f SurveyProgressOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *SurveyProgressOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("SurveyProgressOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *SurveyProgressOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid SurveyProgressOrderField", str)
	}
	return nil
}

// SurveyProgressOrderField defines the ordering field of SurveyProgress.
type SurveyProgressOrderField struct {
	// Value extracts the ordering value from the given SurveyProgress.
	Value    func(*SurveyProgress) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) surveyprogress.OrderOption
	toCursor func(*SurveyProgress) Cursor
}

// SurveyProgressOrder defines the ordering of SurveyProgress.
type SurveyProgressOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *SurveyProgressOrderField `json:"field"`
}

// DefaultSurveyProgressOrder is the default ordering of SurveyProgress.
var DefaultSurveyProgressOrder = &SurveyProgressOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SurveyProgressOrderField{
		Value: func(sp *SurveyProgress) (ent.Value, error) {
			return sp.ID, nil
		},
		column: surveyprogress.FieldID,
		toTerm: surveyprogress.ByID,
		toCursor: func(sp *SurveyProgress) Cursor {
			return Cursor{ID: sp.ID}
		},
	},
}

// ToEdge converts SurveyProgress into SurveyProgressEdge.
func (sp *SurveyProgress) ToEdge(order *SurveyProgressOrder) *SurveyProgressEdge {
	if order == nil {
		order = DefaultSurveyProgressOrder
	}
	return &SurveyProgressEdge{
		Node:   sp,
		Cursor: order.Field.toCursor(sp),
	}
}

// TokenEdge is the edge representation of Token.
type TokenEdge struct {
	Node   *Token `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// TokenConnection is the connection containing edges to Token.
type TokenConnection struct {
	Edges      []*TokenEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *TokenConnection) build(nodes []*Token, pager *tokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Token
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Token {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Token {
			return nodes[i]
		}
	}
	c.Edges = make([]*TokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TokenPaginateOption enables pagination customization.
type TokenPaginateOption func(*tokenPager) error

// WithTokenOrder configures pagination ordering.
func WithTokenOrder(order *TokenOrder) TokenPaginateOption {
	if order == nil {
		order = DefaultTokenOrder
	}
	o := *order
	return func(pager *tokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTokenFilter configures pagination filter.
func WithTokenFilter(filter func(*TokenQuery) (*TokenQuery, error)) TokenPaginateOption {
	return func(pager *tokenPager) error {
		if filter == nil {
			return errors.New("TokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tokenPager struct {
	reverse bool
	order   *TokenOrder
	filter  func(*TokenQuery) (*TokenQuery, error)
}

func newTokenPager(opts []TokenPaginateOption, reverse bool) (*tokenPager, error) {
	pager := &tokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTokenOrder
	}
	return pager, nil
}

func (p *tokenPager) applyFilter(query *TokenQuery) (*TokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tokenPager) toCursor(t *Token) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tokenPager) applyCursors(query *TokenQuery, after, before *Cursor) (*TokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tokenPager) applyOrder(query *TokenQuery) *TokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTokenOrder.Field {
		query = query.Order(DefaultTokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tokenPager) orderExpr(query *TokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTokenOrder.Field {
			b.Comma().Ident(DefaultTokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Token.
func (t *TokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TokenPaginateOption,
) (*TokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TokenConnection{Edges: []*TokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = t.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TokenOrderFieldCreatedAt orders Token by created_at.
	TokenOrderFieldCreatedAt = &TokenOrderField{
		Value: func(t *Token) (ent.Value, error) {
			return t.CreatedAt, nil
		},
		column: token.FieldCreatedAt,
		toTerm: token.ByCreatedAt,
		toCursor: func(t *Token) Cursor {
			return Cursor{
				ID:    t.ID,
				Value: t.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TokenOrderField) String() string {
	var str string
	switch f.column {
	case TokenOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TokenOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TokenOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TokenOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *TokenOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid TokenOrderField", str)
	}
	return nil
}

// TokenOrderField defines the ordering field of Token.
type TokenOrderField struct {
	// Value extracts the ordering value from the given Token.
	Value    func(*Token) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) token.OrderOption
	toCursor func(*Token) Cursor
}

// TokenOrder defines the ordering of Token.
type TokenOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *TokenOrderField `json:"field"`
}

// DefaultTokenOrder is the default ordering of Token.
var DefaultTokenOrder = &TokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TokenOrderField{
		Value: func(t *Token) (ent.Value, error) {
			return t.ID, nil
		},
		column: token.FieldID,
		toTerm: token.ByID,
		toCursor: func(t *Token) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Token into TokenEdge.
func (t *Token) ToEdge(order *TokenOrder) *TokenEdge {
	if order == nil {
		order = DefaultTokenOrder
	}
	return &TokenEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// TrainingCourseEdge is the edge representation of TrainingCourse.
type TrainingCourseEdge struct {
	Node   *TrainingCourse `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// TrainingCourseConnection is the connection containing edges to TrainingCourse.
type TrainingCourseConnection struct {
	Edges      []*TrainingCourseEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *TrainingCourseConnection) build(nodes []*TrainingCourse, pager *trainingcoursePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *TrainingCourse
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrainingCourse {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrainingCourse {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrainingCourseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrainingCourseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrainingCoursePaginateOption enables pagination customization.
type TrainingCoursePaginateOption func(*trainingcoursePager) error

// WithTrainingCourseOrder configures pagination ordering.
func WithTrainingCourseOrder(order *TrainingCourseOrder) TrainingCoursePaginateOption {
	if order == nil {
		order = DefaultTrainingCourseOrder
	}
	o := *order
	return func(pager *trainingcoursePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrainingCourseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrainingCourseFilter configures pagination filter.
func WithTrainingCourseFilter(filter func(*TrainingCourseQuery) (*TrainingCourseQuery, error)) TrainingCoursePaginateOption {
	return func(pager *trainingcoursePager) error {
		if filter == nil {
			return errors.New("TrainingCourseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trainingcoursePager struct {
	reverse bool
	order   *TrainingCourseOrder
	filter  func(*TrainingCourseQuery) (*TrainingCourseQuery, error)
}

func newTrainingCoursePager(opts []TrainingCoursePaginateOption, reverse bool) (*trainingcoursePager, error) {
	pager := &trainingcoursePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrainingCourseOrder
	}
	return pager, nil
}

func (p *trainingcoursePager) applyFilter(query *TrainingCourseQuery) (*TrainingCourseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trainingcoursePager) toCursor(tc *TrainingCourse) Cursor {
	return p.order.Field.toCursor(tc)
}

func (p *trainingcoursePager) applyCursors(query *TrainingCourseQuery, after, before *Cursor) (*TrainingCourseQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrainingCourseOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trainingcoursePager) applyOrder(query *TrainingCourseQuery) *TrainingCourseQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrainingCourseOrder.Field {
		query = query.Order(DefaultTrainingCourseOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trainingcoursePager) orderExpr(query *TrainingCourseQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrainingCourseOrder.Field {
			b.Comma().Ident(DefaultTrainingCourseOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrainingCourse.
func (tc *TrainingCourseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrainingCoursePaginateOption,
) (*TrainingCourseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrainingCoursePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if tc, err = pager.applyFilter(tc); err != nil {
		return nil, err
	}
	conn := &TrainingCourseConnection{Edges: []*TrainingCourseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = tc.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if tc, err = pager.applyCursors(tc, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		tc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := tc.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	tc = pager.applyOrder(tc)
	nodes, err := tc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrainingCourseOrderFieldCreatedAt orders TrainingCourse by created_at.
	TrainingCourseOrderFieldCreatedAt = &TrainingCourseOrderField{
		Value: func(tc *TrainingCourse) (ent.Value, error) {
			return tc.CreatedAt, nil
		},
		column: trainingcourse.FieldCreatedAt,
		toTerm: trainingcourse.ByCreatedAt,
		toCursor: func(tc *TrainingCourse) Cursor {
			return Cursor{
				ID:    tc.ID,
				Value: tc.CreatedAt,
			}
		},
	}
	// TrainingCourseOrderFieldUpdatedAt orders TrainingCourse by updated_at.
	TrainingCourseOrderFieldUpdatedAt = &TrainingCourseOrderField{
		Value: func(tc *TrainingCourse) (ent.Value, error) {
			return tc.UpdatedAt, nil
		},
		column: trainingcourse.FieldUpdatedAt,
		toTerm: trainingcourse.ByUpdatedAt,
		toCursor: func(tc *TrainingCourse) Cursor {
			return Cursor{
				ID:    tc.ID,
				Value: tc.UpdatedAt,
			}
		},
	}
	// TrainingCourseOrderFieldName orders TrainingCourse by name.
	TrainingCourseOrderFieldName = &TrainingCourseOrderField{
		Value: func(tc *TrainingCourse) (ent.Value, error) {
			return tc.Name, nil
		},
		column: trainingcourse.FieldName,
		toTerm: trainingcourse.ByName,
		toCursor: func(tc *TrainingCourse) Cursor {
			return Cursor{
				ID:    tc.ID,
				Value: tc.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrainingCourseOrderField) String() string {
	var str string
	switch f.column {
	case TrainingCourseOrderFieldCreatedAt.column:
		str = "CREATED"
	case TrainingCourseOrderFieldUpdatedAt.column:
		str = "UPDATED"
	case TrainingCourseOrderFieldName.column:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrainingCourseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrainingCourseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrainingCourseOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *TrainingCourseOrderFieldCreatedAt
	case "UPDATED":
		*f = *TrainingCourseOrderFieldUpdatedAt
	case "NAME":
		*f = *TrainingCourseOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid TrainingCourseOrderField", str)
	}
	return nil
}

// TrainingCourseOrderField defines the ordering field of TrainingCourse.
type TrainingCourseOrderField struct {
	// Value extracts the ordering value from the given TrainingCourse.
	Value    func(*TrainingCourse) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trainingcourse.OrderOption
	toCursor func(*TrainingCourse) Cursor
}

// TrainingCourseOrder defines the ordering of TrainingCourse.
type TrainingCourseOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *TrainingCourseOrderField `json:"field"`
}

// DefaultTrainingCourseOrder is the default ordering of TrainingCourse.
var DefaultTrainingCourseOrder = &TrainingCourseOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrainingCourseOrderField{
		Value: func(tc *TrainingCourse) (ent.Value, error) {
			return tc.ID, nil
		},
		column: trainingcourse.FieldID,
		toTerm: trainingcourse.ByID,
		toCursor: func(tc *TrainingCourse) Cursor {
			return Cursor{ID: tc.ID}
		},
	},
}

// ToEdge converts TrainingCourse into TrainingCourseEdge.
func (tc *TrainingCourse) ToEdge(order *TrainingCourseOrder) *TrainingCourseEdge {
	if order == nil {
		order = DefaultTrainingCourseOrder
	}
	return &TrainingCourseEdge{
		Node:   tc,
		Cursor: order.Field.toCursor(tc),
	}
}

// TrainingVideoEdge is the edge representation of TrainingVideo.
type TrainingVideoEdge struct {
	Node   *TrainingVideo `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// TrainingVideoConnection is the connection containing edges to TrainingVideo.
type TrainingVideoConnection struct {
	Edges      []*TrainingVideoEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *TrainingVideoConnection) build(nodes []*TrainingVideo, pager *trainingvideoPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *TrainingVideo
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *TrainingVideo {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *TrainingVideo {
			return nodes[i]
		}
	}
	c.Edges = make([]*TrainingVideoEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TrainingVideoEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TrainingVideoPaginateOption enables pagination customization.
type TrainingVideoPaginateOption func(*trainingvideoPager) error

// WithTrainingVideoOrder configures pagination ordering.
func WithTrainingVideoOrder(order *TrainingVideoOrder) TrainingVideoPaginateOption {
	if order == nil {
		order = DefaultTrainingVideoOrder
	}
	o := *order
	return func(pager *trainingvideoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTrainingVideoOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTrainingVideoFilter configures pagination filter.
func WithTrainingVideoFilter(filter func(*TrainingVideoQuery) (*TrainingVideoQuery, error)) TrainingVideoPaginateOption {
	return func(pager *trainingvideoPager) error {
		if filter == nil {
			return errors.New("TrainingVideoQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type trainingvideoPager struct {
	reverse bool
	order   *TrainingVideoOrder
	filter  func(*TrainingVideoQuery) (*TrainingVideoQuery, error)
}

func newTrainingVideoPager(opts []TrainingVideoPaginateOption, reverse bool) (*trainingvideoPager, error) {
	pager := &trainingvideoPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTrainingVideoOrder
	}
	return pager, nil
}

func (p *trainingvideoPager) applyFilter(query *TrainingVideoQuery) (*TrainingVideoQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *trainingvideoPager) toCursor(tv *TrainingVideo) Cursor {
	return p.order.Field.toCursor(tv)
}

func (p *trainingvideoPager) applyCursors(query *TrainingVideoQuery, after, before *Cursor) (*TrainingVideoQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTrainingVideoOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *trainingvideoPager) applyOrder(query *TrainingVideoQuery) *TrainingVideoQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTrainingVideoOrder.Field {
		query = query.Order(DefaultTrainingVideoOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *trainingvideoPager) orderExpr(query *TrainingVideoQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTrainingVideoOrder.Field {
			b.Comma().Ident(DefaultTrainingVideoOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to TrainingVideo.
func (tv *TrainingVideoQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TrainingVideoPaginateOption,
) (*TrainingVideoConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTrainingVideoPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if tv, err = pager.applyFilter(tv); err != nil {
		return nil, err
	}
	conn := &TrainingVideoConnection{Edges: []*TrainingVideoEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = tv.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if tv, err = pager.applyCursors(tv, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		tv.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := tv.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	tv = pager.applyOrder(tv)
	nodes, err := tv.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// TrainingVideoOrderFieldCreatedAt orders TrainingVideo by created_at.
	TrainingVideoOrderFieldCreatedAt = &TrainingVideoOrderField{
		Value: func(tv *TrainingVideo) (ent.Value, error) {
			return tv.CreatedAt, nil
		},
		column: trainingvideo.FieldCreatedAt,
		toTerm: trainingvideo.ByCreatedAt,
		toCursor: func(tv *TrainingVideo) Cursor {
			return Cursor{
				ID:    tv.ID,
				Value: tv.CreatedAt,
			}
		},
	}
	// TrainingVideoOrderFieldUpdatedAt orders TrainingVideo by updated_at.
	TrainingVideoOrderFieldUpdatedAt = &TrainingVideoOrderField{
		Value: func(tv *TrainingVideo) (ent.Value, error) {
			return tv.UpdatedAt, nil
		},
		column: trainingvideo.FieldUpdatedAt,
		toTerm: trainingvideo.ByUpdatedAt,
		toCursor: func(tv *TrainingVideo) Cursor {
			return Cursor{
				ID:    tv.ID,
				Value: tv.UpdatedAt,
			}
		},
	}
	// TrainingVideoOrderFieldTitle orders TrainingVideo by title.
	TrainingVideoOrderFieldTitle = &TrainingVideoOrderField{
		Value: func(tv *TrainingVideo) (ent.Value, error) {
			return tv.Title, nil
		},
		column: trainingvideo.FieldTitle,
		toTerm: trainingvideo.ByTitle,
		toCursor: func(tv *TrainingVideo) Cursor {
			return Cursor{
				ID:    tv.ID,
				Value: tv.Title,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f TrainingVideoOrderField) String() string {
	var str string
	switch f.column {
	case TrainingVideoOrderFieldCreatedAt.column:
		str = "CREATED"
	case TrainingVideoOrderFieldUpdatedAt.column:
		str = "UPDATED"
	case TrainingVideoOrderFieldTitle.column:
		str = "TITLE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f TrainingVideoOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *TrainingVideoOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("TrainingVideoOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *TrainingVideoOrderFieldCreatedAt
	case "UPDATED":
		*f = *TrainingVideoOrderFieldUpdatedAt
	case "TITLE":
		*f = *TrainingVideoOrderFieldTitle
	default:
		return fmt.Errorf("%s is not a valid TrainingVideoOrderField", str)
	}
	return nil
}

// TrainingVideoOrderField defines the ordering field of TrainingVideo.
type TrainingVideoOrderField struct {
	// Value extracts the ordering value from the given TrainingVideo.
	Value    func(*TrainingVideo) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) trainingvideo.OrderOption
	toCursor func(*TrainingVideo) Cursor
}

// TrainingVideoOrder defines the ordering of TrainingVideo.
type TrainingVideoOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *TrainingVideoOrderField `json:"field"`
}

// DefaultTrainingVideoOrder is the default ordering of TrainingVideo.
var DefaultTrainingVideoOrder = &TrainingVideoOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TrainingVideoOrderField{
		Value: func(tv *TrainingVideo) (ent.Value, error) {
			return tv.ID, nil
		},
		column: trainingvideo.FieldID,
		toTerm: trainingvideo.ByID,
		toCursor: func(tv *TrainingVideo) Cursor {
			return Cursor{ID: tv.ID}
		},
	},
}

// ToEdge converts TrainingVideo into TrainingVideoEdge.
func (tv *TrainingVideo) ToEdge(order *TrainingVideoOrder) *TrainingVideoEdge {
	if order == nil {
		order = DefaultTrainingVideoOrder
	}
	return &TrainingVideoEdge{
		Node:   tv,
		Cursor: order.Field.toCursor(tv),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = u.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserOrderFieldCreatedAt orders User by created_at.
	UserOrderFieldCreatedAt = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.CreatedAt, nil
		},
		column: user.FieldCreatedAt,
		toTerm: user.ByCreatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.CreatedAt,
			}
		},
	}
	// UserOrderFieldDeletedAt orders User by deleted_at.
	UserOrderFieldDeletedAt = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.DeletedAt, nil
		},
		column: user.FieldDeletedAt,
		toTerm: user.ByDeletedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.DeletedAt,
			}
		},
	}
	// UserOrderFieldUpdatedAt orders User by updated_at.
	UserOrderFieldUpdatedAt = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.UpdatedAt, nil
		},
		column: user.FieldUpdatedAt,
		toTerm: user.ByUpdatedAt,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.UpdatedAt,
			}
		},
	}
	// UserOrderFieldEmail orders User by email.
	UserOrderFieldEmail = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.Email, nil
		},
		column: user.FieldEmail,
		toTerm: user.ByEmail,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.Email,
			}
		},
	}
	// UserOrderFieldFirstName orders User by first_name.
	UserOrderFieldFirstName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.FirstName, nil
		},
		column: user.FieldFirstName,
		toTerm: user.ByFirstName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.FirstName,
			}
		},
	}
	// UserOrderFieldLastName orders User by last_name.
	UserOrderFieldLastName = &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.LastName, nil
		},
		column: user.FieldLastName,
		toTerm: user.ByLastName,
		toCursor: func(u *User) Cursor {
			return Cursor{
				ID:    u.ID,
				Value: u.LastName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserOrderField) String() string {
	var str string
	switch f.column {
	case UserOrderFieldCreatedAt.column:
		str = "CREATED"
	case UserOrderFieldDeletedAt.column:
		str = "DELETED"
	case UserOrderFieldUpdatedAt.column:
		str = "UPDATED"
	case UserOrderFieldEmail.column:
		str = "EMAIL"
	case UserOrderFieldFirstName.column:
		str = "FIRST_NAME"
	case UserOrderFieldLastName.column:
		str = "LAST_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *UserOrderFieldCreatedAt
	case "DELETED":
		*f = *UserOrderFieldDeletedAt
	case "UPDATED":
		*f = *UserOrderFieldUpdatedAt
	case "EMAIL":
		*f = *UserOrderFieldEmail
	case "FIRST_NAME":
		*f = *UserOrderFieldFirstName
	case "LAST_NAME":
		*f = *UserOrderFieldLastName
	default:
		return fmt.Errorf("%s is not a valid UserOrderField", str)
	}
	return nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserActivityEdge is the edge representation of UserActivity.
type UserActivityEdge struct {
	Node   *UserActivity `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// UserActivityConnection is the connection containing edges to UserActivity.
type UserActivityConnection struct {
	Edges      []*UserActivityEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *UserActivityConnection) build(nodes []*UserActivity, pager *useractivityPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserActivity
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserActivity {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserActivity {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserActivityEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserActivityEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserActivityPaginateOption enables pagination customization.
type UserActivityPaginateOption func(*useractivityPager) error

// WithUserActivityOrder configures pagination ordering.
func WithUserActivityOrder(order *UserActivityOrder) UserActivityPaginateOption {
	if order == nil {
		order = DefaultUserActivityOrder
	}
	o := *order
	return func(pager *useractivityPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserActivityOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserActivityFilter configures pagination filter.
func WithUserActivityFilter(filter func(*UserActivityQuery) (*UserActivityQuery, error)) UserActivityPaginateOption {
	return func(pager *useractivityPager) error {
		if filter == nil {
			return errors.New("UserActivityQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type useractivityPager struct {
	reverse bool
	order   *UserActivityOrder
	filter  func(*UserActivityQuery) (*UserActivityQuery, error)
}

func newUserActivityPager(opts []UserActivityPaginateOption, reverse bool) (*useractivityPager, error) {
	pager := &useractivityPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserActivityOrder
	}
	return pager, nil
}

func (p *useractivityPager) applyFilter(query *UserActivityQuery) (*UserActivityQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *useractivityPager) toCursor(ua *UserActivity) Cursor {
	return p.order.Field.toCursor(ua)
}

func (p *useractivityPager) applyCursors(query *UserActivityQuery, after, before *Cursor) (*UserActivityQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserActivityOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *useractivityPager) applyOrder(query *UserActivityQuery) *UserActivityQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserActivityOrder.Field {
		query = query.Order(DefaultUserActivityOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *useractivityPager) orderExpr(query *UserActivityQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserActivityOrder.Field {
			b.Comma().Ident(DefaultUserActivityOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserActivity.
func (ua *UserActivityQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserActivityPaginateOption,
) (*UserActivityConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserActivityPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ua, err = pager.applyFilter(ua); err != nil {
		return nil, err
	}
	conn := &UserActivityConnection{Edges: []*UserActivityEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ua.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ua, err = pager.applyCursors(ua, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ua.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ua.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ua = pager.applyOrder(ua)
	nodes, err := ua.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserActivityOrderFieldCreatedAt orders UserActivity by created_at.
	UserActivityOrderFieldCreatedAt = &UserActivityOrderField{
		Value: func(ua *UserActivity) (ent.Value, error) {
			return ua.CreatedAt, nil
		},
		column: useractivity.FieldCreatedAt,
		toTerm: useractivity.ByCreatedAt,
		toCursor: func(ua *UserActivity) Cursor {
			return Cursor{
				ID:    ua.ID,
				Value: ua.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserActivityOrderField) String() string {
	var str string
	switch f.column {
	case UserActivityOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserActivityOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserActivityOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserActivityOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *UserActivityOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid UserActivityOrderField", str)
	}
	return nil
}

// UserActivityOrderField defines the ordering field of UserActivity.
type UserActivityOrderField struct {
	// Value extracts the ordering value from the given UserActivity.
	Value    func(*UserActivity) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) useractivity.OrderOption
	toCursor func(*UserActivity) Cursor
}

// UserActivityOrder defines the ordering of UserActivity.
type UserActivityOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *UserActivityOrderField `json:"field"`
}

// DefaultUserActivityOrder is the default ordering of UserActivity.
var DefaultUserActivityOrder = &UserActivityOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserActivityOrderField{
		Value: func(ua *UserActivity) (ent.Value, error) {
			return ua.ID, nil
		},
		column: useractivity.FieldID,
		toTerm: useractivity.ByID,
		toCursor: func(ua *UserActivity) Cursor {
			return Cursor{ID: ua.ID}
		},
	},
}

// ToEdge converts UserActivity into UserActivityEdge.
func (ua *UserActivity) ToEdge(order *UserActivityOrder) *UserActivityEdge {
	if order == nil {
		order = DefaultUserActivityOrder
	}
	return &UserActivityEdge{
		Node:   ua,
		Cursor: order.Field.toCursor(ua),
	}
}

// UserAuthEdge is the edge representation of UserAuth.
type UserAuthEdge struct {
	Node   *UserAuth `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// UserAuthConnection is the connection containing edges to UserAuth.
type UserAuthConnection struct {
	Edges      []*UserAuthEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *UserAuthConnection) build(nodes []*UserAuth, pager *userauthPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserAuth
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserAuth {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserAuth {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserAuthEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserAuthEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserAuthPaginateOption enables pagination customization.
type UserAuthPaginateOption func(*userauthPager) error

// WithUserAuthOrder configures pagination ordering.
func WithUserAuthOrder(order *UserAuthOrder) UserAuthPaginateOption {
	if order == nil {
		order = DefaultUserAuthOrder
	}
	o := *order
	return func(pager *userauthPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserAuthOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserAuthFilter configures pagination filter.
func WithUserAuthFilter(filter func(*UserAuthQuery) (*UserAuthQuery, error)) UserAuthPaginateOption {
	return func(pager *userauthPager) error {
		if filter == nil {
			return errors.New("UserAuthQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userauthPager struct {
	reverse bool
	order   *UserAuthOrder
	filter  func(*UserAuthQuery) (*UserAuthQuery, error)
}

func newUserAuthPager(opts []UserAuthPaginateOption, reverse bool) (*userauthPager, error) {
	pager := &userauthPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserAuthOrder
	}
	return pager, nil
}

func (p *userauthPager) applyFilter(query *UserAuthQuery) (*UserAuthQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userauthPager) toCursor(ua *UserAuth) Cursor {
	return p.order.Field.toCursor(ua)
}

func (p *userauthPager) applyCursors(query *UserAuthQuery, after, before *Cursor) (*UserAuthQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserAuthOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userauthPager) applyOrder(query *UserAuthQuery) *UserAuthQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserAuthOrder.Field {
		query = query.Order(DefaultUserAuthOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userauthPager) orderExpr(query *UserAuthQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserAuthOrder.Field {
			b.Comma().Ident(DefaultUserAuthOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserAuth.
func (ua *UserAuthQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserAuthPaginateOption,
) (*UserAuthConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserAuthPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ua, err = pager.applyFilter(ua); err != nil {
		return nil, err
	}
	conn := &UserAuthConnection{Edges: []*UserAuthEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ua.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ua, err = pager.applyCursors(ua, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		ua.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ua.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ua = pager.applyOrder(ua)
	nodes, err := ua.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserAuthOrderFieldCreatedAt orders UserAuth by created_at.
	UserAuthOrderFieldCreatedAt = &UserAuthOrderField{
		Value: func(ua *UserAuth) (ent.Value, error) {
			return ua.CreatedAt, nil
		},
		column: userauth.FieldCreatedAt,
		toTerm: userauth.ByCreatedAt,
		toCursor: func(ua *UserAuth) Cursor {
			return Cursor{
				ID:    ua.ID,
				Value: ua.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserAuthOrderField) String() string {
	var str string
	switch f.column {
	case UserAuthOrderFieldCreatedAt.column:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserAuthOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserAuthOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserAuthOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *UserAuthOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid UserAuthOrderField", str)
	}
	return nil
}

// UserAuthOrderField defines the ordering field of UserAuth.
type UserAuthOrderField struct {
	// Value extracts the ordering value from the given UserAuth.
	Value    func(*UserAuth) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userauth.OrderOption
	toCursor func(*UserAuth) Cursor
}

// UserAuthOrder defines the ordering of UserAuth.
type UserAuthOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *UserAuthOrderField `json:"field"`
}

// DefaultUserAuthOrder is the default ordering of UserAuth.
var DefaultUserAuthOrder = &UserAuthOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserAuthOrderField{
		Value: func(ua *UserAuth) (ent.Value, error) {
			return ua.ID, nil
		},
		column: userauth.FieldID,
		toTerm: userauth.ByID,
		toCursor: func(ua *UserAuth) Cursor {
			return Cursor{ID: ua.ID}
		},
	},
}

// ToEdge converts UserAuth into UserAuthEdge.
func (ua *UserAuth) ToEdge(order *UserAuthOrder) *UserAuthEdge {
	if order == nil {
		order = DefaultUserAuthOrder
	}
	return &UserAuthEdge{
		Node:   ua,
		Cursor: order.Field.toCursor(ua),
	}
}

// UserSessionEdge is the edge representation of UserSession.
type UserSessionEdge struct {
	Node   *UserSession `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// UserSessionConnection is the connection containing edges to UserSession.
type UserSessionConnection struct {
	Edges      []*UserSessionEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *UserSessionConnection) build(nodes []*UserSession, pager *usersessionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserSession
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSession {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSession {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSessionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSessionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSessionPaginateOption enables pagination customization.
type UserSessionPaginateOption func(*usersessionPager) error

// WithUserSessionOrder configures pagination ordering.
func WithUserSessionOrder(order *UserSessionOrder) UserSessionPaginateOption {
	if order == nil {
		order = DefaultUserSessionOrder
	}
	o := *order
	return func(pager *usersessionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserSessionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserSessionFilter configures pagination filter.
func WithUserSessionFilter(filter func(*UserSessionQuery) (*UserSessionQuery, error)) UserSessionPaginateOption {
	return func(pager *usersessionPager) error {
		if filter == nil {
			return errors.New("UserSessionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersessionPager struct {
	reverse bool
	order   *UserSessionOrder
	filter  func(*UserSessionQuery) (*UserSessionQuery, error)
}

func newUserSessionPager(opts []UserSessionPaginateOption, reverse bool) (*usersessionPager, error) {
	pager := &usersessionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserSessionOrder
	}
	return pager, nil
}

func (p *usersessionPager) applyFilter(query *UserSessionQuery) (*UserSessionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersessionPager) toCursor(us *UserSession) Cursor {
	return p.order.Field.toCursor(us)
}

func (p *usersessionPager) applyCursors(query *UserSessionQuery, after, before *Cursor) (*UserSessionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserSessionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usersessionPager) applyOrder(query *UserSessionQuery) *UserSessionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserSessionOrder.Field {
		query = query.Order(DefaultUserSessionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usersessionPager) orderExpr(query *UserSessionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserSessionOrder.Field {
			b.Comma().Ident(DefaultUserSessionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSession.
func (us *UserSessionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSessionPaginateOption,
) (*UserSessionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSessionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if us, err = pager.applyFilter(us); err != nil {
		return nil, err
	}
	conn := &UserSessionConnection{Edges: []*UserSessionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = us.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if us, err = pager.applyCursors(us, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		us.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := us.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	us = pager.applyOrder(us)
	nodes, err := us.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserSessionOrderFieldCreatedAt orders UserSession by created_at.
	UserSessionOrderFieldCreatedAt = &UserSessionOrderField{
		Value: func(us *UserSession) (ent.Value, error) {
			return us.CreatedAt, nil
		},
		column: usersession.FieldCreatedAt,
		toTerm: usersession.ByCreatedAt,
		toCursor: func(us *UserSession) Cursor {
			return Cursor{
				ID:    us.ID,
				Value: us.CreatedAt,
			}
		},
	}
	// UserSessionOrderFieldUpdatedAt orders UserSession by updated_at.
	UserSessionOrderFieldUpdatedAt = &UserSessionOrderField{
		Value: func(us *UserSession) (ent.Value, error) {
			return us.UpdatedAt, nil
		},
		column: usersession.FieldUpdatedAt,
		toTerm: usersession.ByUpdatedAt,
		toCursor: func(us *UserSession) Cursor {
			return Cursor{
				ID:    us.ID,
				Value: us.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserSessionOrderField) String() string {
	var str string
	switch f.column {
	case UserSessionOrderFieldCreatedAt.column:
		str = "CREATED"
	case UserSessionOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserSessionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserSessionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserSessionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *UserSessionOrderFieldCreatedAt
	case "UPDATED":
		*f = *UserSessionOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserSessionOrderField", str)
	}
	return nil
}

// UserSessionOrderField defines the ordering field of UserSession.
type UserSessionOrderField struct {
	// Value extracts the ordering value from the given UserSession.
	Value    func(*UserSession) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersession.OrderOption
	toCursor func(*UserSession) Cursor
}

// UserSessionOrder defines the ordering of UserSession.
type UserSessionOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *UserSessionOrderField `json:"field"`
}

// DefaultUserSessionOrder is the default ordering of UserSession.
var DefaultUserSessionOrder = &UserSessionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSessionOrderField{
		Value: func(us *UserSession) (ent.Value, error) {
			return us.ID, nil
		},
		column: usersession.FieldID,
		toTerm: usersession.ByID,
		toCursor: func(us *UserSession) Cursor {
			return Cursor{ID: us.ID}
		},
	},
}

// ToEdge converts UserSession into UserSessionEdge.
func (us *UserSession) ToEdge(order *UserSessionOrder) *UserSessionEdge {
	if order == nil {
		order = DefaultUserSessionOrder
	}
	return &UserSessionEdge{
		Node:   us,
		Cursor: order.Field.toCursor(us),
	}
}

// UserSessionSocketEdge is the edge representation of UserSessionSocket.
type UserSessionSocketEdge struct {
	Node   *UserSessionSocket `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// UserSessionSocketConnection is the connection containing edges to UserSessionSocket.
type UserSessionSocketConnection struct {
	Edges      []*UserSessionSocketEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *UserSessionSocketConnection) build(nodes []*UserSessionSocket, pager *usersessionsocketPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserSessionSocket
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSessionSocket {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSessionSocket {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSessionSocketEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSessionSocketEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSessionSocketPaginateOption enables pagination customization.
type UserSessionSocketPaginateOption func(*usersessionsocketPager) error

// WithUserSessionSocketOrder configures pagination ordering.
func WithUserSessionSocketOrder(order *UserSessionSocketOrder) UserSessionSocketPaginateOption {
	if order == nil {
		order = DefaultUserSessionSocketOrder
	}
	o := *order
	return func(pager *usersessionsocketPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserSessionSocketOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserSessionSocketFilter configures pagination filter.
func WithUserSessionSocketFilter(filter func(*UserSessionSocketQuery) (*UserSessionSocketQuery, error)) UserSessionSocketPaginateOption {
	return func(pager *usersessionsocketPager) error {
		if filter == nil {
			return errors.New("UserSessionSocketQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type usersessionsocketPager struct {
	reverse bool
	order   *UserSessionSocketOrder
	filter  func(*UserSessionSocketQuery) (*UserSessionSocketQuery, error)
}

func newUserSessionSocketPager(opts []UserSessionSocketPaginateOption, reverse bool) (*usersessionsocketPager, error) {
	pager := &usersessionsocketPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserSessionSocketOrder
	}
	return pager, nil
}

func (p *usersessionsocketPager) applyFilter(query *UserSessionSocketQuery) (*UserSessionSocketQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *usersessionsocketPager) toCursor(uss *UserSessionSocket) Cursor {
	return p.order.Field.toCursor(uss)
}

func (p *usersessionsocketPager) applyCursors(query *UserSessionSocketQuery, after, before *Cursor) (*UserSessionSocketQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserSessionSocketOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *usersessionsocketPager) applyOrder(query *UserSessionSocketQuery) *UserSessionSocketQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserSessionSocketOrder.Field {
		query = query.Order(DefaultUserSessionSocketOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *usersessionsocketPager) orderExpr(query *UserSessionSocketQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserSessionSocketOrder.Field {
			b.Comma().Ident(DefaultUserSessionSocketOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSessionSocket.
func (uss *UserSessionSocketQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSessionSocketPaginateOption,
) (*UserSessionSocketConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSessionSocketPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if uss, err = pager.applyFilter(uss); err != nil {
		return nil, err
	}
	conn := &UserSessionSocketConnection{Edges: []*UserSessionSocketEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = uss.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if uss, err = pager.applyCursors(uss, after, before); err != nil {
		return nil, err
	}
	if limit := paginateLimit(first, last); limit != 0 {
		uss.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := uss.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	uss = pager.applyOrder(uss)
	nodes, err := uss.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// UserSessionSocketOrderFieldCreatedAt orders UserSessionSocket by created_at.
	UserSessionSocketOrderFieldCreatedAt = &UserSessionSocketOrderField{
		Value: func(uss *UserSessionSocket) (ent.Value, error) {
			return uss.CreatedAt, nil
		},
		column: usersessionsocket.FieldCreatedAt,
		toTerm: usersessionsocket.ByCreatedAt,
		toCursor: func(uss *UserSessionSocket) Cursor {
			return Cursor{
				ID:    uss.ID,
				Value: uss.CreatedAt,
			}
		},
	}
	// UserSessionSocketOrderFieldUpdatedAt orders UserSessionSocket by updated_at.
	UserSessionSocketOrderFieldUpdatedAt = &UserSessionSocketOrderField{
		Value: func(uss *UserSessionSocket) (ent.Value, error) {
			return uss.UpdatedAt, nil
		},
		column: usersessionsocket.FieldUpdatedAt,
		toTerm: usersessionsocket.ByUpdatedAt,
		toCursor: func(uss *UserSessionSocket) Cursor {
			return Cursor{
				ID:    uss.ID,
				Value: uss.UpdatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f UserSessionSocketOrderField) String() string {
	var str string
	switch f.column {
	case UserSessionSocketOrderFieldCreatedAt.column:
		str = "CREATED"
	case UserSessionSocketOrderFieldUpdatedAt.column:
		str = "UPDATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f UserSessionSocketOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *UserSessionSocketOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("UserSessionSocketOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *UserSessionSocketOrderFieldCreatedAt
	case "UPDATED":
		*f = *UserSessionSocketOrderFieldUpdatedAt
	default:
		return fmt.Errorf("%s is not a valid UserSessionSocketOrderField", str)
	}
	return nil
}

// UserSessionSocketOrderField defines the ordering field of UserSessionSocket.
type UserSessionSocketOrderField struct {
	// Value extracts the ordering value from the given UserSessionSocket.
	Value    func(*UserSessionSocket) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) usersessionsocket.OrderOption
	toCursor func(*UserSessionSocket) Cursor
}

// UserSessionSocketOrder defines the ordering of UserSessionSocket.
type UserSessionSocketOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *UserSessionSocketOrderField `json:"field"`
}

// DefaultUserSessionSocketOrder is the default ordering of UserSessionSocket.
var DefaultUserSessionSocketOrder = &UserSessionSocketOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSessionSocketOrderField{
		Value: func(uss *UserSessionSocket) (ent.Value, error) {
			return uss.ID, nil
		},
		column: usersessionsocket.FieldID,
		toTerm: usersessionsocket.ByID,
		toCursor: func(uss *UserSessionSocket) Cursor {
			return Cursor{ID: uss.ID}
		},
	},
}

// ToEdge converts UserSessionSocket into UserSessionSocketEdge.
func (uss *UserSessionSocket) ToEdge(order *UserSessionSocketOrder) *UserSessionSocketEdge {
	if order == nil {
		order = DefaultUserSessionSocketOrder
	}
	return &UserSessionSocketEdge{
		Node:   uss,
		Cursor: order.Field.toCursor(uss),
	}
}
